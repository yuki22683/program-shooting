{
  "rust_lesson1_course_description": "Learn the basics of \"Rust\", a language that is very good at finding mistakes. Acquire strict rules and become able to create safe programs.",
  "rust_lesson1_course_title": "Challenge Rust!",
  "rust_lesson1_ex10_comment1": "Declare a reassignable variable and assign a number.",
  "rust_lesson1_ex10_comment2": "Evaluate conditional expression (comparison of variables and numbers, etc.) and execute block if true.",
  "rust_lesson1_ex10_slide1_content": "# Let the program \"decide\"\n\n**Conditional Branch** is a mechanism to make the program decide \"If ~, do XX\".\n\n**Familiar Example:**\n- If score is 80 or more -> Display \"Pass!\"\n- If it rains -> Take an umbrella\n- If HP is 0 -> Game Over\n\n**How to write in Rust:**\n```rust\nif score > 80 {\n    println!(\"Pass!\");\n}\n```\n\n**Reading:**\n- `if` -> \"If\"\n- `score > 80` -> \"If score is greater than 80\"\n- Inside `{ }` -> \"Do this\"",
  "rust_lesson1_ex10_slide1_title": "What is Conditional Branch?",
  "rust_lesson1_ex10_title": "What is Conditional Branch?",
  "rust_lesson1_ex11_description": "Learn \"&& (AND)\" and \"|| (OR)\" to combine multiple conditions.",
  "rust_lesson1_ex11_title": "Logical Operators (&&, ||)",
  "rust_lesson1_ex12_comment1": "Evaluate conditional expression (comparison of variables and numbers, etc.) and execute block if true.",
  "rust_lesson1_ex12_slide1_content": "# Logical Operators\n\nSymbols used when you want to combine two or more conditions.\n\n**2 symbols:**\n- `&&` (And And): \"AND\" = When **both** are correct\n- `||` (Or Or): \"OR\" = When **either one** is correct\n\n**Familiar Example:**\n- Amusement park: Can ride if \"18 or older **AND** have ticket\"\n- Snack: OK if \"Homework done **OR** Helped out\"\n\n**Code Example:**\n```rust\nif score >= 70 && bonus > 0 {\n    // 70 or more AND bonus exists -> Pass!\n    println!(\"Pass!\");\n}\n```",
  "rust_lesson1_ex12_slide1_title": "Combine conditions",
  "rust_lesson1_ex12_title": "Combine conditions",
  "rust_lesson1_ex13_description": "Using \"Vector (Vec)\", you can put a lot of data into one \"long box\" together.",
  "rust_lesson1_ex13_title": "Let's summarize a lot of data \"Vector\"",
  "rust_lesson1_ex14_slide1_content": "# Retrieve by specifying number with [ ]\n\nYou can retrieve data by specifying which number it is with `[Number]`.\n\n**Important Rule: Numbers start from \"0\"!**\n- 1st -> `[0]`\n- 2nd -> `[1]`\n- 3rd -> `[2]`\n\n**Code Example:**\n```rust\nlet fruits = vec![\"Apple\", \"Banana\", \"Orange\"];\n//                  ↑0th    ↑1st     ↑2nd\nprintln!(\"{}\", fruits[0]);  // Apple\nprintln!(\"{}\", fruits[1]);  // Banana\n```\n\n\"Counting from 0\" is a universal rule in programming!",
  "rust_lesson1_ex14_slide1_title": "Vector numbers start from \"0\"!",
  "rust_lesson1_ex14_title": "Vector numbers start from \"0\"!",
  "rust_lesson1_ex15_description": "Using \"Dictionary (HashMap)\", you can save data with a name and retrieve it by that name.",
  "rust_lesson1_ex15_title": "Retrieve by name \"Dictionary\"",
  "rust_lesson1_ex16_comment1": "Input insert(\"Orange\", \"OrangeColor\").",
  "rust_lesson1_ex16_comment2": "Output string and newline to standard output using macro.",
  "rust_lesson1_ex16_slide1_content": "# Retrieve by Name (Key)\n\nData put in dictionary can be retrieved by specifying name (key).\n\n**Code Example:**\n```rust\nuse std::collections::HashMap;\nfn main() {\n    let mut fruits = HashMap::new();\n    fruits.insert(\"Apple\", \"Red\");  // Add\n    fruits.insert(\"Banana\", \"Yellow\");  // Add\n    \n    println!(\"{}\", fruits[\"Apple\"]);  // Red is displayed\n}\n```\n\n**Points:**\n- Add with `insert(Name, Data)`\n- Retrieve with `Dictionary[Name]`\n- Convenient to search by \"Name\" instead of number!",
  "rust_lesson1_ex16_slide1_title": "How to use Dictionary",
  "rust_lesson1_ex16_title": "How to use Dictionary",
  "rust_lesson1_ex1_comment1": "Display Hello, Rust!",
  "rust_lesson1_ex1_description": "Let's display text on the screen using Rust. We use a special function called println!.",
  "rust_lesson1_ex1_slide1_content": "# Safe and Fast! Latest Programming Language\n\nRust is a programming language that is very good at \"preventing mistakes in advance\".\n\nGreat things about Rust:\n- Finds program mistakes before running\n- Runs very fast\n- Popular language chosen as \"Favorite!\" by programmers around the world\n\nAnalogy:\nLike a strict but kind teacher. Tells you \"This is wrong\", so you can write programs with peace of mind!",
  "rust_lesson1_ex1_slide1_title": "What is Rust?",
  "rust_lesson1_ex1_slide2_content": "# Display on screen with println!\n\nTo display text on the screen in Rust, use `println!` (print line exclamation).\n\nPoints:\n- Adding `!` is a feature of Rust (called Macro)\n- Write program inside `fn main() { }`\n- `fn` is short for \"function\"\n\nCode Example:\n```rust\nfn main() {\n    println!(\"Yahoo!\");\n}\n// \"Yahoo!\" is displayed on screen\n```\n\n`!` in `println!` is a mark of special function called \"Macro\". For now, just think of it as a \"magic spell\"!",
  "rust_lesson1_ex1_slide2_title": "Rust's \"Magic Spell\"",
  "rust_lesson1_ex1_slide3_content": "Let's display text on the screen using Rust. We use a special function called println!.\n\n(Select \"Start Lesson\" when you are ready.)",
  "rust_lesson1_ex1_slide3_title": "Let's Try It!",
  "rust_lesson1_ex1_title": "Display a Message",
  "rust_lesson1_ex2_comment1": "Define program execution start point (main function).",
  "rust_lesson1_ex2_comment2": "Output string and newline to standard output using macro.",
  "rust_lesson1_ex2_comment3": "End of program.",
  "rust_lesson1_ex2_description": "Let's use a \"variable\" to store data with a name. Create a variable with let.",
  "rust_lesson1_ex2_slide1_content": "# Display on screen with println!\n\nTo display text on the screen in Rust, use `println!` (print line exclamation).\n\n**Points:**\n- Adding `!` is a feature of Rust (called Macro)\n- Write program inside `fn main() { }`\n- `fn` is short for \"function\"\n\n**Code Example:**\n```rust\nfn main() {\n    println!(\"Yahoo!\");\n}\n// \"Yahoo!\" is displayed on screen\n```\n\n`!` in `println!` is a mark of special function called \"Macro\". For now, just think of it as a \"magic spell\"!",
  "rust_lesson1_ex2_slide1_title": "Rust's \"Magic Spell\"",
  "rust_lesson1_ex2_slide2_content": "# Four Arithmetic Operations\n\nYou can calculate in Rust with the same symbols as arithmetic.\n\n4 Basic Symbols:\n- + (Plus): Addition\n- - (Minus): Subtraction\n- \\* (Asterisk): Multiplication (Instead of ×)\n- / (Slash): Division (Instead of ÷)\n\nCode Example:\n```rust\nlet a = 10;\nlet b = 5;\nprintln!(\"{}\", a + b);  // 15 is displayed\n```\n\n`{}` in `println!` is a mark saying \"Put value here\".",
  "rust_lesson1_ex2_slide2_title": "Calculation Symbols (Operators)",
  "rust_lesson1_ex2_slide3_content": "Let's use a \"variable\" to store data with a name. Create a variable with let.\n\n(Select \"Start Lesson\" when you are ready.)",
  "rust_lesson1_ex2_slide3_title": "Let's Try It!",
  "rust_lesson1_ex2_title": "Rust's \"Magic Spell\"",
  "rust_lesson1_ex3_comment1": "Output remainder of 10 divided by 3",
  "rust_lesson1_ex3_description": "Let's use a \"variable\" to store data with a name. Create a variable with let.",
  "rust_lesson1_ex3_slide1_content": "# Remainder Operator \"%\"\n\n`%` (Percent) is a special symbol to calculate the \"remainder\" of division.\n\nEasy example:\n- Divide 10 candies among 3 people?\n- 3 candies each, 1 remains\n- Writing this as `10 % 3`, the answer is `1`\n\nCode Example:\n```rust\nprintln!(\"{}\", 10 % 3);  // 1 (remainder 1)\nprintln!(\"{}\", 8 % 4);   // 0 (no remainder = divisible)\n```\n\nUse cases:\n- Check even or odd (Even if `n % 2` is 0)\n- Clock calculation (Reset to 0 when exceeding 24, etc.)",
  "rust_lesson1_ex3_slide1_title": "Find Remainder",
  "rust_lesson1_ex3_slide2_content": "Learn the \"%\" (percent) operator to find the remainder of division.\n\n(Select \"Start Lesson\" when you are ready.)",
  "rust_lesson1_ex3_slide2_title": "Let's Try It!",
  "rust_lesson1_ex3_title": "Useful \"Box\" Variable",
  "rust_lesson1_ex4_comment1": "Declare a reassignable variable and assign a number.",
  "rust_lesson1_ex4_comment2": "Declare a reassignable variable and assign a number.",
  "rust_lesson1_ex4_comment3": "Output string and newline to standard output using macro.",
  "rust_lesson1_ex4_description": "Learn \"+=\" and \"-=\" to easily increase or decrease variable values.",
  "rust_lesson1_ex4_slide1_content": "# Four Arithmetic Operations\n\nYou can calculate in Rust with the same symbols as arithmetic.\n\n**4 Basic Symbols:**\n- **+** (Plus): Addition\n- **-** (Minus): Subtraction\n- **\\*** (Asterisk): Multiplication (Instead of ×)\n- **/** (Slash): Division (Instead of ÷)\n\n**Code Example:**\n```rust\nlet a = 10;\nlet b = 5;\nprintln!(\"{}\", a + b);  // 15 is displayed\n```\n\n`{}` in `println!` is a mark saying \"Put value here\".",
  "rust_lesson1_ex4_slide1_title": "Calculation Symbols (Operators)",
  "rust_lesson1_ex4_slide2_content": "Learn \"+= \" and \"-= \" to easily increase or decrease variable values.\n\n(Select \"Start Lesson\" when you are ready.)",
  "rust_lesson1_ex4_slide2_title": "Let's Try It!",
  "rust_lesson1_ex4_title": "Calculation Symbols (Operators)",
  "rust_lesson1_ex5_comment1": "Compare with >",
  "rust_lesson1_ex5_description": "Learn the \"%\" (percent) operator to find the remainder of division.",
  "rust_lesson1_ex5_slide1_content": "# Let the program \"decide\"\n\nConditional Branch is a mechanism to make the program decide \"If ~, do XX\".\n\nFamiliar Example:\n- If score is 80 or more -> Display \"Pass!\"\n- If it rains -> Take an umbrella\n- If HP is 0 -> Game Over\n\nHow to write in Rust:\n```rust\nif score > 80 {\n    println!(\"Pass!\");\n}\n```\n\nReading:\n- `if` -> \"If\"\n- `score > 80` -> \"If score is greater than 80\"\n- Inside `{ }` -> \"Do this\"",
  "rust_lesson1_ex5_slide1_title": "What is Conditional Branch?",
  "rust_lesson1_ex5_slide2_content": "Learn the if statement to change behavior depending on conditions.\n\n(Select \"Start Lesson\" when you are ready.)",
  "rust_lesson1_ex5_slide2_title": "Let's Try It!",
  "rust_lesson1_ex5_title": "Remainder Operator (%)",
  "rust_lesson1_ex6_comment1": "Output string and newline to standard output using macro.",
  "rust_lesson1_ex6_description": "Learn \"&& (AND)\" and \"|| (OR)\" to combine multiple conditions.",
  "rust_lesson1_ex6_slide1_content": "# Remainder Operator \"%\"\n\n`%` (Percent) is a special symbol to calculate the **\"remainder\"** of division.\n\n**Easy example:**\n- Divide 10 candies among 3 people?\n- 3 candies each, **1 remains**\n- Writing this as `10 % 3`, the answer is `1`\n\n**Code Example:**\n```rust\nprintln!(\"{}\", 10 % 3);  // 1 (remainder 1)\nprintln!(\"{}\", 8 % 4);   // 0 (no remainder = divisible)\n```\n\n**Use cases:**\n- Check even or odd (Even if `n % 2` is 0)\n- Clock calculation (Reset to 0 when exceeding 24, etc.)",
  "rust_lesson1_ex6_slide1_title": "Find Remainder",
  "rust_lesson1_ex6_slide2_content": "Learn \"&& (AND)\" and \"|| (OR)\" to combine multiple conditions.\n\n(Select \"Start Lesson\" when you are ready.)",
  "rust_lesson1_ex6_slide2_title": "Let's Try It!",
  "rust_lesson1_ex6_title": "Find Remainder",
  "rust_lesson1_ex7_comment1": "Create a vector named colors (order 'Red', 'Blue')",
  "rust_lesson1_ex7_comment2": "Output 2nd data (index 1)",
  "rust_lesson1_ex7_description": "Learn \"+=\" and \"-=\" to easily increase or decrease variable values.",
  "rust_lesson1_ex7_slide1_content": "# \"Long box\" to organize data in order\n\nVector (Vec) is a \"long box\" where you can put many data in order.\n\nFor example:\n- Group all items on shopping list\n- Group all test scores\n- Group all friends' names\n\nEven 100 or 1000 items can be managed together in one variable!\n\nHow to make:\n```rust\nlet fruits = vec![\"Apple\", \"Banana\", \"Orange\"];\n// Create Vector with vec!\n```",
  "rust_lesson1_ex7_slide1_title": "What is Vector (Vec)?",
  "rust_lesson1_ex7_slide2_content": "# Retrieve by specifying number with [ ]\n\nYou can retrieve data by specifying which number it is with `[Number]`.\n\nImportant Rule: Numbers start from \"0\"!\n- 1st -> `[0]`\n- 2nd -> `[1]`\n- 3rd -> `[2]`\n\nCode Example:\n```rust\nlet fruits = vec![\"Apple\", \"Banana\", \"Orange\"];\n//                  ↑0th    ↑1st     ↑2nd\nprintln!(\"{}\", fruits[0]);  // Apple\nprintln!(\"{}\", fruits[1]);  // Banana\n```\n\n\"Counting from 0\" is a universal rule in programming!",
  "rust_lesson1_ex7_slide2_title": "Vector numbers start from \"0\"!",
  "rust_lesson1_ex7_slide3_content": "Using \"Vector (Vec)\", you can put a lot of data into one \"long box\" together.\n\n(Select \"Start Lesson\" when you are ready.)",
  "rust_lesson1_ex7_slide3_title": "Let's Try It!",
  "rust_lesson1_ex7_title": "Compound Assignment Operators (+=, -=)",
  "rust_lesson1_ex8_comment1": "Calculate the value and reassign the result to the same variable.",
  "rust_lesson1_ex8_comment2": "Calculate the value and reassign the result to the same variable.",
  "rust_lesson1_ex8_description": "Using \"Dictionary (HashMap)\", you can save data with a name and retrieve it by that name.",
  "rust_lesson1_ex8_slide1_content": "# Easily increase/decrease values\n\n`+=` (plus equal) and `-=` (minus equal) are convenient symbols to increase or decrease contents of a variable.\n\n**Rust's Important Rule: Need `mut`!**\nIn Rust, you need to write `let mut` to change a variable. `mut` stands for \"mutable\".\n\n**Code Example:**\n```rust\nlet mut score = 100;  // Add mut to make it changeable\nscore += 10;          // Add 10 -> 110\nscore -= 50;          // Subtract 50 -> 60\n```\n\nWithout `mut`, Rust gets angry saying \"You can't change this variable!\".",
  "rust_lesson1_ex8_slide1_title": "What is Compound Assignment Operator?",
  "rust_lesson1_ex8_slide2_content": "# Retrieve by Name (Key)\n\nData put in dictionary can be retrieved by specifying name (key).\n\nCode Example:\n```rust\nuse std::collections::HashMap;\nfn main() {\n    let mut fruits = HashMap::new();\n    fruits.insert(\"Apple\", \"Red\");  // Add\n    fruits.insert(\"Banana\", \"Yellow\");  // Add\n    \n    println!(\"{}\", fruits[\"Apple\"]);  // Red is displayed\n}\n```\n\nPoints:\n- Add with `insert(Name, Data)`\n- Retrieve with `Dictionary[Name]`\n- Convenient to search by \"Name\" instead of number!",
  "rust_lesson1_ex8_slide2_title": "How to use Dictionary",
  "rust_lesson1_ex8_slide3_content": "Using \"Dictionary (HashMap)\", you can save data with a name and retrieve it by that name.\n\n(Select \"Start Lesson\" when you are ready.)",
  "rust_lesson1_ex8_slide3_title": "Let's Try It!",
  "rust_lesson1_ex8_title": "What is Compound Assignment Operator?",
  "rust_lesson1_ex9_description": "Learn the if statement to change behavior depending on conditions.",
  "rust_lesson1_ex9_title": "Separate with \"If...\"",
  "rust_lesson1_title": "Challenge Rust!",
  "rust_lesson2_course_description": "Learn \"Structs\", \"Traits\", \"Pattern Matching\" focusing on Rust's greatest feature \"Ownership\". Acquire the power to write safe and fast programs.",
  "rust_lesson2_course_title": "Rust II - Ownership and Traits",
  "rust_lesson2_ex10_comment1": "Implement method with impl.",
  "rust_lesson2_ex10_comment2": "Define function (area).",
  "rust_lesson2_ex10_comment3": "Output string and newline to standard output using macro.",
  "rust_lesson2_ex10_description": "Learn \"Generics\" to decide types later.",
  "rust_lesson2_ex10_slide1_content": "# Use &self\n\nThe first argument of a method is `&self`.\n\n**Code Example:**\n```rust\nimpl Rect {\n    fn area(&self) -> i32 {\n        self.width * self.height\n    }\n}\n```",
  "rust_lesson2_ex10_slide1_title": "Method Definition",
  "rust_lesson2_ex10_slide2_content": "# \"Decide later\" with <T>\n\nAdd `<T>` after function name and use `T` as \"Type\".\n\nCode Example:\n```rust\n// T can be any type\nfn first<T>(arr: &[T]) -> &T {\n    &arr[0]  // Return first element\n}\n\n// Usage\nfirst(&[1, 2, 3]);         // T is i32\nfirst(&[\"a\", \"b\", \"c\"]);   // T is &str\n```\n\nReading:\n- `<T>` -> \"Use type named T\"\n- `T` is convention for initial of \"Type\"\n- If multiple types needed, write like `<T, U>`",
  "rust_lesson2_ex10_slide2_title": "Writing Generic Functions",
  "rust_lesson2_ex10_slide3_content": "Learn \"Generics\" to decide types later.\n\n(Select \"Start Lesson\" when you are ready.)",
  "rust_lesson2_ex10_slide3_title": "Let's Try It!",
  "rust_lesson2_ex10_title": "Method Definition",
  "rust_lesson2_ex11_description": "Learn \"Enumeration Type (enum)\" representing multiple states.",
  "rust_lesson2_ex11_title": "Represent states with enum",
  "rust_lesson2_ex12_comment1": "Define enum with enum.",
  "rust_lesson2_ex12_comment2": "Use Direction::Up.",
  "rust_lesson2_ex12_comment3": "Pattern match with match.",
  "rust_lesson2_ex12_slide1_content": "# Enumerate Variants\n\nDefine with `enum Name { Variant1, Variant2, ... }`.\n\n**Code Example:**\n```rust\nenum Color {\n    Red,\n    Green,\n    Blue,\n}\nlet c = Color::Red;\n```",
  "rust_lesson2_ex12_slide1_title": "Enum Definition",
  "rust_lesson2_ex12_title": "Enum Definition",
  "rust_lesson2_ex13_description": "Learn \"Option\" representing value presence.",
  "rust_lesson2_ex13_title": "Safe null with Option<T>",
  "rust_lesson2_ex14_comment1": "Indicate value exists with Some.",
  "rust_lesson2_ex14_comment2": "Output string and newline to standard output using macro.",
  "rust_lesson2_ex14_slide1_content": "# Retrieve safely with match\n\nUse `match` to separate processing for \"Exists\" and \"Not exists\".\n\n**Code Example:**\n```rust\nlet x: Option<i32> = Some(5);  // Value exists\n\nmatch x {\n    Some(n) => println!(\"Value is {}\", n),  // 5\n    None => println!(\"No value\"),\n}\n```\n\n**Why safe?**\n- No error like `null` where \"thought it existed but didn't\"\n- Compilation error if \"Not exists\" case is not written\n- Forced to think about both cases!",
  "rust_lesson2_ex14_slide1_title": "Usage of Option",
  "rust_lesson2_ex14_title": "Usage of Option",
  "rust_lesson2_ex15_description": "Learn \"Result\" representing success and failure.",
  "rust_lesson2_ex15_title": "Error handling with Result<T, E>",
  "rust_lesson2_ex16_comment1": "Return error with Err.",
  "rust_lesson2_ex16_comment2": "Return success with Ok.",
  "rust_lesson2_ex16_slide1_content": "# Separate Success and Failure with match\n\nUse `match` to distinguish processing for \"If success\" and \"If failure\".\n\n**Code Example:**\n```rust\nfn divide(a: i32, b: i32) -> Result<i32, String> {\n    if b == 0 {\n        return Err(\"Cannot divide by 0\".to_string());\n    }\n    Ok(a / b)  // Return answer if success\n}\n\nmatch divide(10, 2) {\n    Ok(v) => println!(\"Answer is {}\", v),\n    Err(e) => println!(\"Error: {}\", e),\n}\n```\n\n**Points:**\n- `Ok(Value)` returns success\n- `Err(Error)` returns failure",
  "rust_lesson2_ex16_slide1_title": "Usage of Result",
  "rust_lesson2_ex16_title": "Usage of Result",
  "rust_lesson2_ex17_description": "Learn \"Trait\" to define common behavior.",
  "rust_lesson2_ex17_title": "Let's define a Trait",
  "rust_lesson2_ex18_comment1": "Define trait with trait.",
  "rust_lesson2_ex18_comment2": "Implement Speak for Dog.",
  "rust_lesson2_ex18_slide1_content": "# Make a promise, keep it\n\n1. Define \"Promise\" with `trait`\n2. Implement \"Keep promise\" with `impl Trait for Type`\n\n**Code Example:**\n```rust\n// 1. Define Trait (Promise)\ntrait Speak {\n    fn speak(&self);  // Promise to have method to speak\n}\n\n// 2. Dog struct implements Trait\nstruct Dog;\nimpl Speak for Dog {\n    fn speak(&self) {\n        println!(\"woof\");\n    }\n}\n```\n\nThis means \"Dog can Speak\".",
  "rust_lesson2_ex18_slide1_title": "Trait Definition and Implementation",
  "rust_lesson2_ex18_title": "Trait Definition and Implementation",
  "rust_lesson2_ex19_description": "Learn \"Generics\" to decide types later.",
  "rust_lesson2_ex19_title": "Let's use Generics",
  "rust_lesson2_ex1_comment1": "Move ownership of s1",
  "rust_lesson2_ex1_description": "Learn Rust's unique concept \"Ownership\".",
  "rust_lesson2_ex1_slide1_content": "# Rules deciding \"Owner\" of data\n\nOwnership is Rust's greatest feature. Mechanism to clarify \"Who owns this data\".\n\nRules:\n- Data always has exactly one \"Owner\"\n- When owner is gone, data is automatically cleaned up\n\nAnalogy:\n- Only one person can hold a toy\n- When owner leaves room, toy is put away\n\nThanks to this rule, Rust prevents \"Memory Leak\" (bug where data isn't cleaned up)!",
  "rust_lesson2_ex1_slide1_title": "What is Ownership?",
  "rust_lesson2_ex1_slide2_content": "# Ownership \"Moves\"\n\nAssigning a variable to another variable moves ownership (Move). Original variable becomes unusable.\n\nCode Example:\n```rust\nlet s1 = String::from(\"hello\");  // s1 is owner\nlet s2 = s1;  // Ownership moved to s2!\n// ↓ s1 cannot be used anymore (Error)\n// println!(\"{}\", s1);  // No Good!\nprintln!(\"{}\", s2);  // OK!\n```\n\nImage:\nGiving a toy to a friend means you can't use it anymore. This is Move.",
  "rust_lesson2_ex1_slide2_title": "Move",
  "rust_lesson2_ex1_slide3_content": "Learn Rust's unique concept \"Ownership\".\n\n(Select \"Start Lesson\" when you are ready.)",
  "rust_lesson2_ex1_slide3_title": "Let's Try It!",
  "rust_lesson2_ex1_title": "Basics of Ownership",
  "rust_lesson2_ex20_comment1": "Use T as type parameter.",
  "rust_lesson2_ex20_comment2": "Call with i32 type.",
  "rust_lesson2_ex20_comment3": "Call with &str type.",
  "rust_lesson2_ex20_slide1_content": "# \"Decide later\" with <T>\n\nAdd `<T>` after function name and use `T` as \"Type\".\n\n**Code Example:**\n```rust\n// T can be any type\nfn first<T>(arr: &[T]) -> &T {\n    &arr[0]  // Return first element\n}\n\n// Usage\nfirst(&[1, 2, 3]);         // T is i32\nfirst(&[\"a\", \"b\", \"c\"]);   // T is &str\n```\n\n**Reading:**\n- `<T>` -> \"Use type named T\"\n- `T` is convention for initial of \"Type\"\n- If multiple types needed, write like `<T, U>`",
  "rust_lesson2_ex20_slide1_title": "Writing Generic Functions",
  "rust_lesson2_ex20_title": "Writing Generic Functions",
  "rust_lesson2_ex2_comment1": "Create String.",
  "rust_lesson2_ex2_comment2": "Move ownership of s1 to s2.",
  "rust_lesson2_ex2_comment3": "Output string and newline to standard output using macro.",
  "rust_lesson2_ex2_description": "Learn \"Borrowing\" (Reference) to use value without moving ownership.",
  "rust_lesson2_ex2_slide1_content": "# Ownership \"Moves\"\n\nAssigning a variable to another variable moves ownership **(Move)**. Original variable becomes unusable.\n\n**Code Example:**\n```rust\nlet s1 = String::from(\"hello\");  // s1 is owner\nlet s2 = s1;  // Ownership moved to s2!\n// ↓ s1 cannot be used anymore (Error)\n// println!(\"{}\", s1);  // No Good!\nprintln!(\"{}\", s2);  // OK!\n```\n\n**Image:**\nGiving a toy to a friend means you can't use it anymore. This is Move.",
  "rust_lesson2_ex2_slide1_title": "Move",
  "rust_lesson2_ex2_slide2_content": "# Have function borrow\n\nWhen passing data to function, adding `&` makes it \"Borrowing\". Original variable can still be used.\n\nCode Example:\n```rust\nfn calc_len(s: &String) -> usize {\n    s.len()  // Return length\n}\n\nfn main() {\n    let text = String::from(\"hello\");\n    let len = calc_len(&text);  // Lend text\n    // text still usable!\n    println!(\"Length of {} is {}\", text, len);\n}\n```\n\n`&String` means \"Borrow String\".",
  "rust_lesson2_ex2_slide2_title": "Usage of Reference",
  "rust_lesson2_ex2_slide3_content": "Learn \"Borrowing\" (Reference) to use value without moving ownership.\n\n(Select \"Start Lesson\" when you are ready.)",
  "rust_lesson2_ex2_slide3_title": "Let's Try It!",
  "rust_lesson2_ex2_title": "Move",
  "rust_lesson2_ex3_comment1": "Make mutable variable with mut",
  "rust_lesson2_ex3_description": "Learn \"Borrowing\" (Reference) to use value without moving ownership.",
  "rust_lesson2_ex3_slide1_content": "# \"Writable\" Borrowing\n\nNormal reference `&` is \"Read-only\", but Mutable Reference `&mut` is \"Writable\" borrowing.\n\nAnalogy:\n- `&` = Show book (Read only)\n- `&mut` = Lend notebook (Write OK)\n\nImportant Rule:\n- Only one mutable reference at a time!\n- Either \"Everyone reads\" or \"One person writes\"\n\nThis rule prevents bugs where data is modified simultaneously.",
  "rust_lesson2_ex3_slide1_title": "What is Mutable Reference?",
  "rust_lesson2_ex3_slide2_content": "# mut needed in 2 places\n\nTo be able to change, `mut` is needed for both variable and reference.\n\nCode Example:\n```rust\n// 1. Create variable with mut\nlet mut s = String::from(\"hello\");\n\n// 2. Pass mutable reference with &mut\nchange(&mut s);\n\nfn change(s: &mut String) {\n    s.push_str(\" world\");  // Can change!\n}\n```\n\nPoints:\n- `let mut Variable` makes variable mutable\n- `&mut Variable` creates mutable reference\n- Need both to change!",
  "rust_lesson2_ex3_slide2_title": "Usage of &mut",
  "rust_lesson2_ex3_slide3_content": "Learn \"Mutable Reference\" to modify referred value.\n\n(Select \"Start Lesson\" when you are ready.)",
  "rust_lesson2_ex3_slide3_title": "Let's Try It!",
  "rust_lesson2_ex3_title": "Reference and Borrowing",
  "rust_lesson2_ex4_comment1": "Define function (print_len).",
  "rust_lesson2_ex4_comment2": "Pass reference with &.",
  "rust_lesson2_ex4_description": "Learn \"Structs\" to group related data.",
  "rust_lesson2_ex4_slide1_content": "# Have function borrow\n\nWhen passing data to function, adding `&` makes it \"Borrowing\". Original variable can still be used.\n\n**Code Example:**\n```rust\nfn calc_len(s: &String) -> usize {\n    s.len()  // Return length\n}\n\nfn main() {\n    let text = String::from(\"hello\");\n    let len = calc_len(&text);  // Lend text\n    // text still usable!\n    println!(\"Length of {} is {}\", text, len);\n}\n```\n\n`&String` means \"Borrow String\".",
  "rust_lesson2_ex4_slide1_title": "Usage of Reference",
  "rust_lesson2_ex4_slide2_content": "# Define with struct keyword\n\nDefine structure with `struct Name { Fields }`. Write name and type for fields.\n\nCode Example:\n```rust\n// Define Point structure\nstruct Point {\n    x: i32,  // x field (Integer)\n    y: i32,  // y field (Integer)\n}\n\n// Usage\nlet p = Point { x: 10, y: 20 };\nprintln!(\"x={}, y={}\", p.x, p.y);\n```\n\nPoints:\n- Create struct with `struct Name`\n- Decide data to hold with `{ FieldName: Type }`\n- Access with `.FieldName`",
  "rust_lesson2_ex4_slide2_title": "How to define struct",
  "rust_lesson2_ex4_slide3_content": "Learn \"Structs\" to group related data.\n\n(Select \"Start Lesson\" when you are ready.)",
  "rust_lesson2_ex4_slide3_title": "Let's Try It!",
  "rust_lesson2_ex4_title": "Usage of Reference",
  "rust_lesson2_ex5_comment1": "Implement method with impl",
  "rust_lesson2_ex5_description": "Learn \"Mutable Reference\" to modify referred value.",
  "rust_lesson2_ex5_slide1_content": "# Implementation Block\n\nYou can add methods to structs with impl block. Refer to self with `self`.",
  "rust_lesson2_ex5_slide1_title": "What is impl?",
  "rust_lesson2_ex5_slide2_content": "# Use &self\n\nThe first argument of a method is `&self`.\n\nCode Example:\n```rust\nimpl Rect {\n    fn area(&self) -> i32 {\n        self.width * self.height\n    }\n}\n```",
  "rust_lesson2_ex5_slide2_title": "Method Definition",
  "rust_lesson2_ex5_slide3_content": "Learn \"impl\" to add methods to structs.\n\n(Select \"Start Lesson\" when you are ready.)",
  "rust_lesson2_ex5_slide3_title": "Let's Try It!",
  "rust_lesson2_ex5_title": "Mutable Reference",
  "rust_lesson2_ex6_comment1": "Define function (add_world).",
  "rust_lesson2_ex6_comment2": "Change referred value.",
  "rust_lesson2_ex6_comment3": "Make mutable variable with mut.",
  "rust_lesson2_ex6_comment4": "Pass mutable reference with &mut.",
  "rust_lesson2_ex6_description": "Learn \"Enumeration Type (enum)\" representing multiple states.",
  "rust_lesson2_ex6_slide1_content": "# mut needed in 2 places\n\nTo be able to change, `mut` is needed for both variable and reference.\n\n**Code Example:**\n```rust\n// 1. Create variable with mut\nlet mut s = String::from(\"hello\");\n\n// 2. Pass mutable reference with &mut\nchange(&mut s);\n\nfn change(s: &mut String) {\n    s.push_str(\" world\");  // Can change!\n}\n```\n\n**Points:**\n- `let mut Variable` makes variable mutable\n- `&mut Variable` creates mutable reference\n- Need both to change!",
  "rust_lesson2_ex6_slide1_title": "Usage of &mut",
  "rust_lesson2_ex6_slide2_content": "# Enumerate Variants\n\nDefine with `enum Name { Variant1, Variant2, ... }`.\n\nCode Example:\n```rust\nenum Color {\n    Red,\n    Green,\n    Blue,\n}\nlet c = Color::Red;\n```",
  "rust_lesson2_ex6_slide2_title": "Enum Definition",
  "rust_lesson2_ex6_slide3_content": "Learn \"Enumeration Type (enum)\" representing multiple states.\n\n(Select \"Start Lesson\" when you are ready.)",
  "rust_lesson2_ex6_slide3_title": "Let's Try It!",
  "rust_lesson2_ex6_title": "Usage of &mut",
  "rust_lesson2_ex7_comment1": "Indicate value exists with Some",
  "rust_lesson2_ex7_description": "Learn \"Structs\" to group related data.",
  "rust_lesson2_ex7_slide1_content": "# \"Maybe exists, maybe not\"\n\nOption<T> is a type representing that a value \"might exist, or might not\".\n\nFor example:\n- Search word in dictionary -> Might find, might not\n- Pick up item in game -> Might be dropped, might not\n\n2 States:\n- `Some(Value)` -> Value exists!\n- `None` -> No value...\n\nOther languages use `null`, but Rust handles safely with `Option`.",
  "rust_lesson2_ex7_slide1_title": "What is Option?",
  "rust_lesson2_ex7_slide2_content": "# Retrieve safely with match\n\nUse `match` to separate processing for \"Exists\" and \"Not exists\".\n\nCode Example:\n```rust\nlet x: Option<i32> = Some(5);  // Value exists\n\nmatch x {\n    Some(n) => println!(\"Value is {}\", n),  // 5\n    None => println!(\"No value\"),\n}\n```\n\nWhy safe?\n- No error like `null` where \"thought it existed but didn't\"\n- Compilation error if \"Not exists\" case is not written\n- Forced to think about both cases!",
  "rust_lesson2_ex7_slide2_title": "Usage of Option",
  "rust_lesson2_ex7_slide3_content": "Learn \"Option\" representing value presence.\n\n(Select \"Start Lesson\" when you are ready.)",
  "rust_lesson2_ex7_slide3_title": "Let's Try It!",
  "rust_lesson2_ex7_title": "Let's define Structs",
  "rust_lesson2_ex8_comment1": "Define struct (Rect).",
  "rust_lesson2_ex8_comment2": "Create instance of struct.",
  "rust_lesson2_ex8_comment3": "Output string and newline to standard output using macro.",
  "rust_lesson2_ex8_description": "Learn \"Result\" representing success and failure.",
  "rust_lesson2_ex8_slide1_content": "# Define with struct keyword\n\nDefine structure with `struct Name { Fields }`. Write name and type for fields.\n\n**Code Example:**\n```rust\n// Define Point structure\nstruct Point {\n    x: i32,  // x field (Integer)\n    y: i32,  // y field (Integer)\n}\n\n// Usage\nlet p = Point { x: 10, y: 20 };\nprintln!(\"x={}, y={}\", p.x, p.y);\n```\n\n**Points:**\n- Create struct with `struct Name`\n- Decide data to hold with `{ FieldName: Type }`\n- Access with `.FieldName`",
  "rust_lesson2_ex8_slide1_title": "How to define struct",
  "rust_lesson2_ex8_slide2_content": "# Separate Success and Failure with match\n\nUse `match` to distinguish processing for \"If success\" and \"If failure\".\n\nCode Example:\n```rust\nfn divide(a: i32, b: i32) -> Result<i32, String> {\n    if b == 0 {\n        return Err(\"Cannot divide by 0\".to_string());\n    }\n    Ok(a / b)  // Return answer if success\n}\n\nmatch divide(10, 2) {\n    Ok(v) => println!(\"Answer is {}\", v),\n    Err(e) => println!(\"Error: {}\", e),\n}\n```\n\nPoints:\n- `Ok(Value)` returns success\n- `Err(Error)` returns failure",
  "rust_lesson2_ex8_slide2_title": "Usage of Result",
  "rust_lesson2_ex8_slide3_content": "Learn \"Result\" representing success and failure.\n\n(Select \"Start Lesson\" when you are ready.)",
  "rust_lesson2_ex8_slide3_title": "Let's Try It!",
  "rust_lesson2_ex8_title": "How to define struct",
  "rust_lesson2_ex9_comment1": "Define trait with trait",
  "rust_lesson2_ex9_description": "Learn \"impl\" to add methods to structs.",
  "rust_lesson2_ex9_slide1_content": "# Promise of \"Capabilities\"\n\nTrait defines a promise that \"This type can do this\".\n\nFor example promise \"Can Speak\":\n- Dog barks \"Woof\"\n- Cat meows \"Meow\"\n- Both have capability \"Can Speak\"\n\nTrait is a promise \"Animals that can speak have a method to produce sound\".\n\nComparison with other languages:\n- Java: Interface\n- TypeScript: Interface\n\nSimilar concepts.",
  "rust_lesson2_ex9_slide1_title": "What is Trait?",
  "rust_lesson2_ex9_slide2_content": "# Make a promise, keep it\n\n1. Define \"Promise\" with `trait`\n2. Implement \"Keep promise\" with `impl Trait for Type`\n\nCode Example:\n```rust\n// 1. Define Trait (Promise)\ntrait Speak {\n    fn speak(&self);  // Promise to have method to speak\n}\n\n// 2. Dog struct implements Trait\nstruct Dog;\nimpl Speak for Dog {\n    fn speak(&self) {\n        println!(\"woof\");\n    }\n}\n```\n\nThis means \"Dog can Speak\".",
  "rust_lesson2_ex9_slide2_title": "Trait Definition and Implementation",
  "rust_lesson2_ex9_slide3_content": "Learn \"Trait\" to define common behavior.\n\n(Select \"Start Lesson\" when you are ready.)",
  "rust_lesson2_ex9_slide3_title": "Let's Try It!",
  "rust_lesson2_ex9_title": "Add Method with impl",
  "rust_lesson2_title": "Rust II - Ownership and Traits",
  "rust_lesson3_course_description": "Learn advanced features of Rust. Master lifetimes, iterators, closures, etc.",
  "rust_lesson3_course_title": "Rust III - Lifetimes and Iterators",
  "rust_lesson3_ex10_comment1": "Filter elements matching condition with filter.",
  "rust_lesson3_ex10_description": "Understand differences between string types.",
  "rust_lesson3_ex10_slide1_content": "# filter receives reference to reference\n\nClosure of `filter` receives a reference to a reference (`&&T`). So, to use the value, you need to dereference twice `**x`.\n\n**Why?**\n- `iter()` returns reference (`&T`)\n- `filter` passes it further by reference (`&&T`)\n\n**Writing:**\n```rust\n// Extract value with **x\n.filter(|x| **x > 2)\n\n// Or add * to argument\n.filter(|&x| *x > 2)\n```\n\nConfusing at first, but you'll get used to it!",
  "rust_lesson3_ex10_slide1_title": "Beware of **!",
  "rust_lesson3_ex10_slide2_content": "# Mutual Conversion\n\n```rust\n// &str -> String\nlet s = \"hello\".to_string();\n\n// String -> &str\nlet slice: &str = &s;\n```",
  "rust_lesson3_ex10_slide2_title": "Conversion",
  "rust_lesson3_ex10_slide3_content": "Understand differences between string types.\n\n(Select \"Start Lesson\" when you are ready.)",
  "rust_lesson3_ex10_slide3_title": "Let's Try It!",
  "rust_lesson3_ex10_title": "Beware of **!",
  "rust_lesson3_ex11_description": "Learn fold to aggregate elements into one value.",
  "rust_lesson3_ex11_title": "Aggregate with fold",
  "rust_lesson3_ex12_comment1": "Aggregate with fold.",
  "rust_lesson3_ex12_slide1_content": "# Sum, Product, Join etc.\n\n```rust\n// Product\nv.iter().fold(1, |acc, x| acc * x)\n\n// String Join\nwords.iter().fold(String::new(), |acc, s| acc + s)\n```",
  "rust_lesson3_ex12_slide1_title": "Various Aggregations",
  "rust_lesson3_ex12_title": "Various Aggregations",
  "rust_lesson3_ex13_description": "Let's propagate errors concisely.",
  "rust_lesson3_ex13_title": "Propagate Error with ? Operator",
  "rust_lesson3_ex14_comment1": "Propagate error with ?.",
  "rust_lesson3_ex14_slide1_content": "# Concise Error Handling\n\n```rust\n// Without ?\nmatch result {\n    Ok(v) => v,\n    Err(e) => return Err(e),\n}\n\n// With ?\nresult?\n```",
  "rust_lesson3_ex14_slide1_title": "Short form of match",
  "rust_lesson3_ex14_title": "Short form of match",
  "rust_lesson3_ex15_description": "Let's set default values for Option/Result.",
  "rust_lesson3_ex15_title": "Default Value with unwrap_or",
  "rust_lesson3_ex16_comment1": "Set default value with unwrap_or.",
  "rust_lesson3_ex16_slide1_content": "# Lazy Evaluation\n\n```rust\n// Calculate with closure\nlet value = x.unwrap_or_else(|| expensive_computation());\n```",
  "rust_lesson3_ex16_slide1_title": "unwrap_or_else",
  "rust_lesson3_ex16_title": "unwrap_or_else",
  "rust_lesson3_ex17_description": "Let's add elements to Vec.",
  "rust_lesson3_ex17_title": "push Method of Vec",
  "rust_lesson3_ex18_comment1": "Add element with push.",
  "rust_lesson3_ex18_slide1_content": "# Mutable Reference\n\n```rust\n// mut required\nlet mut v = Vec::new();\nv.push(1);\nv.push(2);\n```",
  "rust_lesson3_ex18_slide1_title": "mut required",
  "rust_lesson3_ex18_title": "mut required",
  "rust_lesson3_ex19_description": "Understand differences between string types.",
  "rust_lesson3_ex19_title": "String and &str",
  "rust_lesson3_ex1_comment1": "Define lifetime with 'a",
  "rust_lesson3_ex1_description": "Learn Lifetime representing reference validity period.",
  "rust_lesson3_ex1_slide1_content": "# Mark showing reference \"Lifespan\"\n\nLifetime is a mark showing until when a reference can be used. Written like `'a` (apostrophe a).\n\nWhy needed?\nReference is \"Borrowing\" state. If original data disappears, reference cannot be used.\n\nFor example:\n- Borrowed book from library -> Cannot read if library closes\n- Data borrowed by reference -> Cannot use if original data disappears\n\nLifetime is a mechanism to tell compiler \"This reference is valid in this range\".",
  "rust_lesson3_ex1_slide1_title": "What is Lifetime?",
  "rust_lesson3_ex1_slide2_content": "# Prevent Dangerous Bugs\n\nThere is a dangerous bug called Dangling Reference. This is a reference pointing to \"data that no longer exists\".\n\nExample:\n```rust\nfn longest<'a>(x: &'a str, y: &'a str) -> &'a str {\n    if x.len() > y.len() { x } else { y }\n}\n```\n\nMeaning of `'a`:\n- Arguments `x` and `y` have same lifetime `'a`\n- Return value also has same lifetime `'a`\n- Means promise \"While both x and y are valid, return value is valid\"\n\nRust checks this automatically!",
  "rust_lesson3_ex1_slide2_title": "Why needed?",
  "rust_lesson3_ex1_slide3_content": "Learn Lifetime representing reference validity period.\n\n(Select \"Start Lesson\" when you are ready.)",
  "rust_lesson3_ex1_slide3_title": "Let's Try It!",
  "rust_lesson3_ex1_title": "Basics of Lifetime",
  "rust_lesson3_ex20_comment1": "Convert to String with to_string.",
  "rust_lesson3_ex20_slide1_content": "# Mutual Conversion\n\n```rust\n// &str -> String\nlet s = \"hello\".to_string();\n\n// String -> &str\nlet slice: &str = &s;\n```",
  "rust_lesson3_ex20_slide1_title": "Conversion",
  "rust_lesson3_ex20_title": "Conversion",
  "rust_lesson3_ex2_comment1": "Define lifetime with 'a.",
  "rust_lesson3_ex2_description": "Learn \"Closure\", an anonymous function that can use surrounding variables.",
  "rust_lesson3_ex2_slide1_content": "# Prevent Dangerous Bugs\n\n**Dangling Reference** is a dangerous bug. This is a reference pointing to \"data that no longer exists\".\n\n**Example:**\n```rust\nfn longest<'a>(x: &'a str, y: &'a str) -> &'a str {\n    if x.len() > y.len() { x } else { y }\n}\n```\n\n**Meaning of `'a`:**\n- Arguments `x` and `y` have same lifetime `'a`\n- Return value also has same lifetime `'a`\n- Means promise \"While both x and y are valid, return value is valid\"\n\nRust checks this automatically!",
  "rust_lesson3_ex2_slide1_title": "Why needed?",
  "rust_lesson3_ex2_slide2_content": "# Enclose arguments with | |\n\nClosure is written in the form `|Arguments| Process`. `||` is called \"Pipe\".\n\nVarious ways to write:\n```rust\n// No arguments\n|| println!(\"Hello\")\n\n// With arguments\n|x, y| x + y\n\n// Multi-line block\n|x| {\n    let y = x * 2;\n    y + 1\n}\n```\n\nPoints:\n- Enclose arguments with `| |` (Instead of `()` in function)\n- Type can often be omitted (Rust infers it)",
  "rust_lesson3_ex2_slide2_title": "How to write Closure",
  "rust_lesson3_ex2_slide3_content": "Learn \"Closure\", an anonymous function that can use surrounding variables.\n\n(Select \"Start Lesson\" when you are ready.)",
  "rust_lesson3_ex2_slide3_title": "Let's Try It!",
  "rust_lesson3_ex2_title": "Why needed?",
  "rust_lesson3_ex3_comment1": "Get iterator with iter",
  "rust_lesson3_ex3_description": "Learn \"Closure\", an anonymous function that can use surrounding variables.",
  "rust_lesson3_ex3_slide1_content": "# Mechanism to retrieve elements one by one\n\nIterator is a mechanism to retrieve data like Vector \"one by one in order\".\n\nFor example:\n- Call people in line one by one\n- Take out contents of drawer one by one\n\nCode Example:\n```rust\nlet v = vec![1, 2, 3];\nfor x in v.iter() {\n    println!(\"{}\", x);  // Display 1, 2, 3 in order\n}\n```\n\nPrepare \"Retrieve in order\" with `iter()`, and process one by one with `for`.",
  "rust_lesson3_ex3_slide1_title": "What is Iterator?",
  "rust_lesson3_ex3_slide2_content": "# Borrow or Take\n\nThere are 3 types of iter, ownership handling is different.\n\n3 Differences:\n```rust\nv.iter()       // Borrow by reference (&T)\nv.iter_mut()   // Borrow mutably (&mut T)\nv.into_iter()  // Take ownership (T)\n```\n\nUsage:\n- `iter()` -> Just look (Can use original vector)\n- `iter_mut()` -> Want to change contents\n- `into_iter()` -> Take whole vector (Cannot use original)\n\nUsually `iter()` is used often.",
  "rust_lesson3_ex3_slide2_title": "3 iter methods",
  "rust_lesson3_ex3_slide3_content": "Learn Iterator to process elements in order.\n\n(Select \"Start Lesson\" when you are ready.)",
  "rust_lesson3_ex3_slide3_title": "Let's Try It!",
  "rust_lesson3_ex3_title": "Basics of Closure",
  "rust_lesson3_ex4_comment1": "Define closure arguments with |x|.",
  "rust_lesson3_ex4_description": "Learn map to transform each element.",
  "rust_lesson3_ex4_slide1_content": "# Enclose arguments with | |\n\nClosure is written in the form `|Arguments| Process`. `||` is called \"Pipe\".\n\n**Various ways to write:**\n```rust\n// No arguments\n|| println!(\"Hello\")\n\n// With arguments\n|x, y| x + y\n\n// Multi-line block\n|x| {\n    let y = x * 2;\n    y + 1\n}\n```\n\n**Points:**\n- Enclose arguments with `| |` (Instead of `()` in function)\n- Type can often be omitted (Rust infers it)",
  "rust_lesson3_ex4_slide1_title": "How to write Closure",
  "rust_lesson3_ex4_slide2_content": "# Not executed just by map!\n\nRust iterator is Lazy Evaluation, meaning \"Don't process until really needed\".\n\nWhy?\nTo save unnecessary calculation. Even if there are 1 million items, if you only want first 10, only process 10.\n\nExecute with collect():\n```rust\n// Nothing happens just with this\nv.iter().map(|x| x * 2);\n\n// Execute with collect() and convert to vector\nlet result: Vec<_> = v.iter().map(|x| x * 2).collect();\n```\n\n`collect()` means \"Process all now and give result\".",
  "rust_lesson3_ex4_slide2_title": "Lazy Evaluation",
  "rust_lesson3_ex4_slide3_content": "Learn map to transform each element.\n\n(Select \"Start Lesson\" when you are ready.)",
  "rust_lesson3_ex4_slide3_title": "Let's Try It!",
  "rust_lesson3_ex4_title": "How to write Closure",
  "rust_lesson3_ex5_comment1": "Filter elements matching condition with filter",
  "rust_lesson3_ex5_description": "Learn Iterator to process elements in order.",
  "rust_lesson3_ex5_slide1_content": "# Keep only matching ones\n\nfilter keeps elements that satisfy the condition and discards others.\n\nFor example:\n- Keep people with 80 points or more\n- Keep only even numbers\n- Keep names starting with \"A\"\n\nCode Example:\n```rust\nlet v = vec![1, 2, 3, 4, 5];\nlet evens: Vec<_> = v.iter()\n    .filter(|x| **x % 2 == 0)  // Only even\n    .collect();\n// [2, 4]\n```\n\nOnly elements where condition is `true` remain.",
  "rust_lesson3_ex5_slide1_title": "What is filter?",
  "rust_lesson3_ex5_slide2_content": "# filter receives reference to reference\n\n`filter` closure receives reference to reference (`&&T`). So to use value, need to dereference twice `**x`.\n\nWhy?\n- `iter()` returns reference (`&T`)\n- `filter` passes it further by reference (`&&T`)\n\nWriting:\n```rust\n// Extract value with **x\n.filter(|x| **x > 2)\n\n// Or add * to argument\n.filter(|&x| *x > 2)\n```\n\nConfusing at first but you'll get used to it!",
  "rust_lesson3_ex5_slide2_title": "Beware of **!",
  "rust_lesson3_ex5_slide3_content": "Let's extract only elements matching condition.\n\n(Select \"Start Lesson\" when you are ready.)",
  "rust_lesson3_ex5_slide3_title": "Let's Try It!",
  "rust_lesson3_ex5_title": "Basics of Iterator",
  "rust_lesson3_ex6_comment1": "Perform repetitive processing (loop) for a specified number of times or range.",
  "rust_lesson3_ex6_description": "Learn fold to aggregate elements into one value.",
  "rust_lesson3_ex6_slide1_content": "# Borrow or Take\n\nThere are 3 types of iter, ownership handling is different.\n\n**3 Differences:**\n```rust\nv.iter()       // Borrow by reference (&T)\nv.iter_mut()   // Borrow mutably (&mut T)\nv.into_iter()  // Take ownership (T)\n```\n\n**Usage:**\n- `iter()` -> Just look (Can use original vector)\n- `iter_mut()` -> Want to change contents\n- `into_iter()` -> Take whole vector (Cannot use original)\n\nUsually `iter()` is used often.",
  "rust_lesson3_ex6_slide1_title": "3 iter methods",
  "rust_lesson3_ex6_slide2_content": "# Sum, Product, Join etc.\n\n```rust\n// Product\nv.iter().fold(1, |acc, x| acc * x)\n\n// String Join\nwords.iter().fold(String::new(), |acc, s| acc + s)\n```",
  "rust_lesson3_ex6_slide2_title": "Various Aggregations",
  "rust_lesson3_ex6_slide3_content": "Learn fold to aggregate elements into one value.\n\n(Select \"Start Lesson\" when you are ready.)",
  "rust_lesson3_ex6_slide3_title": "Let's Try It!",
  "rust_lesson3_ex6_title": "3 iter methods",
  "rust_lesson3_ex7_comment1": "Propagate error with ?",
  "rust_lesson3_ex7_description": "Learn map to transform each element.",
  "rust_lesson3_ex7_slide1_content": "# Early Return on Error\n\n? does early return if Result is Err.\n\n```rust\nfn read_file() -> Result<String, io::Error> {\n    let content = fs::read_to_string(\"file.txt\")?;\n    Ok(content)\n}\n```",
  "rust_lesson3_ex7_slide1_title": "What is ? Operator?",
  "rust_lesson3_ex7_slide2_content": "# Concise Error Handling\n\n```rust\n// Without ?\nmatch result {\n    Ok(v) => v,\n    Err(e) => return Err(e),\n}\n\n// With ?\nresult?\n```",
  "rust_lesson3_ex7_slide2_title": "Short form of match",
  "rust_lesson3_ex7_slide3_content": "Let's propagate errors concisely.\n\n(Select \"Start Lesson\" when you are ready.)",
  "rust_lesson3_ex7_slide3_title": "Let's Try It!",
  "rust_lesson3_ex7_title": "Iterator Conversion with map",
  "rust_lesson3_ex8_comment1": "Transform each element with map.",
  "rust_lesson3_ex8_description": "Let's set default values for Option/Result.",
  "rust_lesson3_ex8_slide1_content": "# Not executed just by map!\n\nRust iterator is **Lazy Evaluation**, meaning \"Don't process until really needed\".\n\n**Why?**\nTo save unnecessary calculation. Even if there are 1 million items, if you only want first 10, only process 10.\n\n**Execute with collect():**\n```rust\n// Nothing happens just with this\nv.iter().map(|x| x * 2);\n\n// Execute with collect() and convert to vector\nlet result: Vec<_> = v.iter().map(|x| x * 2).collect();\n```\n\n`collect()` means \"Process all now and give result\".",
  "rust_lesson3_ex8_slide1_title": "Lazy Evaluation",
  "rust_lesson3_ex8_slide2_content": "# Lazy Evaluation\n\n```rust\n// Calculate with closure\nlet value = x.unwrap_or_else(|| expensive_computation());\n```",
  "rust_lesson3_ex8_slide2_title": "unwrap_or_else",
  "rust_lesson3_ex8_slide3_content": "Let's set default values for Option/Result.\n\n(Select \"Start Lesson\" when you are ready.)",
  "rust_lesson3_ex8_slide3_title": "Let's Try It!",
  "rust_lesson3_ex8_title": "Lazy Evaluation",
  "rust_lesson3_ex9_comment1": "Add element with push",
  "rust_lesson3_ex9_description": "Let's extract only elements matching condition.",
  "rust_lesson3_ex9_slide1_content": "# Add to end\n\npush adds an element to the end of Vec.\n\n```rust\nlet mut v = vec![1, 2];\nv.push(3);\n// [1, 2, 3]\n```",
  "rust_lesson3_ex9_slide1_title": "What is push?",
  "rust_lesson3_ex9_slide2_content": "# Mutable Reference\n\n```rust\n// mut required\nlet mut v = Vec::new();\nv.push(1);\nv.push(2);\n```",
  "rust_lesson3_ex9_slide2_title": "mut required",
  "rust_lesson3_ex9_slide3_content": "Let's add elements to Vec.\n\n(Select \"Start Lesson\" when you are ready.)",
  "rust_lesson3_ex9_slide3_title": "Let's Try It!",
  "rust_lesson3_ex9_title": "Filter with filter",
  "rust_lesson3_title": "Rust III - Lifetimes and Iterators",
  "rust_lesson4_course_description": "Learn Rust traits and smart pointers. Acquire advanced patterns of abstraction and ownership.",
  "rust_lesson4_course_title": "Rust IV - Traits and Smart Pointers",
  "rust_lesson4_ex10_comment1": "Add key and value with insert.",
  "rust_lesson4_ex10_description": "Let's index iterator.",
  "rust_lesson4_ex10_slide1_content": "# Retrieve safely with get\n\n`get()` method can retrieve values. Since it might not be found, `Option` is returned.\n\n**Code Example:**\n```rust\n// get returns Option<&V>\nif let Some(score) = scores.get(\"Blue\") {\n    println!(\"Blue team has {} points\", score);\n}\n```\n\n**Points:**\n- If key exists, `Some(Value)` is returned\n- If key doesn't exist, `None` is returned\n- Can retrieve safely with `if let`\n\nProgram doesn't crash even if accessing with non-existent key!",
  "rust_lesson4_ex10_slide1_title": "Retrieving Value",
  "rust_lesson4_ex10_slide2_content": "# When you need \"What number\"\n\nConvenient when you need both number (index) and element.\n\nCode Example:\n```rust\nlet v = vec![10, 20, 30];\nfor (idx, val) in v.iter().enumerate() {\n    println!(\"{}th value is {}\", idx, val);\n}\n// 0th value is 10\n// 1st value is 20\n// 2nd value is 30\n```\n\nPoints:\n- Receive Tuple (Set of 2) with `(i, x)`\n- Index in `i`, Element in `x`\n- Index starts from 0",
  "rust_lesson4_ex10_slide2_title": "When to use?",
  "rust_lesson4_ex10_slide3_content": "Let's index iterator.\n\n(Select \"Start Lesson\" when you are ready.)",
  "rust_lesson4_ex10_slide3_title": "Let's Try It!",
  "rust_lesson4_ex10_title": "Retrieving Value",
  "rust_lesson4_ex11_description": "Let's manage unique set of values.",
  "rust_lesson4_ex11_title": "HashSet",
  "rust_lesson4_ex12_comment1": "Import HashSet.",
  "rust_lesson4_ex12_slide1_content": "# Union, Intersection etc.\n\n```rust\nset1.union(&set2)\nset1.intersection(&set2)\nset1.difference(&set2)\n```",
  "rust_lesson4_ex12_slide1_title": "Set Operations",
  "rust_lesson4_ex12_title": "Set Operations",
  "rust_lesson4_ex13_description": "Let's add conditions to pattern match.",
  "rust_lesson4_ex13_title": "match guard",
  "rust_lesson4_ex14_comment1": "Output string and newline to standard output using macro.",
  "rust_lesson4_ex14_slide1_content": "# Complex Condition Branching\n\n```rust\nmatch Some(5) {\n    Some(x) if x % 2 == 0 => println!(\"even\"),\n    Some(x) => println!(\"odd: {}\", x),\n    None => println!(\"none\"),\n}\n```",
  "rust_lesson4_ex14_slide1_title": "Usage Example",
  "rust_lesson4_ex14_title": "Usage Example",
  "rust_lesson4_ex15_description": "Let's write function returning trait concisely.",
  "rust_lesson4_ex15_title": "impl Trait",
  "rust_lesson4_ex16_comment1": "Define function (doubles).",
  "rust_lesson4_ex16_slide1_content": "# Substitute for Generics\n\n```rust\nfn print_all(iter: impl Iterator<Item = i32>) {\n    for x in iter {\n        println!(\"{} \", x);\n    }\n}\n```",
  "rust_lesson4_ex16_slide1_title": "Can be used for arguments",
  "rust_lesson4_ex16_title": "Can be used for arguments",
  "rust_lesson4_ex17_description": "Let's convert iterator to collection.",
  "rust_lesson4_ex17_title": "Convert with collect",
  "rust_lesson4_ex18_comment1": "Convert to Vec with collect.",
  "rust_lesson4_ex18_slide1_content": "# Specify Destination\n\n```rust\n// Turbofish syntax\nlet v = (0..5).collect::<Vec<_>>();\n\n// Type annotation for variable\nlet v: Vec<i32> = (0..5).collect();\n```",
  "rust_lesson4_ex18_slide1_title": "Type Hint",
  "rust_lesson4_ex18_title": "Type Hint",
  "rust_lesson4_ex19_description": "Let's index iterator.",
  "rust_lesson4_ex19_title": "Index with enumerate",
  "rust_lesson4_ex1_comment1": "Define trait with trait",
  "rust_lesson4_ex1_description": "Learn Trait defining common behavior.",
  "rust_lesson4_ex1_slide1_content": "# Promise of \"Capabilities\"\n\nTrait is a mechanism to define methods a type should have.\n\nFor example:\n- \"Can Greet\" trait -> Has greet() method\n- \"Can Display\" trait -> Has display() method\n\nCode Example:\n```rust\ntrait Greet {\n    fn greet(&self) -> String;  // Method \"Promise\"\n}\n```\n\nThis is a promise \"Types that can Greet have greet() method\".",
  "rust_lesson4_ex1_slide1_title": "What is Trait? (Review)",
  "rust_lesson4_ex1_slide2_content": "# Keep promise with impl\n\nImplementing a trait for a struct means that struct \"keeps the promise\".\n\nCode Example:\n```rust\nstruct Person { name: String }\n\nimpl Greet for Person {\n    fn greet(&self) -> String {\n        format!(\"Hello, {}\", self.name)\n    }\n}\n```\n\nReading:\n- `impl Greet for Person` -> \"Person implements Greet\"\n- Now Person has become \"Can Greet\"!",
  "rust_lesson4_ex1_slide2_title": "Trait Implementation",
  "rust_lesson4_ex1_slide3_content": "Learn Trait defining common behavior.\n\n(Select \"Start Lesson\" when you are ready.)",
  "rust_lesson4_ex1_slide3_title": "Let's Try It!",
  "rust_lesson4_ex1_title": "Trait Definition",
  "rust_lesson4_ex20_comment1": "Perform repetitive processing (loop) for a specified number of times or range.",
  "rust_lesson4_ex20_slide1_content": "# When you need \"What number\"\n\nConvenient when you need both number (index) and element.\n\n**Code Example:**\n```rust\nlet v = vec![10, 20, 30];\nfor (idx, val) in v.iter().enumerate() {\n    println!(\"{}th value is {}\", idx, val);\n}\n// 0th value is 10\n// 1st value is 20\n// 2nd value is 30\n```\n\n**Points:**\n- Receive Tuple (Set of 2) with `(i, x)`\n- Index in `i`, Element in `x`\n- Index starts from 0",
  "rust_lesson4_ex20_slide1_title": "When to use?",
  "rust_lesson4_ex20_title": "When to use?",
  "rust_lesson4_ex2_comment1": "Define trait with trait.",
  "rust_lesson4_ex2_description": "Learn derive to automatically implement traits.",
  "rust_lesson4_ex2_slide1_content": "# Keep promise with impl\n\nImplementing a trait for a struct means that struct \"keeps the promise\".\n\n**Code Example:**\n```rust\nstruct Person { name: String }\n\nimpl Greet for Person {\n    fn greet(&self) -> String {\n        format!(\"Hello, {}\", self.name)\n    }\n}\n```\n\n**Reading:**\n- `impl Greet for Person` -> \"Person implements Greet\"\n- Now Person has become \"Can Greet\"!",
  "rust_lesson4_ex2_slide1_title": "Trait Implementation",
  "rust_lesson4_ex2_slide2_content": "# 5 Convenient Ones to Remember\n\n**Frequently used derive traits:**\n```rust\nDebug     // Can debug print with {:?}\nClone     // Can create copy with .clone()\nCopy      // Auto copy on assignment (for small types)\nPartialEq // Can compare with ==\nDefault   // Can auto create initial value\n```\n\n**Multiple specify OK:**\n```rust\n#[derive(Debug, Clone, PartialEq)]\nstruct User {\n    name: String,\n    age: u32,\n}\n```\n\n`Debug` is especially useful. Convenient to see struct contents during debugging!",
  "rust_lesson4_ex2_slide2_title": "Common derive Traits",
  "rust_lesson4_ex2_slide3_content": "Learn derive to automatically implement traits.\n\n(Select \"Start Lesson\" when you are ready.)",
  "rust_lesson4_ex2_slide3_title": "Let's Try It!",
  "rust_lesson4_ex2_title": "Trait Implementation",
  "rust_lesson4_ex3_comment1": "Store in heap with Box::new",
  "rust_lesson4_ex3_description": "Learn derive to automatically implement traits.",
  "rust_lesson4_ex3_slide1_content": "# Box to put data in \"Heap\"\n\nBox<T> is a box to put data in a special place called \"Heap\".\n\n2 Memory Places:\n- Stack: Small and fast. For fixed size data\n- Heap: Large and flexible. For large or variable size data\n\nCode Example:\n```rust\nlet b = Box::new(5);  // Put 5 in Heap\nprintln!(\"{}\", *b);   // Extract content with * -> 5\n```\n\n`*` is operation to \"open box and see content\".",
  "rust_lesson4_ex3_slide1_title": "What is Box?",
  "rust_lesson4_ex3_slide2_content": "# When size is unknown\n\nBox is used for types whose size is unknown at compile time.\n\nFor example Recursive Type:\n```rust\n// List is repetition of \"Value + Next List\"\nenum List {\n    Cons(i32, Box<List>),  // Point to next with Box\n    Nil,                   // End\n}\n```\n\nWhy Box needed?\n- `List` inside `List` -> Infinitely large?\n- Using `Box` makes size fixed (pointer size)\n\nImage of holding \"Arrow to content\" instead of \"Content\".",
  "rust_lesson4_ex3_slide2_title": "When to use?",
  "rust_lesson4_ex3_slide3_content": "Learn Box to store data in Heap.\n\n(Select \"Start Lesson\" when you are ready.)",
  "rust_lesson4_ex3_slide3_title": "Let's Try It!",
  "rust_lesson4_ex3_title": "derive Attribute",
  "rust_lesson4_ex4_comment1": "Automatically implement trait with derive.",
  "rust_lesson4_ex4_description": "Let's share data with reference counting.",
  "rust_lesson4_ex4_slide1_content": "# 5 Convenient Ones to Remember\n\n**Frequently used derive traits:**\n```rust\nDebug     // Can debug print with {:?}\nClone     // Can create copy with .clone()\nCopy      // Auto copy on assignment (for small types)\nPartialEq // Can compare with ==\nDefault   // Can auto create initial value\n```\n\n**Multiple specify OK:**\n```rust\n#[derive(Debug, Clone, PartialEq)]\nstruct User {\n    name: String,\n    age: u32,\n}\n```\n\n`Debug` is especially useful. Convenient to see struct contents during debugging!",
  "rust_lesson4_ex4_slide1_title": "Common derive Traits",
  "rust_lesson4_ex4_slide2_content": "# Count \"How many people hold\"\n\nRc counts \"How many people hold this data now\".\n\nCode Example:\n```rust\nlet a = Rc::new(5);\nprintln!(\"{}\", Rc::strong_count(&a));  // 1\n\nlet b = Rc::clone(&a);\nprintln!(\"{}\", Rc::strong_count(&a));  // 2\n```\n\n**When does data disappear?**\n- When count becomes 0 (When no one holds)\n- Automatically cleaned up when last owner is gone\n\n`Rc::clone` is operation to \"Increase owner by 1\".",
  "rust_lesson4_ex4_slide2_title": "Reference Counting Mechanism",
  "rust_lesson4_ex4_slide3_content": "Let's share data with reference counting.\n\n(Select \"Start Lesson\" when you are ready.)",
  "rust_lesson4_ex4_slide3_title": "Let's Try It!",
  "rust_lesson4_ex4_title": "Common derive Traits",
  "rust_lesson4_ex5_comment1": "Add key and value with insert",
  "rust_lesson4_ex5_description": "Learn Box to store data in Heap.",
  "rust_lesson4_ex5_slide1_content": "# \"Dictionary\" looked up by name\n\nHashMap is a dictionary that saves \"Key (Name)\" and \"Value (Data)\" as a set.\n\nFor example:\n- \"Blue Team\" -> 10 points\n- \"Red Team\" -> 15 points\n\nCode Example:\n```rust\nuse std::collections::HashMap;\n\nlet mut scores = HashMap::new();\nscores.insert(\"Blue\", 10);   // Add\nscores.insert(\"Red\", 15);    // Add\n```\n\nUse after loading function with `use`.",
  "rust_lesson4_ex5_slide1_title": "What is HashMap?",
  "rust_lesson4_ex5_slide2_content": "# Retrieve safely with get\n\n`get()` method can retrieve values. Since it might not be found, `Option` is returned.\n\nCode Example:\n```rust\n// get returns Option<&V>\nif let Some(score) = scores.get(\"Blue\") {\n    println!(\"Blue team has {} points\", score);\n}\n```\n\nPoints:\n- If key exists, `Some(Value)` is returned\n- If key doesn't exist, `None` is returned\n- Can retrieve safely with `if let`\n\nProgram doesn't crash even if accessing with non-existent key!",
  "rust_lesson4_ex5_slide2_title": "Retrieving Value",
  "rust_lesson4_ex5_slide3_content": "Let's store key-value pairs.\n\n(Select \"Start Lesson\" when you are ready.)",
  "rust_lesson4_ex5_slide3_title": "Let's Try It!",
  "rust_lesson4_ex5_title": "Box<T>",
  "rust_lesson4_ex6_comment1": "Store in heap with Box::new.",
  "rust_lesson4_ex6_description": "Let's manage unique set of values.",
  "rust_lesson4_ex6_slide1_content": "# When size is unknown\n\nBox is used for types whose size is unknown at compile time.\n\n**For example Recursive Type:**\n```rust\n// List is repetition of \"Value + Next List\"\nenum List {\n    Cons(i32, Box<List>),  // Point to next with Box\n    Nil,                   // End\n}\n```\n\n**Why Box needed?**\n- `List` inside `List` -> Infinitely large?\n- Using `Box` makes size fixed (pointer size)\n\nImage of holding \"Arrow to content\" instead of \"Content\".",
  "rust_lesson4_ex6_slide1_title": "When to use?",
  "rust_lesson4_ex6_slide2_content": "# Union, Intersection etc.\n\n```rust\nset1.union(&set2)\nset1.intersection(&set2)\nset1.difference(&set2)\n```",
  "rust_lesson4_ex6_slide2_title": "Set Operations",
  "rust_lesson4_ex6_slide3_content": "Let's manage unique set of values.\n\n(Select \"Start Lesson\" when you are ready.)",
  "rust_lesson4_ex6_slide3_title": "Let's Try It!",
  "rust_lesson4_ex6_title": "When to use?",
  "rust_lesson4_ex7_comment1": "Add match guard with if",
  "rust_lesson4_ex7_description": "Let's share data with reference counting.",
  "rust_lesson4_ex7_slide1_content": "# Additional Condition\n\nYou can add additional condition to pattern with **if**.\n\n```rust\nmatch x {\n    n if n < 0 => println!(\"negative\"),\n    n if n > 0 => println!(\"positive\"),\n    _ => println!(\"zero\"),\n}\n```",
  "rust_lesson4_ex7_slide1_title": "What is match guard?",
  "rust_lesson4_ex7_slide2_content": "# Complex Condition Branching\n\n```rust\nmatch Some(5) {\n    Some(x) if x % 2 == 0 => println!(\"even\"),\n    Some(x) => println!(\"odd: {}\", x),\n    None => println!(\"none\"),\n}\n```",
  "rust_lesson4_ex7_slide2_title": "Usage Example",
  "rust_lesson4_ex7_slide3_content": "Let's add conditions to pattern match.\n\n(Select \"Start Lesson\" when you are ready.)",
  "rust_lesson4_ex7_slide3_title": "Let's Try It!",
  "rust_lesson4_ex7_title": "Rc<T>",
  "rust_lesson4_ex8_comment1": "Increase reference count with Rc::clone.",
  "rust_lesson4_ex8_description": "Let's write function returning trait concisely.",
  "rust_lesson4_ex8_slide1_content": "# Count \"How many people hold\"\n\nRc counts \"How many people hold this data now\".\n\n**Code Example:**\n```rust\nlet a = Rc::new(5);\nprintln!(\"{}\", Rc::strong_count(&a));  // 1\n\nlet b = Rc::clone(&a);\nprintln!(\"{}\", Rc::strong_count(&a));  // 2\n```\n\n**When does data disappear?**\n- When count becomes 0 (When no one holds)\n- Automatically cleaned up when last owner is gone\n\n`Rc::clone` is operation to \"Increase owner by 1\".",
  "rust_lesson4_ex8_slide1_title": "Reference Counting Mechanism",
  "rust_lesson4_ex8_slide2_content": "# Substitute for Generics\n\n```rust\nfn print_all(iter: impl Iterator<Item = i32>) {\n    for x in iter {\n        println!(\"{} \", x);\n    }\n}\n```",
  "rust_lesson4_ex8_slide2_title": "Can be used for arguments",
  "rust_lesson4_ex8_slide3_content": "Let's write function returning trait concisely.\n\n(Select \"Start Lesson\" when you are ready.)",
  "rust_lesson4_ex8_slide3_title": "Let's Try It!",
  "rust_lesson4_ex8_title": "Reference Counting Mechanism",
  "rust_lesson4_ex9_comment1": "Convert to Vec with collect",
  "rust_lesson4_ex9_description": "Let's store key-value pairs.",
  "rust_lesson4_ex9_slide1_content": "# Iterator to Collection\n\ncollect converts iterator to Vec, HashMap etc.\n\n```rust\nlet v: Vec<_> = (0..5).collect();\nlet s: String = vec!['a', 'b'].into_iter().collect();\n```",
  "rust_lesson4_ex9_slide1_title": "What is collect?",
  "rust_lesson4_ex9_slide2_content": "# Specify Destination\n\n```rust\n// Turbofish syntax\nlet v = (0..5).collect::<Vec<_>>();\n\n// Type annotation for variable\nlet v: Vec<i32> = (0..5).collect();\n```",
  "rust_lesson4_ex9_slide2_title": "Type Hint",
  "rust_lesson4_ex9_slide3_content": "Let's convert iterator to collection.\n\n(Select \"Start Lesson\" when you are ready.)",
  "rust_lesson4_ex9_slide3_title": "Let's Try It!",
  "rust_lesson4_ex9_title": "HashMap",
  "rust_lesson4_title": "Rust IV - Traits and Smart Pointers"
}
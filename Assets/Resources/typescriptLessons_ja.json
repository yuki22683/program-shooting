{
  "typescript_lesson1_course_description": "JavaScriptに「ラベル（型）」をつけて、もっと使いやすくした TypeScript（タイプスクリプト）を学びましょう。間違いの少ないプログラミングができるようになります。",
  "typescript_lesson1_course_title": "TypeScript (タイプスクリプト) に挑戦！",
  "typescript_lesson1_ex10_comment1": "数字を入れるので、ラベルは `number` です。",
  "typescript_lesson1_ex10_comment2": "文字の配列なので `string[]` です。",
  "typescript_lesson1_ex10_comment3": "名前を表示",
  "typescript_lesson1_ex10_comment4": "指定された回数や範囲で、繰り返し処理（ループ）を行います。",
  "typescript_lesson1_ex10_description": "ラベルが貼られた配列から、データを一つずつ取り出してみましょう。",
  "typescript_lesson1_ex10_slide1_content": "# 同じ作業を自動化！\n\n同じことを何回も繰り返すのは大変ですよね。\n\n## たとえ話\n\n「クラスの全員の名前を呼んでください」と言われたとき、一人ずつ呼ぶのは大変です。でもプログラミングでは **ループ** という仕組みを使って、「名簿の全員を順番に呼んで！」とコンピュータにお願いできます。\n\nこれで100人いても、1000人いても、同じコードで対応できるんです！",
  "typescript_lesson1_ex10_slide1_title": "繰り返し（ループ）とは？",
  "typescript_lesson1_ex10_slide2_content": "# 配列から順番に取り出す\n\n`for...of`（フォー オブ）を使うと、配列の中身を1つずつ順番に取り出せます。\n\n## 書き方のポイント\n\n`for (const 変数 of 配列)` という形で書きます。\n- `of` は「〜の中から」という意味\n- 「配列の中から、変数に1つずつ取り出す」ということです\n\n## コードで書くとこうなるよ\n\n```typescript\nconst animals: string[] = ['いぬ', 'ねこ'];\nfor (const animal of animals) {\n    console.log(animal);\n}\n```\n**実行結果：**\nいぬ\nねこ\n\n配列の中身が順番に表示されました！",
  "typescript_lesson1_ex10_slide2_title": "for...of の使い方",
  "typescript_lesson1_ex10_slide3_content": "# TypeScriptが自動で予想してくれる\n\nTypeScriptはとても賢いので、配列に貼られたラベルを見て、中から取り出したデータの種類も自動で「きっとこれです！」と予想してくれます。\n\n## たとえ話\n\n「りんご箱」から取り出したものは「りんご」に決まっていますよね。\n同じように、`string[]`（文字列の配列）から取り出したものは `string`（文字列）だと自動でわかるんです！\n\nこれを **型推論（かたすいろん）** と呼びます。便利ですね！",
  "typescript_lesson1_ex10_slide3_title": "型の推論（すいろん）",
  "typescript_lesson1_ex10_slide4_content": "ラベルが貼られた配列から、データを一つずつ取り出してみましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "typescript_lesson1_ex10_slide4_title": "やってみよう！",
  "typescript_lesson1_ex10_title": "順番に出してみましょう",
  "typescript_lesson1_ex11_comment1": "Userという名前のラベルを作る",
  "typescript_lesson1_ex11_comment2": "name は文字なので `string` です。",
  "typescript_lesson1_ex11_comment3": "中身を出す",
  "typescript_lesson1_ex11_comment4": "自分で作ったラベル `User` を指定します。",
  "typescript_lesson1_ex11_comment6": "ドット `.` を使って、userの中の `name` を取り出します。",
  "typescript_lesson1_ex11_description": "type（タイプ）という言葉を使って、オリジナルのラベルを作ってみましょう。",
  "typescript_lesson1_ex11_slide1_content": "# 自分だけのルールを作る\n\n今まで学んだ `string`（文字）や `number`（数字）は、TypeScriptにもともと用意されているラベルでした。\n\nでも、実際のプログラムでは「名前（文字）」と「年齢（数字）」のように、複数の情報をセットにしたいことがよくあります。\n\n## たとえ話\n\n「生徒カード」を想像してみてください。名前、年齢、クラス...といろんな情報が1枚のカードにまとまっていますよね。\n\nプログラミングでも同じように、自分だけの新しいラベル（**カスタム型**）を作ることができます！",
  "typescript_lesson1_ex11_slide1_title": "オリジナルの型とは？",
  "typescript_lesson1_ex11_slide2_content": "# type（タイプ）キーワード\n\n`type` という言葉を使って、新しいラベルの名前を決められます。これを **タイプエイリアス（型の別名）** と呼びます。\n\n## 書き方のポイント\n\n`type 名前 = { プロパティ名: 型; ... };` という形で書きます。\n\n## コードで書くとこうなるよ\n\n下のコードでは、「Pet（ペット）」という新しいラベルを作っています。\n\n```typescript\n// Petという新しいラベルを作る\ntype Pet = { type: string; name: string };\n// Petラベルを使って変数を作る\nconst myPet: Pet = { type: 'いぬ', name: 'ポチ' };\nconsole.log(myPet.name);\n```\n**実行結果：** ポチ",
  "typescript_lesson1_ex11_slide2_title": "ラベルの組み合わせ（Type Alias）",
  "typescript_lesson1_ex11_slide3_content": "type（タイプ）という言葉を使って、オリジナルのラベルを作ってみましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "typescript_lesson1_ex11_slide3_title": "やってみよう！",
  "typescript_lesson1_ex11_title": "自分だけのラベルを作ってみましょう",
  "typescript_lesson1_ex12_comment1": "文字の配列なので `string` です。",
  "typescript_lesson1_ex12_comment2": "受け取る `name` は文字なので `string` です。",
  "typescript_lesson1_ex12_comment3": "関数を実行する",
  "typescript_lesson1_ex12_description": "新しい関数を作りましょうとき、受け取るデータにラベルを貼ってみましょう。",
  "typescript_lesson1_ex12_slide1_content": "# オリジナルの命令\n\nよく使う手順をひとまとめにして、自分だけの新しい命令を作ることができます。一度作っておけば、いつでも呼び出して使えます。\n\n## たとえ話\n\n「おはようの挨拶をする」という作業を考えてみてください。\n1. 相手の名前を言う\n2. 「おはよう！」と言う\n\nこの手順を「おはよう関数」として登録しておけば、いつでも「おはよう関数（太郎）」と呼び出すだけで、「太郎くん、おはよう！」と実行してくれます。",
  "typescript_lesson1_ex12_slide1_title": "関数（かんすう）とは？",
  "typescript_lesson1_ex12_slide2_content": "# 引数（ひきすう）にラベルを貼る\n\n関数が受け取るデータのことを **引数（ひきすう）** と呼びます。「関数に渡すデータ」と考えてください。\n\nTypeScriptでは、この引数にもラベルを貼ることで、「文字以外は渡さないで！」と決めることができます。\n\n## コードで書くとこうなるよ\n\n下のコードでは、`msg` という引数に `string` ラベルを貼っています。\n\n```typescript\n// 文字列（string）だけを受け取る関数\nfunction sayHello(msg: string) {\n    console.log(`メッセージ: ${msg}`);\n}\nsayHello('ヤッホー');\n```\n**実行結果：** メッセージ: ヤッホー\n\nこれで、間違って数字を渡そうとしても、TypeScriptが「文字を渡してね！」と教えてくれます。",
  "typescript_lesson1_ex12_slide2_title": "入り口のラベル",
  "typescript_lesson1_ex12_slide3_content": "新しい関数を作りましょうとき、受け取るデータにラベルを貼ってみましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "typescript_lesson1_ex12_slide3_title": "やってみよう！",
  "typescript_lesson1_ex12_title": "関数の「入り口」にラベルをはりましょう",
  "typescript_lesson1_ex13_comment1": "何も返さないときは void ラベル",
  "typescript_lesson1_ex13_comment2": "「なにも返さない」ことをあらわす `void` と入力しましょう。",
  "typescript_lesson1_ex13_comment3": "関数を実行する",
  "typescript_lesson1_ex13_description": "関数の結果として何も返さないときに使う、特別なラベルを学びましょう。",
  "typescript_lesson1_ex13_slide1_content": "# 関数の結果\n\n関数が仕事を終えたあとに返してくれる結果を **戻り値（もどりち）** と呼びます。\n\n## たとえ話\n\n自動販売機を想像してみてください。\n- 入り口：お金とボタン（= 引数）\n- 出口：ジュース（= 戻り値）\n\n関数も同じで、データを受け取って、結果を返すことができます。\n\n## 戻り値の型もラベルで指定できる\n\n関数が返すデータの型も、ラベルで指定できます。例えば「この関数は数字を返すよ」と宣言できます。",
  "typescript_lesson1_ex13_slide1_title": "戻り値（もどりち）とは？",
  "typescript_lesson1_ex13_slide2_content": "# 何も返さないときは void です\n\n結果などを「返さない」関数もあります。画面に文字を表示するだけ、など。\n\nそんな関数には、`void`（ボイド）というラベルを貼ります。これは「空っぽ」「何もない」という意味です。\n\n## コードで書くとこうなるよ\n\n下のコードでは、画面にメッセージを表示するだけで、何も返しません。\n\n```typescript\nfunction logger(text: string): void {\n    console.log(`LOG: ${text}`);\n}\nlogger('処理開始');\n```\n**実行結果：** LOG: 処理開始\n\n関数名のあとの `: void` が「何も返さないよ」という意味です。",
  "typescript_lesson1_ex13_slide2_title": "void（ボイド）ラベル",
  "typescript_lesson1_ex13_slide3_content": "関数の結果として何も返さないときに使う、特別なラベルを学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "typescript_lesson1_ex13_slide3_title": "やってみよう！",
  "typescript_lesson1_ex13_title": "「なにも返さない」というラベル",
  "typescript_lesson1_ex14_comment1": "ラベルの名前は `boolean` です。",
  "typescript_lesson1_ex14_comment2": "() のなかに、はこの名前 `isAdult` を入力します。",
  "typescript_lesson1_ex14_slide1_content": "# boolean（ブーリアン）型\n\n`true`（トゥルー：正しい）か `false`（フォルス：間違い）の、どちらかだけを入れられるラベルです。\n\n## コードで書くとこうなるよ\n\n下のコードでは、「お店が開いているか」をチェックしています。\n\n```typescript\nconst isOpen: boolean = false;  // 開いていない\nif (!isOpen) {  // もし開いていなければ\n    console.log('閉まっています');\n}\n```\n**実行結果：** 閉まっています\n\n`!`（ビックリマーク）は「〜ではない」という意味です。`!isOpen` は「開いていない」ということですね。",
  "typescript_lesson1_ex14_slide1_title": "正しいか、間違いか",
  "typescript_lesson1_ex14_title": "正しいか、間違いか",
  "typescript_lesson1_ex15_description": "数字のラベルを使って、点数によってメッセージを変えるプログラムを作りましょう。",
  "typescript_lesson1_ex15_title": "点数で分けてみましょう",
  "typescript_lesson1_ex16_comment1": "数字を入れるので `number` ラベルを貼ります。",
  "typescript_lesson1_ex16_comment2": "条件式（変数と数値の比較など）を評価し、真の場合にブロックを実行します。",
  "typescript_lesson1_ex16_comment3": "デバッグ用コンソールなどに文字列を出力します。",
  "typescript_lesson1_ex16_comment4": "もし条件が満たされなかった場合に実行する処理を記述します。",
  "typescript_lesson1_ex16_comment5": "デバッグ用コンソールなどに文字列を出力します。",
  "typescript_lesson1_ex16_slide1_content": "# 条件で分ける\n\nJavaScriptと同じように、`if`（イフ：もし）と `else`（エルス：そうでなければ）を使って動きを分けることができます。\n\n## コードで書くとこうなるよ\n\n下のコードでは、今の時間が午前か午後かをチェックしています。\n\n```typescript\nconst hour: number = 15;  // 15時\nif (hour < 12) {  // もし12より小さければ\n    console.log('午前中');\n} else {  // そうでなければ\n    console.log('お昼すぎ');\n}\n```\n**実行結果：** お昼すぎ\n\n15は12より大きいので、`else` の中が実行されました！",
  "typescript_lesson1_ex16_slide1_title": "もし〜なら、そうでなければ",
  "typescript_lesson1_ex16_title": "もし〜なら、そうでなければ",
  "typescript_lesson1_ex17_description": "2つ以上の条件を組み合わせる「&&」と「||」を学びましょう。両方の条件を満たすか、どちらかを満たすかを判定できます。",
  "typescript_lesson1_ex17_title": "論理演算子（&&、||）",
  "typescript_lesson1_ex18_comment1": "scoreの初期値を設定します。",
  "typescript_lesson1_ex18_comment2": "条件式（変数と数値の比較など）を評価し、真の場合にブロックを実行します。",
  "typescript_lesson1_ex18_comment3": "デバッグ用コンソールなどに文字列を出力します。",
  "typescript_lesson1_ex18_slide1_content": "# 条件の組み合わせ\n\n## コードで書くとこうなるよ\n\n下のコードでは、「10歳以上、かつ、20歳未満」かどうかをチェックしています。\n\n```typescript\nconst age: number = 15;\nif (age >= 10 && age < 20) {\n    console.log('10代です');\n}\n```\n**実行結果：** 10代です\n\n15歳は「10以上」であり「20より小さい」ので、両方の条件を満たしています！\n\n## まとめ\n\n- `&&` は「かつ」：両方の条件を満たすときに true\n- `||` は「または」：どちらか一方を満たせば true",
  "typescript_lesson1_ex18_slide1_title": "&& と || の使い方",
  "typescript_lesson1_ex18_title": "&& と || の使い方",
  "typescript_lesson1_ex19_description": "ラベルが貼られた配列から、データを一つずつ取り出してみましょう。",
  "typescript_lesson1_ex19_title": "順番に出してみましょう",
  "typescript_lesson1_ex1_comment1": "string（文字）ラベルを貼ったはこを作る",
  "typescript_lesson1_ex1_comment2": "文字を入れるラベルは `string` です。 '=' のあとに `'Hello TS'` と入力しましょう。",
  "typescript_lesson1_ex1_comment4": "console.log の中に、はこの名前 `message` を入力します。",
  "typescript_lesson1_ex1_description": "TypeScriptのいちばんの特徴、データの種類を決める「ラベル（型）」を使ってみましょう。文字を入れるための「string（ストリング）ラベル」を貼ってみます。",
  "typescript_lesson1_ex1_slide1_content": "# 安心・安全なプログラミング\n\nTypeScript（タイプスクリプト）は、JavaScript（ジャバスクリプト）というプログラミング言語に「型（かた）」というルールを追加した言葉です。\n\n## どうして便利なの？\n\n想像してみてください。お弁当箱に「おにぎり専用」と書いてあったら、間違えてサンドイッチを入れようとしたとき「あれ、違うかも？」と気づけますよね。\n\nTypeScriptも同じで、「ここには文字だけ入れてね」「数字だけ入れてね」と決めておくと、間違った種類のデータを入れようとしたときに「ここ間違ってるよ！」と先に教えてくれます。",
  "typescript_lesson1_ex1_slide1_title": "TypeScript（タイプスクリプト）とは？",
  "typescript_lesson1_ex1_slide2_content": "# はこに中身を教えてあげましょう\n\nプログラミングでは、データを入れておく「はこ」のことを **変数（へんすう）** と呼びます。\n\nTypeScriptでは、このはこを作るときに「このはこには文字を入れます！」「数字を入れます！」と先に決めることができます。\n\n## たとえ話\n\nおもちゃ箱に「ブロック」「ぬいぐるみ」などのラベル（シール）を貼っておくと、片付けるときに迷わないですよね。プログラミングでも同じように、はこにラベルを貼っておくと、中に何を入れるべきかがはっきりします。\n\nこの「中身の決まり」を **ラベル（型）** と呼びます。",
  "typescript_lesson1_ex1_slide2_title": "ラベル（型）とは？",
  "typescript_lesson1_ex1_slide3_content": "# :（コロン）のあとに種類を書く\n\nはこ（変数）の名前のあとに、`:`（コロン）をつけてから種類を書きます。\n\n## よく使うラベルの種類\n\n- **string**（ストリング）: 文字を入れるときのラベル（例：「こんにちは」「いぬ」など）\n- **number**（ナンバー）: 数字を入れるときのラベル（例：10、3.14 など）\n\n## コードで書くとこうなるよ\n\n下のコードでは、「animal」というはこに「string」ラベルを貼って、文字「いぬ」を入れています。\n\n```typescript\nconst animal: string = 'いぬ';\nconsole.log(animal);\n```\n**実行結果：** いぬ",
  "typescript_lesson1_ex1_slide3_title": "ラベルの貼りかた",
  "typescript_lesson1_ex1_slide4_content": "TypeScriptのいちばんの特徴、データの種類を決める「ラベル（型）」を使ってみましょう。文字を入れるための「string（ストリング）ラベル」を貼ってみます。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "typescript_lesson1_ex1_slide4_title": "やってみよう！",
  "typescript_lesson1_ex1_title": "はこに「ラベル」をはりましょう",
  "typescript_lesson1_ex20_slide1_content": "# TypeScriptが自動で予想してくれる\n\nTypeScriptはとても賢いので、配列に貼られたラベルを見て、中から取り出したデータの種類も自動で「きっとこれです！」と予想してくれます。\n\n## たとえ話\n\n「りんご箱」から取り出したものは「りんご」に決まっていますよね。\n同じように、`string[]`（文字列の配列）から取り出したものは `string`（文字列）だと自動でわかるんです！\n\nこれを **型推論（かたすいろん）** と呼びます。便利ですね！",
  "typescript_lesson1_ex20_slide1_title": "型の推論（すいろん）",
  "typescript_lesson1_ex20_title": "型の推論（すいろん）",
  "typescript_lesson1_ex21_description": "type（タイプ）という言葉を使って、オリジナルのラベルを作ってみましょう。",
  "typescript_lesson1_ex21_title": "自分だけのラベルを作ってみましょう",
  "typescript_lesson1_ex22_comment1": "name は文字なので `string` です。",
  "typescript_lesson1_ex22_comment2": "自分で作ったラベル `User` を指定します。",
  "typescript_lesson1_ex22_comment3": "ドット `.` を使って、userの中の `name` を取り出します。",
  "typescript_lesson1_ex22_slide1_content": "# type（タイプ）キーワード\n\n`type` という言葉を使って、新しいラベルの名前を決められます。これを **タイプエイリアス（型の別名）** と呼びます。\n\n## 書き方のポイント\n\n`type 名前 = { プロパティ名: 型; ... };` という形で書きます。\n\n## コードで書くとこうなるよ\n\n下のコードでは、「Pet（ペット）」という新しいラベルを作っています。\n\n```typescript\n// Petという新しいラベルを作る\ntype Pet = { type: string; name: string };\n// Petラベルを使って変数を作る\nconst myPet: Pet = { type: 'いぬ', name: 'ポチ' };\nconsole.log(myPet.name);\n```\n**実行結果：** ポチ",
  "typescript_lesson1_ex22_slide1_title": "ラベルの組み合わせ（Type Alias）",
  "typescript_lesson1_ex22_title": "ラベルの組み合わせ（Type Alias）",
  "typescript_lesson1_ex23_description": "新しい関数を作りましょうとき、受け取るデータにラベルを貼ってみましょう。",
  "typescript_lesson1_ex23_title": "関数の「入り口」にラベルをはりましょう",
  "typescript_lesson1_ex24_comment1": "受け取る `name` は文字なので `string` です。",
  "typescript_lesson1_ex24_slide1_content": "# 引数（ひきすう）にラベルを貼る\n\n関数が受け取るデータのことを **引数（ひきすう）** と呼びます。「関数に渡すデータ」と考えてください。\n\nTypeScriptでは、この引数にもラベルを貼ることで、「文字以外は渡さないで！」と決めることができます。\n\n## コードで書くとこうなるよ\n\n下のコードでは、`msg` という引数に `string` ラベルを貼っています。\n\n```typescript\n// 文字列（string）だけを受け取る関数\nfunction sayHello(msg: string) {\n    console.log(`メッセージ: ${msg}`);\n}\nsayHello('ヤッホー');\n```\n**実行結果：** メッセージ: ヤッホー\n\nこれで、間違って数字を渡そうとしても、TypeScriptが「文字を渡してね！」と教えてくれます。",
  "typescript_lesson1_ex24_slide1_title": "入り口のラベル",
  "typescript_lesson1_ex24_title": "入り口のラベル",
  "typescript_lesson1_ex25_description": "関数の結果として何も返さないときに使う、特別なラベルを学びましょう。",
  "typescript_lesson1_ex25_title": "「なにも返さない」というラベル",
  "typescript_lesson1_ex26_comment1": "「なにも返さない」ことをあらわす `void` と入力しましょう。",
  "typescript_lesson1_ex26_slide1_content": "# 何も返さないときは void です\n\n結果などを「返さない」関数もあります。画面に文字を表示するだけ、など。\n\nそんな関数には、`void`（ボイド）というラベルを貼ります。これは「空っぽ」「何もない」という意味です。\n\n## コードで書くとこうなるよ\n\n下のコードでは、画面にメッセージを表示するだけで、何も返しません。\n\n```typescript\nfunction logger(text: string): void {\n    console.log(`LOG: ${text}`);\n}\nlogger('処理開始');\n```\n**実行結果：** LOG: 処理開始\n\n関数名のあとの `: void` が「何も返さないよ」という意味です。",
  "typescript_lesson1_ex26_slide1_title": "void（ボイド）ラベル",
  "typescript_lesson1_ex26_title": "void（ボイド）ラベル",
  "typescript_lesson1_ex2_comment1": "文字を入れるラベルは `string` です。 '=' のあとに `'Hello TS'` と入力しましょう。",
  "typescript_lesson1_ex2_comment2": "x に `number` ラベルを貼ります。",
  "typescript_lesson1_ex2_comment3": "たし算した答えを出す",
  "typescript_lesson1_ex2_comment4": "y にも `number` ラベルを貼ります。",
  "typescript_lesson1_ex2_comment6": "たし算なので `+` を使います。",
  "typescript_lesson1_ex2_description": "数字を入れる「number（ナンバー）ラベル」を使って、たし算をしてみましょう。",
  "typescript_lesson1_ex2_slide1_content": "# 計算するためのラベル\n\n「10」や「3.14」のような数字を扱うときに使うのが **number（ナンバー）** ラベルです。\n\n## いつ使うの？\n\n- テストの点数を計算したいとき\n- ゲームのスコアを足したいとき\n- おこづかいの計算をしたいとき\n\nこんなときは全部 `number` ラベルを使います！計算をするときは、必ず数字ラベル（number）が必要なんです。",
  "typescript_lesson1_ex2_slide1_title": "数値型（すうちがた）とは？",
  "typescript_lesson1_ex2_slide2_content": "# number（ナンバー）型を使ってみよう\n\n整数（せいすう：1、2、3のような小数点のない数）や小数（しょうすう：3.14のような数）など、数字を入れたいときは `number` ラベルを貼ります。\n\n## コードで書くとこうなるよ\n\n下のコードでは、base（ベース：もとになる点数）と bonus（ボーナス：追加の点数）を足しています。\n\n```typescript\nconst base: number = 100;\nconst bonus: number = 50;\nconsole.log(base + bonus);\n```\n**実行結果：** 150\n\n100 + 50 = 150 になりました！",
  "typescript_lesson1_ex2_slide2_title": "数字のラベル",
  "typescript_lesson1_ex2_slide3_content": "数字を入れる「number（ナンバー）ラベル」を使って、たし算をしてみましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "typescript_lesson1_ex2_slide3_title": "やってみよう！",
  "typescript_lesson1_ex2_title": "数字のラベルで計算しましょう",
  "typescript_lesson1_ex3_comment1": "10 を 3 で割ったあまりを出力する",
  "typescript_lesson1_ex3_comment2": "あまりを求める % 演算子を使います。",
  "typescript_lesson1_ex3_description": "割り算の「あまり」を求める「%」（パーセント）演算子を学びましょう。10を3で割ったあまりは1になります。",
  "typescript_lesson1_ex3_slide1_content": "# 割り算の「あまり」を知りたい！\n\n割り算をしたときに、割り切れなくて「あまり」が出ることがありますよね。\n\n## たとえ話\n\nクッキーが10枚あって、3人で分けるとどうなるかな？\n- 1人3枚ずつもらえて、1枚あまる！\n\nこの「あまり」だけを計算してくれるのが `%`（パーセント）という記号です。\n\n**剰余（じょうよ）** という難しい名前がついていますが、単に「あまりを求める記号」と覚えれば大丈夫です！",
  "typescript_lesson1_ex3_slide1_title": "あまりを求める",
  "typescript_lesson1_ex3_slide2_content": "# あまりを計算してみよう\n\n## 例1：10 ÷ 3 のあまり\n\n```typescript\nconsole.log(10 % 3);  // => 1\n```\n\n10 ÷ 3 = 3 あまり **1** なので、「1」が表示されます。\n\n## 例2：8 ÷ 2 のあまり\n\n```typescript\nconsole.log(8 % 2);   // => 0\n```\n\n8 ÷ 2 = 4 あまり **0** なので、「0」が表示されます。\nあまりが0ということは、きれいに割り切れたということですね！",
  "typescript_lesson1_ex3_slide2_title": "% の使い方",
  "typescript_lesson1_ex3_slide3_content": "割り算の「あまり」を求める「%」（パーセント）演算子を学びましょう。10を3で割ったあまりは1になります。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "typescript_lesson1_ex3_slide3_title": "やってみよう！",
  "typescript_lesson1_ex3_title": "剰余演算子（%）",
  "typescript_lesson1_ex4_comment1": "x に `number` ラベルを貼ります。",
  "typescript_lesson1_ex4_comment2": "50 と入力しましょう。",
  "typescript_lesson1_ex4_comment3": "たし算なので `+` を使います。",
  "typescript_lesson1_ex4_comment4": "変数の値を計算して、その結果を同じ変数に再代入します。",
  "typescript_lesson1_ex4_description": "変数に値を足したり引いたりして、同じ変数に戻す便利な書き方を学びましょう。",
  "typescript_lesson1_ex4_slide1_content": "# はこの中身をパワーアップ\n\n「今の点数に10点プラスしたい！」というとき、`+=` を使うと便利です。\n\n## たとえ話\n\n貯金箱に100円入っていて、50円を追加するとき、わざわざ「100円 + 50円 = 150円」と書くのは大変ですよね。\n\n`+=` は「今入っている金額に、もっと足して、同じ場所に保存する」という合体技なんです！\n\n## コードで書くとこうなるよ\n\n```typescript\nlet x: number = 10;\nx += 5;  // x に 5 を足して保存（x = x + 5 と同じ意味）\nconsole.log(x);  // => 15\n```\n\n`let` は中身を変えられるはこを作るときに使います（`const` は変えられないはこでしたね）。",
  "typescript_lesson1_ex4_slide1_title": "中身を増やしたいとき",
  "typescript_lesson1_ex4_slide2_content": "# 引き算バージョン\n\n`-=` を使えば、「今の数字から引いて保存」ができます。\n\n## たとえ話\n\n貯金箱から100円使うとき、残りのお金を計算しますよね。`-=` はそれを簡単にできる記号です。\n\n## コードで書くとこうなるよ\n\n```typescript\nlet x: number = 10;\nx -= 3;  // x から 3 を引いて保存（x = x - 3 と同じ意味）\nconsole.log(x);  // => 7\n```\n\n**覚え方：** `+=` は「足して保存」、`-=` は「引いて保存」です！",
  "typescript_lesson1_ex4_slide2_title": "-= も使える",
  "typescript_lesson1_ex4_slide3_content": "変数に値を足したり引いたりして、同じ変数に戻す便利な書き方を学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "typescript_lesson1_ex4_slide3_title": "やってみよう！",
  "typescript_lesson1_ex4_title": "累算代入演算子（+=、-=）",
  "typescript_lesson1_ex5_comment1": "age というはこに 10 を入れる",
  "typescript_lesson1_ex5_comment2": "数字を入れるので、ラベルは `number` です。",
  "typescript_lesson1_ex5_comment4": "デバッグ用コンソールなどに文字列を出力します。",
  "typescript_lesson1_ex5_description": "ラベルを貼ったはこの中身を、文章の中に埋め込んでみましょう。",
  "typescript_lesson1_ex5_slide1_content": "# テンプレートリテラル\n\n文章の途中に、変数（はこ）の中身を入れたいときに使うのが **テンプレートリテラル** です。\n\n## たとえ話\n\n「こんにちは、○○さん！」という文章の「○○」の部分を、その人の名前に変えたいことってありますよね。\n\nテンプレートリテラルを使うと、文章の一部を変数（はこ）の中身に置き換えることができます。\n\nつまり「こんにちは、${name}さん！」と書くと、nameに入っている名前が自動で入るんです！",
  "typescript_lesson1_ex5_slide1_title": "文章と変数を組み合わせる",
  "typescript_lesson1_ex5_slide2_content": "# JavaScriptと同じ書き方ができます\n\n## 書き方のポイント\n\n1. キーボードの ``` ` ``` という記号（バッククォート）で文章を囲みます\n2. 変数を入れたい場所に `${変数名}` と書きます\n\n## コードで書くとこうなるよ\n\n下のコードでは、「food」というはこの中身「カレー」が、文章に埋め込まれます。\n\n```typescript\nconst food: string = 'カレー';\nconsole.log(`今日の夕飯は${food}です`);\n```\n**実行結果：** 今日の夕飯はカレーです\n\n**ヒント：** バッククォート ` ``` ` ` は、キーボードの左上にある「Shift + @」で打てます！",
  "typescript_lesson1_ex5_slide2_title": "文章と変数をくっつける",
  "typescript_lesson1_ex5_slide3_content": "ラベルを貼ったはこの中身を、文章の中に埋め込んでみましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "typescript_lesson1_ex5_slide3_title": "やってみよう！",
  "typescript_lesson1_ex5_title": "ラベルを貼ったはこを文章に入れましょう",
  "typescript_lesson1_ex6_comment1": "あまりを求める % 演算子を使います。",
  "typescript_lesson1_ex6_comment2": "文字の配列なので `string` です。",
  "typescript_lesson1_ex6_comment4": "2番目のデータの番号は 1 です。",
  "typescript_lesson1_ex6_description": "同じラベル（型）のデータをまとめて入れられる「配列」を使ってみましょう。",
  "typescript_lesson1_ex6_slide1_content": "# データの行列\n\nたくさんのデータを順番に並べておきたいときに使うのが **配列（はいれつ）** です。\n\n## たとえ話\n\nロッカーを想像してみてください。1番、2番、3番...と番号がついた小さな引き出しが並んでいて、それぞれにモノを入れられますよね。\n\n配列はまさにこのロッカーのようなもの！クラスの全員の名前や、買い物リストなど、たくさんのデータを一つの変数にまとめて管理できます。\n\n## 番号は0から始まる\n\nプログラミングでは、1番目ではなく **0番目** からスタートします。これは覚えておきましょう！",
  "typescript_lesson1_ex6_slide1_title": "配列（はいれつ）とは？",
  "typescript_lesson1_ex6_slide2_content": "# string[] や number[]\n\n「文字のラベルがついたデータの列」を作りたいときは、`string[]` のようにラベルの名前のあとに `[]`（角かっこ）をつけます。\n\n## コードで書くとこうなるよ\n\n下のコードでは、2つの食べ物の名前を配列に入れています。\n\n```typescript\n// 文字列の配列（2つの食べ物が入っている）\nconst items: string[] = ['おにぎり', 'パン'];\nconsole.log(items[0]);  // 0番目を取り出す\n```\n**実行結果：** おにぎり\n\n`items[0]` は「itemsの0番目」という意味です。0番目は「おにぎり」ですね！",
  "typescript_lesson1_ex6_slide2_title": "ラベルのあとに [] をつけましょう",
  "typescript_lesson1_ex6_slide3_content": "同じラベル（型）のデータをまとめて入れられる「配列」を使ってみましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "typescript_lesson1_ex6_slide3_title": "やってみよう！",
  "typescript_lesson1_ex6_title": "同じラベルを並べる「配列」",
  "typescript_lesson1_ex7_comment1": "boolean（はい/いいえ）ラベルを貼る",
  "typescript_lesson1_ex7_comment2": "ラベルの名前は `boolean` です。",
  "typescript_lesson1_ex7_comment3": "メッセージを表示",
  "typescript_lesson1_ex7_comment4": "() のなかに、はこの名前 `isAdult` を入力します。",
  "typescript_lesson1_ex7_description": "boolean（ブーリアン）という、2つの状態しかないラベルを使ってみましょう。",
  "typescript_lesson1_ex7_slide1_content": "# スイッチのようなラベル\n\n「はい（正しい）」か「いいえ（間違い）」のどちらかしかない状態を扱うのが **boolean（ブーリアン）** です。\n\n## たとえ話\n\n電気のスイッチを想像してみてください。「ON（つけている）」か「OFF（消している）」の2つしかありませんよね。\n\nbooleanも同じで、「true（正しい・はい）」か「false（間違い・いいえ）」の2つの状態しかありません。\n\n## いつ使うの？\n\n- ログインしているかどうか\n- ゲームがクリアしたかどうか\n- お店が開いているかどうか\n\nこんな「はい/いいえ」で答えられる質問に使います！",
  "typescript_lesson1_ex7_slide1_title": "論理型（ろんりがた）とは？",
  "typescript_lesson1_ex7_slide2_content": "# boolean（ブーリアン）型\n\n`true`（トゥルー：正しい）か `false`（フォルス：間違い）の、どちらかだけを入れられるラベルです。\n\n## コードで書くとこうなるよ\n\n下のコードでは、「お店が開いているか」をチェックしています。\n\n```typescript\nconst isOpen: boolean = false;  // 開いていない\nif (!isOpen) {  // もし開いていなければ\n    console.log('閉まっています');\n}\n```\n**実行結果：** 閉まっています\n\n`!`（ビックリマーク）は「〜ではない」という意味です。`!isOpen` は「開いていない」ということですね。",
  "typescript_lesson1_ex7_slide2_title": "正しいか、間違いか",
  "typescript_lesson1_ex7_slide3_content": "boolean（ブーリアン）という、2つの状態しかないラベルを使ってみましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "typescript_lesson1_ex7_slide3_title": "やってみよう！",
  "typescript_lesson1_ex7_title": "「はい」か「いいえ」のラベル",
  "typescript_lesson1_ex8_comment1": "50 と入力しましょう。",
  "typescript_lesson1_ex8_comment10": "デバッグ用コンソールなどに文字列を出力します。",
  "typescript_lesson1_ex8_comment2": "数字を入れるので `number` ラベルを貼ります。",
  "typescript_lesson1_ex8_comment3": "それ以外の場合",
  "typescript_lesson1_ex8_comment4": "条件式（変数と数値の比較など）を評価し、真の場合にブロックを実行します。",
  "typescript_lesson1_ex8_comment5": "ざんねんメッセージ",
  "typescript_lesson1_ex8_comment6": "デバッグ用コンソールなどに文字列を出力します。",
  "typescript_lesson1_ex8_comment8": "もし条件が満たされなかった場合に実行する処理を記述します。",
  "typescript_lesson1_ex8_description": "数字のラベルを使って、点数によってメッセージを変えるプログラムを作りましょう。",
  "typescript_lesson1_ex8_slide1_content": "# もし〜なら、の仕組み\n\n「雨が降ったら傘をさす」「晴れたら外で遊ぶ」のように、状況によって動きを変えることを **条件分岐（じょうけんぶんき）** と呼びます。\n\n## たとえ話\n\n自動販売機でジュースを買うときを想像してみてください。\n- もしお金が足りたら → ジュースが出てくる\n- もしお金が足りなかったら → 「お金が足りません」と表示される\n\nこれが条件分岐です！プログラムに「こういうときはこうして」と判断させることができます。",
  "typescript_lesson1_ex8_slide1_title": "条件分岐（じょうけんぶんき）とは？",
  "typescript_lesson1_ex8_slide2_content": "# 条件で分ける\n\nJavaScriptと同じように、`if`（イフ：もし）と `else`（エルス：そうでなければ）を使って動きを分けることができます。\n\n## コードで書くとこうなるよ\n\n下のコードでは、今の時間が午前か午後かをチェックしています。\n\n```typescript\nconst hour: number = 15;  // 15時\nif (hour < 12) {  // もし12より小さければ\n    console.log('午前中');\n} else {  // そうでなければ\n    console.log('お昼すぎ');\n}\n```\n**実行結果：** お昼すぎ\n\n15は12より大きいので、`else` の中が実行されました！",
  "typescript_lesson1_ex8_slide2_title": "もし〜なら、そうでなければ",
  "typescript_lesson1_ex8_slide3_content": "数字のラベルを使って、点数によってメッセージを変えるプログラムを作りましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "typescript_lesson1_ex8_slide3_title": "やってみよう！",
  "typescript_lesson1_ex8_title": "点数で分けてみましょう",
  "typescript_lesson1_ex9_comment1": "scoreに85を入れる",
  "typescript_lesson1_ex9_comment2": "scoreの初期値を設定します。",
  "typescript_lesson1_ex9_comment3": "ごうかくメッセージを表示",
  "typescript_lesson1_ex9_comment4": "条件式（変数と数値の比較など）を評価し、真の場合にブロックを実行します。",
  "typescript_lesson1_ex9_comment6": "デバッグ用コンソールなどに文字列を出力します。",
  "typescript_lesson1_ex9_description": "2つ以上の条件を組み合わせる「&&」と「||」を学びましょう。両方の条件を満たすか、どちらかを満たすかを判定できます。",
  "typescript_lesson1_ex9_slide1_content": "# 複数の条件\n\n「10歳以上で、かつ、宿題が終わっていたら、ゲームをしてもいいよ」というように、2つの条件を組み合わせたいときがありますよね。\n\n## 2つの記号を覚えよう\n\n- `&&`（アンドアンド）：「かつ」= 両方とも満たすとき\n- `||`（オアオア）：「または」= どちらか一方を満たすとき\n\n## たとえ話\n\n- 「傘を持っている **かつ** 雨が降っている」→ 傘をさす\n- 「暑い **または** のどが渇いた」→ 水を飲む",
  "typescript_lesson1_ex9_slide1_title": "条件を組み合わせる",
  "typescript_lesson1_ex9_slide2_content": "# 条件の組み合わせ\n\n## コードで書くとこうなるよ\n\n下のコードでは、「10歳以上、かつ、20歳未満」かどうかをチェックしています。\n\n```typescript\nconst age: number = 15;\nif (age >= 10 && age < 20) {\n    console.log('10代です');\n}\n```\n**実行結果：** 10代です\n\n15歳は「10以上」であり「20より小さい」ので、両方の条件を満たしています！\n\n## まとめ\n\n- `&&` は「かつ」：両方の条件を満たすときに true\n- `||` は「または」：どちらか一方を満たせば true",
  "typescript_lesson1_ex9_slide2_title": "&& と || の使い方",
  "typescript_lesson1_ex9_slide3_content": "2つ以上の条件を組み合わせる「&&」と「||」を学びましょう。両方の条件を満たすか、どちらかを満たすかを判定できます。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "typescript_lesson1_ex9_slide3_title": "やってみよう！",
  "typescript_lesson1_ex9_title": "論理演算子（&&、||）",
  "typescript_lesson1_title": "TypeScript (タイプスクリプト) に挑戦！",
  "typescript_lesson2_course_description": "TypeScriptの基本をマスターしたら、より高度な型システムを学びましょう！ユニオン型、インターフェース、ジェネリクスなどを身につけます。",
  "typescript_lesson2_course_title": "TypeScript II - ステップアップ！",
  "typescript_lesson2_ex10_comment1": "`readonly` キーワードを使います。",
  "typescript_lesson2_ex10_comment10": "名前は文字列なので `string` です。",
  "typescript_lesson2_ex10_comment14": "名前の値を文字列で指定します。",
  "typescript_lesson2_ex10_comment16": "取得したいプロパティ名を指定します。",
  "typescript_lesson2_ex10_comment2": "名前は文字列なので `string` です。",
  "typescript_lesson2_ex10_comment3": "名前の値を文字列で指定します。",
  "typescript_lesson2_ex10_comment4": "IDは数値なので `number` です。",
  "typescript_lesson2_ex10_comment5": "Userオブジェクトを作成",
  "typescript_lesson2_ex10_comment6": "名前を出力",
  "typescript_lesson2_ex10_comment8": "`extends` キーワードを使います。",
  "typescript_lesson2_ex10_description": "既存のインターフェースを拡張して新しいインターフェースを作る方法を学びましょう。",
  "typescript_lesson2_ex10_slide1_content": "# インターフェースの継承（けいしょう）\n\n**extends**（エクステンズ）を使うと、既存のインターフェースを「土台」にして、新しいプロパティを追加できます。\n\n## たとえ話\n\n「動物カード」には「名前」が書いてあります。「犬カード」は動物なので名前があり、さらに「犬種」も書いてあります。\n\nつまり「犬カード」は「動物カード」を拡張したものですね！\n\n## コードで書くとこうなるよ\n\n```typescript\ninterface Animal {\n    name: string;  // 動物の名前\n}\n\ninterface Dog extends Animal {\n    breed: string;  // 犬種を追加！\n}\n// Dogはnameとbreedの両方を持つ\n```",
  "typescript_lesson2_ex10_slide1_title": "extendsで拡張",
  "typescript_lesson2_ex10_slide2_content": "# 複数から継承\n\n複数のインターフェースを組み合わせることもできます。カンマ（,）で区切って書きます。\n\n## たとえ話\n\n「歌える」という能力と「踊れる」という能力があるとします。「アイドル」は両方の能力を持っていますよね！\n\n## コードで書くとこうなるよ\n\n```typescript\ninterface A { a: string; }  // Aの特徴\ninterface B { b: number; }  // Bの特徴\n\n// AとBの両方を継承\ninterface C extends A, B {\n    c: boolean;  // Cだけの特徴\n}\n\nconst obj: C = { a: 'hi', b: 1, c: true };\n// a, b, c すべて必要！\n```",
  "typescript_lesson2_ex10_slide2_title": "複数の拡張",
  "typescript_lesson2_ex10_slide3_content": "既存のインターフェースを拡張して新しいインターフェースを作る方法を学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "typescript_lesson2_ex10_slide3_title": "やってみよう！",
  "typescript_lesson2_ex10_title": "インターフェースの拡張",
  "typescript_lesson2_ex11_description": "関連する定数をグループ化する「列挙型」を学びましょう。",
  "typescript_lesson2_ex11_title": "列挙型（enum）",
  "typescript_lesson2_ex12_comment1": "`enum` キーワードを使います。",
  "typescript_lesson2_ex12_comment2": "日曜日を表す値を指定します。",
  "typescript_lesson2_ex12_comment3": "月曜日を表す値を指定します。",
  "typescript_lesson2_ex12_comment4": "火曜日を表す値を指定します。",
  "typescript_lesson2_ex12_comment5": "月曜日の列挙値を指定します。",
  "typescript_lesson2_ex12_comment6": "出力する変数を指定します。",
  "typescript_lesson2_ex12_slide1_content": "# 自動で番号が振られる\n\nenumを作ると、自動で0から順番に番号が割り当てられます。\n\n## たとえ話\n\nクラスの出席番号のようなものです。1番目の人が0番、2番目の人が1番...というふうに自動で番号がつきます。\n\n## コードで書くとこうなるよ\n\n```typescript\nenum Color {\n    Red,    // 0 が自動で割り当て\n    Green,  // 1 が自動で割り当て\n    Blue    // 2 が自動で割り当て\n}\n\nconsole.log(Color.Green);  // 1 と表示される\n```\n\n0から始まるのがポイントです！",
  "typescript_lesson2_ex12_slide1_title": "enumの値",
  "typescript_lesson2_ex12_title": "enumの値",
  "typescript_lesson2_ex13_description": "型を引数のように扱う「ジェネリクス」の基本を学びましょう。",
  "typescript_lesson2_ex13_title": "ジェネリクス入門",
  "typescript_lesson2_ex14_comment1": "型パラメータは `<T>` のように書きます。",
  "typescript_lesson2_ex14_comment2": "引数で受け取った値を配列に入れて返します。",
  "typescript_lesson2_ex14_comment3": "配列に入れる値を指定します。",
  "typescript_lesson2_ex14_comment4": "出力する変数を指定します。",
  "typescript_lesson2_ex14_slide1_content": "# TypeScriptが型を推測\n\nTypeScriptは賢いので、渡した値から型を自動的に判断してくれます。これを **型推論（かたすいろん）** と呼びます。\n\n## たとえ話\n\n「りんご」を箱に入れたら、わざわざ「これはりんご箱です」と言わなくても、見ればわかりますよね。TypeScriptも同じです！\n\n## コードで書くとこうなるよ\n\n```typescript\nfunction identity<T>(arg: T): T {\n    return arg;\n}\n\n// <string> を書かなくても、TypeScriptが推測してくれる！\nconst str = identity('hello');  // string と推論\nconst num = identity(42);       // number と推論\n```\n\n便利ですね！",
  "typescript_lesson2_ex14_slide1_title": "型推論と一緒に",
  "typescript_lesson2_ex14_title": "型推論と一緒に",
  "typescript_lesson2_ex15_description": "インターフェースでジェネリクスを使う方法を学びましょう。",
  "typescript_lesson2_ex15_title": "ジェネリクスとインターフェース",
  "typescript_lesson2_ex16_comment1": "型パラメータ `T` を使います。",
  "typescript_lesson2_ex16_comment2": "型パラメータで指定した型を使います。",
  "typescript_lesson2_ex16_comment3": "アイテムの値を文字列で指定します。",
  "typescript_lesson2_ex16_comment4": "取得したいプロパティ名を指定します。",
  "typescript_lesson2_ex16_slide1_content": "# APIレスポンスなどに\n\nWebサイトからデータを取得するとき、「成功/失敗」と「データ」がセットで返ってくることが多いです。ジェネリクスを使うと、いろんなデータに対応できる型を作れます。\n\n## コードで書くとこうなるよ\n\n```typescript\n// 汎用的なレスポンスの型\ninterface Response<T> {\n    data: T;         // データ（型は後で決める）\n    status: number;  // 状態コード（200=成功など）\n}\n\ninterface User { name: string; }\n\n// ユーザー情報のレスポンス\nconst res: Response<User> = {\n    data: { name: 'Taro' },\n    status: 200\n};\n```\n\nこれで同じ型を使いまわせて便利です！",
  "typescript_lesson2_ex16_slide1_title": "実践的な例",
  "typescript_lesson2_ex16_title": "実践的な例",
  "typescript_lesson2_ex17_description": "既存の変数から型を取得する `typeof` を学びましょう。",
  "typescript_lesson2_ex17_title": "typeof 型演算子",
  "typescript_lesson2_ex18_comment1": "y座標の値を数値で指定します。",
  "typescript_lesson2_ex18_comment2": "`typeof` で変数の型を取得します。",
  "typescript_lesson2_ex18_comment3": "取得したいプロパティ名を指定します。",
  "typescript_lesson2_ex18_slide1_content": "# 型の再利用\n\n既にある変数と「まったく同じ形」の新しい変数を作りたいときに便利です。\n\n## たとえ話\n\n設定ファイルを2つ作りたいとき、「1つ目の設定と同じ項目を持つ2つ目の設定」を作れます。\n\n## コードで書くとこうなるよ\n\n```typescript\nconst config = {\n    api: 'https://...',\n    timeout: 5000\n};\n\n// configと同じ形の別の設定を作る\nconst config2: typeof config = {\n    api: 'https://other...',\n    timeout: 3000\n};\n```\n\nこうすれば、同じ項目を忘れずに設定できます！",
  "typescript_lesson2_ex18_slide1_title": "同じ型の変数を作る",
  "typescript_lesson2_ex18_title": "同じ型の変数を作る",
  "typescript_lesson2_ex19_description": "既存のインターフェースを拡張して新しいインターフェースを作る方法を学びましょう。",
  "typescript_lesson2_ex19_title": "インターフェースの拡張",
  "typescript_lesson2_ex1_comment1": "| でユニオン型を定義",
  "typescript_lesson2_ex1_comment10": "数値の引数を渡します。",
  "typescript_lesson2_ex1_comment2": "ユニオン型は `|` で区切ります。",
  "typescript_lesson2_ex1_comment3": "文字列を渡す",
  "typescript_lesson2_ex1_comment4": "出力する変数を指定します。",
  "typescript_lesson2_ex1_comment8": "文字列の引数を渡します。",
  "typescript_lesson2_ex1_description": "複数の型のどれかを許容する「ユニオン型」を学びましょう。",
  "typescript_lesson2_ex1_slide1_content": "# 複数の型を許容する\n\n**ユニオン型**は、「AまたはB」のように、複数の型のうちどれかを受け入れる型です。\n\n## たとえ話\n\n「飲み物専用」と「お菓子専用」の両方OKな引き出しがあったら便利ですよね。ユニオン型はまさにそれ！「文字でも数字でもOK」というラベルを作れます。\n\n## 書き方のポイント\n\n`|`（パイプ・縦棒）で型をつなげます。\n\n```typescript\nlet value: string | number;  // 文字か数字のどちらかOK\nvalue = 'hello';  // 文字 → OK!\nvalue = 42;       // 数字 → OK!\n```",
  "typescript_lesson2_ex1_slide1_title": "ユニオン型とは？",
  "typescript_lesson2_ex1_slide2_content": "# 柔軟な関数の引数\n\n関数の引数にユニオン型を使うと、いろんな種類のデータを受け取れるようになります。\n\n## たとえ話\n\nIDカードを想像してみてください。番号だけのID（例：12345）もあれば、文字入りのID（例：ABC-001）もありますよね。どちらも受け付けられる関数を作れます！\n\n## コードで書くとこうなるよ\n\n```typescript\nfunction printId(id: string | number) {\n    console.log('ID:', id);\n}\n\nprintId('abc');  // 文字のID → OK!\nprintId(123);    // 数字のID → OK!\n```",
  "typescript_lesson2_ex1_slide2_title": "ユニオン型の使い方",
  "typescript_lesson2_ex1_slide3_content": "複数の型のどれかを許容する「ユニオン型」を学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "typescript_lesson2_ex1_slide3_title": "やってみよう！",
  "typescript_lesson2_ex1_title": "ユニオン型",
  "typescript_lesson2_ex20_comment1": "IDは数値なので `number` です。",
  "typescript_lesson2_ex20_comment2": "`extends` キーワードを使います。",
  "typescript_lesson2_ex20_comment3": "名前は文字列なので `string` です。",
  "typescript_lesson2_ex20_comment4": "名前の値を文字列で指定します。",
  "typescript_lesson2_ex20_comment5": "取得したいプロパティ名を指定します。",
  "typescript_lesson2_ex20_slide1_content": "# 複数から継承\n\n複数のインターフェースを組み合わせることもできます。カンマ（,）で区切って書きます。\n\n## たとえ話\n\n「歌える」という能力と「踊れる」という能力があるとします。「アイドル」は両方の能力を持っていますよね！\n\n## コードで書くとこうなるよ\n\n```typescript\ninterface A { a: string; }  // Aの特徴\ninterface B { b: number; }  // Bの特徴\n\n// AとBの両方を継承\ninterface C extends A, B {\n    c: boolean;  // Cだけの特徴\n}\n\nconst obj: C = { a: 'hi', b: 1, c: true };\n// a, b, c すべて必要！\n```",
  "typescript_lesson2_ex20_slide1_title": "複数の拡張",
  "typescript_lesson2_ex20_title": "複数の拡張",
  "typescript_lesson2_ex2_comment1": "ユニオン型は `|` で区切ります。",
  "typescript_lesson2_ex2_comment10": "年齢の値を数値で指定します。",
  "typescript_lesson2_ex2_comment12": "取得したいプロパティ名を指定します。",
  "typescript_lesson2_ex2_comment2": "`interface` キーワードを使います。",
  "typescript_lesson2_ex2_comment3": "文字列の引数を渡します。",
  "typescript_lesson2_ex2_comment4": "名前は文字列なので `string` です。",
  "typescript_lesson2_ex2_comment5": "名前を出力",
  "typescript_lesson2_ex2_comment6": "年齢は数値なので `number` です。",
  "typescript_lesson2_ex2_description": "オブジェクトの形を定義する「インターフェース」を学びましょう。",
  "typescript_lesson2_ex2_slide1_content": "# オブジェクトの設計図\n\n**インターフェース**（interface）は、オブジェクトが持つべきプロパティ（属性・特徴）を定義する「設計図」のようなものです。\n\n## たとえ話\n\n「生徒カード」を作るときの規則を想像してみてください。\n- 必ず「名前」を書く\n- 必ず「年齢」を書く\n\nインターフェースは、こんな規則をプログラムで表現したものです。\n\n## コードで書くとこうなるよ\n\n```typescript\ninterface User {\n    name: string;  // 名前は必須\n    age: number;   // 年齢も必須\n}\n\nconst user: User = {\n    name: 'Taro',\n    age: 20\n};\n```",
  "typescript_lesson2_ex2_slide1_title": "インターフェースとは？",
  "typescript_lesson2_ex2_slide2_content": "# 間違いを防ぐ\n\nインターフェースの規則に合わないオブジェクトを作ろうとすると、TypeScriptがエラーで教えてくれます。\n\n## たとえ話\n\n「名前と年齢を両方書いてね」というルールなのに、名前だけ書いて提出しようとしたら「年齢も書いて！」と言われますよね。\n\n## コードで書くとこうなるよ\n\n```typescript\ninterface User {\n    name: string;\n    age: number;\n}\n\n// エラー！ 'age' がありません\nconst user: User = { name: 'Taro' };\n```\n\nこうやって、うっかり忘れを防いでくれるんです！",
  "typescript_lesson2_ex2_slide2_title": "型チェックの恩恵",
  "typescript_lesson2_ex2_slide3_content": "オブジェクトの形を定義する「インターフェース」を学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "typescript_lesson2_ex2_slide3_title": "やってみよう！",
  "typescript_lesson2_ex2_title": "インターフェース",
  "typescript_lesson2_ex3_comment1": "nicknameは省略可能",
  "typescript_lesson2_ex3_comment10": "名前の値を文字列で指定します。",
  "typescript_lesson2_ex3_comment12": "取得したいプロパティ名を指定します。",
  "typescript_lesson2_ex3_comment2": "? でオプショナルに",
  "typescript_lesson2_ex3_comment3": "Profileオブジェクトを作成",
  "typescript_lesson2_ex3_comment4": "名前は文字列なので `string` です。",
  "typescript_lesson2_ex3_comment6": "`?` を使うとオプショナルになります。",
  "typescript_lesson2_ex3_description": "あってもなくてもいいプロパティを定義する方法を学びましょう。",
  "typescript_lesson2_ex3_slide1_content": "# 省略可能なプロパティ\n\n**オプショナルプロパティ**は、「あってもなくてもOK」な項目のことです。プロパティ名の後に `?`（クエスチョンマーク）をつけると設定できます。\n\n## たとえ話\n\nアンケート用紙を想像してみてください。\n- 名前：必須\n- メールアドレス：任意（書いても書かなくてもOK）\n\nプログラミングでも同じように、「必須の項目」と「あればいいな」の項目を分けられます。\n\n## コードで書くとこうなるよ\n\n```typescript\ninterface User {\n    name: string;     // 必須\n    email?: string;   // ?がついているので省略OK\n}\n```",
  "typescript_lesson2_ex3_slide1_title": "? でオプショナルに",
  "typescript_lesson2_ex3_slide2_content": "# 柔軟なオブジェクト\n\n`?` をつけたプロパティは、あってもなくてもエラーになりません。\n\n## コードで書くとこうなるよ\n\n```typescript\ninterface User {\n    name: string;\n    email?: string;  // オプショナル\n}\n\n// emailなし → OK!\nconst user1: User = { name: 'Taro' };\n\n// emailあり → もちろんOK!\nconst user2: User = { name: 'Hanako', email: 'h@example.com' };\n```\n\nどちらもエラーにならず、柔軟に対応できますね！",
  "typescript_lesson2_ex3_slide2_title": "オプショナルの使い方",
  "typescript_lesson2_ex3_slide3_content": "あってもなくてもいいプロパティを定義する方法を学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "typescript_lesson2_ex3_slide3_title": "やってみよう！",
  "typescript_lesson2_ex3_title": "オプショナルプロパティ",
  "typescript_lesson2_ex4_comment1": "`interface` キーワードを使います。",
  "typescript_lesson2_ex4_comment2": "`type` キーワードを使います。",
  "typescript_lesson2_ex4_comment3": "年齢は数値なので `number` です。",
  "typescript_lesson2_ex4_comment4": "年齢の値を数値で指定します。",
  "typescript_lesson2_ex4_comment5": "数学の点数を数値で指定します。",
  "typescript_lesson2_ex4_comment7": "英語の点数を数値で指定します。",
  "typescript_lesson2_ex4_comment9": "足し算の演算子を使います。",
  "typescript_lesson2_ex4_description": "型に名前をつける「型エイリアス」を学びましょう。",
  "typescript_lesson2_ex4_slide1_content": "# 型に別名をつける\n\n**型エイリアス**（Type Alias）は、型に自分で名前をつける機能です。`type` というキーワードを使います。\n\n## たとえ話\n\n「ID」というものを考えてみてください。学校では「出席番号」、お店では「会員番号」など、いろんな名前がありますが、どれも「番号」や「コード」ですよね。\n\n型エイリアスを使うと、「この型は ID と呼ぶことにしよう！」と決められます。\n\n## コードで書くとこうなるよ\n\n```typescript\ntype ID = string | number;  // IDという名前をつける\n\nlet userId: ID = 'abc';   // 文字のID\nlet orderId: ID = 123;    // 数字のID\n```",
  "typescript_lesson2_ex4_slide1_title": "型エイリアスとは？",
  "typescript_lesson2_ex4_slide2_content": "# 読みやすいコードに\n\n型エイリアスを使うと、複雑な型に分かりやすい名前をつけられます。\n\n## たとえ話\n\n「緯度と経度のペア」を毎回 `{ latitude: number; longitude: number; }` と書くのは大変ですよね。\n「座標」という名前をつけておけば、すっきり書けます！\n\n## コードで書くとこうなるよ\n\n```typescript\ntype Point = {\n    x: number;\n    y: number;\n};\n\nconst origin: Point = { x: 0, y: 0 };\n```\n\nこれで何度も同じ型を書かなくて済みますし、コードも読みやすくなります！",
  "typescript_lesson2_ex4_slide2_title": "複雑な型を整理",
  "typescript_lesson2_ex4_slide3_content": "型に名前をつける「型エイリアス」を学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "typescript_lesson2_ex4_slide3_title": "やってみよう！",
  "typescript_lesson2_ex4_title": "型エイリアス",
  "typescript_lesson2_ex5_comment1": "idは読み取り専用",
  "typescript_lesson2_ex5_comment10": "名前の値を文字列で指定します。",
  "typescript_lesson2_ex5_comment12": "取得したいプロパティ名を指定します。",
  "typescript_lesson2_ex5_comment2": "readonly で読み取り専用に",
  "typescript_lesson2_ex5_comment3": "Itemオブジェクトを作成",
  "typescript_lesson2_ex5_comment4": "`readonly` キーワードを使います。",
  "typescript_lesson2_ex5_comment6": "名前は文字列なので `string` です。",
  "typescript_lesson2_ex5_description": "読み取り専用のプロパティを定義する方法を学びましょう。",
  "typescript_lesson2_ex5_slide1_content": "# 書き換え禁止\n\n**readonly**（リードオンリー）は、「読み取り専用」という意味です。このキーワードをつけたプロパティは、一度値を入れたら変更できなくなります。\n\n## たとえ話\n\n図書館の本を想像してみてください。借りて読むことはできますが、書き込みはできませんよね。`readonly` はまさにそれ！「読むだけで、書き換えは禁止」です。\n\n## コードで書くとこうなるよ\n\n```typescript\ninterface Config {\n    readonly apiKey: string;  // 読み取り専用\n}\n\nconst config: Config = { apiKey: 'abc123' };\nconfig.apiKey = 'xyz';  // エラー！変更できません\n```",
  "typescript_lesson2_ex5_slide1_title": "readonlyとは？",
  "typescript_lesson2_ex5_slide2_content": "# 安全なコード\n\n「絶対に変更されたくない値」を守れます。例えば、ユーザーのIDは変わってはいけませんよね。\n\n## コードで書くとこうなるよ\n\n```typescript\ninterface User {\n    readonly id: number;  // IDは変更禁止\n    name: string;         // 名前は変更OK\n}\n\nconst user: User = { id: 1, name: 'Taro' };\nuser.name = 'Jiro';  // OK! 名前は変えられる\nuser.id = 2;         // エラー！ IDは変えられない\n```\n\nこうやって、大切なデータを間違って変更してしまうのを防げます！",
  "typescript_lesson2_ex5_slide2_title": "readonlyの活用",
  "typescript_lesson2_ex5_slide3_content": "読み取り専用のプロパティを定義する方法を学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "typescript_lesson2_ex5_slide3_title": "やってみよう！",
  "typescript_lesson2_ex5_title": "readonly プロパティ",
  "typescript_lesson2_ex6_comment1": "名前は文字列なので `string` です。",
  "typescript_lesson2_ex6_comment12": "月曜日の列挙値を指定します。",
  "typescript_lesson2_ex6_comment14": "出力する変数を指定します。",
  "typescript_lesson2_ex6_comment2": "`enum` キーワードを使います。",
  "typescript_lesson2_ex6_comment3": "名前の値を文字列で指定します。",
  "typescript_lesson2_ex6_comment4": "日曜日を表す値を指定します。",
  "typescript_lesson2_ex6_comment5": "月曜日を代入",
  "typescript_lesson2_ex6_comment6": "月曜日を表す値を指定します。",
  "typescript_lesson2_ex6_comment8": "火曜日を表す値を指定します。",
  "typescript_lesson2_ex6_description": "関連する定数をグループ化する「列挙型」を学びましょう。",
  "typescript_lesson2_ex6_slide1_content": "# 名前付きの定数群\n\n**enum**（イーナム）は、「列挙型（れっきょがた）」と呼ばれ、関連する値に名前をつけてグループ化できる機能です。\n\n## たとえ話\n\n方角を考えてみてください。「上・下・左・右」という4つの決まった選択肢がありますよね。これをプログラムで表すのに便利なのが enum です！\n\n## コードで書くとこうなるよ\n\n```typescript\nenum Direction {  // 「方角」というグループ\n    Up,     // 上\n    Down,   // 下\n    Left,   // 左\n    Right   // 右\n}\n\nlet dir: Direction = Direction.Up;  // 「上」を選択\n```\n\nこれで「Up」「Down」など、決まった値だけを使えるようになります！",
  "typescript_lesson2_ex6_slide1_title": "enumとは？",
  "typescript_lesson2_ex6_slide2_content": "# 自動で番号が振られる\n\nenumを作ると、自動で0から順番に番号が割り当てられます。\n\n## たとえ話\n\nクラスの出席番号のようなものです。1番目の人が0番、2番目の人が1番...というふうに自動で番号がつきます。\n\n## コードで書くとこうなるよ\n\n```typescript\nenum Color {\n    Red,    // 0 が自動で割り当て\n    Green,  // 1 が自動で割り当て\n    Blue    // 2 が自動で割り当て\n}\n\nconsole.log(Color.Green);  // 1 と表示される\n```\n\n0から始まるのがポイントです！",
  "typescript_lesson2_ex6_slide2_title": "enumの値",
  "typescript_lesson2_ex6_slide3_content": "関連する定数をグループ化する「列挙型」を学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "typescript_lesson2_ex6_slide3_title": "やってみよう！",
  "typescript_lesson2_ex6_title": "列挙型（enum）",
  "typescript_lesson2_ex7_comment1": "<T> で型パラメータを定義",
  "typescript_lesson2_ex7_comment10": "出力する変数を指定します。",
  "typescript_lesson2_ex7_comment2": "型パラメータは `<T>` のように書きます。",
  "typescript_lesson2_ex7_comment3": "関数を呼び出し",
  "typescript_lesson2_ex7_comment4": "引数で受け取った値を配列に入れて返します。",
  "typescript_lesson2_ex7_comment8": "配列に入れる値を指定します。",
  "typescript_lesson2_ex7_description": "型を引数のように扱う「ジェネリクス」の基本を学びましょう。",
  "typescript_lesson2_ex7_slide1_content": "# 型を変数のように使う\n\n**ジェネリクス**（Generics）とは、「後から型を決められる」仕組みです。`<T>` のように書いて、Tの部分に好きな型を入れられます。\n\n## たとえ話\n\n「何でも入る箱」を想像してみてください。りんごを入れれば「りんご箱」、おもちゃを入れれば「おもちゃ箱」になりますよね。\n\nジェネリクスも同じで、使うときに「これは文字用」「これは数字用」と決められるのです！\n\n## コードで書くとこうなるよ\n\n```typescript\nfunction identity<T>(arg: T): T {\n    return arg;\n}\n\nidentity<string>('hello');  // 文字列用として使う\nidentity<number>(42);       // 数値用として使う\n```",
  "typescript_lesson2_ex7_slide1_title": "ジェネリクスとは？",
  "typescript_lesson2_ex7_slide2_content": "# TypeScriptが型を推測\n\nTypeScriptは賢いので、渡した値から型を自動的に判断してくれます。これを **型推論（かたすいろん）** と呼びます。\n\n## たとえ話\n\n「りんご」を箱に入れたら、わざわざ「これはりんご箱です」と言わなくても、見ればわかりますよね。TypeScriptも同じです！\n\n## コードで書くとこうなるよ\n\n```typescript\nfunction identity<T>(arg: T): T {\n    return arg;\n}\n\n// <string> を書かなくても、TypeScriptが推測してくれる！\nconst str = identity('hello');  // string と推論\nconst num = identity(42);       // number と推論\n```\n\n便利ですね！",
  "typescript_lesson2_ex7_slide2_title": "型推論と一緒に",
  "typescript_lesson2_ex7_slide3_content": "型を引数のように扱う「ジェネリクス」の基本を学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "typescript_lesson2_ex7_slide3_title": "やってみよう！",
  "typescript_lesson2_ex7_title": "ジェネリクス入門",
  "typescript_lesson2_ex8_comment1": "`type` キーワードを使います。",
  "typescript_lesson2_ex8_comment10": "取得したいプロパティ名を指定します。",
  "typescript_lesson2_ex8_comment2": "型パラメータ `T` を使います。",
  "typescript_lesson2_ex8_comment3": "英語の点数を数値で指定します。",
  "typescript_lesson2_ex8_comment4": "型パラメータで指定した型を使います。",
  "typescript_lesson2_ex8_comment8": "アイテムの値を文字列で指定します。",
  "typescript_lesson2_ex8_description": "インターフェースでジェネリクスを使う方法を学びましょう。",
  "typescript_lesson2_ex8_slide1_content": "# 柔軟なデータ構造\n\nインターフェース（設計図）にもジェネリクスを使えます。「中身の型は後で決める箱」のような設計図を作れるのです！\n\n## たとえ話\n\n「プレゼント箱」の設計図があるとします。中身は「おもちゃ」でも「お菓子」でも「本」でも何でもOK。箱の形は同じで、中身だけ変わりますよね。\n\n## コードで書くとこうなるよ\n\n```typescript\ninterface Box<T> {   // Tは後で決める\n    value: T;\n}\n\nconst numBox: Box<number> = { value: 42 };  // 数字の箱\nconst strBox: Box<string> = { value: 'hi' }; // 文字の箱\n```",
  "typescript_lesson2_ex8_slide1_title": "ジェネリックインターフェース",
  "typescript_lesson2_ex8_slide2_content": "# APIレスポンスなどに\n\nWebサイトからデータを取得するとき、「成功/失敗」と「データ」がセットで返ってくることが多いです。ジェネリクスを使うと、いろんなデータに対応できる型を作れます。\n\n## コードで書くとこうなるよ\n\n```typescript\n// 汎用的なレスポンスの型\ninterface Response<T> {\n    data: T;         // データ（型は後で決める）\n    status: number;  // 状態コード（200=成功など）\n}\n\ninterface User { name: string; }\n\n// ユーザー情報のレスポンス\nconst res: Response<User> = {\n    data: { name: 'Taro' },\n    status: 200\n};\n```\n\nこれで同じ型を使いまわせて便利です！",
  "typescript_lesson2_ex8_slide2_title": "実践的な例",
  "typescript_lesson2_ex8_slide3_content": "インターフェースでジェネリクスを使う方法を学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "typescript_lesson2_ex8_slide3_title": "やってみよう！",
  "typescript_lesson2_ex8_title": "ジェネリクスとインターフェース",
  "typescript_lesson2_ex9_comment1": "変数から型を取得",
  "typescript_lesson2_ex9_comment2": "y座標の値を数値で指定します。",
  "typescript_lesson2_ex9_comment3": "x座標を出力",
  "typescript_lesson2_ex9_comment4": "`typeof` で変数の型を取得します。",
  "typescript_lesson2_ex9_comment6": "取得したいプロパティ名を指定します。",
  "typescript_lesson2_ex9_description": "既存の変数から型を取得する `typeof` を学びましょう。",
  "typescript_lesson2_ex9_slide1_content": "# 変数から型を取得\n\n**typeof**（タイプオブ）を使うと、「この変数と同じ型」という意味になります。既に作った変数の型をコピーできるのです！\n\n## たとえ話\n\n「太郎くんと同じ服を買いたい」というとき、太郎くんの服を見れば何を買えばいいかわかりますよね。typeofも同じで、既にある変数を見て型を決められます。\n\n## コードで書くとこうなるよ\n\n```typescript\nconst user = { name: 'Taro', age: 20 };\n\ntype UserType = typeof user;\n// UserTypeは { name: string; age: number; } と同じ意味になる\n```",
  "typescript_lesson2_ex9_slide1_title": "typeof型演算子",
  "typescript_lesson2_ex9_slide2_content": "# 型の再利用\n\n既にある変数と「まったく同じ形」の新しい変数を作りたいときに便利です。\n\n## たとえ話\n\n設定ファイルを2つ作りたいとき、「1つ目の設定と同じ項目を持つ2つ目の設定」を作れます。\n\n## コードで書くとこうなるよ\n\n```typescript\nconst config = {\n    api: 'https://...',\n    timeout: 5000\n};\n\n// configと同じ形の別の設定を作る\nconst config2: typeof config = {\n    api: 'https://other...',\n    timeout: 3000\n};\n```\n\nこうすれば、同じ項目を忘れずに設定できます！",
  "typescript_lesson2_ex9_slide2_title": "同じ型の変数を作る",
  "typescript_lesson2_ex9_slide3_content": "既存の変数から型を取得する `typeof` を学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "typescript_lesson2_ex9_slide3_title": "やってみよう！",
  "typescript_lesson2_ex9_title": "typeof 型演算子",
  "typescript_lesson2_title": "TypeScript II - ステップアップ！",
  "typescript_lesson3_course_description": "TypeScriptの高度な型システムを学びます。ユーティリティ型、条件型、マップ型など、型の達人を目指しましょう。",
  "typescript_lesson3_course_title": "TypeScript III - 高度な型",
  "typescript_lesson3_ex10_comment1": "ユニオン型を作る演算子です。",
  "typescript_lesson3_ex10_comment11": "ポート番号は数値なので `number` です。",
  "typescript_lesson3_ex10_comment15": "ホスト名の値を文字列で指定します。",
  "typescript_lesson3_ex10_comment17": "出力するプロパティ名を指定します。",
  "typescript_lesson3_ex10_comment2": "Record でキーと値の型を指定します。",
  "typescript_lesson3_ex10_comment3": "りんごの価格を数値で指定します。",
  "typescript_lesson3_ex10_comment4": "Tの全てのキーに対して処理を行うキーワードです。",
  "typescript_lesson3_ex10_comment5": "取得したいプロパティ名を指定します。",
  "typescript_lesson3_ex10_comment9": "ホスト名は文字列なので `string` です。",
  "typescript_lesson3_ex10_description": "既存の型を変換するマップ型を学びましょう。",
  "typescript_lesson3_ex10_slide1_content": "# プロパティを変換\n\n**マップ型**（Mapped Types）は、既存の型の「すべてのプロパティ」に対して、同じ変換を適用できます。\n\n## たとえ話\n\nクラス全員に「帽子をかぶせる」ような感じです。一人一人に同じ処理をするのではなく、「全員に」適用できます。\n\n## 書き方\n\n`[K in keyof T]` で「Tのすべてのキーに対して」という意味になります。\n\n## コードで書くとこうなるよ\n\n```typescript\n// すべてのプロパティをreadonlyにする\ntype Readonly<T> = {\n  readonly [K in keyof T]: T[K];\n};\n// 「Tのすべてのキーに対して、readonlyをつける」\n```",
  "typescript_lesson3_ex10_slide1_title": "マップ型とは？",
  "typescript_lesson3_ex10_slide2_content": "# 独自の変換を定義\n\n自分だけの変換ルールを作ることもできます。\n\n## たとえ話\n\n「すべての項目に『nullでもOK』を追加する」といった変換ができます。\n\n## コードで書くとこうなるよ\n\n```typescript\n// すべてのプロパティを「nullでもOK」にする\ntype Nullable<T> = {\n  [K in keyof T]: T[K] | null;\n};\n\ninterface User {\n  name: string;\n}\n\ntype NullableUser = Nullable<User>;\n// { name: string | null; }\n// nameがnullでもOKになった！\n```\n\nこうやって、型を「一括変換」できるのがマップ型の強みです！",
  "typescript_lesson3_ex10_slide2_title": "カスタムマップ型",
  "typescript_lesson3_ex10_slide3_content": "既存の型を変換するマップ型を学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "typescript_lesson3_ex10_slide3_title": "やってみよう！",
  "typescript_lesson3_ex10_title": "マップ型（Mapped Types）",
  "typescript_lesson3_ex11_description": "関数の戻り値の型を取得しましょう。",
  "typescript_lesson3_ex11_title": "ReturnType<T>",
  "typescript_lesson3_ex12_comment1": "y座標の値を数値で指定します。",
  "typescript_lesson3_ex12_comment2": "ReturnType で戻り値の型を取得します。",
  "typescript_lesson3_ex12_comment3": "y座標の値を数値で指定します。",
  "typescript_lesson3_ex12_comment4": "x座標のプロパティ名を指定します。",
  "typescript_lesson3_ex12_slide1_content": "# 型を二重管理しない\n\n関数の戻り値と同じ型を使いたいとき、わざわざ別の場所で型を定義しなくて済みます。\n\n## たとえ話\n\n料理のレシピを変えたら、自動で「完成品の説明」も変わってほしいですよね。ReturnTypeなら、関数を変えれば型も自動で変わります！\n\n## コードで書くとこうなるよ\n\n```typescript\n// 関数の戻り値から型を自動取得\ntype Result = ReturnType<typeof fetchData>;\n\nfunction processResult(result: Result) {\n  // 関数の戻り値と同じ型が使える！\n}\n```\n\nこれで型の書き忘れや不一致を防げます。",
  "typescript_lesson3_ex12_slide1_title": "使いどころ",
  "typescript_lesson3_ex12_title": "使いどころ",
  "typescript_lesson3_ex13_description": "条件によって型を変える条件型を学びましょう。",
  "typescript_lesson3_ex13_title": "条件型（Conditional Types）",
  "typescript_lesson3_ex14_comment1": "条件型で「TがUに当てはまるなら」を表すキーワードです。",
  "typescript_lesson3_ex14_comment2": "配列の要素の型を指定します。",
  "typescript_lesson3_ex14_comment3": "非配列の型を指定します。",
  "typescript_lesson3_ex14_slide1_content": "# 型に応じた変換\n\n配列なら中身を取り出す、そうでなければそのまま...といった処理ができます。\n\n## たとえ話\n\n「箱なら中身を見せて。箱じゃなければそのまま見せて」という感じです。\n\n## コードで書くとこうなるよ\n\n```typescript\n// 配列なら中身の型を取り出す\ntype Flatten<T> = T extends Array<infer U> ? U : T;\n\ntype A = Flatten<string[]>;  // string（配列の中身）\ntype B = Flatten<number>;    // number（そのまま）\n```\n\n`infer` は「ここの型を推測して！」という意味です。",
  "typescript_lesson3_ex14_slide1_title": "実用例",
  "typescript_lesson3_ex14_title": "実用例",
  "typescript_lesson3_ex15_description": "条件型の中で型を推論するinferを学びましょう。",
  "typescript_lesson3_ex15_title": "infer キーワード",
  "typescript_lesson3_ex16_comment1": "Promiseの中身の型を推論して取り出すキーワードです。",
  "typescript_lesson3_ex16_comment2": "Promiseでラップされる型を指定します。",
  "typescript_lesson3_ex16_comment3": "Promiseではない型を指定します。",
  "typescript_lesson3_ex16_comment4": "Promise<string>をアンラップした結果の値です。",
  "typescript_lesson3_ex16_comment5": "numberはそのまま返されるのでnumber型の値です。",
  "typescript_lesson3_ex16_comment6": "2つ目の変数を出力に追加します。",
  "typescript_lesson3_ex16_slide1_content": "# 関数の引数の型も取り出せる\n\ninferを使えば、関数が受け取る引数の型も取り出せます。\n\n## たとえ話\n\n「この関数は何を受け取る？」と聞いて、引数の型を教えてもらえます。\n\n## コードで書くとこうなるよ\n\n```typescript\n// 最初の引数の型を取り出す\ntype FirstArg<T> = \n  T extends (arg: infer A, ...args: any[]) => any \n    ? A \n    : never;\n// 「Aを推測して！」とお願い\n\ntype A = FirstArg<(x: number) => void>; \n// number と見つけてくれた！\n```\n\nこれがTypeScript組み込みの `Parameters` 型の仕組みです！",
  "typescript_lesson3_ex16_slide1_title": "関数の引数型を抽出",
  "typescript_lesson3_ex16_title": "関数の引数型を抽出",
  "typescript_lesson3_ex17_description": "オブジェクト型のキーを取得するkeyofを学びましょう。",
  "typescript_lesson3_ex17_title": "keyof 演算子",
  "typescript_lesson3_ex18_comment1": "名前は文字列なのでstring型です。",
  "typescript_lesson3_ex18_comment2": "年齢は数値なのでnumber型です。",
  "typescript_lesson3_ex18_comment3": "オブジェクトのキーをユニオン型として取得するキーワードです。",
  "typescript_lesson3_ex18_comment4": "引数で受け取ったkeyを使ってプロパティにアクセスします。",
  "typescript_lesson3_ex18_comment5": "Bobの年齢を数値で指定します。",
  "typescript_lesson3_ex18_comment6": "取得したいプロパティ名を文字列で指定します。",
  "typescript_lesson3_ex18_slide1_content": "# 動的アクセスを型安全に\n\nkeyofを使うと、「存在するキーだけ使える」という安全な関数が作れます。\n\n## たとえ話\n\nロッカーを開けるとき、「存在する番号」しか使えませんよね。keyofで「存在するキー」だけを許可できます。\n\n## コードで書くとこうなるよ\n\n```typescript\nfunction getValue<T, K extends keyof T>(obj: T, key: K): T[K] {\n  return obj[key];\n}\n\nconst user = { id: 1, name: 'Alice' };\ngetValue(user, 'name'); // OK! 'name'は存在する\ngetValue(user, 'age');  // エラー！ 'age'は存在しない\n```\n\n存在しないキーを使おうとするとエラーで教えてくれます！",
  "typescript_lesson3_ex18_slide1_title": "型安全なアクセス",
  "typescript_lesson3_ex18_title": "型安全なアクセス",
  "typescript_lesson3_ex19_description": "既存の型を変換するマップ型を学びましょう。",
  "typescript_lesson3_ex19_title": "マップ型（Mapped Types）",
  "typescript_lesson3_ex1_comment1": "Partial で全プロパティをオプショナルに",
  "typescript_lesson3_ex1_comment13": "ポート番号の初期値を数値で指定します。",
  "typescript_lesson3_ex1_comment15": "取得したいプロパティ名を指定します。",
  "typescript_lesson3_ex1_comment2": "ポート番号の型",
  "typescript_lesson3_ex1_comment3": "ホスト名は文字列なので `string` です。",
  "typescript_lesson3_ex1_comment4": "設定オブジェクトを作成",
  "typescript_lesson3_ex1_comment5": "ポート番号は数値なので `number` です。",
  "typescript_lesson3_ex1_comment8": "Partial で全プロパティをオプショナルにします。",
  "typescript_lesson3_ex1_description": "全てのプロパティをオプショナルにするPartialを学びましょう。",
  "typescript_lesson3_ex1_slide1_content": "# 全プロパティをオプショナルに\n\n**Partial<T>**（パーシャル）は、TypeScriptに組み込まれた「便利な型変換ツール」（ユーティリティ型）の1つです。型Tの全てのプロパティを「あってもなくてもOK」に変えます。\n\n## たとえ話\n\n「必ず全部書いて！」というアンケートを、「書きたい項目だけでOK！」に変えるようなものです。\n\n## コードで書くとこうなるよ\n\n```typescript\ninterface User {\n  name: string;   // 必須\n  age: number;    // 必須\n}\n\ntype PartialUser = Partial<User>;\n// ↓ これと同じ意味になる\n// { name?: string; age?: number; }\n// 全部オプショナル（?付き）になった！\n```",
  "typescript_lesson3_ex1_slide1_title": "Partial とは？",
  "typescript_lesson3_ex1_slide2_content": "# 部分的な更新に便利\n\nデータの一部だけを更新したいときに便利です。全項目を毎回指定しなくていいのです！\n\n## たとえ話\n\nプロフィールの「名前だけ変えたい」「年齢だけ変えたい」というとき、変えたい項目だけ指定できます。\n\n## コードで書くとこうなるよ\n\n```typescript\nfunction updateUser(user: User, updates: Partial<User>) {\n  return { ...user, ...updates };\n}\n\n// 名前だけ更新、ageは省略OK！\nupdateUser(user, { name: 'Bob' });\n```",
  "typescript_lesson3_ex1_slide2_title": "使いどころ",
  "typescript_lesson3_ex1_slide3_content": "全てのプロパティをオプショナルにするPartialを学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "typescript_lesson3_ex1_slide3_title": "やってみよう！",
  "typescript_lesson3_ex1_title": "Partial<T>",
  "typescript_lesson3_ex20_comment1": "Tの全てのキーに対して処理を行うキーワードです。",
  "typescript_lesson3_ex20_comment2": "ホスト名は文字列なので `string` です。",
  "typescript_lesson3_ex20_comment3": "ポート番号は数値なので `number` です。",
  "typescript_lesson3_ex20_comment4": "ホスト名の値を文字列で指定します。",
  "typescript_lesson3_ex20_comment5": "出力するプロパティ名を指定します。",
  "typescript_lesson3_ex20_slide1_content": "# 独自の変換を定義\n\n自分だけの変換ルールを作ることもできます。\n\n## たとえ話\n\n「すべての項目に『nullでもOK』を追加する」といった変換ができます。\n\n## コードで書くとこうなるよ\n\n```typescript\n// すべてのプロパティを「nullでもOK」にする\ntype Nullable<T> = {\n  [K in keyof T]: T[K] | null;\n};\n\ninterface User {\n  name: string;\n}\n\ntype NullableUser = Nullable<User>;\n// { name: string | null; }\n// nameがnullでもOKになった！\n```\n\nこうやって、型を「一括変換」できるのがマップ型の強みです！",
  "typescript_lesson3_ex20_slide1_title": "カスタムマップ型",
  "typescript_lesson3_ex20_title": "カスタムマップ型",
  "typescript_lesson3_ex2_comment1": "ホスト名は文字列なので `string` です。",
  "typescript_lesson3_ex2_comment10": "取得したいプロパティ名を指定します。",
  "typescript_lesson3_ex2_comment14": "verboseの値を真偽値で指定します。",
  "typescript_lesson3_ex2_comment2": "ポート番号は数値なので `number` です。",
  "typescript_lesson3_ex2_comment3": "デバッグ設定は真偽値なので `boolean` です。",
  "typescript_lesson3_ex2_comment4": "ポート番号の初期値を数値で指定します。",
  "typescript_lesson3_ex2_comment5": "詳細出力設定は真偽値なので `boolean` です。",
  "typescript_lesson3_ex2_comment8": "Required で全プロパティを必須にします。",
  "typescript_lesson3_ex2_description": "全てのプロパティを必須にするRequiredを学びましょう。",
  "typescript_lesson3_ex2_slide1_content": "# 全プロパティを必須に\n\n**Required<T>**（リクワイアード）は、Partialの逆で、全てのプロパティを「必ず書いて！」に変えます。\n\n## たとえ話\n\n「任意」だったアンケート項目を、「全部必須」に変えるようなものです。\n\n## コードで書くとこうなるよ\n\n```typescript\ninterface Props {\n  name?: string;   // オプショナル（任意）\n  age?: number;    // オプショナル（任意）\n}\n\ntype RequiredProps = Required<Props>;\n// ↓ これと同じ意味になる\n// { name: string; age: number; }\n// ?が消えて、全部必須になった！\n```",
  "typescript_lesson3_ex2_slide1_title": "Required とは？",
  "typescript_lesson3_ex2_slide2_content": "# オプショナルを必須に変換\n\n「ここでは全項目が揃っていることを保証したい」というときに使います。\n\n## たとえ話\n\n登録時は一部の項目が任意でも、「最終確認画面」では全項目が入力されていることを確認したいですよね。\n\n## コードで書くとこうなるよ\n\n```typescript\nfunction processUser(user: Required<User>) {\n  // 全プロパティが存在することが保証される！\n  console.log(user.name.toUpperCase());\n}\n```\n\nこれで「nameがないかも」と心配せずに安全にコードが書けます。",
  "typescript_lesson3_ex2_slide2_title": "使いどころ",
  "typescript_lesson3_ex2_slide3_content": "全てのプロパティを必須にするRequiredを学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "typescript_lesson3_ex2_slide3_title": "やってみよう！",
  "typescript_lesson3_ex2_title": "Required<T>",
  "typescript_lesson3_ex3_comment1": "Pick で特定のプロパティを選択",
  "typescript_lesson3_ex3_comment10": "Pick で特定のプロパティを選択します。",
  "typescript_lesson3_ex3_comment13": "商品名の値を文字列で指定します。",
  "typescript_lesson3_ex3_comment15": "取得したいプロパティ名を指定します。",
  "typescript_lesson3_ex3_comment2": "名前の型",
  "typescript_lesson3_ex3_comment3": "IDは数値なので `number` です。",
  "typescript_lesson3_ex3_comment4": "Pickで特定のプロパティを選択",
  "typescript_lesson3_ex3_comment5": "名前は文字列なので `string` です。",
  "typescript_lesson3_ex3_comment6": "名前を出力",
  "typescript_lesson3_ex3_comment7": "価格は数値なので `number` です。",
  "typescript_lesson3_ex3_description": "特定のプロパティだけを取り出すPickを学びましょう。",
  "typescript_lesson3_ex3_slide1_content": "# 特定のプロパティを選択\n\n**Pick<T, K>**（ピック）は、型Tから「欲しいプロパティだけ」を選んで取り出します。\n\n## たとえ話\n\n名簿の中から「名前と電話番号だけ」を抜き出して別のリストを作るようなものです。全部の情報は要らなくて、必要な部分だけ欲しいときに使います。\n\n## コードで書くとこうなるよ\n\n```typescript\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n}\n\n// id と name だけを選ぶ\ntype UserPreview = Pick<User, 'id' | 'name'>;\n// ↓ これと同じ意味になる\n// { id: number; name: string; }\n// emailは含まれない！\n```",
  "typescript_lesson3_ex3_slide1_title": "Pick とは？",
  "typescript_lesson3_ex3_slide2_content": "# 必要な情報だけを抽出\n\n一部の情報だけ使いたいとき、Pickで新しい型を作れます。\n\n## たとえ話\n\n全ユーザー情報のうち、「名前だけ表示するカード」を作りたいとき。パスワードやメールは不要ですよね。\n\n## コードで書くとこうなるよ\n\n```typescript\nfunction getPreview(user: User): Pick<User, 'name'> {\n  return { name: user.name };\n}\n```\n\nこれで「nameだけを持つ型」が作れます！",
  "typescript_lesson3_ex3_slide2_title": "使いどころ",
  "typescript_lesson3_ex3_slide3_content": "特定のプロパティだけを取り出すPickを学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "typescript_lesson3_ex3_slide3_title": "やってみよう！",
  "typescript_lesson3_ex3_title": "Pick<T, K>",
  "typescript_lesson3_ex4_comment1": "デバッグ設定は真偽値なので `boolean` です。",
  "typescript_lesson3_ex4_comment10": "Omit で特定のプロパティを除外します。",
  "typescript_lesson3_ex4_comment13": "名前の値を文字列で指定します。",
  "typescript_lesson3_ex4_comment15": "取得したいプロパティ名を指定します。",
  "typescript_lesson3_ex4_comment2": "詳細出力設定は真偽値なので `boolean` です。",
  "typescript_lesson3_ex4_comment3": "IDは数値なので `number` です。",
  "typescript_lesson3_ex4_comment4": "取得したいプロパティ名を指定します。",
  "typescript_lesson3_ex4_comment5": "名前は文字列なので `string` です。",
  "typescript_lesson3_ex4_comment6": "名前を出力",
  "typescript_lesson3_ex4_comment7": "秘密情報は文字列なので `string` です。",
  "typescript_lesson3_ex4_description": "特定のプロパティを除外するOmitを学びましょう。",
  "typescript_lesson3_ex4_slide1_content": "# 特定のプロパティを除外\n\n**Omit<T, K>**（オミット）は、Pickの逆で、「指定したプロパティを除外」します。\n\n## たとえ話\n\n名簿から「電話番号だけ消して」他の情報はそのまま使いたいとき、Omitが便利です。「これだけ要らない」というときに使います。\n\n## コードで書くとこうなるよ\n\n```typescript\ninterface User {\n  id: number;\n  name: string;\n  password: string;  // 秘密の情報\n}\n\n// passwordだけ除外する\ntype PublicUser = Omit<User, 'password'>;\n// ↓ これと同じ意味になる\n// { id: number; name: string; }\n// passwordが消えた！\n```",
  "typescript_lesson3_ex4_slide1_title": "Omit とは？",
  "typescript_lesson3_ex4_slide2_content": "# 機密情報を除外\n\n「見せたくない情報」を除いて公開用のデータを作るときに便利です。\n\n## たとえ話\n\nユーザーのパスワードは他の人に見せてはいけませんよね。公開するデータからパスワードだけ除外できます。\n\n## コードで書くとこうなるよ\n\n```typescript\nfunction toPublic(user: User): Omit<User, 'password'> {\n  const { password, ...rest } = user;\n  return rest;\n}\n```\n\nこれで安全に公開用データが作れます！",
  "typescript_lesson3_ex4_slide2_title": "使いどころ",
  "typescript_lesson3_ex4_slide3_content": "特定のプロパティを除外するOmitを学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "typescript_lesson3_ex4_slide3_title": "やってみよう！",
  "typescript_lesson3_ex4_title": "Omit<T, K>",
  "typescript_lesson3_ex5_comment1": "Record でキーと値の型を指定",
  "typescript_lesson3_ex5_comment11": "バナナの価格を数値で指定します。",
  "typescript_lesson3_ex5_comment15": "取得したいプロパティ名を指定します。",
  "typescript_lesson3_ex5_comment2": "ユニオン型を作る演算子です。",
  "typescript_lesson3_ex5_comment3": "りんごの価格",
  "typescript_lesson3_ex5_comment4": "Record でキーと値の型を指定します。",
  "typescript_lesson3_ex5_comment5": "りんごの価格を出力",
  "typescript_lesson3_ex5_comment9": "りんごの価格を数値で指定します。",
  "typescript_lesson3_ex5_description": "キーと値の型を指定したオブジェクト型を作りましょう。",
  "typescript_lesson3_ex5_slide1_content": "# キーと値の型を指定\n\n**Record<K, V>**（レコード）は、「キー（項目名）」と「値」の型を指定したオブジェクト型を作ります。\n\n## たとえ話\n\n成績表を想像してみてください。「科目名」がキーで、「点数」が値ですよね。\n- 数学 → 90点\n- 英語 → 85点\n\nこんな構造を型で表せます！\n\n## コードで書くとこうなるよ\n\n```typescript\ntype Scores = Record<string, number>;\n// キーは文字列、値は数字\n\nconst scores: Scores = {\n  math: 90,     // 数学の点数\n  english: 85   // 英語の点数\n};\n```",
  "typescript_lesson3_ex5_slide1_title": "Record とは？",
  "typescript_lesson3_ex5_slide2_content": "# 特定のキーに限定\n\nキーを特定の値だけに限定することもできます。これで「決まったキーしか使えない」オブジェクトが作れます。\n\n## たとえ話\n\n信号機の色は「赤・黄・緑」の3つだけですよね。「紫」は無いはず！Recordで決まったキーだけを許可できます。\n\n## コードで書くとこうなるよ\n\n```typescript\n// 決まった状態だけを許可\ntype Status = 'pending' | 'done' | 'error';\ntype StatusColors = Record<Status, string>;\n\nconst colors: StatusColors = {\n  pending: 'yellow',  // 保留中は黄色\n  done: 'green',      // 完了は緑\n  error: 'red'        // エラーは赤\n};\n// この3つ以外は使えない！\n```",
  "typescript_lesson3_ex5_slide2_title": "リテラル型と組み合わせ",
  "typescript_lesson3_ex5_slide3_content": "キーと値の型を指定したオブジェクト型を作りましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "typescript_lesson3_ex5_slide3_title": "やってみよう！",
  "typescript_lesson3_ex5_title": "Record<K, V>",
  "typescript_lesson3_ex6_comment1": "IDは数値なので `number` です。",
  "typescript_lesson3_ex6_comment11": "x座標のプロパティ名を指定します。",
  "typescript_lesson3_ex6_comment2": "名前は文字列なので `string` です。",
  "typescript_lesson3_ex6_comment3": "y座標の値を数値で指定します。",
  "typescript_lesson3_ex6_comment4": "Pick で特定のプロパティを選択します。",
  "typescript_lesson3_ex6_comment5": "商品名の値を文字列で指定します。",
  "typescript_lesson3_ex6_comment6": "ReturnType で戻り値の型を取得します。",
  "typescript_lesson3_ex6_comment9": "y座標の値を数値で指定します。",
  "typescript_lesson3_ex6_description": "関数の戻り値の型を取得しましょう。",
  "typescript_lesson3_ex6_slide1_content": "# 関数の戻り値の型を抽出\n\n**ReturnType<T>**（リターンタイプ）は、関数が「何を返すか」の型を取得します。\n\n## たとえ話\n\n自動販売機にお金を入れると「ジュース」が出てきますよね。ReturnTypeは「この自動販売機から何が出てくるか」を調べるようなものです。\n\n## コードで書くとこうなるよ\n\n```typescript\nfunction getUser() {\n  return { id: 1, name: 'Alice' };\n}\n\n// この関数は何を返す？\ntype User = ReturnType<typeof getUser>;\n// ↓ これと同じ意味になる\n// { id: number; name: string; }\n```",
  "typescript_lesson3_ex6_slide1_title": "ReturnType とは？",
  "typescript_lesson3_ex6_slide2_content": "# 型を二重管理しない\n\n関数の戻り値と同じ型を使いたいとき、わざわざ別の場所で型を定義しなくて済みます。\n\n## たとえ話\n\n料理のレシピを変えたら、自動で「完成品の説明」も変わってほしいですよね。ReturnTypeなら、関数を変えれば型も自動で変わります！\n\n## コードで書くとこうなるよ\n\n```typescript\n// 関数の戻り値から型を自動取得\ntype Result = ReturnType<typeof fetchData>;\n\nfunction processResult(result: Result) {\n  // 関数の戻り値と同じ型が使える！\n}\n```\n\nこれで型の書き忘れや不一致を防げます。",
  "typescript_lesson3_ex6_slide2_title": "使いどころ",
  "typescript_lesson3_ex6_slide3_content": "関数の戻り値の型を取得しましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "typescript_lesson3_ex6_slide3_title": "やってみよう！",
  "typescript_lesson3_ex6_title": "ReturnType<T>",
  "typescript_lesson3_ex7_comment1": "extends で条件型を定義",
  "typescript_lesson3_ex7_comment10": "number[]は配列なので結果はtrueになります。",
  "typescript_lesson3_ex7_comment12": "stringは配列ではないので結果はfalseになります。",
  "typescript_lesson3_ex7_comment14": "2つ目の変数を出力に追加します。",
  "typescript_lesson3_ex7_comment2": "条件型で「TがUに当てはまるなら」を表すキーワードです。",
  "typescript_lesson3_ex7_comment3": "非配列型をチェック",
  "typescript_lesson3_ex7_comment4": "結果を変数に代入",
  "typescript_lesson3_ex7_comment5": "配列の要素の型を指定します。",
  "typescript_lesson3_ex7_comment6": "出力",
  "typescript_lesson3_ex7_comment7": "非配列の型を指定します。",
  "typescript_lesson3_ex7_description": "条件によって型を変える条件型を学びましょう。",
  "typescript_lesson3_ex7_slide1_content": "# 型レベルの「もし〜なら」\n\n**条件型**（Conditional Types）は、「もしこの型なら、こっち。そうでなければ、あっち」という分岐ができます。\n\n## たとえ話\n\n「もし犬なら『ワン』、そうでなければ『ニャー』と鳴く」のように、条件によって結果が変わりますよね。型でも同じことができるのです！\n\n## 書き方\n\n`T extends U ? X : Y` という形で書きます。\n- もしTがUに当てはまるなら → X\n- そうでなければ → Y\n\n## コードで書くとこうなるよ\n\n```typescript\ntype IsString<T> = T extends string ? 'yes' : 'no';\n\ntype A = IsString<string>;  // 'yes'（文字列だから）\ntype B = IsString<number>;  // 'no'（数字だから）\n```",
  "typescript_lesson3_ex7_slide1_title": "条件型とは？",
  "typescript_lesson3_ex7_slide2_content": "# 型に応じた変換\n\n配列なら中身を取り出す、そうでなければそのまま...といった処理ができます。\n\n## たとえ話\n\n「箱なら中身を見せて。箱じゃなければそのまま見せて」という感じです。\n\n## コードで書くとこうなるよ\n\n```typescript\n// 配列なら中身の型を取り出す\ntype Flatten<T> = T extends Array<infer U> ? U : T;\n\ntype A = Flatten<string[]>;  // string（配列の中身）\ntype B = Flatten<number>;    // number（そのまま）\n```\n\n`infer` は「ここの型を推測して！」という意味です。",
  "typescript_lesson3_ex7_slide2_title": "実用例",
  "typescript_lesson3_ex7_slide3_content": "条件によって型を変える条件型を学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "typescript_lesson3_ex7_slide3_title": "やってみよう！",
  "typescript_lesson3_ex7_title": "条件型（Conditional Types）",
  "typescript_lesson3_ex8_comment1": "IDは数値なので `number` です。",
  "typescript_lesson3_ex8_comment10": "Promise<string>をアンラップした結果の値です。",
  "typescript_lesson3_ex8_comment12": "numberはそのまま返されるのでnumber型の値です。",
  "typescript_lesson3_ex8_comment14": "2つ目の変数を出力に追加します。",
  "typescript_lesson3_ex8_comment2": "Promiseの中身の型を推論して取り出すキーワードです。",
  "typescript_lesson3_ex8_comment3": "秘密情報は文字列なので `string` です。",
  "typescript_lesson3_ex8_comment4": "Omit で特定のプロパティを除外します。",
  "typescript_lesson3_ex8_comment5": "Promiseでラップされる型を指定します。",
  "typescript_lesson3_ex8_comment6": "取得したいプロパティ名を指定します。",
  "typescript_lesson3_ex8_comment7": "Promiseではない型を指定します。",
  "typescript_lesson3_ex8_description": "条件型の中で型を推論するinferを学びましょう。",
  "typescript_lesson3_ex8_slide1_content": "# 型を推論して抽出\n\n**infer**（インファー）は、条件型の中で「ここの型を自動で見つけて！」とお願いできるキーワードです。\n\n## たとえ話\n\n「この箱の中身は何？」と聞いて、TypeScriptに中身の型を教えてもらうようなものです。\n\n## コードで書くとこうなるよ\n\n```typescript\n// 配列の中身の型を取り出す\ntype GetArrayElement<T> = \n  T extends (infer U)[] ? U : never;\n// 「Uを推測して！」とお願い\n\ntype A = GetArrayElement<string[]>; // string\n// 「string[]の中身はstring」と見つけてくれた！\n```",
  "typescript_lesson3_ex8_slide1_title": "infer とは？",
  "typescript_lesson3_ex8_slide2_content": "# 関数の引数の型も取り出せる\n\ninferを使えば、関数が受け取る引数の型も取り出せます。\n\n## たとえ話\n\n「この関数は何を受け取る？」と聞いて、引数の型を教えてもらえます。\n\n## コードで書くとこうなるよ\n\n```typescript\n// 最初の引数の型を取り出す\ntype FirstArg<T> = \n  T extends (arg: infer A, ...args: any[]) => any \n    ? A \n    : never;\n// 「Aを推測して！」とお願い\n\ntype A = FirstArg<(x: number) => void>; \n// number と見つけてくれた！\n```\n\nこれがTypeScript組み込みの `Parameters` 型の仕組みです！",
  "typescript_lesson3_ex8_slide2_title": "関数の引数型を抽出",
  "typescript_lesson3_ex8_slide3_content": "条件型の中で型を推論するinferを学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "typescript_lesson3_ex8_slide3_title": "やってみよう！",
  "typescript_lesson3_ex8_title": "infer キーワード",
  "typescript_lesson3_ex9_comment1": "keyof でオブジェクトのキーを取得",
  "typescript_lesson3_ex9_comment10": "引数で受け取ったkeyを使ってプロパティにアクセスします。",
  "typescript_lesson3_ex9_comment14": "Bobの年齢を数値で指定します。",
  "typescript_lesson3_ex9_comment16": "取得したいプロパティ名を文字列で指定します。",
  "typescript_lesson3_ex9_comment2": "年齢の型",
  "typescript_lesson3_ex9_comment3": "名前は文字列なのでstring型です。",
  "typescript_lesson3_ex9_comment4": "プロパティの値を返す",
  "typescript_lesson3_ex9_comment5": "年齢は数値なのでnumber型です。",
  "typescript_lesson3_ex9_comment6": "名前を取得して出力",
  "typescript_lesson3_ex9_comment8": "オブジェクトのキーをユニオン型として取得するキーワードです。",
  "typescript_lesson3_ex9_description": "オブジェクト型のキーを取得するkeyofを学びましょう。",
  "typescript_lesson3_ex9_slide1_content": "# オブジェクトのキーをUnion型に\n\n**keyof**（キーオブ）は、オブジェクト型の「キー（項目名）」をすべて取り出して、ユニオン型にします。\n\n## たとえ話\n\n生徒カードの項目を想像してみてください。「名前」「年齢」「クラス」...といった項目名がありますよね。keyofは「このカードにはどんな項目がある？」と聞くようなものです。\n\n## コードで書くとこうなるよ\n\n```typescript\ninterface User {\n  id: number;\n  name: string;\n}\n\ntype UserKeys = keyof User; // 'id' | 'name'\n// Userのキーは 'id' か 'name' のどちらか\n```",
  "typescript_lesson3_ex9_slide1_title": "keyof とは？",
  "typescript_lesson3_ex9_slide2_content": "# 動的アクセスを型安全に\n\nkeyofを使うと、「存在するキーだけ使える」という安全な関数が作れます。\n\n## たとえ話\n\nロッカーを開けるとき、「存在する番号」しか使えませんよね。keyofで「存在するキー」だけを許可できます。\n\n## コードで書くとこうなるよ\n\n```typescript\nfunction getValue<T, K extends keyof T>(obj: T, key: K): T[K] {\n  return obj[key];\n}\n\nconst user = { id: 1, name: 'Alice' };\ngetValue(user, 'name'); // OK! 'name'は存在する\ngetValue(user, 'age');  // エラー！ 'age'は存在しない\n```\n\n存在しないキーを使おうとするとエラーで教えてくれます！",
  "typescript_lesson3_ex9_slide2_title": "型安全なアクセス",
  "typescript_lesson3_ex9_slide3_content": "オブジェクト型のキーを取得するkeyofを学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "typescript_lesson3_ex9_slide3_title": "やってみよう！",
  "typescript_lesson3_ex9_title": "keyof 演算子",
  "typescript_lesson3_title": "TypeScript III - 高度な型",
  "typescript_lesson4_course_description": "TypeScriptのデコレータと高度なパターンを学びます。メタプログラミング、型ガード、ユーティリティなどを身につけましょう。",
  "typescript_lesson4_course_title": "TypeScript IV - デコレータと高度なパターン",
  "typescript_lesson4_ex10_comment1": "ユニオン型を作る演算子です。",
  "typescript_lesson4_ex10_comment2": "データの型は文字列なので `string` です。",
  "typescript_lesson4_ex10_comment3": "テンプレートリテラルを開始するバッククォートです。",
  "typescript_lesson4_ex10_comment4": "Promiseの解決型を取得するユーティリティ型です。",
  "typescript_lesson4_ex10_comment5": "出力する変数を指定します。",
  "typescript_lesson4_ex10_comment7": "データの値を文字列で指定します。",
  "typescript_lesson4_ex10_comment9": "取得したいプロパティ名を指定します。",
  "typescript_lesson4_ex10_description": "Promiseの解決型を取得しましょう。",
  "typescript_lesson4_ex10_slide1_content": "# Promiseの中身の型を取得\n\n**Awaited**（アウェイテッド）は、Promise（「後で届く約束」のようなもの）が解決したときの型を取得します。\n\n## たとえ話\n\n「配達中の荷物」を想像してみてください。荷物が届く前から「中身は本です」とわかっていれば準備できますよね。AwaitedはPromiseの「中身の型」を教えてくれます。\n\n## コードで書くとこうなるよ\n\n```typescript\ntype P = Promise<string>;  // 「後でstringが届く」約束\ntype T = Awaited<P>;\n// string\n// Promiseの中身はstringだとわかった！\n```",
  "typescript_lesson4_ex10_slide1_title": "Awaited<T>とは？",
  "typescript_lesson4_ex10_slide2_content": "# 非同期処理の結果の型\n\nWebからデータを取得するなど、非同期処理の結果の型を知りたいときに使います。\n\n## たとえ話\n\n「この注文をすると、何が届く？」という質問に答えるようなものです。\n\n## コードで書くとこうなるよ\n\n```typescript\ntype AsyncResult = Promise<{ data: string }>;\n\n// Promiseが解決したら何になる？\ntype Result = Awaited<AsyncResult>;\n// { data: string }\n\n// 同じ型の変数を作れる\nconst result: Result = { data: 'success' };\n```\n\nasync/awaitで取得する値の型がわかって便利です！",
  "typescript_lesson4_ex10_slide2_title": "Awaitedの使い方",
  "typescript_lesson4_ex10_slide3_content": "Promiseの解決型を取得しましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "typescript_lesson4_ex10_slide3_title": "やってみよう！",
  "typescript_lesson4_ex10_title": "Awaited型",
  "typescript_lesson4_ex11_description": "ユニオン型から特定の型を除外しましょう。",
  "typescript_lesson4_ex11_title": "Exclude型",
  "typescript_lesson4_ex12_comment1": "ユニオン型を作る演算子です。",
  "typescript_lesson4_ex12_comment2": "型を除外するユーティリティ型です。",
  "typescript_lesson4_ex12_comment3": "除外されていないステータスを文字列で指定します。",
  "typescript_lesson4_ex12_comment4": "出力する変数を指定します。",
  "typescript_lesson4_ex12_slide1_content": "# 特定の状態を除外\n\n「使いたくない状態」を除外した新しい型を作れます。\n\n## たとえ話\n\nすべてのステータスの中から「キャンセル済み」だけを除外して、「アクティブなステータス」だけを使いたいときに便利です。\n\n## コードで書くとこうなるよ\n\n```typescript\ntype Status = 'pending' | 'success' | 'error' | 'cancelled';\n\n// cancelledを除外\ntype ActiveStatus = Exclude<Status, 'cancelled'>;\n// 'pending' | 'success' | 'error'\n```",
  "typescript_lesson4_ex12_slide1_title": "Excludeの使い方",
  "typescript_lesson4_ex12_title": "Excludeの使い方",
  "typescript_lesson4_ex13_description": "ユニオン型から特定の型を抽出しましょう。",
  "typescript_lesson4_ex13_title": "Extract型",
  "typescript_lesson4_ex14_comment1": "ユニオン型を作る演算子です。",
  "typescript_lesson4_ex14_comment2": "型を抽出するユーティリティ型です。",
  "typescript_lesson4_ex14_comment3": "抽出されたマウスイベントを文字列で指定します。",
  "typescript_lesson4_ex14_comment4": "出力する変数を指定します。",
  "typescript_lesson4_ex14_slide1_content": "# 特定の種類だけを抽出\n\n「使いたい型だけ」を選び出せます。\n\n## たとえ話\n\nすべてのイベントの中から「マウス関連のイベント」だけを選びたいときに便利です。\n\n## コードで書くとこうなるよ\n\n```typescript\ntype Event = 'click' | 'scroll' | 'keydown';\n\n// マウス関連だけを抽出\ntype MouseEvent = Extract<Event, 'click' | 'scroll'>;\n// 'click' | 'scroll'\n```\n\nExcludeが「除外」、Extractが「抽出」と覚えましょう！",
  "typescript_lesson4_ex14_slide1_title": "Extractの使い方",
  "typescript_lesson4_ex14_title": "Extractの使い方",
  "typescript_lesson4_ex15_description": "nullとundefinedを除外しましょう。",
  "typescript_lesson4_ex15_title": "NonNullable型",
  "typescript_lesson4_ex16_comment1": "ユニオン型を作る演算子です。",
  "typescript_lesson4_ex16_comment2": "null/undefinedを除外するユーティリティ型です。",
  "typescript_lesson4_ex16_comment3": "確定した文字列の値を指定します。",
  "typescript_lesson4_ex16_comment4": "出力する変数を指定します。",
  "typescript_lesson4_ex16_slide1_content": "# 安全に値を使う\n\nnullやundefinedの可能性を排除して、安全に値を使えるようにします。\n\n## たとえ話\n\nデータを取得したとき「まだない」場合はnullかもしれません。でも「確実にある」場面ではNonNullableで保証できます。\n\n## コードで書くとこうなるよ\n\n```typescript\ntype MaybeString = string | null | undefined;\n\n// null/undefinedを除外\ntype DefiniteString = NonNullable<MaybeString>;\n// string\n\nconst text: DefiniteString = 'Hello';\n// null や undefined は代入できない！\n```",
  "typescript_lesson4_ex16_slide1_title": "NonNullableの使い方",
  "typescript_lesson4_ex16_title": "NonNullableの使い方",
  "typescript_lesson4_ex17_description": "関数の引数の型を取得しましょう。",
  "typescript_lesson4_ex17_title": "Parameters型",
  "typescript_lesson4_ex18_comment1": "デバッグ用コンソールなどに文字列を出力します。",
  "typescript_lesson4_ex18_comment2": "関数の引数型を取得するユーティリティ型です。",
  "typescript_lesson4_ex18_comment3": "年齢の値を数値で指定します。",
  "typescript_lesson4_ex18_comment4": "スプレッド構文で展開する配列を指定します。",
  "typescript_lesson4_ex18_slide1_content": "# 引数を再利用する\n\n既存の関数と同じ引数を使いたいときに便利です。\n\n## たとえ話\n\n「この関数と同じ材料で、別の料理を作る」ような感じです。引数の型を一から書かなくて済みます。\n\n## コードで書くとこうなるよ\n\n```typescript\nfunction greet(name: string, age: number): void {\n  console.log(`${name} is ${age}`);\n}\n\n// 関数の引数の型を取得\ntype GreetParams = Parameters<typeof greet>;\n// [string, number]\n\n// 同じ型の引数を使える！\nconst args: GreetParams = ['Taro', 25];\ngreet(...args);  // 'Taro is 25'\n```",
  "typescript_lesson4_ex18_slide1_title": "Parametersの使い方",
  "typescript_lesson4_ex18_title": "Parametersの使い方",
  "typescript_lesson4_ex19_description": "Promiseの解決型を取得しましょう。",
  "typescript_lesson4_ex19_title": "Awaited型",
  "typescript_lesson4_ex1_comment1": "is で型ガードの戻り値型を定義",
  "typescript_lesson4_ex1_comment10": "型ガード関数に渡す変数を指定します。",
  "typescript_lesson4_ex1_comment12": "掛け算の倍数を数値で指定します。",
  "typescript_lesson4_ex1_comment2": "型ガードの戻り値型を定義します。",
  "typescript_lesson4_ex1_comment3": "unknown型の値",
  "typescript_lesson4_ex1_comment4": "チェックする型名を文字列で指定します。",
  "typescript_lesson4_ex1_comment5": "数値として計算",
  "typescript_lesson4_ex1_comment8": "チェックする値を数値で指定します。",
  "typescript_lesson4_ex1_description": "カスタム型ガードを作成しましょう。",
  "typescript_lesson4_ex1_slide1_content": "# 型を絞り込む\n\n**型ガード**（Type Guard）は、「この値は○○型です！」と確認する関数です。確認した後は、TypeScriptがその型として扱ってくれます。\n\n## たとえ話\n\n「この箱の中身は何？」と確認してから使うような感じです。中身が「りんご」だとわかれば、りんごとして扱えます。\n\n## 書き方のポイント\n\n戻り値の型を `x is string` のように書きます。これは「xはstringです」という意味の特別な書き方です。\n\n## コードで書くとこうなるよ\n\n```typescript\nfunction isString(x: unknown): x is string {\n  return typeof x === 'string';\n}\n// 「xがstringかどうかチェックする関数」\n```",
  "typescript_lesson4_ex1_slide1_title": "型ガードとは？",
  "typescript_lesson4_ex1_slide2_content": "# 安全に型を使う\n\n型ガードでチェックした後は、TypeScriptがその型として扱ってくれるので、安全にメソッドなどを使えます。\n\n## コードで書くとこうなるよ\n\n```typescript\nfunction isString(x: unknown): x is string {\n  return typeof x === 'string';\n}\n\nconst value: unknown = 'hello';\n\nif (isString(value)) {\n  // ここではvalueはstring型！\n  console.log(value.toUpperCase());\n  // 文字列のメソッドが使える！\n}\n```",
  "typescript_lesson4_ex1_slide2_title": "型ガードの使い方",
  "typescript_lesson4_ex1_slide3_content": "カスタム型ガードを作成しましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "typescript_lesson4_ex1_slide3_title": "やってみよう！",
  "typescript_lesson4_ex1_title": "型ガード関数",
  "typescript_lesson4_ex20_comment1": "データの型は文字列なので `string` です。",
  "typescript_lesson4_ex20_comment2": "Promiseの解決型を取得するユーティリティ型です。",
  "typescript_lesson4_ex20_comment3": "データの値を文字列で指定します。",
  "typescript_lesson4_ex20_comment4": "取得したいプロパティ名を指定します。",
  "typescript_lesson4_ex20_slide1_content": "# 非同期処理の結果の型\n\nWebからデータを取得するなど、非同期処理の結果の型を知りたいときに使います。\n\n## たとえ話\n\n「この注文をすると、何が届く？」という質問に答えるようなものです。\n\n## コードで書くとこうなるよ\n\n```typescript\ntype AsyncResult = Promise<{ data: string }>;\n\n// Promiseが解決したら何になる？\ntype Result = Awaited<AsyncResult>;\n// { data: string }\n\n// 同じ型の変数を作れる\nconst result: Result = { data: 'success' };\n```\n\nasync/awaitで取得する値の型がわかって便利です！",
  "typescript_lesson4_ex20_slide1_title": "Awaitedの使い方",
  "typescript_lesson4_ex20_title": "Awaitedの使い方",
  "typescript_lesson4_ex2_comment1": "型ガードの戻り値型を定義します。",
  "typescript_lesson4_ex2_comment10": "デバッグ用コンソールなどに文字列を出力します。",
  "typescript_lesson4_ex2_comment13": "デバッグ用コンソールなどに文字列を出力します。",
  "typescript_lesson4_ex2_comment2": "戻り値がないことを示す型です。",
  "typescript_lesson4_ex2_comment3": "チェックする値を数値で指定します。",
  "typescript_lesson4_ex2_comment4": "戻り値がないことを示す型です。",
  "typescript_lesson4_ex2_comment5": "掛け算の倍数を数値で指定します。",
  "typescript_lesson4_ex2_comment6": "車を操作",
  "typescript_lesson4_ex2_comment8": "プロパティの存在をチェックする演算子です。",
  "typescript_lesson4_ex2_description": "プロパティの存在で型を絞り込みましょう。",
  "typescript_lesson4_ex2_slide1_content": "# プロパティで型を絞り込む\n\n**in演算子**は、オブジェクトに「特定のプロパティがあるかどうか」をチェックします。これで型を絞り込むことができます。\n\n## たとえ話\n\n「羽があれば鳥、ひれがあれば魚」のように、特徴で見分けるような感じです。\n\n## コードで書くとこうなるよ\n\n```typescript\ntype Fish = { swim: () => void };  // 泳げる\ntype Bird = { fly: () => void };   // 飛べる\n\nfunction move(animal: Fish | Bird) {\n  if ('swim' in animal) {\n    // swimがある = 魚！\n    animal.swim();\n  } else {\n    // swimがない = 鳥！\n    animal.fly();\n  }\n}\n```",
  "typescript_lesson4_ex2_slide1_title": "in演算子とは？",
  "typescript_lesson4_ex2_slide2_content": "# 書き方のポイント\n\n`'プロパティ名' in オブジェクト` という形で書きます。\n\n## 注意点\n\n- プロパティ名は文字列（クォートで囲む）\n- 存在すればtrue、なければfalseが返る\n\n## たとえ話\n\n「このオブジェクトに○○という項目はある？」と聞いているようなものです。\n\n## コードで書くとこうなるよ\n\n```typescript\nconst obj = { name: 'Taro', age: 10 };\n\nif ('age' in obj) {\n  console.log('ageがあります！');\n}\n```",
  "typescript_lesson4_ex2_slide2_title": "in演算子の使い方",
  "typescript_lesson4_ex2_slide3_content": "プロパティの存在で型を絞り込みましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "typescript_lesson4_ex2_slide3_title": "やってみよう！",
  "typescript_lesson4_ex2_title": "in演算子での型絞り込み",
  "typescript_lesson4_ex3_comment1": "status で判別プロパティを使う",
  "typescript_lesson4_ex3_comment10": "判別プロパティ名を指定します。",
  "typescript_lesson4_ex3_comment13": "成功時に取得するプロパティ名を指定します。",
  "typescript_lesson4_ex3_comment17": "失敗時に取得するプロパティ名を指定します。",
  "typescript_lesson4_ex3_comment2": "データは文字列なので `string` です。",
  "typescript_lesson4_ex3_comment23": "成功時のデータ値を文字列で指定します。",
  "typescript_lesson4_ex3_comment3": "結果のユニオン型",
  "typescript_lesson4_ex3_comment4": "エラーは文字列なので `string` です。",
  "typescript_lesson4_ex3_comment5": "データを出力",
  "typescript_lesson4_ex3_comment6": "ユニオン型を作る演算子です。",
  "typescript_lesson4_ex3_comment7": "成功結果を処理",
  "typescript_lesson4_ex3_description": "判別可能なユニオン型を使いましょう。",
  "typescript_lesson4_ex3_slide1_content": "# 判別プロパティで型を区別\n\n**Discriminated Union**（判別可能なユニオン）は、共通の「目印プロパティ」を使って、どの型かを見分ける方法です。\n\n## たとえ話\n\nお菓子の袋に「種類：チョコ」「種類：クッキー」と書いてあれば、中身を開けなくても何が入っているかわかりますよね。\n\n## コードで書くとこうなるよ\n\n```typescript\n// kindが「目印」になる\ntype Circle = { kind: 'circle'; radius: number };\ntype Square = { kind: 'square'; size: number };\ntype Shape = Circle | Square;\n\nfunction area(s: Shape): number {\n  switch (s.kind) {  // kindで判別\n    case 'circle': return Math.PI * s.radius ** 2;\n    case 'square': return s.size ** 2;\n  }\n}\n```",
  "typescript_lesson4_ex3_slide1_title": "Discriminated Unionとは？",
  "typescript_lesson4_ex3_slide2_content": "# なぜ便利なの？\n\n判別プロパティ（kindなど）を見れば、TypeScriptがその型だと自動で理解してくれます。\n\n## メリット\n\n1. **switch文で簡単に分岐できる**\n2. **各caseで正しいプロパティが使える**\n3. **漏れがあるとエラーで教えてくれる**\n\n## たとえ話\n\n「円」と「四角」では使えるプロパティが違います。kindを見て判別すれば、円なら「radius」、四角なら「size」が使えると自動でわかります！",
  "typescript_lesson4_ex3_slide2_title": "Discriminated Unionの利点",
  "typescript_lesson4_ex3_slide3_content": "判別可能なユニオン型を使いましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "typescript_lesson4_ex3_slide3_title": "やってみよう！",
  "typescript_lesson4_ex3_title": "Discriminated Union",
  "typescript_lesson4_ex4_comment1": "戻り値がないことを示す型です。",
  "typescript_lesson4_ex4_comment11": "青色のカラーコードを16進数で返します。",
  "typescript_lesson4_ex4_comment14": "全ケースを処理した後は到達しないことを示す型です。",
  "typescript_lesson4_ex4_comment16": "変数の値を呼び出し元に返します（戻り値）。",
  "typescript_lesson4_ex4_comment2": "ユニオン型に色を追加する演算子です。",
  "typescript_lesson4_ex4_comment21": "カラーコードを取得したい色を指定します。",
  "typescript_lesson4_ex4_comment3": "プロパティの存在をチェックする演算子です。",
  "typescript_lesson4_ex4_comment4": "デバッグ用コンソールなどに文字列を出力します。",
  "typescript_lesson4_ex4_comment5": "デバッグ用コンソールなどに文字列を出力します。",
  "typescript_lesson4_ex4_comment6": "赤のカラーコードを出力",
  "typescript_lesson4_ex4_comment7": "赤色のカラーコードを16進数で返します。",
  "typescript_lesson4_ex4_comment9": "緑色のカラーコードを16進数で返します。",
  "typescript_lesson4_ex4_description": "switch文の網羅性をチェックしましょう。",
  "typescript_lesson4_ex4_slide1_content": "# 到達不能な型\n\n**never型**は「絶対にここには来ない」という意味の特別な型です。値を持たない型なので、何も代入できません。\n\n## たとえ話\n\n「ありえない」を型で表現したものです。例えば、全ての可能性を処理した後の「残り」は「ありえない」ですよね。\n\n## いつ使うの？\n\nswitch文で「全てのケースを処理したか」をチェックするのに使います。もし処理し忘れたケースがあると、TypeScriptがエラーで教えてくれます！\n\n## コードで書くとこうなるよ\n\n```typescript\nfunction exhaustiveCheck(x: never): never {\n  throw new Error('Unexpected value');\n}\n// 「ここには絶対来ないはず」という関数\n```",
  "typescript_lesson4_ex4_slide1_title": "never型とは？",
  "typescript_lesson4_ex4_slide2_content": "# 処理し忘れを防ぐ\n\nswitch文のdefaultでnever型を使うと、全ケースを処理したかチェックできます。\n\n## たとえ話\n\n「赤・青・緑」の3色を処理するとき、もし「青」を忘れていたらエラーで教えてくれます。\n\n## コードで書くとこうなるよ\n\n```typescript\ntype Color = 'red' | 'blue';\n\nfunction handle(c: Color) {\n  switch (c) {\n    case 'red': return '#ff0000';\n    case 'blue': return '#0000ff';\n    default:\n      // 全ケース処理済みなら、ここには来ない\n      const _check: never = c;\n      return _check;\n  }\n}\n```\n\n新しい色を追加したとき、処理を忘れるとエラーになります！",
  "typescript_lesson4_ex4_slide2_title": "網羅性チェック",
  "typescript_lesson4_ex4_slide3_content": "switch文の網羅性をチェックしましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "typescript_lesson4_ex4_slide3_title": "やってみよう！",
  "typescript_lesson4_ex4_title": "never型で網羅性チェック",
  "typescript_lesson4_ex5_comment1": "` でテンプレートリテラル型を定義",
  "typescript_lesson4_ex5_comment11": "出力する変数を指定します。",
  "typescript_lesson4_ex5_comment2": "ユニオン型を作る演算子です。",
  "typescript_lesson4_ex5_comment3": "テンプレートリテラル型を定義",
  "typescript_lesson4_ex5_comment4": "ユニオン型を作る演算子です。",
  "typescript_lesson4_ex5_comment5": "出力",
  "typescript_lesson4_ex5_comment6": "テンプレートリテラルを開始するバッククォートです。",
  "typescript_lesson4_ex5_comment9": "有効なルートパターンを文字列で指定します。",
  "typescript_lesson4_ex5_description": "文字列リテラル型を組み合わせましょう。",
  "typescript_lesson4_ex5_slide1_content": "# 文字列型を組み合わせる\n\n**テンプレートリテラル型**は、文字列リテラル型を組み合わせて、新しい文字列パターンを作る機能です。\n\n## たとえ話\n\n「サイズ」と「色」を組み合わせて「小-赤」「大-青」などのパターンを自動で作れます。全部手で書かなくてOK！\n\n## コードで書くとこうなるよ\n\n```typescript\ntype Color = 'red' | 'blue';\ntype Size = 'small' | 'large';\ntype Style = `${Size}-${Color}`;\n// 自動で4パターンができる！\n// 'small-red' | 'small-blue' | 'large-red' | 'large-blue'\n```",
  "typescript_lesson4_ex5_slide1_title": "テンプレートリテラル型とは？",
  "typescript_lesson4_ex5_slide2_content": "# 書き方のポイント\n\nバッククォート（`）で囲んで、`${型名}` で他の型を埋め込みます。\n\n## 便利な使い方\n\nAPIのルートや、CSSのクラス名など、決まったパターンの文字列を型で表現できます。\n\n## コードで書くとこうなるよ\n\n```typescript\ntype Method = 'get' | 'post';\ntype Path = '/users' | '/posts';\n\n// メソッドとパスの組み合わせ\ntype Route = `${Method} ${Path}`;\n// 'get /users' | 'get /posts' | 'post /users' | 'post /posts'\n\nconst route: Route = 'get /users';  // OK!\nconst bad: Route = 'delete /users'; // エラー！\n```",
  "typescript_lesson4_ex5_slide2_title": "テンプレートリテラル型の書き方",
  "typescript_lesson4_ex5_slide3_content": "文字列リテラル型を組み合わせましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "typescript_lesson4_ex5_slide3_title": "やってみよう！",
  "typescript_lesson4_ex5_title": "テンプレートリテラル型",
  "typescript_lesson4_ex6_comment1": "データは文字列なので `string` です。",
  "typescript_lesson4_ex6_comment2": "ユニオン型を作る演算子です。",
  "typescript_lesson4_ex6_comment3": "ユニオン型を作る演算子です。",
  "typescript_lesson4_ex6_comment4": "型を除外するユーティリティ型です。",
  "typescript_lesson4_ex6_comment5": "成功時に取得するプロパティ名を指定します。",
  "typescript_lesson4_ex6_comment6": "失敗時に取得するプロパティ名を指定します。",
  "typescript_lesson4_ex6_comment7": "除外されていないステータスを文字列で指定します。",
  "typescript_lesson4_ex6_comment9": "出力する変数を指定します。",
  "typescript_lesson4_ex6_description": "ユニオン型から特定の型を除外しましょう。",
  "typescript_lesson4_ex6_slide1_content": "# ユニオン型から除外する\n\n**Exclude**（エクスクルード）は、ユニオン型から特定の型を「除外」します。\n\n## たとえ話\n\n「りんご・みかん・バナナ」の中から「バナナ」を除外すると「りんご・みかん」になりますよね。Excludeはまさにそれ！\n\n## コードで書くとこうなるよ\n\n```typescript\ntype T = 'a' | 'b' | 'c';\ntype Without_A = Exclude<T, 'a'>;\n// 'b' | 'c'\n// 'a' が除外された！\n```",
  "typescript_lesson4_ex6_slide1_title": "Exclude<T, U>とは？",
  "typescript_lesson4_ex6_slide2_content": "# 特定の状態を除外\n\n「使いたくない状態」を除外した新しい型を作れます。\n\n## たとえ話\n\nすべてのステータスの中から「キャンセル済み」だけを除外して、「アクティブなステータス」だけを使いたいときに便利です。\n\n## コードで書くとこうなるよ\n\n```typescript\ntype Status = 'pending' | 'success' | 'error' | 'cancelled';\n\n// cancelledを除外\ntype ActiveStatus = Exclude<Status, 'cancelled'>;\n// 'pending' | 'success' | 'error'\n```",
  "typescript_lesson4_ex6_slide2_title": "Excludeの使い方",
  "typescript_lesson4_ex6_slide3_content": "ユニオン型から特定の型を除外しましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "typescript_lesson4_ex6_slide3_title": "やってみよう！",
  "typescript_lesson4_ex6_title": "Exclude型",
  "typescript_lesson4_ex7_comment1": "Extract でユニオン型から特定の型を抽出",
  "typescript_lesson4_ex7_comment2": "ユニオン型を作る演算子です。",
  "typescript_lesson4_ex7_comment3": "マウスイベントを代入",
  "typescript_lesson4_ex7_comment4": "型を抽出するユーティリティ型です。",
  "typescript_lesson4_ex7_comment7": "抽出されたマウスイベントを文字列で指定します。",
  "typescript_lesson4_ex7_comment9": "出力する変数を指定します。",
  "typescript_lesson4_ex7_description": "ユニオン型から特定の型を抽出しましょう。",
  "typescript_lesson4_ex7_slide1_content": "# ユニオン型から抽出する\n\n**Extract**（エクストラクト）は、Excludeの逆で、ユニオン型から「欲しい型だけ」を抽出します。\n\n## たとえ話\n\n「りんご・みかん・バナナ」の中から「りんご・みかん」だけを選び出すようなものです。「これだけ欲しい！」というときに使います。\n\n## コードで書くとこうなるよ\n\n```typescript\ntype T = 'a' | 'b' | 'c';\ntype Only_AB = Extract<T, 'a' | 'b'>;\n// 'a' | 'b'\n// 'a' と 'b' だけ抽出された！\n```",
  "typescript_lesson4_ex7_slide1_title": "Extract<T, U>とは？",
  "typescript_lesson4_ex7_slide2_content": "# 特定の種類だけを抽出\n\n「使いたい型だけ」を選び出せます。\n\n## たとえ話\n\nすべてのイベントの中から「マウス関連のイベント」だけを選びたいときに便利です。\n\n## コードで書くとこうなるよ\n\n```typescript\ntype Event = 'click' | 'scroll' | 'keydown';\n\n// マウス関連だけを抽出\ntype MouseEvent = Extract<Event, 'click' | 'scroll'>;\n// 'click' | 'scroll'\n```\n\nExcludeが「除外」、Extractが「抽出」と覚えましょう！",
  "typescript_lesson4_ex7_slide2_title": "Extractの使い方",
  "typescript_lesson4_ex7_slide3_content": "ユニオン型から特定の型を抽出しましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "typescript_lesson4_ex7_slide3_title": "やってみよう！",
  "typescript_lesson4_ex7_title": "Extract型",
  "typescript_lesson4_ex8_comment1": "ユニオン型に色を追加する演算子です。",
  "typescript_lesson4_ex8_comment2": "ユニオン型を作る演算子です。",
  "typescript_lesson4_ex8_comment3": "緑色のカラーコードを16進数で返します。",
  "typescript_lesson4_ex8_comment4": "null/undefinedを除外するユーティリティ型です。",
  "typescript_lesson4_ex8_comment5": "全ケースを処理した後は到達しないことを示す型です。",
  "typescript_lesson4_ex8_comment6": "変数の値を呼び出し元に返します（戻り値）。",
  "typescript_lesson4_ex8_comment7": "確定した文字列の値を指定します。",
  "typescript_lesson4_ex8_comment9": "出力する変数を指定します。",
  "typescript_lesson4_ex8_description": "nullとundefinedを除外しましょう。",
  "typescript_lesson4_ex8_slide1_content": "# null/undefinedを除外\n\n**NonNullable**（ノンナラブル）は、型から `null` と `undefined` を除外します。「確実に値がある」ことを保証したいときに使います。\n\n## たとえ話\n\n「空っぽかもしれない」状態から「必ず中身がある」状態に変えるようなものです。\n\n## コードで書くとこうなるよ\n\n```typescript\ntype T = string | null | undefined;\ntype NonNull = NonNullable<T>;\n// string\n// null と undefined が消えた！\n```",
  "typescript_lesson4_ex8_slide1_title": "NonNullable<T>とは？",
  "typescript_lesson4_ex8_slide2_content": "# 安全に値を使う\n\nnullやundefinedの可能性を排除して、安全に値を使えるようにします。\n\n## たとえ話\n\nデータを取得したとき「まだない」場合はnullかもしれません。でも「確実にある」場面ではNonNullableで保証できます。\n\n## コードで書くとこうなるよ\n\n```typescript\ntype MaybeString = string | null | undefined;\n\n// null/undefinedを除外\ntype DefiniteString = NonNullable<MaybeString>;\n// string\n\nconst text: DefiniteString = 'Hello';\n// null や undefined は代入できない！\n```",
  "typescript_lesson4_ex8_slide2_title": "NonNullableの使い方",
  "typescript_lesson4_ex8_slide3_content": "nullとundefinedを除外しましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "typescript_lesson4_ex8_slide3_title": "やってみよう！",
  "typescript_lesson4_ex8_title": "NonNullable型",
  "typescript_lesson4_ex9_comment1": "Parameters で関数の引数型を取得",
  "typescript_lesson4_ex9_comment10": "スプレッド構文で展開する配列を指定します。",
  "typescript_lesson4_ex9_comment2": "引数の配列 args を渡して呼び出し",
  "typescript_lesson4_ex9_comment3": "デバッグ用コンソールなどに文字列を出力します。",
  "typescript_lesson4_ex9_comment4": "引数の配列を定義",
  "typescript_lesson4_ex9_comment5": "引数の配列argsを渡して呼び出し",
  "typescript_lesson4_ex9_comment6": "関数の引数型を取得するユーティリティ型です。",
  "typescript_lesson4_ex9_comment8": "年齢の値を数値で指定します。",
  "typescript_lesson4_ex9_description": "関数の引数の型を取得しましょう。",
  "typescript_lesson4_ex9_slide1_content": "# 関数の引数型を取得\n\n**Parameters**（パラメーターズ）は、関数が「何を受け取るか」の型を取得します。引数の型がタプル（順番付きの配列）として返ってきます。\n\n## たとえ話\n\n料理のレシピを見て「材料リスト」を知るようなものです。関数がどんな材料（引数）を必要としているかがわかります。\n\n## コードで書くとこうなるよ\n\n```typescript\ntype Fn = (a: string, b: number) => void;\ntype Params = Parameters<Fn>;\n// [string, number]\n// 「1番目はstring、2番目はnumber」\n```",
  "typescript_lesson4_ex9_slide1_title": "Parameters<T>とは？",
  "typescript_lesson4_ex9_slide2_content": "# 引数を再利用する\n\n既存の関数と同じ引数を使いたいときに便利です。\n\n## たとえ話\n\n「この関数と同じ材料で、別の料理を作る」ような感じです。引数の型を一から書かなくて済みます。\n\n## コードで書くとこうなるよ\n\n```typescript\nfunction greet(name: string, age: number): void {\n  console.log(`${name} is ${age}`);\n}\n\n// 関数の引数の型を取得\ntype GreetParams = Parameters<typeof greet>;\n// [string, number]\n\n// 同じ型の引数を使える！\nconst args: GreetParams = ['Taro', 25];\ngreet(...args);  // 'Taro is 25'\n```",
  "typescript_lesson4_ex9_slide2_title": "Parametersの使い方",
  "typescript_lesson4_ex9_slide3_content": "関数の引数の型を取得しましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "typescript_lesson4_ex9_slide3_title": "やってみよう！",
  "typescript_lesson4_ex9_title": "Parameters型",
  "typescript_lesson4_title": "TypeScript IV - デコレータと高度なパターン"
}
{
  "haskell_lesson1_course_title": "Úvod do Haskellu",
  "haskell_lesson1_course_description": "Naučte se základy programování v Haskellu.",
  "haskell_lesson2_course_title": "Haskell II - Pokročilé",
  "haskell_lesson2_course_description": "Ovládněte pokročilé koncepty Haskellu.",
  "haskell_lesson2_ex9_slide3_content": "Naučte se \"list comprehensions\" pro vytváření seznamů stručně.\n\n(Až budete připraveni, vyberte \"Začít lekci\".)",
  "haskell_lesson2_ex2_slide2_content": "# jméno :: typ\n\nPište jako `názevFunkce :: typArgumentu -> návratovýTyp`.\n\nPříklad kódu:\n```haskell\ndouble :: Int -> Int\ndouble x = x * 2\n```",
  "haskell_lesson2_ex4_comment1": "map transformuje každý prvek",
  "haskell_lesson3_ex4_comment1": "foldr skládá zprava",
  "haskell_lesson2_ex8_slide1_title": "Lambda výrazy?",
  "haskell_lesson3_ex1_description": "Použijte funkci map k aplikaci funkce na každý prvek seznamu.",
  "haskell_lesson2_ex8_slide1_content": "# Anonymní funkce\n\nLambda výrazy jsou funkce definované bez jména. Píšeme je jako `\\argument -> tělo`.",
  "haskell_lesson2_ex6_slide2_content": "# Více definic\n\nDefinujte stejnou funkci vícekrát a nechte vzory argumentů vybrat.\n\nPříklad kódu:\n```haskell\nfactorial 0 = 1\nfactorial n = n * factorial (n - 1)\n```",
  "haskell_lesson2_ex4_slide3_content": "Naučte se \"map\" pro transformaci každého prvku seznamu.\n\n(Až budete připraveni, vyberte \"Začít lekci\".)",
  "haskell_lesson2_ex3_slide1_content": "# Sekvence prvků stejného typu\n\nSeznamy v Haskellu jsou uspořádané kolekce prvků stejného typu. Vytváříme je pomocí `[ ]`.",
  "haskell_lesson2_ex10_slide3_content": "Naučte se \"foldr\" pro složení seznamu do jedné hodnoty.\n\n(Až budete připraveni, vyberte \"Začít lekci\".)",
  "haskell_lesson3_course_description": "Naučte se funkce vyššího řádu, lambda výrazy, kompozici funkcí a základy monád v Haskellu. Ovládněte operace se seznamy pomocí map, filter, fold a zpracování chyb s Maybe a Either.",
  "haskell_lesson2_ex1_slide3_content": "Naučte se definici funkcí v Haskellu.\n\n(Až budete připraveni, vyberte \"Začít lekci\".)",
  "haskell_lesson2_ex3_comment1": "head získá první prvek",
  "haskell_lesson3_ex10_slide1_title": "List Comprehensions",
  "haskell_lesson2_ex5_slide1_content": "# Filtrování podle podmínky\n\nfilter vytváří nový seznam pouze s prvky, které splňují podmínku.",
  "haskell_lesson2_ex10_description": "Naučte se \"foldr\" pro složení seznamu do jedné hodnoty.",
  "haskell_lesson2_ex1_slide2_content": "# Předávání argumentů mezerami\n\nVolejte funkce zápisem `názevFunkce argument`.\n\nPříklad kódu:\n```haskell\ndouble x = x * 2\nmain = print (double 5) -- 10\n```",
  "haskell_lesson3_ex3_slide1_title": "Lambda výrazy",
  "haskell_lesson3_ex8_description": "Použijte fmap z typové třídy Functor.",
  "haskell_lesson2_ex9_slide3_title": "Vyzkoušejte si to!",
  "haskell_lesson3_ex2_slide1_content": "Funkce filter vybírá pouze prvky, které splňují podmínku (predikátovou funkci).\n\n```haskell\n-- filter :: (a -> Bool) -> [a] -> [a]\nevens = filter even [1, 2, 3, 4, 5]\n-- Výsledek: [2, 4]\n\npositive = filter (> 0) [-1, 2, -3, 4]\n-- Výsledek: [2, 4]\n```",
  "haskell_lesson2_ex1_title": "Definice funkcí",
  "haskell_lesson3_ex10_slide2_content": "Generujte seznamy pomocí list comprehensions.\n\n(Až budete připraveni, vyberte \"Začít lekci\".)",
  "haskell_lesson3_ex8_comment1": "fmap aplikuje funkci na hodnoty uvnitř Functoru",
  "haskell_lesson3_ex1_slide1_content": "Funkce map aplikuje funkci na každý prvek seznamu a vrací nový seznam.\n\n```haskell\n-- map :: (a -> b) -> [a] -> [b]\ndoubled = map (*2) [1, 2, 3]\n-- Výsledek: [2, 4, 6]\n\nuppers = map toUpper \"hello\"\n-- Výsledek: \"HELLO\"\n```",
  "haskell_lesson3_ex1_comment1": "map aplikuje funkci na každý prvek",
  "haskell_lesson2_ex6_slide2_title": "Syntaxe pattern matchingu",
  "haskell_lesson3_course_title": "Haskell III - Funkce vyššího řádu a monády",
  "haskell_lesson3_ex7_slide2_title": "Vyzkoušejte si to!",
  "haskell_lesson3_ex6_title": "Typ Maybe",
  "haskell_lesson2_ex3_slide2_title": "Operace se seznamy",
  "haskell_lesson3_ex3_slide2_title": "Vyzkoušejte si to!",
  "haskell_lesson2_ex9_title": "List Comprehensions",
  "haskell_lesson3_ex3_slide2_content": "Použijte anonymní funkce (lambda výrazy).\n\n(Až budete připraveni, vyberte \"Začít lekci\".)",
  "haskell_lesson3_ex1_title": "Funkce map",
  "haskell_lesson2_ex2_slide2_title": "Syntaxe typových anotací",
  "haskell_lesson2_ex8_slide2_title": "Použití lambda",
  "haskell_lesson2_ex3_slide3_content": "Naučte se základy seznamů v Haskellu.\n\n(Až budete připraveni, vyberte \"Začít lekci\".)",
  "haskell_lesson3_ex6_slide1_title": "Typ Maybe",
  "haskell_lesson2_ex8_slide3_content": "Naučte se \"lambda výrazy\" - funkce bez jména.\n\n(Až budete připraveni, vyberte \"Začít lekci\".)",
  "haskell_lesson2_ex9_slide1_title": "List Comprehensions?",
  "haskell_lesson3_ex8_slide1_title": "fmap (Functor)",
  "haskell_lesson2_ex7_slide1_content": "# Větvení podle podmínky\n\nGuards jsou způsob definování různého zpracování pro každou podmínku pomocí `|`.",
  "haskell_lesson3_ex8_title": "fmap (Functor)",
  "haskell_lesson2_ex10_slide2_title": "Použití foldr",
  "haskell_lesson3_ex4_slide1_content": "foldr skládá seznam zprava.\n\n```haskell\n-- foldr :: (a -> b -> b) -> b -> [a] -> b\n-- foldr f init [x1, x2, x3]\n-- = f x1 (f x2 (f x3 init))\n\nsum' = foldr (+) 0 [1, 2, 3]\n-- = 1 + (2 + (3 + 0)) = 6\n```",
  "haskell_lesson2_ex3_slide3_title": "Vyzkoušejte si to!",
  "haskell_lesson3_ex2_description": "Použijte funkci filter k výběru pouze prvků splňujících podmínku.",
  "haskell_lesson2_ex1_slide2_title": "Použití funkcí",
  "haskell_lesson2_ex4_slide2_title": "Použití map",
  "haskell_lesson2_ex6_slide1_content": "# Větvení podle tvaru hodnoty\n\nPattern matching je funkce, která používá různé definice podle hodnot nebo struktury argumentů.",
  "haskell_lesson2_ex10_slide1_title": "foldr?",
  "haskell_lesson2_ex2_description": "Naučte se \"typové anotace\" pro explicitní specifikaci typů funkcí.",
  "haskell_lesson2_ex9_slide1_content": "# Matematická generace seznamů\n\nList comprehensions jsou způsob vytváření seznamů podobný matematickému zápisu množin.",
  "haskell_lesson2_ex5_comment1": "filter vybírá prvky odpovídající podmínce",
  "haskell_lesson3_ex9_description": "Použijte monadickou do notaci.",
  "haskell_lesson2_title": "Haskell II - Funkce a typy",
  "haskell_lesson3_ex9_slide2_content": "Použijte monadickou do notaci.\n\n(Až budete připraveni, vyberte \"Začít lekci\".)",
  "haskell_lesson2_ex6_description": "Naučte se větvit podle vzorů argumentů.",
  "haskell_lesson2_ex7_description": "Naučte se \"guards\" pro větvení podle podmínek.",
  "haskell_lesson2_ex5_slide3_content": "Naučte se \"filter\" pro výběr pouze prvků odpovídajících podmínce.\n\n(Až budete připraveni, vyberte \"Začít lekci\".)",
  "haskell_lesson2_ex2_comment1": ":: pro typovou anotaci",
  "haskell_lesson3_ex3_title": "Lambda výrazy",
  "haskell_lesson3_ex9_comment1": "do provádí monadické operace sekvenčně",
  "haskell_lesson2_ex5_slide2_content": "# filter podmínkováFunkce seznam\n\nZůstanou pouze prvky, pro které podmínková funkce vrací True.\n\nPříklad kódu:\n```haskell\nfilter (>3) [1, 2, 3, 4, 5] -- [4, 5]\n```",
  "haskell_lesson2_ex5_slide3_title": "Vyzkoušejte si to!",
  "haskell_lesson3_ex2_slide1_title": "Funkce filter",
  "haskell_lesson3_ex6_slide2_content": "Použijte typ Maybe k reprezentaci hodnot, které nemusí existovat.\n\n(Až budete připraveni, vyberte \"Začít lekci\".)",
  "haskell_lesson3_ex9_title": "do notace",
  "haskell_lesson2_ex9_slide2_content": "# [výraz | proměnná <- seznam, podmínka]\n\nKombinujte pravidla generování s podmínkami.\n\nPříklad kódu:\n```haskell\n[x * 2 | x <- [1..5]] -- [2,4,6,8,10]\n```",
  "haskell_lesson2_ex1_comment1": "* pro násobení",
  "haskell_lesson3_ex5_slide1_title": "Kompozice funkcí",
  "haskell_lesson2_ex9_description": "Naučte se \"list comprehensions\" pro stručné vytváření seznamů.",
  "haskell_lesson2_ex8_slide3_title": "Vyzkoušejte si to!",
  "haskell_lesson3_ex6_slide2_title": "Vyzkoušejte si to!",
  "haskell_lesson2_ex6_comment1": "Odečti 2 a rekurzuj",
  "haskell_lesson2_ex2_slide1_content": "# Explicitní specifikace typů\n\nTypové anotace explicitně zapisují typ funkcí nebo hodnot. Píšeme je pomocí `::`.",
  "haskell_lesson2_ex6_slide3_title": "Vyzkoušejte si to!",
  "haskell_lesson2_ex6_slide1_title": "Pattern Matching?",
  "haskell_lesson2_ex4_slide3_title": "Vyzkoušejte si to!",
  "haskell_lesson2_ex10_slide2_content": "# foldr funkce počátečníHodnota seznam\n\nPředejte binární funkci, počáteční hodnotu a seznam.\n\nPříklad kódu:\n```haskell\nfoldr (+) 0 [1, 2, 3] -- 6\n```",
  "haskell_lesson2_ex3_slide1_title": "Seznamy?",
  "haskell_lesson2_ex4_slide2_content": "# map funkce seznam\n\nPředejte funkci a seznam.\n\nPříklad kódu:\n```haskell\nmap (*2) [1, 2, 3] -- [2, 4, 6]\n```",
  "haskell_lesson2_ex4_slide1_title": "map?",
  "haskell_lesson2_ex6_slide3_content": "Naučte se větvit podle vzorů argumentů.\n\n(Až budete připraveni, vyberte \"Začít lekci\".)",
  "haskell_lesson2_ex7_slide2_content": "# | podmínka = zpracování\n\n`otherwise` je pro případy, kdy žádná podmínka neodpovídá.\n\nPříklad kódu:\n```haskell\nabs' x\n  | x < 0     = -x\n  | otherwise = x\n```",
  "haskell_lesson2_ex2_slide1_title": "Typové anotace?",
  "haskell_lesson2_ex5_slide2_title": "Použití filter",
  "haskell_lesson2_ex4_description": "Naučte se \"map\" pro transformaci každého prvku seznamu.",
  "haskell_lesson3_ex6_description": "Použijte typ Maybe k reprezentaci hodnot, které nemusí existovat.",
  "haskell_lesson2_ex1_description": "Naučte se definici funkcí v Haskellu.",
  "haskell_lesson2_ex5_slide1_title": "filter?",
  "haskell_lesson2_ex8_title": "Použití lambda výrazů",
  "haskell_lesson3_ex5_slide1_content": "Kompozice funkcí (.) kombinuje dvě funkce.\n\n```haskell\n-- (.) :: (b -> c) -> (a -> b) -> a -> c\n-- (f . g) x = f (g x)\n\ndoubleNegate = negate . (*2)\n-- doubleNegate 3 = negate (3 * 2) = -6\n\nabs' = abs . negate\n-- abs' 5 = abs (negate 5) = 5\n```",
  "haskell_lesson2_ex1_slide1_content": "# Jednoduché definice\n\nV Haskellu definujte funkce jednoduše jako `jméno argument = tělo`. Závorky nejsou potřeba.",
  "haskell_lesson3_ex2_comment1": "filter vybírá prvky splňující podmínku",
  "haskell_lesson2_ex8_comment1": "\\ začíná lambda výraz",
  "haskell_lesson2_ex1_slide1_title": "Definice funkcí",
  "haskell_lesson2_ex6_title": "Použití pattern matchingu",
  "haskell_lesson3_ex1_slide1_title": "Funkce map",
  "haskell_lesson3_ex5_description": "Kombinujte více funkcí pomocí operátoru kompozice funkcí (.).",
  "haskell_lesson3_ex7_description": "Použijte typ Either k reprezentaci výsledků, které mohou obsahovat informace o chybě.",
  "haskell_lesson3_ex5_title": "Kompozice funkcí",
  "haskell_lesson2_ex7_title": "Podmínky s guards",
  "haskell_lesson3_ex2_slide2_content": "Použijte funkci filter k výběru pouze prvků splňujících podmínku.\n\n(Až budete připraveni, vyberte \"Začít lekci\".)",
  "haskell_lesson2_ex2_title": "Psaní typových anotací",
  "haskell_lesson2_ex5_description": "Naučte se \"filter\" pro výběr pouze prvků odpovídajících podmínce.",
  "haskell_lesson3_ex1_slide2_content": "Použijte funkci map k aplikaci funkce na každý prvek seznamu.\n\n(Až budete připraveni, vyberte \"Začít lekci\".)",
  "haskell_lesson3_ex10_slide2_title": "Vyzkoušejte si to!",
  "haskell_lesson3_ex10_slide1_content": "List comprehensions mají syntaxi podobnou matematickému zápisu množin.\n\n```haskell\n-- [výraz | generátor, podmínka]\nevens = [x | x <- [1..10], even x]\n-- Výsledek: [2, 4, 6, 8, 10]\n\npairs = [(x, y) | x <- [1,2], y <- [3,4]]\n-- Výsledek: [(1,3),(1,4),(2,3),(2,4)]\n```",
  "haskell_lesson2_ex8_description": "Naučte se \"lambda výrazy\" - funkce bez jména.",
  "haskell_lesson3_ex2_slide2_title": "Vyzkoušejte si to!",
  "haskell_lesson2_ex7_comment1": "otherwise je pro všechny ostatní případy",
  "haskell_lesson3_ex8_slide2_title": "Vyzkoušejte si to!",
  "haskell_lesson2_ex3_description": "Naučte se základy seznamů v Haskellu.",
  "haskell_lesson2_ex5_title": "Filtrování pomocí filter",
  "haskell_lesson3_ex10_title": "List Comprehensions",
  "haskell_lesson2_ex4_title": "Transformace pomocí map",
  "haskell_lesson2_ex9_slide2_title": "Syntaxe comprehension",
  "haskell_lesson3_ex7_slide1_content": "Typ Either reprezentuje neúspěch (Left) nebo úspěch (Right).\n\n```haskell\n-- data Either a b = Left a | Right b\n\nsafeDiv :: Int -> Int -> Either String Int\nsafeDiv _ 0 = Left \"Dělení nulou\"\nsafeDiv x y = Right (x `div` y)\n\n-- safeDiv 10 2 = Right 5\n-- safeDiv 10 0 = Left \"Dělení nulou\"\n```",
  "haskell_lesson2_ex2_slide3_content": "Naučte se \"typové anotace\" pro explicitní specifikaci typů funkcí.\n\n(Až budete připraveni, vyberte \"Začít lekci\".)",
  "haskell_lesson3_ex9_slide2_title": "Vyzkoušejte si to!",
  "haskell_lesson2_ex10_comment1": "foldr pro skládání",
  "haskell_lesson2_ex8_slide2_content": "# Začíná s \\\n\n`\\` je symbol lambda.\n\nPříklad kódu:\n```haskell\nmap (\\x -> x * 2) [1, 2, 3]\n-- [2, 4, 6]\n```",
  "haskell_lesson3_ex4_slide2_content": "Použijte funkci foldr ke složení seznamu zprava.\n\n(Až budete připraveni, vyberte \"Začít lekci\".)",
  "haskell_lesson3_ex4_description": "Použijte funkci foldr ke složení seznamu zprava.",
  "haskell_lesson3_ex5_slide2_title": "Vyzkoušejte si to!",
  "haskell_lesson3_ex1_slide2_title": "Vyzkoušejte si to!",
  "haskell_lesson2_ex9_comment1": "<- extrahuje prvky ze seznamu",
  "haskell_lesson2_ex3_title": "Používání seznamů",
  "haskell_lesson3_title": "Haskell III - Funkce vyššího řádu a monády",
  "haskell_lesson3_ex8_slide1_content": "fmap aplikuje funkci na hodnoty uvnitř kontejneru.\n\n```haskell\n-- fmap :: Functor f => (a -> b) -> f a -> f b\n\nfmap (+1) (Just 5)     -- Just 6\nfmap (+1) Nothing      -- Nothing\nfmap (*2) [1, 2, 3]    -- [2, 4, 6]\nfmap length (Right \"hello\")  -- Right 5\n```",
  "haskell_lesson3_ex2_title": "Funkce filter",
  "haskell_lesson3_ex10_comment1": "| odděluje před generátory",
  "haskell_lesson2_ex7_slide3_content": "Naučte se \"guards\" pro větvení podle podmínek.\n\n(Až budete připraveni, vyberte \"Začít lekci\".)",
  "haskell_lesson3_ex7_slide1_title": "Typ Either",
  "haskell_lesson3_ex7_comment1": "Left reprezentuje chyby",
  "haskell_lesson3_ex7_title": "Typ Either",
  "haskell_lesson3_ex3_comment1": "\\ začíná lambda výraz",
  "haskell_lesson3_ex4_slide2_title": "Vyzkoušejte si to!",
  "haskell_lesson3_ex3_description": "Použijte anonymní funkce (lambda výrazy).",
  "haskell_lesson3_ex4_slide1_title": "foldr (skládání zprava)",
  "haskell_lesson3_ex4_title": "foldr (skládání zprava)",
  "haskell_lesson2_ex10_title": "Skládání pomocí foldr",
  "haskell_lesson3_ex6_slide1_content": "Typ Maybe reprezentuje hodnoty, které mohou existovat (Just) nebo nemusí (Nothing).\n\n```haskell\n-- data Maybe a = Nothing | Just a\n\nsafeHead :: [a] -> Maybe a\nsafeHead [] = Nothing\nsafeHead (x:_) = Just x\n\n-- safeHead [1,2,3] = Just 1\n-- safeHead [] = Nothing\n```",
  "haskell_lesson3_ex9_slide1_content": "do notace umožňuje psát monadické operace imperativním stylem.\n\n```haskell\n-- Použití bind (>>=)\nresult = Just 5 >>= \\x -> Just (x + 1)\n\n-- Použití do notace\nresult = do\n  x <- Just 5\n  return (x + 1)\n-- Výsledek: Just 6\n```",
  "haskell_lesson2_ex3_slide2_content": "# head a tail\n\nZískejte první prvek pomocí `head`, zbytek pomocí `tail`.\n\nPříklad kódu:\n```haskell\nhead [1, 2, 3] -- 1\ntail [1, 2, 3] -- [2, 3]\n```",
  "haskell_lesson3_ex3_slide1_content": "Lambda výrazy definují funkce bez jména. Začínají zpětným lomítkem (\\).\n\n```haskell\n-- \\argument -> tělo\ndoubled = map (\\x -> x * 2) [1, 2, 3]\n-- Výsledek: [2, 4, 6]\n\nadded = map (\\x -> x + 10) [1, 2, 3]\n-- Výsledek: [11, 12, 13]\n```",
  "haskell_lesson3_ex6_comment1": "Nothing reprezentuje žádnou hodnotu",
  "haskell_lesson3_ex5_comment1": ". pro kompozici funkcí",
  "haskell_lesson2_ex7_slide3_title": "Vyzkoušejte si to!",
  "haskell_lesson2_ex10_slide3_title": "Vyzkoušejte si to!",
  "haskell_lesson3_ex10_description": "Generujte seznamy pomocí list comprehensions.",
  "haskell_lesson2_ex2_slide3_title": "Vyzkoušejte si to!",
  "haskell_lesson3_ex9_slide1_title": "do notace",
  "haskell_lesson2_ex10_slide1_content": "# Skládání seznamů\n\nfoldr skládá prvky seznamu zprava doleva pomocí binární operace.",
  "haskell_lesson3_ex8_slide2_content": "Použijte fmap z typové třídy Functor.\n\n(Až budete připraveni, vyberte \"Začít lekci\".)",
  "haskell_lesson2_ex4_slide1_content": "# Transformace každého prvku\n\n**map** aplikuje funkci na každý prvek seznamu a vytváří nový seznam.",
  "haskell_lesson2_ex7_slide1_title": "Guards?",
  "haskell_lesson3_ex7_slide2_content": "Použijte typ Either k reprezentaci výsledků, které mohou obsahovat informace o chybě.\n\n(Až budete připraveni, vyberte \"Začít lekci\".)",
  "haskell_lesson2_ex1_slide3_title": "Vyzkoušejte si to!",
  "haskell_lesson2_ex7_slide2_title": "Syntaxe guards",
  "haskell_lesson3_ex5_slide2_content": "Kombinujte více funkcí pomocí operátoru kompozice funkcí (.).\n\n(Až budete připraveni, vyberte \"Začít lekci\".)"
}
{
    "en": {
        "cpp_lesson1_course_title": "C++ Challenge!",
        "cpp_lesson1_course_description": "Learn the basics of C++, a powerful extension of C. Master modern features to create versatile programs.",
        "cpp_lesson1_title": "C++ I - Getting Started",
        "cpp_lesson2_course_title": "C++ II - Classes & OOP",
        "cpp_lesson2_course_description": "Learn object-oriented programming with C++ classes. Master inheritance, templates, and smart pointers.",
        "cpp_lesson2_title": "C++ II - Classes & OOP",
        "cpp_lesson3_course_title": "C++ III - Modern C++",
        "cpp_lesson3_course_description": "Learn modern C++ features including smart pointers, move semantics, and STL algorithms.",
        "cpp_lesson3_title": "C++ III - Modern C++",
        "cpp_lesson4_course_title": "C++ IV - STL & Advanced",
        "cpp_lesson4_course_description": "Master STL algorithms and C++17 features. Write efficient and expressive code.",
        "cpp_lesson4_title": "C++ IV - STL & Advanced",

        "cpp_lesson1_ex1_title": "Display a message",
        "cpp_lesson1_ex1_comment1": "Prepare input/output functionality",
        "cpp_lesson1_ex1_comment2": "Output message using std::cout",
        "cpp_lesson1_ex1_slide1_title": "What is C++?",
        "cpp_lesson1_ex1_slide1_content": "C++ is a powerful and fast programming language based on C with many additional features.\n\nLike a sports car compared to a regular car - same speed but with more features!\n\nUsed in games, browsers (Chrome, Firefox), and 3D graphics software where speed matters.",
        "cpp_lesson1_ex1_slide2_title": "Getting Started with C++",
        "cpp_lesson1_ex1_slide2_content": "In C++, we use std::cout (character output) to display text.\n\nThe << operator sends text to the screen.\n\n#include <iostream>\nint main() {\n    std::cout << \"C++ is awesome!\" << std::endl;\n    return 0;\n}\n\nstd::endl adds a newline.",

        "cpp_lesson1_ex2_title": "Number box 'int'",
        "cpp_lesson1_ex2_comment1": "Create an int variable",
        "cpp_lesson1_ex2_comment2": "Display its contents",
        "cpp_lesson1_ex2_slide1_title": "What are Variables?",
        "cpp_lesson1_ex2_slide1_content": "Variables are named 'boxes' that store data in your program.\n\nJust like labeling toy boxes 'blocks' or 'dolls', we name variables to know what's inside.",
        "cpp_lesson1_ex2_slide2_title": "The int Label",
        "cpp_lesson1_ex2_slide2_content": "Use 'int' for integers (whole numbers like 1, 2, 3).\n\nint age = 20;\nstd::cout << age << std::endl;\n=> 20\n\nUnlike C's printf, C++ uses std::cout << variable directly!",

        "cpp_lesson1_ex3_title": "Calculate with computer",
        "cpp_lesson1_ex3_comment1": "Put numbers in boxes",
        "cpp_lesson1_ex3_comment2": "Display addition result",
        "cpp_lesson1_ex3_slide1_title": "Computers Excel at Math",
        "cpp_lesson1_ex3_slide1_content": "Computers can calculate much faster than humans.\n\nThey never get tired, even with millions of calculations!",
        "cpp_lesson1_ex3_slide2_title": "Calculation Symbols",
        "cpp_lesson1_ex3_slide2_content": "Use << to chain outputs:\n\nint cookies = 10;\nint friends = 2;\nstd::cout << cookies / friends << std::endl;\n=> 5",

        "cpp_lesson1_ex4_title": "Modulo operator (%)",
        "cpp_lesson1_ex4_comment1": "Output 10 divided by 3 remainder",
        "cpp_lesson1_ex4_slide1_title": "Finding Remainders",
        "cpp_lesson1_ex4_slide1_content": "The % operator gives you the remainder of division.\n\n10 cookies shared by 3 people = 3 each, 1 left over!",
        "cpp_lesson1_ex4_slide2_title": "Using %",
        "cpp_lesson1_ex4_slide2_content": "std::cout << 10 % 3 << std::endl;  // => 1\n\nstd::cout << 8 % 2 << std::endl;   // => 0 (divides evenly)",

        "cpp_lesson1_ex5_title": "Compound assignment (+=, -=)",
        "cpp_lesson1_ex5_comment1": "Set score to 50",
        "cpp_lesson1_ex5_comment2": "Add 10 points",
        "cpp_lesson1_ex5_comment3": "Display result",
        "cpp_lesson1_ex5_slide1_title": "Increasing Values",
        "cpp_lesson1_ex5_slide1_content": "Use += to add to current value and save it.\n\nint x = 10;\nx += 5;  // same as x = x + 5\nstd::cout << x << std::endl;  // => 15",
        "cpp_lesson1_ex5_slide2_title": "-= Works Too",
        "cpp_lesson1_ex5_slide2_content": "Use -= to subtract and save:\n\nint x = 10;\nx -= 3;  // same as x = x - 3\nstd::cout << x << std::endl;  // => 7",

        "cpp_lesson1_ex6_title": "Combine text and variables",
        "cpp_lesson1_ex6_comment1": "Put 10 in age",
        "cpp_lesson1_ex6_comment2": "Display variable in sentence",
        "cpp_lesson1_ex6_slide1_title": "Concatenation",
        "cpp_lesson1_ex6_slide1_content": "Combine text and variables in a single message using << like train cars connecting together.",
        "cpp_lesson1_ex6_slide2_title": "Chain with <<",
        "cpp_lesson1_ex6_slide2_content": "Use multiple << to connect items:\n\nint hour = 15;\nstd::cout << \"It is \" << hour << \" o'clock\" << std::endl;\n=> It is 15 o'clock",

        "cpp_lesson1_ex7_title": "Flexible box 'vector'",
        "cpp_lesson1_ex7_comment1": "Create a vector array",
        "cpp_lesson1_ex7_comment2": "Get 2nd item (index 1)",
        "cpp_lesson1_ex7_slide1_title": "What is a Dynamic Array?",
        "cpp_lesson1_ex7_slide1_content": "A dynamic array can grow or shrink as needed.\n\nLike expandable lockers that can add more compartments when needed!",
        "cpp_lesson1_ex7_slide2_title": "std::vector",
        "cpp_lesson1_ex7_slide2_content": "Specify what goes in < >:\n\n#include <vector>\n\nstd::vector<std::string> items = {\"Apple\", \"Orange\"};\nstd::cout << items[0] << std::endl;  // Apple\n\nRemember: Index starts at 0!",

        "cpp_lesson1_ex8_title": "if statement",
        "cpp_lesson1_ex8_comment1": "Set score to 100",
        "cpp_lesson1_ex8_comment2": "Compare if greater than 80",
        "cpp_lesson1_ex8_comment3": "Display pass message",
        "cpp_lesson1_ex8_slide1_title": "Conditional Logic",
        "cpp_lesson1_ex8_slide1_content": "Make decisions based on conditions.\n\n'If it rains, bring umbrella'\n'If sunny, play outside'\n'If score >= 80, get a reward'",
        "cpp_lesson1_ex8_slide2_title": "Using if",
        "cpp_lesson1_ex8_slide2_content": "if (condition) { do this }\n\nint temp = 30;\nif (temp > 25) {\n    std::cout << \"Hot!\" << std::endl;\n}",

        "cpp_lesson1_ex9_title": "if-else statement",
        "cpp_lesson1_ex9_comment1": "Set age to 10",
        "cpp_lesson1_ex9_comment2": "Check if 20 or older",
        "cpp_lesson1_ex9_comment3": "else for other cases",
        "cpp_lesson1_ex9_slide1_title": "Otherwise?",
        "cpp_lesson1_ex9_slide1_content": "else handles when the condition isn't met.\n\nLike 'If score >= 80, play games. Otherwise, study.'",
        "cpp_lesson1_ex9_slide2_title": "else Block",
        "cpp_lesson1_ex9_slide2_content": "Choose one of two routes:\n\nint age = 15;\nif (age >= 20) {\n    std::cout << \"Adult\" << std::endl;\n} else {\n    std::cout << \"Minor\" << std::endl;\n}",

        "cpp_lesson1_ex10_title": "Logical operators (&&, ||)",
        "cpp_lesson1_ex10_comment1": "Set score to 85",
        "cpp_lesson1_ex10_comment2": "Check both conditions with &&",
        "cpp_lesson1_ex10_slide1_title": "Combining Conditions",
        "cpp_lesson1_ex10_slide1_content": "Combine multiple conditions:\n\n&& (AND): both must be true\n|| (OR): either can be true",
        "cpp_lesson1_ex10_slide2_title": "Using && and ||",
        "cpp_lesson1_ex10_slide2_content": "int age = 15;\nif (age >= 10 && age < 20) {\n    std::cout << \"Teenager\" << std::endl;\n}",

        "cpp_lesson1_ex11_title": "Range-based for loop",
        "cpp_lesson1_ex11_comment1": "Specify array to iterate",
        "cpp_lesson1_ex11_slide1_title": "What are Loops?",
        "cpp_lesson1_ex11_slide1_content": "Loops repeat actions automatically.\n\nLike taking attendance - calling each name one by one.",
        "cpp_lesson1_ex11_slide2_title": "Range-based for",
        "cpp_lesson1_ex11_slide2_content": "for (type var : container)\n\nstd::vector<std::string> fruits = {\"Apple\", \"Banana\"};\nfor (std::string f : fruits) {\n    std::cout << f << std::endl;\n}",

        "cpp_lesson1_ex12_title": "Dictionary 'map'",
        "cpp_lesson1_ex12_comment1": "Specify key name",
        "cpp_lesson1_ex12_comment2": "Retrieve by key",
        "cpp_lesson1_ex12_slide1_title": "What is a Dictionary?",
        "cpp_lesson1_ex12_slide1_content": "A dictionary (map) stores key-value pairs.\n\nLike a phone book - look up a name to get the number!",
        "cpp_lesson1_ex12_slide2_title": "std::map",
        "cpp_lesson1_ex12_slide2_content": "#include <map>\n\nstd::map<std::string, std::string> colors;\ncolors[\"apple\"] = \"red\";\nstd::cout << colors[\"apple\"] << std::endl;  // red",

        "cpp_lesson1_ex13_title": "Create your own function",
        "cpp_lesson1_ex13_comment1": "Call greet function",
        "cpp_lesson1_ex13_slide1_title": "What are Functions?",
        "cpp_lesson1_ex13_slide1_content": "Functions package reusable code with a name.\n\n'Morning routine' = wash face + brush teeth + change clothes. Just say 'do morning routine'!",
        "cpp_lesson1_ex13_slide2_title": "Defining Functions",
        "cpp_lesson1_ex13_slide2_content": "void sayHello() {\n    std::cout << \"Hello!\" << std::endl;\n}\n\nsayHello();  // Outputs: Hello!",

        "cpp_lesson2_ex1_title": "Create a class",
        "cpp_lesson2_ex1_comment1": "Use class to define a class",
        "cpp_lesson2_ex1_comment2": "Define member variable with string",
        "cpp_lesson2_ex1_slide1_title": "What is a Class?",
        "cpp_lesson2_ex1_slide1_content": "A class is a 'blueprint' that bundles data (variables) and functions together.\n\nLike a 'Dog' blueprint with data (name, age) and functions (bark, run).",
        "cpp_lesson2_ex1_slide2_title": "Defining a Class",
        "cpp_lesson2_ex1_slide2_content": "class Dog {\npublic:\n    std::string name;\n};\n\nDog d;\nd.name = \"Pochi\";\n\nUse . to access members.",

        "cpp_lesson2_ex2_title": "Using constructors",
        "cpp_lesson2_ex2_comment1": "Define constructor with class name",
        "cpp_lesson2_ex2_comment2": "Assign value to count",
        "cpp_lesson2_ex2_slide1_title": "What is a Constructor?",
        "cpp_lesson2_ex2_slide1_content": "A constructor is a special function that runs automatically when an object is created.\n\nLike initial setup when you buy a new phone!",
        "cpp_lesson2_ex2_slide2_title": "Constructor Syntax",
        "cpp_lesson2_ex2_slide2_content": "class Box {\npublic:\n    int size;\n    Box(int s) {\n        size = s;\n    }\n};\n\nBox b(10);  // size = 10 automatically!",

        "cpp_lesson2_ex3_title": "Member functions",
        "cpp_lesson2_ex3_comment1": "Multiply with *",
        "cpp_lesson2_ex3_comment2": "Call member function with area()",
        "cpp_lesson2_ex3_slide1_title": "What are Member Functions?",
        "cpp_lesson2_ex3_slide1_content": "Member functions are functions defined inside a class. They can use the class's data.",
        "cpp_lesson2_ex3_slide2_title": "Defining Member Functions",
        "cpp_lesson2_ex3_slide2_content": "class Circle {\npublic:\n    int radius;\n    int area() {\n        return radius * radius * 3;\n    }\n};",

        "cpp_lesson2_ex4_title": "References",
        "cpp_lesson2_ex4_comment1": "Create reference with &",
        "cpp_lesson2_ex4_comment2": "Assign 100 to ref",
        "cpp_lesson2_ex4_slide1_title": "What is a Reference?",
        "cpp_lesson2_ex4_slide1_content": "A reference is an alias (another name) for an existing variable.",
        "cpp_lesson2_ex4_slide2_title": "Using References",
        "cpp_lesson2_ex4_slide2_content": "int x = 10;\nint& ref = x;  // ref is another name for x\nref = 20;      // x is now 20 too!",

        "cpp_lesson2_ex5_title": "Inheritance",
        "cpp_lesson2_ex5_comment1": "Inherit with public",
        "cpp_lesson2_ex5_comment2": "Call inherited move()",
        "cpp_lesson2_ex5_slide1_title": "What is Inheritance?",
        "cpp_lesson2_ex5_slide1_content": "Inheritance lets you create a new class based on an existing one.\n\n'Dog' inherits from 'Animal' - gets eat() and sleep() for free!",
        "cpp_lesson2_ex5_slide2_title": "Inheritance Syntax",
        "cpp_lesson2_ex5_slide2_content": "class Animal {\npublic:\n    void eat() { ... }\n};\n\nclass Dog : public Animal {\n    // eat() is available automatically!\n};",

        "cpp_lesson2_ex6_title": "Virtual functions & override",
        "cpp_lesson2_ex6_comment1": "Define virtual function",
        "cpp_lesson2_ex6_comment2": "Override parent function",
        "cpp_lesson2_ex6_slide1_title": "What is Override?",
        "cpp_lesson2_ex6_slide1_content": "Override lets you replace a parent class's function in the child class. Use virtual in the parent.",
        "cpp_lesson2_ex6_slide2_title": "virtual and override",
        "cpp_lesson2_ex6_slide2_content": "class Animal {\npublic:\n    virtual void speak() { ... }\n};\nclass Cat : public Animal {\npublic:\n    void speak() override { std::cout << \"meow\"; }\n};",

        "cpp_lesson2_ex7_title": "Templates",
        "cpp_lesson2_ex7_comment1": "Define type parameter T",
        "cpp_lesson2_ex7_comment2": "Call bigger function",
        "cpp_lesson2_ex7_slide1_title": "What are Templates?",
        "cpp_lesson2_ex7_slide1_content": "Templates let you write generic code that works with any type.\n\nOne code works for int, double, string, and more!",
        "cpp_lesson2_ex7_slide2_title": "Function Templates",
        "cpp_lesson2_ex7_slide2_content": "template<typename T>\nT add(T a, T b) {\n    return a + b;\n}\n\nadd(1, 2);       // T = int\nadd(1.5, 2.5);   // T = double",

        "cpp_lesson2_ex8_title": "Lambda expressions",
        "cpp_lesson2_ex8_comment1": "Start lambda body with {",
        "cpp_lesson2_ex8_comment2": "Call lambda with square(4)",
        "cpp_lesson2_ex8_slide1_title": "What are Lambdas?",
        "cpp_lesson2_ex8_slide1_content": "Lambda expressions create anonymous functions on the spot.\n\nPerfect for short, one-time-use functions!",
        "cpp_lesson2_ex8_slide2_title": "Lambda Syntax",
        "cpp_lesson2_ex8_slide2_content": "auto add = [](int a, int b) {\n    return a + b;\n};\n\nstd::cout << add(2, 3) << std::endl; // 5",

        "cpp_lesson2_ex9_title": "Smart pointer unique_ptr",
        "cpp_lesson2_ex9_comment1": "Create smart pointer with make_unique",
        "cpp_lesson2_ex9_comment2": "Access contents with *ptr",
        "cpp_lesson2_ex9_slide1_title": "What are Smart Pointers?",
        "cpp_lesson2_ex9_slide1_content": "Smart pointers automatically free memory when done.\n\nLike an auto-return library book system - no memory leaks!",
        "cpp_lesson2_ex9_slide2_title": "Using unique_ptr",
        "cpp_lesson2_ex9_slide2_content": "#include <memory>\n\nauto p = std::make_unique<int>(42);\nstd::cout << *p << std::endl; // 42\n// Memory freed automatically!",

        "cpp_lesson2_ex10_title": "Exception handling try-catch",
        "cpp_lesson2_ex10_comment1": "Throw exception with throw",
        "cpp_lesson2_ex10_comment2": "Catch exception with catch",
        "cpp_lesson2_ex10_slide1_title": "What is Exception Handling?",
        "cpp_lesson2_ex10_slide1_content": "Exception handling lets you deal with errors gracefully.\n\nLike a safety net in a circus - catch errors before they crash!",
        "cpp_lesson2_ex10_slide2_title": "try-catch Syntax",
        "cpp_lesson2_ex10_slide2_content": "try {\n    throw \"error!\";\n} catch (const char* e) {\n    std::cout << e << std::endl;\n}",

        "cpp_lesson3_ex1_title": "Type inference with auto",
        "cpp_lesson3_ex1_comment1": "Let compiler infer type",
        "cpp_lesson3_ex1_slide1_title": "What is auto?",
        "cpp_lesson3_ex1_slide1_content": "auto lets the compiler automatically determine the type.\n\nauto x = 42;        // int\nauto pi = 3.14;     // double\nauto name = \"Alice\"; // const char*",
        "cpp_lesson3_ex1_slide2_title": "Convenient with Iterators",
        "cpp_lesson3_ex1_slide2_content": "auto is especially useful for long type names:\n\n// Without auto: std::vector<int>::iterator it = v.begin();\n// With auto:\nauto it = v.begin();  // Much cleaner!",

        "cpp_lesson3_ex2_title": "Range-based for loop",
        "cpp_lesson3_ex2_comment1": "Create vector array",
        "cpp_lesson3_ex2_comment2": "Use : for range-based for",
        "cpp_lesson3_ex2_slide1_title": "Range-based for Loop",
        "cpp_lesson3_ex2_slide1_content": "C++11's range-based for makes iterating easy.\n\nvector<int> v = {1, 2, 3};\nfor (int x : v) {\n    cout << x << endl;\n}",
        "cpp_lesson3_ex2_slide2_title": "Receiving by Reference",
        "cpp_lesson3_ex2_slide2_content": "Avoid copying large objects:\n\nfor (const auto& x : v) {\n    // No copy, just reference\n    cout << x << endl;\n}",

        "cpp_lesson3_ex3_title": "nullptr",
        "cpp_lesson3_ex3_comment1": "Set null pointer with nullptr",
        "cpp_lesson3_ex3_comment2": "Compare with nullptr",
        "cpp_lesson3_ex3_slide1_title": "What is nullptr?",
        "cpp_lesson3_ex3_slide1_content": "nullptr is a type-safe null pointer.\n\nint* p = nullptr;\nif (p == nullptr) {\n    cout << \"null\" << endl;\n}",
        "cpp_lesson3_ex3_slide2_title": "Why nullptr over NULL?",
        "cpp_lesson3_ex3_slide2_content": "NULL is actually 0, which can be ambiguous:\n\nvoid f(int);    // takes int\nvoid f(int*);   // takes pointer\n\nf(NULL);    // Ambiguous!\nf(nullptr); // Clearly f(int*)",

        "cpp_lesson3_ex4_title": "constexpr",
        "cpp_lesson3_ex4_comment1": "Define compile-time constant",
        "cpp_lesson3_ex4_slide1_title": "What is constexpr?",
        "cpp_lesson3_ex4_slide1_content": "constexpr means 'computable at compile time'.\n\nconstexpr int square(int x) {\n    return x * x;\n}\nconstexpr int val = square(5); // Computed at compile time!",
        "cpp_lesson3_ex4_slide2_title": "const vs constexpr",
        "cpp_lesson3_ex4_slide2_content": "const: value won't change after initialization\nconstexpr: value is known at compile time\n\nconst int a = getValue();     // OK at runtime\nconstexpr int b = 10 * 10;    // Must be compile-time",

        "cpp_lesson3_ex5_title": "Initializer lists",
        "cpp_lesson3_ex5_comment1": "Initialize with {",
        "cpp_lesson3_ex5_comment2": "Range-based for with :",
        "cpp_lesson3_ex5_slide1_title": "What are Initializer Lists?",
        "cpp_lesson3_ex5_slide1_content": "Use {} for uniform initialization:\n\nvector<int> v = {1, 2, 3};\nmap<string, int> m = {{\"apple\", 100}, {\"banana\", 80}};",
        "cpp_lesson3_ex5_slide2_title": "Prevents Narrowing",
        "cpp_lesson3_ex5_slide2_content": "{} prevents data loss:\n\nint x = 3.14;   // OK (becomes 3)\nint z{3.14};    // Error! Narrowing conversion",

        "cpp_lesson3_ex6_title": "shared_ptr",
        "cpp_lesson3_ex6_comment1": "Create shared pointer with make_shared",
        "cpp_lesson3_ex6_comment2": "Access contents with *p",
        "cpp_lesson3_ex6_slide1_title": "What is shared_ptr?",
        "cpp_lesson3_ex6_slide1_content": "shared_ptr allows multiple pointers to share ownership.\n\nauto p1 = make_shared<int>(42);\nauto p2 = p1;  // Both own the data\n// Freed when last owner is gone",
        "cpp_lesson3_ex6_slide2_title": "Using make_shared",
        "cpp_lesson3_ex6_slide2_content": "auto p = make_shared<int>(100);\n// More efficient than: shared_ptr<int> p(new int(100));",

        "cpp_lesson3_ex7_title": "std::move",
        "cpp_lesson3_ex7_comment1": "Create string variable",
        "cpp_lesson3_ex7_comment2": "Move ownership",
        "cpp_lesson3_ex7_slide1_title": "What is move?",
        "cpp_lesson3_ex7_slide1_content": "std::move transfers ownership instead of copying.\n\nstring s1 = \"Hello\";\nstring s2 = move(s1);  // s1 is now empty\n// s2 has \"Hello\"",
        "cpp_lesson3_ex7_slide2_title": "More Efficient than Copying",
        "cpp_lesson3_ex7_slide2_content": "For large data, move is much faster:\n\nvector<int> v1(1000000);\nvector<int> v2 = move(v1);  // Just moves pointer, not data!",

        "cpp_lesson3_ex8_title": "std::optional",
        "cpp_lesson3_ex8_comment1": "Hold value with optional",
        "cpp_lesson3_ex8_comment2": "Check value with has_value",
        "cpp_lesson3_ex8_slide1_title": "What is optional?",
        "cpp_lesson3_ex8_slide1_content": "optional represents 'value that might not exist'.\n\noptional<int> find(vector<int>& v, int x) {\n    for (int n : v) if (n == x) return n;\n    return nullopt;  // Not found\n}",
        "cpp_lesson3_ex8_slide2_title": "Getting the Value",
        "cpp_lesson3_ex8_slide2_content": "Check before accessing:\n\nif (result.has_value()) {\n    cout << result.value() << endl;\n}\n// Or: if (result) cout << *result;",

        "cpp_lesson3_ex9_title": "std::array",
        "cpp_lesson3_ex9_comment1": "Define fixed-size array",
        "cpp_lesson3_ex9_comment2": "Range-based for with :",
        "cpp_lesson3_ex9_slide1_title": "What is std::array?",
        "cpp_lesson3_ex9_slide1_content": "std::array is a safer fixed-size array.\n\narray<int, 5> arr = {1, 2, 3, 4, 5};\ncout << arr.size() << endl;  // 5",
        "cpp_lesson3_ex9_slide2_title": "Safer than C Arrays",
        "cpp_lesson3_ex9_slide2_content": "array<int, 3> arr = {10, 20, 30};\n\narr.at(1);   // OK: 20\narr.at(10);  // Error! Out of range\narr[10];     // Undefined behavior (dangerous)",

        "cpp_lesson3_ex10_title": "Lambda captures",
        "cpp_lesson3_ex10_comment1": "Declare int variable",
        "cpp_lesson3_ex10_comment2": "Capture x by copy",
        "cpp_lesson3_ex10_slide1_title": "What is Capture?",
        "cpp_lesson3_ex10_slide1_content": "Capture lets lambdas use external variables.\n\nint x = 10;\nauto f = [x]() { return x * 2; };  // Capture by copy\nauto g = [&x]() { x++; };           // Capture by reference",
        "cpp_lesson3_ex10_slide2_title": "Capture Types",
        "cpp_lesson3_ex10_slide2_content": "[x]      // Capture x by copy\n[&x]     // Capture x by reference\n[=]      // Capture all by copy\n[&]      // Capture all by reference\n[=, &x]  // All by copy, x by reference",

        "cpp_lesson4_ex1_title": "unique_ptr",
        "cpp_lesson4_ex1_comment1": "Create exclusive pointer with make_unique",
        "cpp_lesson4_ex1_comment2": "Access contents with *p",
        "cpp_lesson4_ex1_slide1_title": "What is unique_ptr?",
        "cpp_lesson4_ex1_slide1_content": "unique_ptr is an exclusive ownership smart pointer.\n\nLike a movie ticket - only one person can hold it!\n\nauto p = make_unique<int>(42);\ncout << *p << endl; // 42",
        "cpp_lesson4_ex1_slide2_title": "No Copy, Only Move",
        "cpp_lesson4_ex1_slide2_content": "unique_ptr cannot be copied, only moved:\n\nauto p1 = make_unique<int>(10);\n// auto p2 = p1;           // Error! Can't copy\nauto p2 = move(p1);         // OK! p1 is now empty",

        "cpp_lesson4_ex2_title": "std::variant",
        "cpp_lesson4_ex2_comment1": "Hold one of multiple types",
        "cpp_lesson4_ex2_comment2": "Get value with get<type>",
        "cpp_lesson4_ex2_slide1_title": "What is variant?",
        "cpp_lesson4_ex2_slide1_content": "variant safely holds one of several types.\n\nvariant<int, string> v;\nv = 42;        // Now holds int\nv = \"hello\";   // Now holds string",
        "cpp_lesson4_ex2_slide2_title": "Getting the Value",
        "cpp_lesson4_ex2_slide2_content": "Check type before accessing:\n\nif (holds_alternative<int>(v)) {\n    cout << get<int>(v) << endl;\n}",

        "cpp_lesson4_ex3_title": "Structured bindings",
        "cpp_lesson4_ex3_comment1": "Bundle values with tuple",
        "cpp_lesson4_ex3_comment2": "Destructure with auto",
        "cpp_lesson4_ex3_slide1_title": "What are Structured Bindings?",
        "cpp_lesson4_ex3_slide1_content": "Unpack multiple values at once:\n\npair<int, string> p = {1, \"hello\"};\nauto [num, str] = p;\n// num = 1, str = \"hello\"",
        "cpp_lesson4_ex3_slide2_title": "With Maps",
        "cpp_lesson4_ex3_slide2_content": "Great for iterating maps:\n\nfor (auto [key, value] : m) {\n    cout << key << \": \" << value << endl;\n}",

        "cpp_lesson4_ex4_title": "std::string_view",
        "cpp_lesson4_ex4_comment1": "Receive string view parameter",
        "cpp_lesson4_ex4_comment2": "Call greet function",
        "cpp_lesson4_ex4_slide1_title": "What is string_view?",
        "cpp_lesson4_ex4_slide1_content": "string_view is a lightweight view into a string without copying.\n\nvoid print(string_view sv) {\n    cout << sv << endl;\n}\nprint(\"hello\");  // No copy!",
        "cpp_lesson4_ex4_slide2_title": "Benefits",
        "cpp_lesson4_ex4_slide2_content": "Works with any string type, no copying:\n\nvoid f(string_view sv);  // Recommended!\n\nf(s);        // string\nf(\"hello\");  // literal\nf(cstr);     // const char*",

        "cpp_lesson4_ex5_title": "std::transform",
        "cpp_lesson4_ex5_comment1": "Create vector array",
        "cpp_lesson4_ex5_comment2": "Transform each element",
        "cpp_lesson4_ex5_slide1_title": "What is transform?",
        "cpp_lesson4_ex5_slide1_content": "transform applies a function to each element:\n\nvector<int> in = {1, 2, 3};\nvector<int> out(3);\ntransform(in.begin(), in.end(), out.begin(),\n          [](int x) { return x * 2; });\n// out = {2, 4, 6}",
        "cpp_lesson4_ex5_slide2_title": "Example",
        "cpp_lesson4_ex5_slide2_content": "Convert string to uppercase:\n\nstring s = \"hello\";\ntransform(s.begin(), s.end(), s.begin(), ::toupper);\n// s = \"HELLO\"",

        "cpp_lesson4_ex6_title": "std::accumulate",
        "cpp_lesson4_ex6_comment1": "Create vector array",
        "cpp_lesson4_ex6_comment2": "Aggregate elements",
        "cpp_lesson4_ex6_slide1_title": "What is accumulate?",
        "cpp_lesson4_ex6_slide1_content": "accumulate combines all elements into one value:\n\nvector<int> v = {1, 2, 3, 4, 5};\nint sum = accumulate(v.begin(), v.end(), 0);\n// 0 + 1 + 2 + 3 + 4 + 5 = 15",
        "cpp_lesson4_ex6_slide2_title": "Custom Operations",
        "cpp_lesson4_ex6_slide2_content": "Use custom function for other operations:\n\nint product = accumulate(v.begin(), v.end(), 1,\n    [](int a, int b) { return a * b; });\n// 1 * 1 * 2 * 3 * 4 * 5 = 120",

        "cpp_lesson4_ex7_title": "std::find_if",
        "cpp_lesson4_ex7_comment1": "Create vector array",
        "cpp_lesson4_ex7_comment2": "Find element matching condition",
        "cpp_lesson4_ex7_slide1_title": "What is find_if?",
        "cpp_lesson4_ex7_slide1_content": "find_if finds the first element matching a condition:\n\nvector<int> v = {1, 3, 5, 6, 7};\nauto it = find_if(v.begin(), v.end(),\n    [](int x) { return x % 2 == 0; });\ncout << *it << endl;  // 6",
        "cpp_lesson4_ex7_slide2_title": "When Not Found",
        "cpp_lesson4_ex7_slide2_content": "Returns end() if not found:\n\nif (it != v.end()) {\n    cout << \"Found: \" << *it << endl;\n} else {\n    cout << \"Not found\" << endl;\n}",

        "cpp_lesson4_ex8_title": "std::sort with lambda",
        "cpp_lesson4_ex8_comment1": "Create vector array",
        "cpp_lesson4_ex8_comment2": "Sort with custom order",
        "cpp_lesson4_ex8_slide1_title": "Custom Sorting",
        "cpp_lesson4_ex8_slide1_content": "Pass a lambda to sort for custom order:\n\nvector<int> v = {3, 1, 4, 1, 5};\nsort(v.begin(), v.end(), [](int a, int b) {\n    return a > b;  // Descending\n});\n// {5, 4, 3, 1, 1}",
        "cpp_lesson4_ex8_slide2_title": "Sorting Objects",
        "cpp_lesson4_ex8_slide2_content": "Sort custom objects by any field:\n\nsort(people.begin(), people.end(),\n    [](const Person& a, const Person& b) {\n        return a.age < b.age;\n    });",

        "cpp_lesson4_ex9_title": "try-catch exception handling",
        "cpp_lesson4_ex9_comment1": "Throw exception",
        "cpp_lesson4_ex9_comment2": "Catch exception",
        "cpp_lesson4_ex9_slide1_title": "Exception Handling",
        "cpp_lesson4_ex9_slide1_content": "try-catch safely handles errors:\n\ntry {\n    throw runtime_error(\"Error!\");\n} catch (const exception& e) {\n    cout << e.what() << endl;\n}",
        "cpp_lesson4_ex9_slide2_title": "Standard Exceptions",
        "cpp_lesson4_ex9_slide2_content": "Common exception types:\n\nruntime_error     // Runtime error\nlogic_error       // Logic error\nout_of_range      // Index out of bounds\ninvalid_argument  // Invalid argument",

        "cpp_lesson4_ex10_title": "noexcept specifier",
        "cpp_lesson4_ex10_comment1": "Declare no exceptions with noexcept",
        "cpp_lesson4_ex10_comment2": "Add with +",
        "cpp_lesson4_ex10_slide1_title": "What is noexcept?",
        "cpp_lesson4_ex10_slide1_content": "noexcept promises a function won't throw exceptions.\n\nvoid safe() noexcept {\n    int x = 1 + 1;  // No exceptions possible\n}",
        "cpp_lesson4_ex10_slide2_title": "Benefits",
        "cpp_lesson4_ex10_slide2_content": "noexcept enables optimizations:\n\nint add(int a, int b) noexcept {\n    return a + b;\n}\n// Compiler can optimize away exception handling code"
    },
    "ja": {
        "cpp_lesson1_course_title": "C++ (シープラスプラス) に挑戦！",
        "cpp_lesson1_course_description": "C言語をもっとパワーアップさせた「C++（シープラスプラス）」のきほんを学びましょう。いろいろな機能を使って、自由にプログラムを作れるようになります。",
        "cpp_lesson1_title": "C++ I - はじめてのC++",
        "cpp_lesson2_course_title": "C++ II - クラスとオブジェクト指向",
        "cpp_lesson2_course_description": "C++の真髄「クラス」を使ったオブジェクト指向プログラミングを学びます。継承、テンプレート、スマートポインタなど現代C++の機能を身につけましょう。",
        "cpp_lesson2_title": "C++ II - クラスとオブジェクト指向",
        "cpp_lesson3_course_title": "C++ III - モダンC++",
        "cpp_lesson3_course_description": "モダンC++の機能を学びます。スマートポインタ、ムーブセマンティクス、STLアルゴリズムなどを身につけましょう。",
        "cpp_lesson3_title": "C++ III - モダンC++",
        "cpp_lesson4_course_title": "C++ IV - STLアルゴリズムと高度な機能",
        "cpp_lesson4_course_description": "STLアルゴリズムとC++17以降の機能を学びます。効率的で表現力豊かなコードを書くスキルを身につけましょう。",
        "cpp_lesson4_title": "C++ IV - STLアルゴリズムと高度な機能",

        "cpp_lesson1_ex1_title": "画面にメッセージを出しましょう",
        "cpp_lesson1_ex1_comment1": "入出力の機能を使えるように準備します",
        "cpp_lesson1_ex1_comment2": "std::cout と << を使って、文字を画面に出します",
        "cpp_lesson1_ex1_slide1_title": "C++（シープラスプラス）とは？",
        "cpp_lesson1_ex1_slide1_content": "C++（シープラスプラス）は、C言語を元にしてさらに便利な機能を追加した言語です。\n\nC言語が「普通の車」だとしたら、C++は「スーパーカー」のような存在です！速さはそのままに、もっと便利な機能がついています。\n\nゲーム、ブラウザ（ChromeやFirefoxなど）、3DCGソフトなど、スピードが求められる場所で大活躍しています。",
        "cpp_lesson1_ex1_slide2_title": "C++への入り口",
        "cpp_lesson1_ex1_slide2_content": "C++で画面に文字を出すには、std::cout（スタンダード・シーアウト）を使います。\ncout は「Character OUTput」（文字を出力）の略です。\n\n<< という矢印のような記号を使って、文字を画面の方へ送ります。\n\n#include <iostream>\nint main() {\n    std::cout << \"C++最高！\" << std::endl;\n    return 0;\n}\n\nstd::endl（エンドエル）は改行して次の行に進みます。",

        "cpp_lesson1_ex2_title": "数字を入れる「はこ」",
        "cpp_lesson1_ex2_comment1": "int（数字）ラベルのはこを作る",
        "cpp_lesson1_ex2_comment2": "中身を表示する",
        "cpp_lesson1_ex2_slide1_title": "変数（へんすう）とは？",
        "cpp_lesson1_ex2_slide1_content": "プログラムの中で数字や文字に名前をつけて、あとで使いやすくするための仕組みが変数（へんすう）です。\n\nおもちゃ箱に「レゴ入れ」「ぬいぐるみ入れ」とラベルを貼るように、プログラムでも「はこ」に名前をつけてデータをしまっておきます。",
        "cpp_lesson1_ex2_slide2_title": "数字のラベル int",
        "cpp_lesson1_ex2_slide2_content": "数字（1, 2, 3 のような整数）を入れたいときは、int（イント）というラベルを貼ります。\n\nint age = 20;\nstd::cout << age << std::endl;\n=> 20 と表示されます\n\nC言語では printf(\"%d\", age) と書いていましたが、C++では std::cout << age とシンプルに書けます！",

        "cpp_lesson1_ex3_title": "コンピュータで計算しましょう",
        "cpp_lesson1_ex3_comment1": "はこに数字を入れる",
        "cpp_lesson1_ex3_comment2": "たし算した結果を表示する",
        "cpp_lesson1_ex3_slide1_title": "計算はコンピュータにお任せ",
        "cpp_lesson1_ex3_slide1_content": "コンピュータは人間よりもずっと速く計算できます。\nどんなに大きな数字でも、プログラミングで指示を出せば一瞬で解いてくれます。",
        "cpp_lesson1_ex3_slide2_title": "計算の記号",
        "cpp_lesson1_ex3_slide2_content": "<< で繋ぐことで、計算した結果をそのまま画面に出すことができます。\n\nint cookies = 10;\nint friends = 2;\nstd::cout << cookies / friends << std::endl;\n=> 5",

        "cpp_lesson1_ex4_title": "剰余演算子（%）",
        "cpp_lesson1_ex4_comment1": "10 を 3 で割ったあまりを出力する",
        "cpp_lesson1_ex4_slide1_title": "あまりを求める",
        "cpp_lesson1_ex4_slide1_content": "割り算をしたときに、割り切れなくて「あまり」が出ることがありますよね。\n% という記号を使うと、そのあまりだけを計算してくれます。",
        "cpp_lesson1_ex4_slide2_title": "% の使い方",
        "cpp_lesson1_ex4_slide2_content": "std::cout << 10 % 3 << std::endl;  // => 1\n10 ÷ 3 は 3 あまり 1 なので、「1」が表示されます。\n\nstd::cout << 8 % 2 << std::endl;   // => 0\n割り切れるということです！",

        "cpp_lesson1_ex5_title": "累算代入演算子（+=、-=）",
        "cpp_lesson1_ex5_comment1": "scoreに50を入れる",
        "cpp_lesson1_ex5_comment2": "10点プラスする",
        "cpp_lesson1_ex5_comment3": "結果を表示",
        "cpp_lesson1_ex5_slide1_title": "中身を増やしたいとき",
        "cpp_lesson1_ex5_slide1_content": "「今の点数に10点プラスしたい！」というとき、+= を使うと便利です。\n\nint x = 10;\nx += 5;  // x = x + 5 と同じ意味\nstd::cout << x << std::endl;  // => 15",
        "cpp_lesson1_ex5_slide2_title": "-= も使える",
        "cpp_lesson1_ex5_slide2_content": "-= を使えば、「今の数字から引いて保存」ができます。\n\nint x = 10;\nx -= 3;  // x = x - 3 と同じ意味\nstd::cout << x << std::endl;  // => 7",

        "cpp_lesson1_ex6_title": "文字と「はこ」を並べましょう",
        "cpp_lesson1_ex6_comment1": "ageに10を入れる",
        "cpp_lesson1_ex6_comment2": "文字とはこを並べて表示する",
        "cpp_lesson1_ex6_slide1_title": "連結（れんけつ）とは？",
        "cpp_lesson1_ex6_slide1_content": "文章の途中に、変数（はこ）の中身を流し込んで一つのメッセージにすることを連結と呼びます。\nC++では << を使って、電車のように情報を連結して画面へ送ります。",
        "cpp_lesson1_ex6_slide2_title": "<< でつなげましょう",
        "cpp_lesson1_ex6_slide2_content": "<< を何回も使うことで、文字やはこの中身をどんどん繋げることができます。\n\nint hour = 15;\nstd::cout << \"今は \" << hour << \" 時です\" << std::endl;\n=> 今は 15 時です",

        "cpp_lesson1_ex7_title": "自由に伸びる「はこ」vector",
        "cpp_lesson1_ex7_comment1": "くだものの配列（vector）を作る",
        "cpp_lesson1_ex7_comment2": "2番目のデータを表示する",
        "cpp_lesson1_ex7_slide1_title": "動的配列（どうてきはいれつ）とは？",
        "cpp_lesson1_ex7_slide1_content": "あとから中身を増やしたり減らしたりできる「はこ」の列を動的配列（どうてきはいれつ）と呼びます。\n\n普通の配列は「決まった数のロッカー」ですが、vector は「必要に応じて増やせるロッカー」のようなものです。",
        "cpp_lesson1_ex7_slide2_title": "std::vector",
        "cpp_lesson1_ex7_slide2_content": "< > の中に「何を入れるか」を指定します。\n\n#include <vector>\n\nstd::vector<std::string> items = {\"Apple\", \"Orange\"};\nstd::cout << items[0] << std::endl;  // Apple\n\n番号は0から始まります！",

        "cpp_lesson1_ex8_title": "「もし〜なら」で分けましょう",
        "cpp_lesson1_ex8_comment1": "scoreに100を入れる",
        "cpp_lesson1_ex8_comment2": "> で「より大きい」を比較",
        "cpp_lesson1_ex8_comment3": "メッセージを表示",
        "cpp_lesson1_ex8_slide1_title": "条件分岐（じょうけんぶんき）とは？",
        "cpp_lesson1_ex8_slide1_content": "「雨が降ったら傘をさす」「晴れたら外で遊ぶ」\nこんなふうに、状況によって動きを変えることを条件分岐（じょうけんぶんき）と呼びます。",
        "cpp_lesson1_ex8_slide2_title": "if文",
        "cpp_lesson1_ex8_slide2_content": "if (条件) のあとに { } を入力して、その中にやりたいことを入力します。\n\nint temp = 30;\nif (temp > 25) {\n    std::cout << \"暑いですね\" << std::endl;\n}",

        "cpp_lesson1_ex9_title": "ちがう場合はどうしましょう？",
        "cpp_lesson1_ex9_comment1": "ageに10を入れる",
        "cpp_lesson1_ex9_comment2": "20さい以上かどうかで分ける",
        "cpp_lesson1_ex9_comment3": "それ以外の場合",
        "cpp_lesson1_ex9_slide1_title": "それ以外の場合は？",
        "cpp_lesson1_ex9_slide1_content": "条件に当てはまらなかったときの別のルートを作るのが else（エルス）です。",
        "cpp_lesson1_ex9_slide2_title": "elseブロック",
        "cpp_lesson1_ex9_slide2_content": "条件に当てはまらないときの動きは else を使って入力します。\n\nint age = 15;\nif (age >= 20) {\n    std::cout << \"大人\" << std::endl;\n} else {\n    std::cout << \"子供\" << std::endl;\n}",

        "cpp_lesson1_ex10_title": "論理演算子（&&、||）",
        "cpp_lesson1_ex10_comment1": "scoreに85を入れる",
        "cpp_lesson1_ex10_comment2": "両方の条件を満たすので && を使います",
        "cpp_lesson1_ex10_slide1_title": "条件を組み合わせる",
        "cpp_lesson1_ex10_slide1_content": "2つの条件を両方クリアしているかチェックしたいときは && （アンド）を使います。\n逆に「どちらか片方でもOK」なら || （オア）を使います。",
        "cpp_lesson1_ex10_slide2_title": "&& と || の使い方",
        "cpp_lesson1_ex10_slide2_content": "int age = 15;\nif (age >= 10 && age < 20) {\n    std::cout << \"10代です\" << std::endl;\n}",

        "cpp_lesson1_ex11_title": "中身を全部出してみましょう",
        "cpp_lesson1_ex11_comment1": "取り出ししたい対象の配列を指定します",
        "cpp_lesson1_ex11_slide1_title": "繰り返し（ループ）とは？",
        "cpp_lesson1_ex11_slide1_content": "同じ作業を何度も繰り返すための仕組みがループ（繰り返し）です。\n\n出席をとるとき、一人ずつ名前を呼びますよね。ループはこの「順番に全員をチェック」する作業を自動でやってくれます。",
        "cpp_lesson1_ex11_slide2_title": "範囲for文",
        "cpp_lesson1_ex11_slide2_content": "C++には範囲for文（はんいフォーぶん）という便利なループがあります。\n\nstd::vector<std::string> fruits = {\"Apple\", \"Banana\"};\nfor (std::string f : fruits) {\n    std::cout << f << std::endl;\n}",

        "cpp_lesson1_ex12_title": "名前で探しましょう「じしょ」",
        "cpp_lesson1_ex12_comment1": "名前（キー）として登録します",
        "cpp_lesson1_ex12_comment2": "同じキー名でデータを取り出します",
        "cpp_lesson1_ex12_slide1_title": "辞書（じしょ）とは？",
        "cpp_lesson1_ex12_slide1_content": "「名前」と「データ」をセットにして保存できるのが辞書（map＝マップ）です。\n\n国語辞典を想像してください。「りんご」という言葉を調べると、その意味が出てきますよね。",
        "cpp_lesson1_ex12_slide2_title": "std::map",
        "cpp_lesson1_ex12_slide2_content": "#include <map>\n\nstd::map<std::string, std::string> colors;\ncolors[\"りんご\"] = \"あか\";\nstd::cout << colors[\"りんご\"] << std::endl;  // あか",

        "cpp_lesson1_ex13_title": "自分だけの関数を作りましょう",
        "cpp_lesson1_ex13_comment1": "greet(); と入力して、関数を実行します",
        "cpp_lesson1_ex13_slide1_title": "関数（かんすう）とは？",
        "cpp_lesson1_ex13_slide1_content": "何度も使う手順をまとめて名前をつけたものを関数（かんすう）と呼びます。\n\n「朝の準備」という言葉を聞くと、「起きる→顔を洗う→着替える→ご飯を食べる」という一連の動作を思い浮かべますよね。",
        "cpp_lesson1_ex13_slide2_title": "手順をまとめる",
        "cpp_lesson1_ex13_slide2_content": "void sayHello() {\n    std::cout << \"ハロー！\" << std::endl;\n}\n\nsayHello();  // これで「ハロー！」と表示される",

        "cpp_lesson2_ex1_title": "クラスを作ろう",
        "cpp_lesson2_ex1_comment1": "class を使ってクラスを定義します",
        "cpp_lesson2_ex1_comment2": "メンバ変数を定義します",
        "cpp_lesson2_ex1_slide1_title": "クラスとは？",
        "cpp_lesson2_ex1_slide1_content": "クラスは、データ（変数）と機能（関数）をひとまとめにした「設計図」です。\n\n「犬」の設計図を考えてみましょう。\n- データ: 名前、年齢、毛の色\n- 機能: 吠（ほ）える、走る、食べる",
        "cpp_lesson2_ex1_slide2_title": "クラスの定義",
        "cpp_lesson2_ex1_slide2_content": "class Dog {\npublic:\n    std::string name;\n};\n\nDog d;\nd.name = \"Pochi\";\n\nドット「.」を使って中のデータにアクセスします。",

        "cpp_lesson2_ex2_title": "コンストラクタを使おう",
        "cpp_lesson2_ex2_comment1": "コンストラクタはクラス名と同じ名前です",
        "cpp_lesson2_ex2_comment2": "引数で受け取った値を設定します",
        "cpp_lesson2_ex2_slide1_title": "コンストラクタとは？",
        "cpp_lesson2_ex2_slide1_content": "コンストラクタは、オブジェクトを作るときに自動的に呼ばれる特別な関数です。\n\n新しいスマホを買ったとき、最初に「言語設定」「名前登録」などの初期設定をしますよね。それと同じです！",
        "cpp_lesson2_ex2_slide2_title": "コンストラクタの書き方",
        "cpp_lesson2_ex2_slide2_content": "class Box {\npublic:\n    int size;\n    Box(int s) {\n        size = s;\n    }\n};\n\nBox b(10);  // size = 10 で初期化！",

        "cpp_lesson2_ex3_title": "メンバ関数を作ろう",
        "cpp_lesson2_ex3_comment1": "* を使って掛け算します",
        "cpp_lesson2_ex3_comment2": "r.area() でメンバ関数を呼びます",
        "cpp_lesson2_ex3_slide1_title": "メンバ関数とは？",
        "cpp_lesson2_ex3_slide1_content": "メンバ関数は、クラスの中で定義される関数です。そのクラスのデータを使った処理ができます。",
        "cpp_lesson2_ex3_slide2_title": "メンバ関数の定義",
        "cpp_lesson2_ex3_slide2_content": "class Circle {\npublic:\n    int radius;\n    int area() {\n        return radius * radius * 3;\n    }\n};",

        "cpp_lesson2_ex4_title": "参照を使おう",
        "cpp_lesson2_ex4_comment1": "& を使って参照を作ります",
        "cpp_lesson2_ex4_comment2": "ref を変えると num も変わります",
        "cpp_lesson2_ex4_slide1_title": "参照とは？",
        "cpp_lesson2_ex4_slide1_content": "参照は、既存の変数に別の名前をつける機能です。参照を通じて元の変数を操作できます。",
        "cpp_lesson2_ex4_slide2_title": "参照の使い方",
        "cpp_lesson2_ex4_slide2_content": "int x = 10;\nint& ref = x;  // ref は x の別名\nref = 20;      // x も 20 になる",

        "cpp_lesson2_ex5_title": "継承を学ぼう",
        "cpp_lesson2_ex5_comment1": "public を使って継承します",
        "cpp_lesson2_ex5_comment2": "Car は move() を使えます",
        "cpp_lesson2_ex5_slide1_title": "継承（けいしょう）とは？",
        "cpp_lesson2_ex5_slide1_content": "継承（けいしょう）を使うと、既存のクラス（親クラス）の機能を引き継いだ新しいクラス（子クラス）を作れます。\n\n「犬」は「動物」の子クラスです。動物なので「食べる」「寝る」ができ、さらに「吠える」という独自の機能を追加できます。",
        "cpp_lesson2_ex5_slide2_title": "継承の書き方",
        "cpp_lesson2_ex5_slide2_content": "class Animal {\npublic:\n    void eat() { ... }\n};\n\nclass Dog : public Animal {\n    // eat() は自動的に使える！\n};",

        "cpp_lesson2_ex6_title": "仮想関数でオーバーライド",
        "cpp_lesson2_ex6_comment1": "virtual をつけて仮想関数にします",
        "cpp_lesson2_ex6_comment2": "override で上書きします",
        "cpp_lesson2_ex6_slide1_title": "オーバーライドとは？",
        "cpp_lesson2_ex6_slide1_content": "オーバーライドは、親クラスで定義された関数を子クラスで書き換える機能です。virtual キーワードを使います。",
        "cpp_lesson2_ex6_slide2_title": "virtual と override",
        "cpp_lesson2_ex6_slide2_content": "class Animal {\npublic:\n    virtual void speak() { ... }\n};\nclass Cat : public Animal {\npublic:\n    void speak() override { std::cout << \"meow\"; }\n};",

        "cpp_lesson2_ex7_title": "テンプレートを使おう",
        "cpp_lesson2_ex7_comment1": "T を型パラメータとして定義します",
        "cpp_lesson2_ex7_comment2": "int型で呼び出されます",
        "cpp_lesson2_ex7_slide1_title": "テンプレートとは？",
        "cpp_lesson2_ex7_slide1_content": "テンプレートを使うと、どんな型（かた）でも使える汎用的な関数やクラスが作れます。\n\n1つのコードで、int でも double でも使える！これがテンプレートの力です。",
        "cpp_lesson2_ex7_slide2_title": "関数テンプレート",
        "cpp_lesson2_ex7_slide2_content": "template<typename T>\nT add(T a, T b) {\n    return a + b;\n}\n\nadd(1, 2);       // T = int\nadd(1.5, 2.5);   // T = double",

        "cpp_lesson2_ex8_title": "ラムダ式を使おう",
        "cpp_lesson2_ex8_comment1": "{ でラムダ式の本体を始めます",
        "cpp_lesson2_ex8_comment2": "square(4) で 16 が出力されます",
        "cpp_lesson2_ex8_slide1_title": "ラムダ式とは？",
        "cpp_lesson2_ex8_slide1_content": "ラムダ式（しき）は、名前をつけずにその場で関数を作る方法です。\n\n普通の関数は「料理のレシピに名前をつけて保存」、ラムダ式は「その場でちょっと作るメモ書きレシピ」のようなものです。",
        "cpp_lesson2_ex8_slide2_title": "ラムダ式の書き方",
        "cpp_lesson2_ex8_slide2_content": "auto add = [](int a, int b) {\n    return a + b;\n};\n\nstd::cout << add(2, 3) << std::endl; // 5",

        "cpp_lesson2_ex9_title": "スマートポインタ unique_ptr",
        "cpp_lesson2_ex9_comment1": "make_unique でスマートポインタを作ります",
        "cpp_lesson2_ex9_comment2": "*ptr で中身にアクセスします",
        "cpp_lesson2_ex9_slide1_title": "スマートポインタとは？",
        "cpp_lesson2_ex9_slide1_content": "スマートポインタは、使い終わったら自動的にメモリを解放（かいほう）してくれる便利なポインタです。\n\n「自動返却システム」がついた図書館の本のようなもの。メモリリークを防ぐことができます。",
        "cpp_lesson2_ex9_slide2_title": "unique_ptr の使い方",
        "cpp_lesson2_ex9_slide2_content": "#include <memory>\n\nauto p = std::make_unique<int>(42);\nstd::cout << *p << std::endl; // 42\n// ここでスコープを出ると、自動でメモリが解放される！",

        "cpp_lesson2_ex10_title": "例外処理 try-catch",
        "cpp_lesson2_ex10_comment1": "throw で例外を投げます",
        "cpp_lesson2_ex10_comment2": "catch で例外を捕まえます",
        "cpp_lesson2_ex10_slide1_title": "例外処理（れいがいしょり）とは？",
        "cpp_lesson2_ex10_slide1_content": "例外処理（れいがいしょり）を使うと、プログラム実行中のエラーに対処（たいしょ）できます。\n\nサーカスの「安全ネット」のように、万が一のエラーでもクラッシュせずに対処できます。",
        "cpp_lesson2_ex10_slide2_title": "try-catch の使い方",
        "cpp_lesson2_ex10_slide2_content": "try {\n    throw \"error!\";\n} catch (const char* e) {\n    std::cout << e << std::endl;\n}",

        "cpp_lesson3_ex1_title": "auto で型推論",
        "cpp_lesson3_ex1_comment1": "auto で型を推論させます",
        "cpp_lesson3_ex1_slide1_title": "auto とは？",
        "cpp_lesson3_ex1_slide1_content": "auto（オート）を使うと、コンパイラが自動で型を判断してくれます。\n\nauto x = 42;        // int型と自動判断\nauto pi = 3.14;     // double型と自動判断",
        "cpp_lesson3_ex1_slide2_title": "イテレータで便利",
        "cpp_lesson3_ex1_slide2_content": "auto は、型名が長いときに特に便利です。\n\n// auto がないと...\nstd::vector<int>::iterator it = v.begin();\n\n// auto を使うと...\nauto it = v.begin();  // スッキリ！",

        "cpp_lesson3_ex2_title": "範囲for文",
        "cpp_lesson3_ex2_comment1": "vector で配列を作成",
        "cpp_lesson3_ex2_comment2": ": で範囲for文を使います",
        "cpp_lesson3_ex2_slide1_title": "範囲for文とは？",
        "cpp_lesson3_ex2_slide1_content": "C++11の範囲（はんい）for文を使うと、配列やベクターの中身を簡単に1つずつ取り出せます。\n\nvector<int> v = {1, 2, 3};\nfor (int x : v) {\n    cout << x << endl;\n}",
        "cpp_lesson3_ex2_slide2_title": "参照で受け取る",
        "cpp_lesson3_ex2_slide2_content": "大きなデータだとコピーに時間がかかります。\n\nfor (const auto& x : v) {\n    // コピーしない（参照で受け取る）\n    cout << x << endl;\n}",

        "cpp_lesson3_ex3_title": "nullptr",
        "cpp_lesson3_ex3_comment1": "nullptr で型安全なヌルを表します",
        "cpp_lesson3_ex3_comment2": "nullptr と比較",
        "cpp_lesson3_ex3_slide1_title": "nullptr とは？",
        "cpp_lesson3_ex3_slide1_content": "nullptr（ヌルポインタ）は、「どこも指していないポインタ」を表す特別な値です。\n\nint* p = nullptr;\nif (p == nullptr) {\n    cout << \"null\" << endl;\n}",
        "cpp_lesson3_ex3_slide2_title": "NULL との違い",
        "cpp_lesson3_ex3_slide2_content": "古い NULL は実は「0」という数字なので問題が起きることがあります。\n\nvoid f(int);    // 整数を受け取る関数\nvoid f(int*);   // ポインタを受け取る関数\n\nf(NULL);    // どっち？あいまい！\nf(nullptr); // 明確！f(int*) が呼ばれる",

        "cpp_lesson3_ex4_title": "constexpr",
        "cpp_lesson3_ex4_comment1": "constexpr でコンパイル時計算を可能にします",
        "cpp_lesson3_ex4_slide1_title": "constexpr とは？",
        "cpp_lesson3_ex4_slide1_content": "constexpr（コンストエクスプレス）は、「コンパイル時に計算できる」ことを示すキーワードです。\n\nconstexpr int square(int x) {\n    return x * x;\n}\nconstexpr int val = square(5); // コンパイル時に25と計算済み！",
        "cpp_lesson3_ex4_slide2_title": "const との違い",
        "cpp_lesson3_ex4_slide2_content": "const: 一度決めたら変えない（いつ決まるかは問わない）\nconstexpr: プログラムを動かす前に決まっている\n\nconst int a = getValue();     // 実行時に決まってもOK\nconstexpr int b = 10 * 10;    // コンパイル時に決まっていないとダメ",

        "cpp_lesson3_ex5_title": "初期化子リスト",
        "cpp_lesson3_ex5_comment1": "{} で初期化します",
        "cpp_lesson3_ex5_comment2": ": で範囲for文",
        "cpp_lesson3_ex5_slide1_title": "初期化子リストとは？",
        "cpp_lesson3_ex5_slide1_content": "初期化子（しょきかし）リストは、波括弧（なみかっこ）{} を使って値を設定する方法です。\n\nvector<int> v = {1, 2, 3};\nmap<string, int> m = {{\"りんご\", 100}, {\"バナナ\", 80}};",
        "cpp_lesson3_ex5_slide2_title": "縮小変換を防ぐ",
        "cpp_lesson3_ex5_slide2_content": "{} を使うと、データが失われる変換（縮小変換）を防いでくれます。\n\nint x = 3.14;   // OK（でも 3 になる）\nint z{3.14};    // エラー！小数点以下が消えるので拒否",

        "cpp_lesson3_ex6_title": "shared_ptr",
        "cpp_lesson3_ex6_comment1": "make_shared で共有ポインタを作成します",
        "cpp_lesson3_ex6_comment2": "*p で中身にアクセス",
        "cpp_lesson3_ex6_slide1_title": "shared_ptr とは？",
        "cpp_lesson3_ex6_slide1_content": "shared_ptr（シェアードポインタ）は、「複数人で共有できる」スマートポインタです。\n\nauto p1 = make_shared<int>(42);\nauto p2 = p1;  // 同じデータを共有\n// 最後の1人が使い終わると、自動で解放",
        "cpp_lesson3_ex6_slide2_title": "make_shared",
        "cpp_lesson3_ex6_slide2_content": "auto p = make_shared<int>(100);\n// 非推奨の書き方（効率が悪い）: shared_ptr<int> p(new int(100));",

        "cpp_lesson3_ex7_title": "std::move",
        "cpp_lesson3_ex7_comment1": "string で文字列を作成",
        "cpp_lesson3_ex7_comment2": "move で所有権を移動",
        "cpp_lesson3_ex7_slide1_title": "move とは？",
        "cpp_lesson3_ex7_slide1_content": "std::move（ムーブ）は、データの「所有権」を別の変数に移す機能です。\n\nstring s1 = \"Hello\";\nstring s2 = move(s1);  // s1 の中身を s2 に移動！\n// s1 は空っぽになる",
        "cpp_lesson3_ex7_slide2_title": "コピーより効率的",
        "cpp_lesson3_ex7_slide2_content": "大きなデータを扱うとき、move はコピーより圧倒的に速いです。\n\nvector<int> v1(1000000);  // 100万個の要素\nvector<int> v2 = move(v1);  // ポインタだけ移動（速い！）",

        "cpp_lesson3_ex8_title": "std::optional",
        "cpp_lesson3_ex8_comment1": "optional で値を保持",
        "cpp_lesson3_ex8_comment2": "has_value で値の有無をチェックします",
        "cpp_lesson3_ex8_slide1_title": "optional とは？",
        "cpp_lesson3_ex8_slide1_content": "std::optional（オプショナル）は、「値があるかもしれないし、ないかもしれない」という状態を安全に表現できる型です。\n\noptional<int> find(...) {\n    if (found) return value;\n    return nullopt;  // 見つからなかった\n}",
        "cpp_lesson3_ex8_slide2_title": "値の取得",
        "cpp_lesson3_ex8_slide2_content": "値があるかチェックしてから使います。\n\nif (result.has_value()) {\n    cout << result.value() << endl;\n}\n// 省略形: if (result) cout << *result;",

        "cpp_lesson3_ex9_title": "std::array",
        "cpp_lesson3_ex9_comment1": "array で固定長配列を使います",
        "cpp_lesson3_ex9_comment2": ": で範囲for文",
        "cpp_lesson3_ex9_slide1_title": "array とは？",
        "cpp_lesson3_ex9_slide1_content": "std::array（アレイ）は、サイズが固定された安全な配列です。\n\narray<int, 5> arr = {1, 2, 3, 4, 5};\ncout << arr.size() << endl;  // 5（サイズを取得できる！）",
        "cpp_lesson3_ex9_slide2_title": "C配列との違い",
        "cpp_lesson3_ex9_slide2_content": "array<int, 3> arr = {10, 20, 30};\n\narr.at(1);   // OK: 20\narr.at(10);  // エラー！「範囲外」と教えてくれる\narr[10];     // 危険（何が起こるかわからない）",

        "cpp_lesson3_ex10_title": "ラムダのキャプチャ",
        "cpp_lesson3_ex10_comment1": "int で変数を宣言",
        "cpp_lesson3_ex10_comment2": "[x] で x をコピーキャプチャします",
        "cpp_lesson3_ex10_slide1_title": "キャプチャとは？",
        "cpp_lesson3_ex10_slide1_content": "キャプチャとは、ラムダ式の中で「外にある変数」を使えるようにする機能です。\n\nint x = 10;\nauto f = [x]() { return x * 2; };  // コピーで持ち込む\nauto g = [&x]() { x++; };           // 参照で持ち込む",
        "cpp_lesson3_ex10_slide2_title": "キャプチャの種類",
        "cpp_lesson3_ex10_slide2_content": "[x]      // x だけコピーで持ち込む\n[&x]     // x だけ参照で持ち込む\n[=]      // 全部コピーで持ち込む\n[&]      // 全部参照で持ち込む\n[=, &x]  // 基本コピー、x だけ参照",

        "cpp_lesson4_ex1_title": "unique_ptr",
        "cpp_lesson4_ex1_comment1": "make_unique で排他的ポインタを作成します",
        "cpp_lesson4_ex1_comment2": "*p で中身にアクセス",
        "cpp_lesson4_ex1_slide1_title": "unique_ptr とは？",
        "cpp_lesson4_ex1_slide1_content": "unique_ptr（ユニークポインタ）は、「1人だけが持てる」スマートポインタです。\n\n映画のチケットのようなものです。1枚のチケットは1人しか持てません。\n\nauto p = make_unique<int>(42);\ncout << *p << endl; // 42",
        "cpp_lesson4_ex1_slide2_title": "コピー不可",
        "cpp_lesson4_ex1_slide2_content": "unique_ptr はコピーできません。移動（いどう）のみです。\n\nauto p1 = make_unique<int>(10);\n// auto p2 = p1;           // エラー！コピーは禁止\nauto p2 = move(p1);         // OK！p1 から p2 に渡す",

        "cpp_lesson4_ex2_title": "std::variant",
        "cpp_lesson4_ex2_comment1": "variant で複数型のうち1つを保持",
        "cpp_lesson4_ex2_comment2": "get<型> で値を取得します",
        "cpp_lesson4_ex2_slide1_title": "variant とは？",
        "cpp_lesson4_ex2_slide1_content": "std::variant（バリアント）は、「いくつかの型のうち、どれか1つ」を安全に保持できます。\n\nvariant<int, string> v;\nv = 42;        // 今は int を保持中\nv = \"hello\";   // 今は string を保持中",
        "cpp_lesson4_ex2_slide2_title": "値の取得",
        "cpp_lesson4_ex2_slide2_content": "今何が入っているかをチェックしてから取り出します。\n\nif (holds_alternative<int>(v)) {\n    cout << get<int>(v) << endl;\n}",

        "cpp_lesson4_ex3_title": "構造化束縛",
        "cpp_lesson4_ex3_comment1": "tuple で複数の値をまとめる",
        "cpp_lesson4_ex3_comment2": "auto で構造化束縛を使います",
        "cpp_lesson4_ex3_slide1_title": "構造化束縛とは？",
        "cpp_lesson4_ex3_slide1_content": "構造化束縛（こうぞうかそくばく）は、まとまったデータを一度にバラバラの変数に分けて受け取る機能です。\n\npair<int, string> p = {1, \"hello\"};\nauto [num, str] = p;\n// num = 1, str = \"hello\"",
        "cpp_lesson4_ex3_slide2_title": "mapのイテレーション",
        "cpp_lesson4_ex3_slide2_content": "map をループするときにとても便利です。\n\nfor (auto [key, value] : m) {\n    cout << key << \": \" << value << endl;\n}",

        "cpp_lesson4_ex4_title": "std::string_view",
        "cpp_lesson4_ex4_comment1": "string_view で文字列ビューを受け取ります",
        "cpp_lesson4_ex4_comment2": "greet で関数を呼び出し",
        "cpp_lesson4_ex4_slide1_title": "string_view とは？",
        "cpp_lesson4_ex4_slide1_content": "string_view（ストリングビュー）は、文字列を「コピーせずに見る」ための型です。\n\nvoid print(string_view sv) {\n    cout << sv << endl;\n}\nprint(\"hello\");  // コピーなし！",
        "cpp_lesson4_ex4_slide2_title": "メリット",
        "cpp_lesson4_ex4_slide2_content": "どんな種類の文字列でも、コピーなしで受け取れます。\n\nvoid f(string_view sv);  // オススメ！\n\nf(s);        // string型 → OK\nf(\"hello\");  // 文字列リテラル → OK",

        "cpp_lesson4_ex5_title": "std::transform",
        "cpp_lesson4_ex5_comment1": "vector で配列を作成",
        "cpp_lesson4_ex5_comment2": "transform で各要素を変換します",
        "cpp_lesson4_ex5_slide1_title": "transform とは？",
        "cpp_lesson4_ex5_slide1_content": "transform（トランスフォーム）は、配列の各要素に同じ処理を適用して、結果を保存するアルゴリズムです。\n\nvector<int> in = {1, 2, 3};\nvector<int> out(3);\ntransform(in.begin(), in.end(), out.begin(),\n          [](int x) { return x * 2; });\n// out = {2, 4, 6}",
        "cpp_lesson4_ex5_slide2_title": "使用例",
        "cpp_lesson4_ex5_slide2_content": "文字列を大文字（おおもじ）に変換：\n\nstring s = \"hello\";\ntransform(s.begin(), s.end(), s.begin(), ::toupper);\n// s = \"HELLO\"",

        "cpp_lesson4_ex6_title": "std::accumulate",
        "cpp_lesson4_ex6_comment1": "vector で配列を作成",
        "cpp_lesson4_ex6_comment2": "accumulate で要素を集約します",
        "cpp_lesson4_ex6_slide1_title": "accumulate とは？",
        "cpp_lesson4_ex6_slide1_content": "accumulate（アキュムレート）は、配列の全要素を1つの値にまとめるアルゴリズムです。\n\nvector<int> v = {1, 2, 3, 4, 5};\nint sum = accumulate(v.begin(), v.end(), 0);\n// 0 + 1 + 2 + 3 + 4 + 5 = 15",
        "cpp_lesson4_ex6_slide2_title": "カスタム演算",
        "cpp_lesson4_ex6_slide2_content": "足し算以外の計算もできます：\n\nint product = accumulate(v.begin(), v.end(), 1,\n    [](int a, int b) { return a * b; });\n// 1 * 1 * 2 * 3 * 4 * 5 = 120",

        "cpp_lesson4_ex7_title": "std::find_if",
        "cpp_lesson4_ex7_comment1": "vector で配列を作成",
        "cpp_lesson4_ex7_comment2": "find_if で条件に合う要素を検索します",
        "cpp_lesson4_ex7_slide1_title": "find_if とは？",
        "cpp_lesson4_ex7_slide1_content": "find_if（ファインドイフ）は、「条件に合う最初の要素」を見つけるアルゴリズムです。\n\nvector<int> v = {1, 3, 5, 6, 7};\nauto it = find_if(v.begin(), v.end(),\n    [](int x) { return x % 2 == 0; });\ncout << *it << endl;  // 6",
        "cpp_lesson4_ex7_slide2_title": "見つからない場合",
        "cpp_lesson4_ex7_slide2_content": "条件に合う要素が1つもない場合、end() が返されます。\n\nif (it != v.end()) {\n    cout << \"Found: \" << *it << endl;\n} else {\n    cout << \"Not found\" << endl;\n}",

        "cpp_lesson4_ex8_title": "std::sort with lambda",
        "cpp_lesson4_ex8_comment1": "vector で配列を作成",
        "cpp_lesson4_ex8_comment2": "sort でカスタム順序でソートします",
        "cpp_lesson4_ex8_slide1_title": "カスタムソート",
        "cpp_lesson4_ex8_slide1_content": "sort（ソート）にラムダ式を渡すと、好きな順番で並べ替えができます。\n\nvector<int> v = {3, 1, 4, 1, 5};\nsort(v.begin(), v.end(), [](int a, int b) {\n    return a > b;  // 降順（大きい順）\n});\n// {5, 4, 3, 1, 1}",
        "cpp_lesson4_ex8_slide2_title": "オブジェクトのソート",
        "cpp_lesson4_ex8_slide2_content": "自分で作ったクラスのリストも、好きな基準でソートできます。\n\nsort(people.begin(), people.end(),\n    [](const Person& a, const Person& b) {\n        return a.age < b.age;\n    });",

        "cpp_lesson4_ex9_title": "try-catch 例外処理",
        "cpp_lesson4_ex9_comment1": "throw で例外を投げます",
        "cpp_lesson4_ex9_comment2": "catch で例外を捕まえます",
        "cpp_lesson4_ex9_slide1_title": "例外処理",
        "cpp_lesson4_ex9_slide1_content": "try-catch でエラーを安全に処理します。\n\ntry {\n    throw runtime_error(\"Error!\");\n} catch (const exception& e) {\n    cout << e.what() << endl;\n}",
        "cpp_lesson4_ex9_slide2_title": "標準例外",
        "cpp_lesson4_ex9_slide2_content": "よく使う例外の種類：\n\nruntime_error     // 実行時エラー\nlogic_error       // 論理エラー\nout_of_range      // 範囲外アクセス\ninvalid_argument  // 不正な引数",

        "cpp_lesson4_ex10_title": "noexcept 指定",
        "cpp_lesson4_ex10_comment1": "noexcept で例外を投げないことを宣言します",
        "cpp_lesson4_ex10_comment2": "+ で足し算",
        "cpp_lesson4_ex10_slide1_title": "noexcept とは？",
        "cpp_lesson4_ex10_slide1_content": "noexcept（ノーエクセプト）は、「この関数は例外を投げません」と宣言するキーワードです。\n\nvoid safe() noexcept {\n    int x = 1 + 1;  // 絶対にエラーが起きない処理\n}",
        "cpp_lesson4_ex10_slide2_title": "メリット",
        "cpp_lesson4_ex10_slide2_content": "noexcept をつけると何が良いの？\n\nint add(int a, int b) noexcept {\n    return a + b;\n}\n// コンパイラが「例外処理のコード」を省略できる → 速い！"
    }
}

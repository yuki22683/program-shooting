{
  "rust_lesson1_course_description": "間違いを見つけるのがとても得意な言葉「Rust（ラスト）」のきほんを学びましょう。きっちりしたルールを身につけて、安全なプログラムを作れるようになります。",
  "rust_lesson1_course_title": "Rust (ラスト) に挑戦！",
  "rust_lesson1_ex10_comment1": "再代入可能な変数を宣言し、数値を代入します。",
  "rust_lesson1_ex10_comment2": "条件式（変数と数値の比較など）を評価し、真の場合にブロックを実行します。",
  "rust_lesson1_ex10_slide1_content": "# プログラムに「判断」させよう\n\n**条件分岐** は、「もし〜なら、〇〇する」という判断をプログラムにさせる仕組みです。\n\n**身近な例：**\n- もし80点以上なら → 「合格！」と表示\n- もし雨なら → 傘を持っていく\n- もしHPが0なら → ゲームオーバー\n\n**Rustでの書き方：**\n```rust\nif score > 80 {\n    println!(\\\"合格！\\\");\n}\n```\n\n**読み方：**\n- `if` →「もし」\n- `score > 80` →「スコアが80より大きいなら」\n- `{ }` の中 →「これをやる」",
  "rust_lesson1_ex10_slide1_title": "条件分岐（じょうけんぶんき）とは？",
  "rust_lesson1_ex10_title": "条件分岐（じょうけんぶんき）とは？",
  "rust_lesson1_ex11_description": "複数の条件を組み合わせる「&&（かつ）」と「||（または）」を学びましょう。",
  "rust_lesson1_ex11_title": "論理演算子（&&、||）",
  "rust_lesson1_ex12_comment1": "条件式（変数と数値の比較など）を評価し、真の場合にブロックを実行します。",
  "rust_lesson1_ex12_slide1_content": "# 論理演算子（ろんりえんざんし）\n\n2つ以上の条件を組み合わせたいときに使う記号です。\n\n**2つの記号：**\n- `&&`（アンドアンド）：「かつ」＝ **両方とも** 正しいとき\n- `||`（オアオア）：「または」＝ **どちらか** 正しいとき\n\n**身近な例：**\n- 遊園地：「18歳以上 **かつ** チケットあり」なら乗れる\n- おやつ：「宿題終わった **または** お手伝いした」ならOK\n\n**コード例：**\n```rust\nif score >= 70 && bonus > 0 {\n    // 70点以上 かつ ボーナスあり → 合格！\n    println!(\\\"合格！\\\");\n}\n```",
  "rust_lesson1_ex12_slide1_title": "条件を組み合わせる",
  "rust_lesson1_ex12_title": "条件を組み合わせる",
  "rust_lesson1_ex13_description": "「ベクタ（Vec）」を使うと、たくさんのデータを一つの「長い はこ」にまとめて入れられます。",
  "rust_lesson1_ex13_title": "たくさんのデータをまとめましょう「ベクタ」",
  "rust_lesson1_ex14_slide1_content": "# [ ]で番号を指定して取り出す\n\n`[番号]` で何番目のデータか指定して取り出せます。\n\n**大事なルール：番号は「0」から！**\n- 1番目 → `[0]`\n- 2番目 → `[1]`\n- 3番目 → `[2]`\n\n**コード例：**\n```rust\nlet fruits = vec![\\\"りんご\\\", \\\"バナナ\\\", \\\"みかん\\\"];\n//                  ↑0番    ↑1番     ↑2番\nprintln!(\\\"{}\\\", fruits[0]);  // りんご\nprintln!(\\\"{}\\\", fruits[1]);  // バナナ\n```\n\nプログラミングでは「0から数える」のが世界共通のルールです！",
  "rust_lesson1_ex14_slide1_title": "ベクタの番号は「0」から！",
  "rust_lesson1_ex14_title": "ベクタの番号は「0」から！",
  "rust_lesson1_ex15_description": "「辞書（HashMap）」を使うと、名前をつけてデータを保存し、その名前で取り出せます。",
  "rust_lesson1_ex15_title": "名前で引き出す「辞書」",
  "rust_lesson1_ex16_comment1": "insert(\\\"みかん\\\", \\\"オレンジ\\\") と入力しましょう。",
  "rust_lesson1_ex16_comment2": "マクロを使用して、文字列と改行を標準出力に出力します。",
  "rust_lesson1_ex16_slide1_content": "# 名前（キー）で取り出す\n\n辞書に入れたデータは、名前（キー）を指定して取り出せます。\n\n**コード例：**\n```rust\nuse std::collections::HashMap;\nfn main() {\n    let mut fruits = HashMap::new();\n    fruits.insert(\\\"りんご\\\", \\\"あか\\\");  // 追加\n    fruits.insert(\\\"バナナ\\\", \\\"きいろ\\\");  // 追加\n    \n    println!(\\\"{}\\\", fruits[\\\"りんご\\\"]);  // あか と表示\n}\n```\n\n**ポイント：**\n- `insert(名前, データ)` で追加\n- `辞書[名前]` で取り出し\n- 番号ではなく「名前」で探せるのが便利！",
  "rust_lesson1_ex16_slide1_title": "辞書の使い方",
  "rust_lesson1_ex16_title": "辞書の使い方",
  "rust_lesson1_ex1_comment1": "Hello, Rust! と表示する",
  "rust_lesson1_ex1_description": "Rustを使って画面に文字を表示してみましょう。println! という特別な関数を使います。",
  "rust_lesson1_ex1_slide1_content": "# 安全で速い！最新のプログラミング言語\n\nRust（ラスト）は、「間違いを事前に防ぐ」ことがとても得意なプログラミング言語です。\n\nRustのすごいところ：\n- プログラムのミスを実行する前に見つけてくれる\n- とても速く動く\n- 世界中のプログラマーが「一番好き！」と選ぶ人気の言語\n\nたとえるなら：\n厳しいけど優しい先生のような言語です。「ここ間違ってるよ」と教えてくれるので、安心してプログラムが書けます！",
  "rust_lesson1_ex1_slide1_title": "Rust（ラスト）とは？",
  "rust_lesson1_ex1_slide2_content": "# println! で画面に表示\n\nRustで文字を画面に表示するには、`println!`（プリントラインびっくり）を使います。\n\nポイント：\n- `!` がつくのがRustの特徴（マクロと呼ばれます）\n- プログラムは `fn main() { }` の中に書く\n- `fn` は「function（関数）」の略\n\nコード例：\n```rust\nfn main() {\n    println!(\"ヤッホー！\");\n}\n// 「ヤッホー！」と画面に表示される\n```\n\n`println!` の `!` は「マクロ」という特別な機能の印です。今は「おまじない」と思っておけばOK！",
  "rust_lesson1_ex1_slide2_title": "Rustの「おまじない」",
  "rust_lesson1_ex1_slide3_content": "Rustを使って画面に文字を表示してみましょう。println! という特別な関数を使います。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "rust_lesson1_ex1_slide3_title": "やってみよう！",
  "rust_lesson1_ex1_title": "画面にメッセージを出しましょう",
  "rust_lesson1_ex2_comment1": "プログラムの実行開始地点（main関数）を定義します。",
  "rust_lesson1_ex2_comment2": "マクロを使用して、文字列と改行を標準出力に出力します。",
  "rust_lesson1_ex2_comment3": "プログラムの終わりです。",
  "rust_lesson1_ex2_description": "データに名前をつけて保存できる「変数（へんすう）」を使ってみましょう。letで変数を作ります。",
  "rust_lesson1_ex2_slide1_content": "# println! で画面に表示\n\nRustで文字を画面に表示するには、`println!`（プリントラインびっくり）を使います。\n\n**ポイント：**\n- `!` がつくのがRustの特徴（マクロと呼ばれます）\n- プログラムは `fn main() { }` の中に書く\n- `fn` は「function（関数）」の略\n\n**コード例：**\n```rust\nfn main() {\n    println!(\\\"ヤッホー！\\\");\n}\n// 「ヤッホー！」と画面に表示される\n```\n\n`println!` の `!` は「マクロ」という特別な機能の印です。今は「おまじない」と思っておけばOK！",
  "rust_lesson1_ex2_slide1_title": "Rustの「おまじない」",
  "rust_lesson1_ex2_slide2_content": "# 四則演算（しそくえんざん）\n\nRustでも算数と同じ記号で計算ができます。\n\n4つの基本記号：\n- +（プラス）: たし算\n- -（マイナス）: ひき算\n- \\*（アスタリスク）: かけ算（×の代わり）\n- /（スラッシュ）: わり算（÷の代わり）\n\nコード例：\n```rust\nlet a = 10;\nlet b = 5;\nprintln!(\"{}\", a + b);  // 15 と表示される\n```\n\n`println!` の `{}` は「ここに値を入れてね」という目印です。",
  "rust_lesson1_ex2_slide2_title": "計算の記号（演算子）",
  "rust_lesson1_ex2_slide3_content": "データに名前をつけて保存できる「変数（へんすう）」を使ってみましょう。letで変数を作ります。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "rust_lesson1_ex2_slide3_title": "やってみよう！",
  "rust_lesson1_ex2_title": "Rustの「おまじない」",
  "rust_lesson1_ex3_comment1": "10 を 3 で割ったあまりを出力する",
  "rust_lesson1_ex3_description": "データに名前をつけて保存できる「変数（へんすう）」を使ってみましょう。letで変数を作ります。",
  "rust_lesson1_ex3_slide1_content": "# 剰余演算子（じょうよえんざんし）「%」\n\n`%`（パーセント）は、割り算の 「あまり」 を計算する特別な記号です。\n\nわかりやすい例：\n- 10このアメを3人で分けると？\n- 1人3こずつで、1こあまる\n- これを `10 % 3` と書くと、答えは `1`\n\nコード例：\n```rust\nprintln!(\"{}\", 10 % 3);  // 1（あまり1）\nprintln!(\"{}\", 8 % 4);   // 0（あまりなし＝割り切れる）\n```\n\n使いどころ：\n- 偶数か奇数か調べる（`n % 2` が0なら偶数）\n- 時計の計算（24を超えたら0に戻る、など）",
  "rust_lesson1_ex3_slide1_title": "あまりを求める",
  "rust_lesson1_ex3_slide2_content": "割り算の「あまり」を求める「%」（パーセント）演算子を学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "rust_lesson1_ex3_slide2_title": "やってみよう！",
  "rust_lesson1_ex3_title": "便利な「はこ」変数（へんすう）",
  "rust_lesson1_ex4_comment1": "再代入可能な変数を宣言し、数値を代入します。",
  "rust_lesson1_ex4_comment2": "再代入可能な変数を宣言し、数値を代入します。",
  "rust_lesson1_ex4_comment3": "マクロを使用して、文字列と改行を標準出力に出力します。",
  "rust_lesson1_ex4_description": "変数の値を手軽に増やしたり減らしたりする「+=」「-=」を学びましょう。",
  "rust_lesson1_ex4_slide1_content": "# 四則演算（しそくえんざん）\n\nRustでも算数と同じ記号で計算ができます。\n\n**4つの基本記号：**\n- **+**（プラス）: たし算\n- **-**（マイナス）: ひき算\n- **\\\\***（アスタリスク）: かけ算（×の代わり）\n- **/**（スラッシュ）: わり算（÷の代わり）\n\n**コード例：**\n```rust\nlet a = 10;\nlet b = 5;\nprintln!(\\\"{}\\\", a + b);  // 15 と表示される\n```\n\n`println!` の `{}` は「ここに値を入れてね」という目印です。",
  "rust_lesson1_ex4_slide1_title": "計算の記号（演算子）",
  "rust_lesson1_ex4_slide2_content": "変数の値を手軽に増やしたり減らしたりする「+=」「-=」を学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "rust_lesson1_ex4_slide2_title": "やってみよう！",
  "rust_lesson1_ex4_title": "計算の記号（演算子）",
  "rust_lesson1_ex5_comment1": "> で比較する",
  "rust_lesson1_ex5_description": "割り算の「あまり」を求める「%」（パーセント）演算子を学びましょう。",
  "rust_lesson1_ex5_slide1_content": "# プログラムに「判断」させよう\n\n条件分岐 は、「もし〜なら、〇〇する」という判断をプログラムにさせる仕組みです。\n\n身近な例：\n- もし80点以上なら → 「合格！」と表示\n- もし雨なら → 傘を持っていく\n- もしHPが0なら → ゲームオーバー\n\nRustでの書き方：\n```rust\nif score > 80 {\n    println!(\"合格！\");\n}\n```\n\n読み方：\n- `if` →「もし」\n- `score > 80` →「スコアが80より大きいなら」\n- `{ }` の中 →「これをやる」",
  "rust_lesson1_ex5_slide1_title": "条件分岐（じょうけんぶんき）とは？",
  "rust_lesson1_ex5_slide2_content": "条件によって動きを変える if文を学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "rust_lesson1_ex5_slide2_title": "やってみよう！",
  "rust_lesson1_ex5_title": "剰余演算子（%）",
  "rust_lesson1_ex6_comment1": "マクロを使用して、文字列と改行を標準出力に出力します。",
  "rust_lesson1_ex6_description": "複数の条件を組み合わせる「&&（かつ）」と「||（または）」を学びましょう。",
  "rust_lesson1_ex6_slide1_content": "# 剰余演算子（じょうよえんざんし）「%」\n\n`%`（パーセント）は、割り算の **「あまり」** を計算する特別な記号です。\n\n**わかりやすい例：**\n- 10このアメを3人で分けると？\n- 1人3こずつで、**1こあまる**\n- これを `10 % 3` と書くと、答えは `1`\n\n**コード例：**\n```rust\nprintln!(\\\"{}\\\", 10 % 3);  // 1（あまり1）\nprintln!(\\\"{}\\\", 8 % 4);   // 0（あまりなし＝割り切れる）\n```\n\n**使いどころ：**\n- 偶数か奇数か調べる（`n % 2` が0なら偶数）\n- 時計の計算（24を超えたら0に戻る、など）",
  "rust_lesson1_ex6_slide1_title": "あまりを求める",
  "rust_lesson1_ex6_slide2_content": "複数の条件を組み合わせる「&&（かつ）」と「||（または）」を学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "rust_lesson1_ex6_slide2_title": "やってみよう！",
  "rust_lesson1_ex6_title": "あまりを求める",
  "rust_lesson1_ex7_comment1": "colors というベクタを作る（'あか', 'あお'の順）",
  "rust_lesson1_ex7_comment2": "2番目のデータ（1番）を出す",
  "rust_lesson1_ex7_description": "変数の値を手軽に増やしたり減らしたりする「+=」「-=」を学びましょう。",
  "rust_lesson1_ex7_slide1_content": "# データを並べてまとめる「長い箱」\n\nベクタ（Vec） は、たくさんのデータを順番に並べて入れられる「長い箱」です。\n\nたとえば：\n- 買い物リストの商品を全部まとめる\n- テストの点数を全部まとめる\n- 友だちの名前を全部まとめる\n\n100個でも1000個でも、1つの変数でまとめて管理できます！\n\n作り方：\n```rust\nlet fruits = vec![\"りんご\", \"バナナ\", \"みかん\"];\n// vec! で ベクタを作る\n```",
  "rust_lesson1_ex7_slide1_title": "ベクタ（Vec）とは？",
  "rust_lesson1_ex7_slide2_content": "# [ ]で番号を指定して取り出す\n\n`[番号]` で何番目のデータか指定して取り出せます。\n\n大事なルール：番号は「0」から！\n- 1番目 → `[0]`\n- 2番目 → `[1]`\n- 3番目 → `[2]`\n\nコード例：\n```rust\nlet fruits = vec![\"りんご\", \"バナナ\", \"みかん\"];\n//                  ↑0番    ↑1番     ↑2番\nprintln!(\"{}\", fruits[0]);  // りんご\nprintln!(\"{}\", fruits[1]);  // バナナ\n```\n\nプログラミングでは「0から数える」のが世界共通のルールです！",
  "rust_lesson1_ex7_slide2_title": "ベクタの番号は「0」から！",
  "rust_lesson1_ex7_slide3_content": "「ベクタ（Vec）」を使うと、たくさんのデータを一つの「長い はこ」にまとめて入れられます。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "rust_lesson1_ex7_slide3_title": "やってみよう！",
  "rust_lesson1_ex7_title": "累算代入演算子（+=、-=）",
  "rust_lesson1_ex8_comment1": "変数の値を計算して、その結果を同じ変数に再代入します。",
  "rust_lesson1_ex8_comment2": "変数の値を計算して、その結果を同じ変数に再代入します。",
  "rust_lesson1_ex8_description": "「辞書（HashMap）」を使うと、名前をつけてデータを保存し、その名前で取り出せます。",
  "rust_lesson1_ex8_slide1_content": "# 値をかんたんに増やす・減らす\n\n`+=`（プラスイコール）と `-=`（マイナスイコール）は、変数の中身を増やしたり減らしたりする便利な記号です。\n\n**Rustの大事なルール：`mut`が必要！**\nRustでは、変数を変更するには `let mut`（レット ミュート）と書く必要があります。`mut` は「mutable（変更できる）」の略です。\n\n**コード例：**\n```rust\nlet mut score = 100;  // mut をつけて変更可能に\nscore += 10;          // 10を足す → 110に\nscore -= 50;          // 50を引く → 60に\n```\n\n`mut` がないと「この変数は変えちゃダメ！」とRustが怒ります。",
  "rust_lesson1_ex8_slide1_title": "累算代入演算子（るいさんだいにゅう）とは？",
  "rust_lesson1_ex8_slide2_content": "# 名前（キー）で取り出す\n\n辞書に入れたデータは、名前（キー）を指定して取り出せます。\n\nコード例：\n```rust\nuse std::collections::HashMap;\nfn main() {\n    let mut fruits = HashMap::new();\n    fruits.insert(\"りんご\", \"あか\");  // 追加\n    fruits.insert(\"バナナ\", \"きいろ\");  // 追加\n    \n    println!(\"{}\", fruits[\"りんご\"]);  // あか と表示\n}\n```\n\nポイント：\n- `insert(名前, データ)` で追加\n- `辞書[名前]` で取り出し\n- 番号ではなく「名前」で探せるのが便利！",
  "rust_lesson1_ex8_slide2_title": "辞書の使い方",
  "rust_lesson1_ex8_slide3_content": "「辞書（HashMap）」を使うと、名前をつけてデータを保存し、その名前で取り出せます。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "rust_lesson1_ex8_slide3_title": "やってみよう！",
  "rust_lesson1_ex8_title": "累算代入演算子（るいさんだいにゅう）とは？",
  "rust_lesson1_ex9_description": "条件によって動きを変える if文を学びましょう。",
  "rust_lesson1_ex9_title": "「もし〜なら」で分けましょう",
  "rust_lesson1_title": "Rust (ラスト) に挑戦！",
  "rust_lesson2_course_description": "Rust最大の特徴「所有権」を中心に、構造体、トレイト、パターンマッチングを学びます。安全で高速なプログラムを書く力を身につけましょう。",
  "rust_lesson2_course_title": "Rust II - 所有権とトレイト",
  "rust_lesson2_ex10_comment1": "impl でメソッドを実装します。",
  "rust_lesson2_ex10_comment2": "関数（area）を定義します。",
  "rust_lesson2_ex10_comment3": "マクロを使用して、文字列と改行を標準出力に出力します。",
  "rust_lesson2_ex10_description": "型を後から決められる「ジェネリクス」を学びましょう。",
  "rust_lesson2_ex10_slide1_content": "# &self を使う\n\nメソッドの最初の引数は `&self` です。\n\n**コード例：**\n```rust\nimpl Rect {\n    fn area(&self) -> i32 {\n        self.width * self.height\n    }\n}\n```",
  "rust_lesson2_ex10_slide1_title": "メソッドの定義",
  "rust_lesson2_ex10_slide2_content": "# <T> で型を「あとで決める」\n\n関数名の後に `<T>` をつけて、`T` を「型」として使います。\n\nコード例：\n```rust\n// Tはどんな型でもOK\nfn first<T>(arr: &[T]) -> &T {\n    &arr[0]  // 最初の要素を返す\n}\n\n// 使い方\nfirst(&[1, 2, 3]);         // Tはi32\nfirst(&[\"a\", \"b\", \"c\"]);   // Tは&str\n```\n\n読み方：\n- `<T>` → 「Tという名前の型を使うよ」\n- `T` は慣習で「Type（型）」の頭文字\n- 複数の型が必要なら `<T, U>` のように書く",
  "rust_lesson2_ex10_slide2_title": "ジェネリック関数の書き方",
  "rust_lesson2_ex10_slide3_content": "型を後から決められる「ジェネリクス」を学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "rust_lesson2_ex10_slide3_title": "やってみよう！",
  "rust_lesson2_ex10_title": "メソッドの定義",
  "rust_lesson2_ex11_description": "複数の状態を表す「列挙型（enum）」を学びましょう。",
  "rust_lesson2_ex11_title": "enum で状態を表す",
  "rust_lesson2_ex12_comment1": "enum で列挙型を定義します。",
  "rust_lesson2_ex12_comment2": "Direction::Up を使います。",
  "rust_lesson2_ex12_comment3": "match でパターンマッチングします。",
  "rust_lesson2_ex12_slide1_content": "# バリアントを列挙\n\n`enum 名前 { バリアント1, バリアント2, ... }` で定義します。\n\n**コード例：**\n```rust\nenum Color {\n    Red,\n    Green,\n    Blue,\n}\nlet c = Color::Red;\n```",
  "rust_lesson2_ex12_slide1_title": "enum の定義",
  "rust_lesson2_ex12_title": "enum の定義",
  "rust_lesson2_ex13_description": "値があるかないかを表す「Option」を学びましょう。",
  "rust_lesson2_ex13_title": "Option<T> で null を安全に",
  "rust_lesson2_ex14_comment1": "Some で値があることを示します。",
  "rust_lesson2_ex14_comment2": "マクロを使用して、文字列と改行を標準出力に出力します。",
  "rust_lesson2_ex14_slide1_content": "# match で安全に取り出す\n\n`match` を使って「ある場合」と「ない場合」で処理を分けます。\n\n**コード例：**\n```rust\nlet x: Option<i32> = Some(5);  // 値あり\n\nmatch x {\n    Some(n) => println!(\\\"値は{}です\\\", n),  // 5\n    None => println!(\\\"値がありません\\\"),\n}\n```\n\n**なぜ安全？**\n- `null` のように「あるつもりでアクセスしたら無かった」エラーが起きない\n- 「ない場合」の処理を書かないとコンパイルエラーになる\n- 強制的に両方のケースを考えることになる！",
  "rust_lesson2_ex14_slide1_title": "Option の使い方",
  "rust_lesson2_ex14_title": "Option の使い方",
  "rust_lesson2_ex15_description": "成功と失敗を表す「Result」を学びましょう。",
  "rust_lesson2_ex15_title": "Result<T, E> でエラー処理",
  "rust_lesson2_ex16_comment1": "Err でエラーを返します。",
  "rust_lesson2_ex16_comment2": "Ok で成功を返します。",
  "rust_lesson2_ex16_slide1_content": "# match で成功と失敗を分ける\n\n`match` で「成功したら」「失敗したら」の処理を書き分けます。\n\n**コード例：**\n```rust\nfn divide(a: i32, b: i32) -> Result<i32, String> {\n    if b == 0 {\n        return Err(\\\"0で割れません\\\".to_string());\n    }\n    Ok(a / b)  // 成功なら答えを返す\n}\n\nmatch divide(10, 2) {\n    Ok(v) => println!(\\\"答えは{}\\\", v),\n    Err(e) => println!(\\\"エラー: {}\\\", e),\n}\n```\n\n**ポイント：**\n- `Ok(値)` で成功を返す\n- `Err(エラー)` で失敗を返す",
  "rust_lesson2_ex16_slide1_title": "Result の使い方",
  "rust_lesson2_ex16_title": "Result の使い方",
  "rust_lesson2_ex17_description": "共通の振る舞いを定義する「トレイト」を学びましょう。",
  "rust_lesson2_ex17_title": "トレイトを定義しよう",
  "rust_lesson2_ex18_comment1": "trait でトレイトを定義します。",
  "rust_lesson2_ex18_comment2": "Dog に Speak を実装します。",
  "rust_lesson2_ex18_slide1_content": "# 約束を作って、守る\n\n1. `trait` で「約束」を定義\n2. `impl トレイト for 型` で「約束を守る」実装をする\n\n**コード例：**\n```rust\n// 1. トレイト（約束）を定義\ntrait Speak {\n    fn speak(&self);  // 鳴くメソッドを持つ約束\n}\n\n// 2. Dog構造体がトレイトを実装\nstruct Dog;\nimpl Speak for Dog {\n    fn speak(&self) {\n        println!(\\\"woof\\\");\n    }\n}\n```\n\n「DogはSpeakができる」ということになります。",
  "rust_lesson2_ex18_slide1_title": "trait の定義と実装",
  "rust_lesson2_ex18_title": "trait の定義と実装",
  "rust_lesson2_ex19_description": "型を後から決められる「ジェネリクス」を学びましょう。",
  "rust_lesson2_ex19_title": "ジェネリクスを使おう",
  "rust_lesson2_ex1_comment1": "s1 の所有権を移動",
  "rust_lesson2_ex1_description": "Rust独自の概念「所有権」を学びましょう。",
  "rust_lesson2_ex1_slide1_content": "# データの「持ち主」を決めるルール\n\n所有権 は、Rust最大の特徴です。「このデータの持ち主は誰か」をはっきりさせる仕組みです。\n\nルール：\n- データには必ず1人だけ「持ち主」がいる\n- 持ち主がいなくなると、データは自動的に片付けられる\n\nたとえるなら：\n- おもちゃは1人しか持てない\n- 持ち主が部屋を出たら、おもちゃは片付けられる\n\nこのルールのおかげで、Rustは「メモリリーク」（データが片付けられないバグ）を防げます！",
  "rust_lesson2_ex1_slide1_title": "所有権（しょゆうけん）とは？",
  "rust_lesson2_ex1_slide2_content": "# 所有権は「移動」する\n\n変数を別の変数に代入すると、所有権が 移動（ムーブ） します。元の変数は使えなくなります。\n\nコード例：\n```rust\nlet s1 = String::from(\"hello\");  // s1 が持ち主\nlet s2 = s1;  // 所有権が s2 に移動！\n// ↓ s1 はもう使えない（エラーになる）\n// println!(\"{}\", s1);  // ダメ！\nprintln!(\"{}\", s2);  // OK！\n```\n\nイメージ：\nおもちゃを友だちにあげたら、自分はもう使えない。これがムーブです。",
  "rust_lesson2_ex1_slide2_title": "ムーブ（移動）",
  "rust_lesson2_ex1_slide3_content": "Rust独自の概念「所有権」を学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "rust_lesson2_ex1_slide3_title": "やってみよう！",
  "rust_lesson2_ex1_title": "所有権の基本",
  "rust_lesson2_ex20_comment1": "T を型パラメータとして使います。",
  "rust_lesson2_ex20_comment2": "i32 型で呼び出します。",
  "rust_lesson2_ex20_comment3": "&str 型で呼び出します。",
  "rust_lesson2_ex20_slide1_content": "# <T> で型を「あとで決める」\n\n関数名の後に `<T>` をつけて、`T` を「型」として使います。\n\n**コード例：**\n```rust\n// Tはどんな型でもOK\nfn first<T>(arr: &[T]) -> &T {\n    &arr[0]  // 最初の要素を返す\n}\n\n// 使い方\nfirst(&[1, 2, 3]);         // Tはi32\nfirst(&[\\\"a\\\", \\\"b\\\", \\\"c\\\"]);   // Tは&str\n```\n\n**読み方：**\n- `<T>` → 「Tという名前の型を使うよ」\n- `T` は慣習で「Type（型）」の頭文字\n- 複数の型が必要なら `<T, U>` のように書く",
  "rust_lesson2_ex20_slide1_title": "ジェネリック関数の書き方",
  "rust_lesson2_ex20_title": "ジェネリック関数の書き方",
  "rust_lesson2_ex2_comment1": "String を作成します。",
  "rust_lesson2_ex2_comment2": "s1 の所有権を s2 に移動します。",
  "rust_lesson2_ex2_comment3": "マクロを使用して、文字列と改行を標準出力に出力します。",
  "rust_lesson2_ex2_description": "所有権を移さずに値を借りる「参照」を学びましょう。",
  "rust_lesson2_ex2_slide1_content": "# 所有権は「移動」する\n\n変数を別の変数に代入すると、所有権が **移動（ムーブ）** します。元の変数は使えなくなります。\n\n**コード例：**\n```rust\nlet s1 = String::from(\\\"hello\\\");  // s1 が持ち主\nlet s2 = s1;  // 所有権が s2 に移動！\n// ↓ s1 はもう使えない（エラーになる）\n// println!(\\\"{}\\\", s1);  // ダメ！\nprintln!(\\\"{}\\\", s2);  // OK！\n```\n\n**イメージ：**\nおもちゃを友だちにあげたら、自分はもう使えない。これがムーブです。",
  "rust_lesson2_ex2_slide1_title": "ムーブ（移動）",
  "rust_lesson2_ex2_slide2_content": "# 関数に借りてもらう\n\n関数にデータを渡すとき、`&` をつけると「借りる」形になります。元の変数はそのまま使い続けられます。\n\nコード例：\n```rust\nfn calc_len(s: &String) -> usize {\n    s.len()  // 長さを返す\n}\n\nfn main() {\n    let text = String::from(\"hello\");\n    let len = calc_len(&text);  // textを貸す\n    // text はまだ使える！\n    println!(\"{}の長さは{}\", text, len);\n}\n```\n\n`&String` は「Stringを借りる」という意味です。",
  "rust_lesson2_ex2_slide2_title": "参照の使い方",
  "rust_lesson2_ex2_slide3_content": "所有権を移さずに値を借りる「参照」を学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "rust_lesson2_ex2_slide3_title": "やってみよう！",
  "rust_lesson2_ex2_title": "ムーブ（移動）",
  "rust_lesson2_ex3_comment1": "mut で可変変数にする",
  "rust_lesson2_ex3_description": "所有権を移さずに値を借りる「参照」を学びましょう。",
  "rust_lesson2_ex3_slide1_content": "# 「書き換えできる」借り方\n\n普通の参照 `&` は「見るだけ」ですが、可変参照 `&mut` は「変更もできる」借り方です。\n\nたとえるなら：\n- `&` = 本を見せてもらう（読むだけ）\n- `&mut` = ノートを借りる（書き込みOK）\n\n大事なルール：\n- 可変参照は同時に1つだけ！\n- 「みんなで見る」か「1人で書く」かのどちらか\n\nこのルールで、データが同時に書き換えられるバグを防いでいます。",
  "rust_lesson2_ex3_slide1_title": "可変参照（かへんさんしょう）とは？",
  "rust_lesson2_ex3_slide2_content": "# mut が2か所に必要\n\n変更できるようにするには、変数と参照の両方に `mut` が必要です。\n\nコード例：\n```rust\n// 1. 変数を mut で作る\nlet mut s = String::from(\"hello\");\n\n// 2. &mut で可変参照を渡す\nchange(&mut s);\n\nfn change(s: &mut String) {\n    s.push_str(\" world\");  // 変更できる！\n}\n```\n\nポイント：\n- `let mut 変数` で変数を変更可能に\n- `&mut 変数` で可変参照を作る\n- 両方ないと変更できない！",
  "rust_lesson2_ex3_slide2_title": "&mut の使い方",
  "rust_lesson2_ex3_slide3_content": "参照先の値を変更できる「可変参照」を学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "rust_lesson2_ex3_slide3_title": "やってみよう！",
  "rust_lesson2_ex3_title": "参照と借用",
  "rust_lesson2_ex4_comment1": "関数（print_len）を定義します。",
  "rust_lesson2_ex4_comment2": "& で参照を渡します。",
  "rust_lesson2_ex4_description": "関連するデータをまとめる「構造体」を学びましょう。",
  "rust_lesson2_ex4_slide1_content": "# 関数に借りてもらう\n\n関数にデータを渡すとき、`&` をつけると「借りる」形になります。元の変数はそのまま使い続けられます。\n\n**コード例：**\n```rust\nfn calc_len(s: &String) -> usize {\n    s.len()  // 長さを返す\n}\n\nfn main() {\n    let text = String::from(\\\"hello\\\");\n    let len = calc_len(&text);  // textを貸す\n    // text はまだ使える！\n    println!(\\\"{}の長さは{}\\\", text, len);\n}\n```\n\n`&String` は「Stringを借りる」という意味です。",
  "rust_lesson2_ex4_slide1_title": "参照の使い方",
  "rust_lesson2_ex4_slide2_content": "# struct キーワードで定義\n\n`struct 名前 { フィールド }` で構造体を定義します。フィールドには名前と型を書きます。\n\nコード例：\n```rust\n// Point 構造体を定義\nstruct Point {\n    x: i32,  // xフィールド（整数）\n    y: i32,  // yフィールド（整数）\n}\n\n// 使い方\nlet p = Point { x: 10, y: 20 };\nprintln!(\"x={}, y={}\", p.x, p.y);\n```\n\nポイント：\n- `struct 名前` で構造体を作る\n- `{ フィールド名: 型 }` でどんなデータを持つか決める\n- `.フィールド名` でアクセス",
  "rust_lesson2_ex4_slide2_title": "struct の定義のしかた",
  "rust_lesson2_ex4_slide3_content": "関連するデータをまとめる「構造体」を学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "rust_lesson2_ex4_slide3_title": "やってみよう！",
  "rust_lesson2_ex4_title": "参照の使い方",
  "rust_lesson2_ex5_comment1": "impl でメソッドを実装",
  "rust_lesson2_ex5_description": "参照先の値を変更できる「可変参照」を学びましょう。",
  "rust_lesson2_ex5_slide1_content": "# 実装ブロック\n\nimpl ブロックで、構造体にメソッドを追加できます。`self` で自分自身を参照します。",
  "rust_lesson2_ex5_slide1_title": "impl とは？",
  "rust_lesson2_ex5_slide2_content": "# &self を使う\n\nメソッドの最初の引数は `&self` です。\n\nコード例：\n```rust\nimpl Rect {\n    fn area(&self) -> i32 {\n        self.width * self.height\n    }\n}\n```",
  "rust_lesson2_ex5_slide2_title": "メソッドの定義",
  "rust_lesson2_ex5_slide3_content": "構造体にメソッドを追加する「impl」を学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "rust_lesson2_ex5_slide3_title": "やってみよう！",
  "rust_lesson2_ex5_title": "可変参照",
  "rust_lesson2_ex6_comment1": "関数（add_world）を定義します。",
  "rust_lesson2_ex6_comment2": "参照先を変更します。",
  "rust_lesson2_ex6_comment3": "mut で可変変数にします。",
  "rust_lesson2_ex6_comment4": "&mut で可変参照を渡します。",
  "rust_lesson2_ex6_description": "複数の状態を表す「列挙型（enum）」を学びましょう。",
  "rust_lesson2_ex6_slide1_content": "# mut が2か所に必要\n\n変更できるようにするには、変数と参照の両方に `mut` が必要です。\n\n**コード例：**\n```rust\n// 1. 変数を mut で作る\nlet mut s = String::from(\\\"hello\\\");\n\n// 2. &mut で可変参照を渡す\nchange(&mut s);\n\nfn change(s: &mut String) {\n    s.push_str(\\\" world\\\");  // 変更できる！\n}\n```\n\n**ポイント：**\n- `let mut 変数` で変数を変更可能に\n- `&mut 変数` で可変参照を作る\n- 両方ないと変更できない！",
  "rust_lesson2_ex6_slide1_title": "&mut の使い方",
  "rust_lesson2_ex6_slide2_content": "# バリアントを列挙\n\n`enum 名前 { バリアント1, バリアント2, ... }` で定義します。\n\nコード例：\n```rust\nenum Color {\n    Red,\n    Green,\n    Blue,\n}\nlet c = Color::Red;\n```",
  "rust_lesson2_ex6_slide2_title": "enum の定義",
  "rust_lesson2_ex6_slide3_content": "複数の状態を表す「列挙型（enum）」を学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "rust_lesson2_ex6_slide3_title": "やってみよう！",
  "rust_lesson2_ex6_title": "&mut の使い方",
  "rust_lesson2_ex7_comment1": "Some で値があることを示す",
  "rust_lesson2_ex7_description": "関連するデータをまとめる「構造体」を学びましょう。",
  "rust_lesson2_ex7_slide1_content": "# 「あるかもしれない、ないかもしれない」\n\nOption<T> は、値が「あるかもしれないし、ないかもしれない」ことを表す型です。\n\nたとえば：\n- 辞書で単語を探す → 見つかるかもしれないし、ないかもしれない\n- ゲームでアイテムを拾う → 落ちてるかもしれないし、ないかもしれない\n\n2つの状態：\n- `Some(値)` → 値がある！\n- `None` → 値がない...\n\n他の言語では `null` を使いますが、Rustでは `Option` で安全に扱います。",
  "rust_lesson2_ex7_slide1_title": "Option（オプション）とは？",
  "rust_lesson2_ex7_slide2_content": "# match で安全に取り出す\n\n`match` を使って「ある場合」と「ない場合」で処理を分けます。\n\nコード例：\n```rust\nlet x: Option<i32> = Some(5);  // 値あり\n\nmatch x {\n    Some(n) => println!(\"値は{}です\", n),  // 5\n    None => println!(\"値がありません\"),\n}\n```\n\nなぜ安全？\n- `null` のように「あるつもりでアクセスしたら無かった」エラーが起きない\n- 「ない場合」の処理を書かないとコンパイルエラーになる\n- 強制的に両方のケースを考えることになる！",
  "rust_lesson2_ex7_slide2_title": "Option の使い方",
  "rust_lesson2_ex7_slide3_content": "値があるかないかを表す「Option」を学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "rust_lesson2_ex7_slide3_title": "やってみよう！",
  "rust_lesson2_ex7_title": "構造体を定義しよう",
  "rust_lesson2_ex8_comment1": "構造体（Rect）を定義します。",
  "rust_lesson2_ex8_comment2": "構造体のインスタンスを作成します。",
  "rust_lesson2_ex8_comment3": "マクロを使用して、文字列と改行を標準出力に出力します。",
  "rust_lesson2_ex8_description": "成功と失敗を表す「Result」を学びましょう。",
  "rust_lesson2_ex8_slide1_content": "# struct キーワードで定義\n\n`struct 名前 { フィールド }` で構造体を定義します。フィールドには名前と型を書きます。\n\n**コード例：**\n```rust\n// Point 構造体を定義\nstruct Point {\n    x: i32,  // xフィールド（整数）\n    y: i32,  // yフィールド（整数）\n}\n\n// 使い方\nlet p = Point { x: 10, y: 20 };\nprintln!(\\\"x={}, y={}\\\", p.x, p.y);\n```\n\n**ポイント：**\n- `struct 名前` で構造体を作る\n- `{ フィールド名: 型 }` でどんなデータを持つか決める\n- `.フィールド名` でアクセス",
  "rust_lesson2_ex8_slide1_title": "struct の定義のしかた",
  "rust_lesson2_ex8_slide2_content": "# match で成功と失敗を分ける\n\n`match` で「成功したら」「失敗したら」の処理を書き分けます。\n\nコード例：\n```rust\nfn divide(a: i32, b: i32) -> Result<i32, String> {\n    if b == 0 {\n        return Err(\"0で割れません\".to_string());\n    }\n    Ok(a / b)  // 成功なら答えを返す\n}\n\nmatch divide(10, 2) {\n    Ok(v) => println!(\"答えは{}\", v),\n    Err(e) => println!(\"エラー: {}\", e),\n}\n```\n\nポイント：\n- `Ok(値)` で成功を返す\n- `Err(エラー)` で失敗を返す",
  "rust_lesson2_ex8_slide2_title": "Result の使い方",
  "rust_lesson2_ex8_slide3_content": "成功と失敗を表す「Result」を学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "rust_lesson2_ex8_slide3_title": "やってみよう！",
  "rust_lesson2_ex8_title": "struct の定義のしかた",
  "rust_lesson2_ex9_comment1": "trait でトレイトを定義",
  "rust_lesson2_ex9_description": "構造体にメソッドを追加する「impl」を学びましょう。",
  "rust_lesson2_ex9_slide1_content": "# 「できること」の約束\n\nトレイト は、「この型はこういうことができる」という約束を定義します。\n\nたとえば「鳴ける」という約束：\n- 犬は「ワン」と鳴く\n- 猫は「ニャー」と鳴く\n- 両方とも「鳴ける」能力がある\n\nトレイトは「鳴ける動物は、鳴き声を出すメソッドを持つ」という約束です。\n\n他の言語との比較：\n- Java: インターフェース\n- TypeScript: インターフェース\n\nに似た概念です。",
  "rust_lesson2_ex9_slide1_title": "トレイトとは？",
  "rust_lesson2_ex9_slide2_content": "# 約束を作って、守る\n\n1. `trait` で「約束」を定義\n2. `impl トレイト for 型` で「約束を守る」実装をする\n\nコード例：\n```rust\n// 1. トレイト（約束）を定義\ntrait Speak {\n    fn speak(&self);  // 鳴くメソッドを持つ約束\n}\n\n// 2. Dog構造体がトレイトを実装\nstruct Dog;\nimpl Speak for Dog {\n    fn speak(&self) {\n        println!(\"woof\");\n    }\n}\n```\n\n「DogはSpeakができる」ということになります。",
  "rust_lesson2_ex9_slide2_title": "trait の定義と実装",
  "rust_lesson2_ex9_slide3_content": "共通の振る舞いを定義する「トレイト」を学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "rust_lesson2_ex9_slide3_title": "やってみよう！",
  "rust_lesson2_ex9_title": "impl でメソッドを追加",
  "rust_lesson2_title": "Rust II - 所有権とトレイト",
  "rust_lesson3_course_description": "Rustの高度な機能を学びます。ライフタイム、イテレータ、クロージャなど、Rustの真髄を身につけましょう。",
  "rust_lesson3_course_title": "Rust III - ライフタイムとイテレータ",
  "rust_lesson3_ex10_comment1": "filter で条件に合う要素を絞り込みます。",
  "rust_lesson3_ex10_description": "文字列型の違いを理解しましょう。",
  "rust_lesson3_ex10_slide1_content": "# filter は参照の参照を受け取る\n\n`filter` のクロージャは、参照の参照（`&&T`）を受け取ります。そのため、値を使うには `**x` と2回参照を外す必要があります。\n\n**なぜ？**\n- `iter()` は参照（`&T`）を返す\n- `filter` はそれをさらに参照で渡す（`&&T`）\n\n**書き方：**\n```rust\n// **x で値を取り出す\n.filter(|x| **x > 2)\n\n// または * を引数につける\n.filter(|&x| *x > 2)\n```\n\n最初は混乱しますが、慣れれば大丈夫！",
  "rust_lesson3_ex10_slide1_title": "** に注意！",
  "rust_lesson3_ex10_slide2_content": "# 相互変換\n\n```rust\n// &str -> String\nlet s = \"hello\".to_string();\n\n// String -> &str\nlet slice: &str = &s;\n```",
  "rust_lesson3_ex10_slide2_title": "変換",
  "rust_lesson3_ex10_slide3_content": "文字列型の違いを理解しましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "rust_lesson3_ex10_slide3_title": "やってみよう！",
  "rust_lesson3_ex10_title": "** に注意！",
  "rust_lesson3_ex11_description": "要素を1つの値にまとめるfoldを学びましょう。",
  "rust_lesson3_ex11_title": "fold で畳み込み",
  "rust_lesson3_ex12_comment1": "fold で畳み込みます。",
  "rust_lesson3_ex12_slide1_content": "# 合計、積、結合など\n\n```rust\n// 積\nv.iter().fold(1, |acc, x| acc * x)\n\n// 文字列結合\nwords.iter().fold(String::new(), |acc, s| acc + s)\n```",
  "rust_lesson3_ex12_slide1_title": "様々な畳み込み",
  "rust_lesson3_ex12_title": "様々な畳み込み",
  "rust_lesson3_ex13_description": "エラーを簡潔に伝播させましょう。",
  "rust_lesson3_ex13_title": "? 演算子でエラー伝播",
  "rust_lesson3_ex14_comment1": "? でエラーを伝播します。",
  "rust_lesson3_ex14_slide1_content": "# 簡潔なエラー処理\n\n```rust\n// ? を使わない場合\nmatch result {\n    Ok(v) => v,\n    Err(e) => return Err(e),\n}\n\n// ? を使う\nresult?\n```",
  "rust_lesson3_ex14_slide1_title": "match の省略形",
  "rust_lesson3_ex14_title": "match の省略形",
  "rust_lesson3_ex15_description": "Option/Resultのデフォルト値を設定しましょう。",
  "rust_lesson3_ex15_title": "unwrap_or でデフォルト値",
  "rust_lesson3_ex16_comment1": "unwrap_or でデフォルト値を設定します。",
  "rust_lesson3_ex16_slide1_content": "# 遅延評価\n\n```rust\n// クロージャで計算\nlet value = x.unwrap_or_else(|| expensive_computation());\n```",
  "rust_lesson3_ex16_slide1_title": "unwrap_or_else",
  "rust_lesson3_ex16_title": "unwrap_or_else",
  "rust_lesson3_ex17_description": "Vecに要素を追加しましょう。",
  "rust_lesson3_ex17_title": "Vec のメソッド push",
  "rust_lesson3_ex18_comment1": "push で要素を追加します。",
  "rust_lesson3_ex18_slide1_content": "# 可変参照\n\n```rust\n// mut が必要\nlet mut v = Vec::new();\nv.push(1);\nv.push(2);\n```",
  "rust_lesson3_ex18_slide1_title": "mut が必要",
  "rust_lesson3_ex18_title": "mut が必要",
  "rust_lesson3_ex19_description": "文字列型の違いを理解しましょう。",
  "rust_lesson3_ex19_title": "String と &str",
  "rust_lesson3_ex1_comment1": "'a でライフタイムを定義",
  "rust_lesson3_ex1_description": "参照の有効期間を表すライフタイムを学びましょう。",
  "rust_lesson3_ex1_slide1_content": "# 参照の「寿命」を示す印\n\nライフタイム は、参照がいつまで使えるかを示す印です。`'a`（アポストロフィ・エー）のように書きます。\n\nなぜ必要？\n参照は「借りている」状態。借りた元のデータが消えたら、参照も使えなくなります。\n\nたとえば：\n- 図書館で借りた本 → 図書館が閉まったら読めない\n- 参照で借りたデータ → 元のデータが消えたら使えない\n\nライフタイムは「この参照はこの範囲で有効だよ」とコンパイラに伝える仕組みです。",
  "rust_lesson3_ex1_slide1_title": "ライフタイムとは？",
  "rust_lesson3_ex1_slide2_content": "# 危険なバグを防ぐ\n\nダングリング参照 という危険なバグがあります。これは「もう存在しないデータ」を指し続けている参照のことです。\n\n例：\n```rust\nfn longest<'a>(x: &'a str, y: &'a str) -> &'a str {\n    if x.len() > y.len() { x } else { y }\n}\n```\n\n`'a` の意味：\n- 引数 `x` と `y` は同じライフタイム `'a` を持つ\n- 戻り値も同じライフタイム `'a` を持つ\n- つまり「xとyが両方有効な間、戻り値も有効」という約束\n\nRustはこれを自動でチェックしてくれます！",
  "rust_lesson3_ex1_slide2_title": "なぜ必要？",
  "rust_lesson3_ex1_slide3_content": "参照の有効期間を表すライフタイムを学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "rust_lesson3_ex1_slide3_title": "やってみよう！",
  "rust_lesson3_ex1_title": "ライフタイムの基本",
  "rust_lesson3_ex20_comment1": "to_string で String に変換します。",
  "rust_lesson3_ex20_slide1_content": "# 相互変換\n\n```rust\n// &str -> String\nlet s = \\\"hello\\\".to_string();\n\n// String -> &str\nlet slice: &str = &s;\n```",
  "rust_lesson3_ex20_slide1_title": "変換",
  "rust_lesson3_ex20_title": "変換",
  "rust_lesson3_ex2_comment1": "'a でライフタイムを定義します。",
  "rust_lesson3_ex2_description": "周囲の変数を使える無名関数「クロージャ」を学びましょう。",
  "rust_lesson3_ex2_slide1_content": "# 危険なバグを防ぐ\n\n**ダングリング参照** という危険なバグがあります。これは「もう存在しないデータ」を指し続けている参照のことです。\n\n**例：**\n```rust\nfn longest<'a>(x: &'a str, y: &'a str) -> &'a str {\n    if x.len() > y.len() { x } else { y }\n}\n```\n\n**`'a` の意味：**\n- 引数 `x` と `y` は同じライフタイム `'a` を持つ\n- 戻り値も同じライフタイム `'a` を持つ\n- つまり「xとyが両方有効な間、戻り値も有効」という約束\n\nRustはこれを自動でチェックしてくれます！",
  "rust_lesson3_ex2_slide1_title": "なぜ必要？",
  "rust_lesson3_ex2_slide2_content": "# | | で引数を囲む\n\nクロージャは `|引数| 処理` という形で書きます。`||` は「パイプ」と呼ばれます。\n\nいろいろな書き方：\n```rust\n// 引数なし\n|| println!(\"Hello\")\n\n// 引数あり\n|x, y| x + y\n\n// 複数行のブロック\n|x| {\n    let y = x * 2;\n    y + 1\n}\n```\n\nポイント：\n- 引数を `| |` で囲む（関数の `()` の代わり）\n- 型は省略できることが多い（Rustが推測してくれる）",
  "rust_lesson3_ex2_slide2_title": "クロージャの書き方",
  "rust_lesson3_ex2_slide3_content": "周囲の変数を使える無名関数「クロージャ」を学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "rust_lesson3_ex2_slide3_title": "やってみよう！",
  "rust_lesson3_ex2_title": "なぜ必要？",
  "rust_lesson3_ex3_comment1": "iter でイテレータを取得",
  "rust_lesson3_ex3_description": "周囲の変数を使える無名関数「クロージャ」を学びましょう。",
  "rust_lesson3_ex3_slide1_content": "# 要素を1つずつ取り出す仕組み\n\nイテレータ は、ベクタなどのデータを「1つずつ順番に」取り出す仕組みです。\n\nたとえば：\n- 行列に並んでいる人を1人ずつ呼ぶ\n- 引き出しの中身を1つずつ出す\n\nコード例：\n```rust\nlet v = vec![1, 2, 3];\nfor x in v.iter() {\n    println!(\"{}\", x);  // 1, 2, 3 と順番に表示\n}\n```\n\n`iter()` で「順番に取り出す準備」をして、`for` で1つずつ処理します。",
  "rust_lesson3_ex3_slide1_title": "イテレータとは？",
  "rust_lesson3_ex3_slide2_content": "# 借りるか、もらうか\n\n3種類の iter があり、所有権の扱いが違います。\n\n3つの違い：\n```rust\nv.iter()       // 参照で借りる（&T）\nv.iter_mut()   // 変更可能で借りる（&mut T）\nv.into_iter()  // 所有権をもらう（T）\n```\n\n使い分け：\n- `iter()` → 見るだけ（元のベクタも使える）\n- `iter_mut()` → 中身を変更したい\n- `into_iter()` → ベクタごともらう（元は使えない）\n\n普通は `iter()` を使うことが多いです。",
  "rust_lesson3_ex3_slide2_title": "3つの iter メソッド",
  "rust_lesson3_ex3_slide3_content": "要素を順番に処理するイテレータを学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "rust_lesson3_ex3_slide3_title": "やってみよう！",
  "rust_lesson3_ex3_title": "クロージャの基本",
  "rust_lesson3_ex4_comment1": "|x| でクロージャの引数を定義します。",
  "rust_lesson3_ex4_description": "各要素を変換するmapを学びましょう。",
  "rust_lesson3_ex4_slide1_content": "# | | で引数を囲む\n\nクロージャは `|引数| 処理` という形で書きます。`||` は「パイプ」と呼ばれます。\n\n**いろいろな書き方：**\n```rust\n// 引数なし\n|| println!(\\\"Hello\\\")\n\n// 引数あり\n|x, y| x + y\n\n// 複数行のブロック\n|x| {\n    let y = x * 2;\n    y + 1\n}\n```\n\n**ポイント：**\n- 引数を `| |` で囲む（関数の `()` の代わり）\n- 型は省略できることが多い（Rustが推測してくれる）",
  "rust_lesson3_ex4_slide1_title": "クロージャの書き方",
  "rust_lesson3_ex4_slide2_content": "# map だけでは実行されない！\n\nRustのイテレータは 遅延評価 といって、「本当に必要になるまで処理しない」仕組みです。\n\nなぜ？\n無駄な計算を省けるから。100万件あっても、最初の10件だけ欲しいなら10件だけ処理すればいい。\n\ncollect() で実行：\n```rust\n// これだけでは何も起きない\nv.iter().map(|x| x * 2);\n\n// collect() で実行してベクタに変換\nlet result: Vec<_> = v.iter().map(|x| x * 2).collect();\n```\n\n`collect()` は「今すぐ全部処理して結果をちょうだい」という意味です。",
  "rust_lesson3_ex4_slide2_title": "遅延評価（ちえんひょうか）",
  "rust_lesson3_ex4_slide3_content": "各要素を変換するmapを学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "rust_lesson3_ex4_slide3_title": "やってみよう！",
  "rust_lesson3_ex4_title": "クロージャの書き方",
  "rust_lesson3_ex5_comment1": "filter で条件に合う要素を絞り込む",
  "rust_lesson3_ex5_description": "要素を順番に処理するイテレータを学びましょう。",
  "rust_lesson3_ex5_slide1_content": "# 条件に合うものだけ残す\n\nfilter は、条件を満たす要素だけを残し、他を捨てます。\n\nたとえば：\n- 80点以上の人だけ残す\n- 偶数だけ残す\n- 「あ」から始まる名前だけ残す\n\nコード例：\n```rust\nlet v = vec![1, 2, 3, 4, 5];\nlet evens: Vec<_> = v.iter()\n    .filter(|x| **x % 2 == 0)  // 偶数だけ\n    .collect();\n// [2, 4]\n```\n\n条件が `true` の要素だけが残ります。",
  "rust_lesson3_ex5_slide1_title": "filter（フィルター）とは？",
  "rust_lesson3_ex5_slide2_content": "# filter は参照の参照を受け取る\n\n`filter` のクロージャは、参照の参照（`&&T`）を受け取ります。そのため、値を使うには `**x` と2回参照を外す必要があります。\n\nなぜ？\n- `iter()` は参照（`&T`）を返す\n- `filter` はそれをさらに参照で渡す（`&&T`）\n\n書き方：\n```rust\n// **x で値を取り出す\n.filter(|x| **x > 2)\n\n// または * を引数につける\n.filter(|&x| *x > 2)\n```\n\n最初は混乱しますが、慣れれば大丈夫！",
  "rust_lesson3_ex5_slide2_title": "** に注意！",
  "rust_lesson3_ex5_slide3_content": "条件に合う要素だけを取り出しましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "rust_lesson3_ex5_slide3_title": "やってみよう！",
  "rust_lesson3_ex5_title": "イテレータの基本",
  "rust_lesson3_ex6_comment1": "指定された回数や範囲で、繰り返し処理（ループ）を行います。",
  "rust_lesson3_ex6_description": "要素を1つの値にまとめるfoldを学びましょう。",
  "rust_lesson3_ex6_slide1_content": "# 借りるか、もらうか\n\n3種類の iter があり、所有権の扱いが違います。\n\n**3つの違い：**\n```rust\nv.iter()       // 参照で借りる（&T）\nv.iter_mut()   // 変更可能で借りる（&mut T）\nv.into_iter()  // 所有権をもらう（T）\n```\n\n**使い分け：**\n- `iter()` → 見るだけ（元のベクタも使える）\n- `iter_mut()` → 中身を変更したい\n- `into_iter()` → ベクタごともらう（元は使えない）\n\n普通は `iter()` を使うことが多いです。",
  "rust_lesson3_ex6_slide1_title": "3つの iter メソッド",
  "rust_lesson3_ex6_slide2_content": "# 合計、積、結合など\n\n```rust\n// 積\nv.iter().fold(1, |acc, x| acc * x)\n\n// 文字列結合\nwords.iter().fold(String::new(), |acc, s| acc + s)\n```",
  "rust_lesson3_ex6_slide2_title": "様々な畳み込み",
  "rust_lesson3_ex6_slide3_content": "要素を1つの値にまとめるfoldを学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "rust_lesson3_ex6_slide3_title": "やってみよう！",
  "rust_lesson3_ex6_title": "3つの iter メソッド",
  "rust_lesson3_ex7_comment1": "? でエラーを伝播",
  "rust_lesson3_ex7_description": "各要素を変換するmapを学びましょう。",
  "rust_lesson3_ex7_slide1_content": "# エラーの早期リターン\n\n? は、Resultが Err の場合に早期リターンします。\n\n```rust\nfn read_file() -> Result<String, io::Error> {\n    let content = fs::read_to_string(\"file.txt\")?;\n    Ok(content)\n}\n```",
  "rust_lesson3_ex7_slide1_title": "? 演算子とは？",
  "rust_lesson3_ex7_slide2_content": "# 簡潔なエラー処理\n\n```rust\n// ? を使わない場合\nmatch result {\n    Ok(v) => v,\n    Err(e) => return Err(e),\n}\n\n// ? を使う\nresult?\n```",
  "rust_lesson3_ex7_slide2_title": "match の省略形",
  "rust_lesson3_ex7_slide3_content": "エラーを簡潔に伝播させましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "rust_lesson3_ex7_slide3_title": "やってみよう！",
  "rust_lesson3_ex7_title": "map でイテレータ変換",
  "rust_lesson3_ex8_comment1": "map で各要素を変換します。",
  "rust_lesson3_ex8_description": "Option/Resultのデフォルト値を設定しましょう。",
  "rust_lesson3_ex8_slide1_content": "# map だけでは実行されない！\n\nRustのイテレータは **遅延評価** といって、「本当に必要になるまで処理しない」仕組みです。\n\n**なぜ？**\n無駄な計算を省けるから。100万件あっても、最初の10件だけ欲しいなら10件だけ処理すればいい。\n\n**collect() で実行：**\n```rust\n// これだけでは何も起きない\nv.iter().map(|x| x * 2);\n\n// collect() で実行してベクタに変換\nlet result: Vec<_> = v.iter().map(|x| x * 2).collect();\n```\n\n`collect()` は「今すぐ全部処理して結果をちょうだい」という意味です。",
  "rust_lesson3_ex8_slide1_title": "遅延評価（ちえんひょうか）",
  "rust_lesson3_ex8_slide2_content": "# 遅延評価\n\n```rust\n// クロージャで計算\nlet value = x.unwrap_or_else(|| expensive_computation());\n```",
  "rust_lesson3_ex8_slide2_title": "unwrap_or_else",
  "rust_lesson3_ex8_slide3_content": "Option/Resultのデフォルト値を設定しましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "rust_lesson3_ex8_slide3_title": "やってみよう！",
  "rust_lesson3_ex8_title": "遅延評価（ちえんひょうか）",
  "rust_lesson3_ex9_comment1": "push で要素を追加",
  "rust_lesson3_ex9_description": "条件に合う要素だけを取り出しましょう。",
  "rust_lesson3_ex9_slide1_content": "# 末尾に追加\n\npush は、Vecの末尾に要素を追加します。\n\n```rust\nlet mut v = vec![1, 2];\nv.push(3);\n// [1, 2, 3]\n```",
  "rust_lesson3_ex9_slide1_title": "push とは？",
  "rust_lesson3_ex9_slide2_content": "# 可変参照\n\n```rust\n// mut が必要\nlet mut v = Vec::new();\nv.push(1);\nv.push(2);\n```",
  "rust_lesson3_ex9_slide2_title": "mut が必要",
  "rust_lesson3_ex9_slide3_content": "Vecに要素を追加しましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "rust_lesson3_ex9_slide3_title": "やってみよう！",
  "rust_lesson3_ex9_title": "filter で絞り込み",
  "rust_lesson3_title": "Rust III - ライフタイムとイテレータ",
  "rust_lesson4_course_description": "Rustのトレイトとスマートポインタを学びます。抽象化と所有権の高度なパターンを身につけましょう。",
  "rust_lesson4_course_title": "Rust IV - トレイトとスマートポインタ",
  "rust_lesson4_ex10_comment1": "insert でキーと値を追加します。",
  "rust_lesson4_ex10_description": "イテレータにインデックスを付けましょう。",
  "rust_lesson4_ex10_slide1_content": "# get で安全に取り出す\n\n`get()` メソッドで値を取り出せます。見つからない可能性があるので、`Option` が返ってきます。\n\n**コード例：**\n```rust\n// getはOption<&V>を返す\nif let Some(score) = scores.get(\\\"Blue\\\") {\n    println!(\\\"青チームは{}点\\\", score);\n}\n```\n\n**ポイント：**\n- キーがあれば `Some(値)` が返る\n- キーがなければ `None` が返る\n- `if let` で安全に取り出せる\n\n存在しないキーでアクセスしてもプログラムが落ちない！",
  "rust_lesson4_ex10_slide1_title": "値の取得",
  "rust_lesson4_ex10_slide2_content": "# 「何番目か」が必要なとき\n\n番号（インデックス）と要素の両方が必要なときに便利です。\n\nコード例：\n```rust\nlet v = vec![10, 20, 30];\nfor (idx, val) in v.iter().enumerate() {\n    println!(\"{}番目の値は{}\", idx, val);\n}\n// 0番目の値は10\n// 1番目の値は20\n// 2番目の値は30\n```\n\nポイント：\n- `(i, x)` でタプル（2つのセット）を受け取る\n- `i` にインデックス、`x` に要素が入る\n- インデックスは0から始まる",
  "rust_lesson4_ex10_slide2_title": "いつ使う？",
  "rust_lesson4_ex10_slide3_content": "イテレータにインデックスを付けましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "rust_lesson4_ex10_slide3_title": "やってみよう！",
  "rust_lesson4_ex10_title": "値の取得",
  "rust_lesson4_ex11_description": "一意な値の集合を管理しましょう。",
  "rust_lesson4_ex11_title": "HashSet",
  "rust_lesson4_ex12_comment1": "HashSet をインポートします。",
  "rust_lesson4_ex12_slide1_content": "# 和集合、積集合など\n\n```rust\nset1.union(&set2)\nset1.intersection(&set2)\nset1.difference(&set2)\n```",
  "rust_lesson4_ex12_slide1_title": "集合演算",
  "rust_lesson4_ex12_title": "集合演算",
  "rust_lesson4_ex13_description": "パターンマッチに条件を追加しましょう。",
  "rust_lesson4_ex13_title": "match ガード",
  "rust_lesson4_ex14_comment1": "マクロを使用して、文字列と改行を標準出力に出力します。",
  "rust_lesson4_ex14_slide1_content": "# 複雑な条件分岐\n\n```rust\nmatch Some(5) {\n    Some(x) if x % 2 == 0 => println!(\\\"even\\\"),\n    Some(x) => println!(\\\"odd: {}\\\", x),\n    None => println!(\\\"none\\\"),\n}\n```",
  "rust_lesson4_ex14_slide1_title": "使用例",
  "rust_lesson4_ex14_title": "使用例",
  "rust_lesson4_ex15_description": "トレイトを返す関数を簡潔に書きましょう。",
  "rust_lesson4_ex15_title": "impl Trait",
  "rust_lesson4_ex16_comment1": "関数（doubles）を定義します。",
  "rust_lesson4_ex16_slide1_content": "# ジェネリクスの代わり\n\n```rust\nfn print_all(iter: impl Iterator<Item = i32>) {\n    for x in iter {\n        println!(\\\"{}\\\", x);\n    }\n}\n```",
  "rust_lesson4_ex16_slide1_title": "引数にも使える",
  "rust_lesson4_ex16_title": "引数にも使える",
  "rust_lesson4_ex17_description": "イテレータをコレクションに変換しましょう。",
  "rust_lesson4_ex17_title": "collect で変換",
  "rust_lesson4_ex18_comment1": "collect でVecに変換します。",
  "rust_lesson4_ex18_slide1_content": "# 変換先を指定\n\n```rust\n// ターボフィッシュ構文\nlet v = (0..5).collect::<Vec<_>>();\n\n// 変数の型注釈\nlet v: Vec<i32> = (0..5).collect();\n```",
  "rust_lesson4_ex18_slide1_title": "型ヒント",
  "rust_lesson4_ex18_title": "型ヒント",
  "rust_lesson4_ex19_description": "イテレータにインデックスを付けましょう。",
  "rust_lesson4_ex19_title": "enumerate でインデックス付き",
  "rust_lesson4_ex1_comment1": "trait でトレイトを定義",
  "rust_lesson4_ex1_description": "共通の振る舞いを定義するトレイトを学びましょう。",
  "rust_lesson4_ex1_slide1_content": "# 「できること」の約束\n\nトレイト は、型が持つべきメソッドを定義する仕組みです。\n\nたとえば：\n- 「あいさつできる」トレイト → greet() メソッドを持つ\n- 「表示できる」トレイト → display() メソッドを持つ\n\nコード例：\n```rust\ntrait Greet {\n    fn greet(&self) -> String;  // メソッドの「約束」\n}\n```\n\nこれは「Greetできる型は、greet()メソッドを持つ」という約束です。",
  "rust_lesson4_ex1_slide1_title": "トレイトとは？（復習）",
  "rust_lesson4_ex1_slide2_content": "# impl で約束を守る\n\n構造体にトレイトを実装すると、その構造体は「約束を守る」ことになります。\n\nコード例：\n```rust\nstruct Person { name: String }\n\nimpl Greet for Person {\n    fn greet(&self) -> String {\n        format!(\"Hello, {}\", self.name)\n    }\n}\n```\n\n読み方：\n- `impl Greet for Person` → 「PersonはGreetを実装する」\n- これでPersonは「あいさつできる」ようになった！",
  "rust_lesson4_ex1_slide2_title": "トレイトの実装",
  "rust_lesson4_ex1_slide3_content": "共通の振る舞いを定義するトレイトを学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "rust_lesson4_ex1_slide3_title": "やってみよう！",
  "rust_lesson4_ex1_title": "トレイトの定義",
  "rust_lesson4_ex20_comment1": "指定された回数や範囲で、繰り返し処理（ループ）を行います。",
  "rust_lesson4_ex20_slide1_content": "# 「何番目か」が必要なとき\n\n番号（インデックス）と要素の両方が必要なときに便利です。\n\n**コード例：**\n```rust\nlet v = vec![10, 20, 30];\nfor (idx, val) in v.iter().enumerate() {\n    println!(\\\"{}番目の値は{}\\\", idx, val);\n}\n// 0番目の値は10\n// 1番目の値は20\n// 2番目の値は30\n```\n\n**ポイント：**\n- `(i, x)` でタプル（2つのセット）を受け取る\n- `i` にインデックス、`x` に要素が入る\n- インデックスは0から始まる",
  "rust_lesson4_ex20_slide1_title": "いつ使う？",
  "rust_lesson4_ex20_title": "いつ使う？",
  "rust_lesson4_ex2_comment1": "trait でトレイトを定義します。",
  "rust_lesson4_ex2_description": "トレイトを自動実装するderiveを学びましょう。",
  "rust_lesson4_ex2_slide1_content": "# impl で約束を守る\n\n構造体にトレイトを実装すると、その構造体は「約束を守る」ことになります。\n\n**コード例：**\n```rust\nstruct Person { name: String }\n\nimpl Greet for Person {\n    fn greet(&self) -> String {\n        format!(\\\"Hello, {}\\\", self.name)\n    }\n}\n```\n\n**読み方：**\n- `impl Greet for Person` → 「PersonはGreetを実装する」\n- これでPersonは「あいさつできる」ようになった！",
  "rust_lesson4_ex2_slide1_title": "トレイトの実装",
  "rust_lesson4_ex2_slide2_content": "# 覚えておくと便利な5つ\n\nよく使うderiveトレイト：\n```rust\nDebug     // {:?} でデバッグ表示できる\nClone     // .clone() でコピーを作れる\nCopy      // 代入時に自動でコピー（小さい型向け）\nPartialEq // == で比較できる\nDefault   // 初期値を自動で作れる\n```\n\n複数指定もOK：\n```rust\n#[derive(Debug, Clone, PartialEq)]\nstruct User {\n    name: String,\n    age: u32,\n}\n```\n\n`Debug` は特によく使います。デバッグ時に構造体の中身を見れて便利！",
  "rust_lesson4_ex2_slide2_title": "よく使う derive トレイト",
  "rust_lesson4_ex2_slide3_content": "トレイトを自動実装するderiveを学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "rust_lesson4_ex2_slide3_title": "やってみよう！",
  "rust_lesson4_ex2_title": "トレイトの実装",
  "rust_lesson4_ex3_comment1": "Box::new でヒープに格納",
  "rust_lesson4_ex3_description": "トレイトを自動実装するderiveを学びましょう。",
  "rust_lesson4_ex3_slide1_content": "# データを「ヒープ」に置く箱\n\nBox<T> は、データを「ヒープ」という特別な場所に置くための箱です。\n\nメモリの2つの場所：\n- スタック：小さくて速い。サイズが決まっているデータ向け\n- ヒープ：大きくて柔軟。サイズが大きいor変わるデータ向け\n\nコード例：\n```rust\nlet b = Box::new(5);  // 5をヒープに置く\nprintln!(\"{}\", *b);   // *で中身を取り出す → 5\n```\n\n`*` は「箱を開けて中身を見る」操作です。",
  "rust_lesson4_ex3_slide1_title": "Box（ボックス）とは？",
  "rust_lesson4_ex3_slide2_content": "# サイズが決まらないとき\n\nBoxは、コンパイル時にサイズがわからない型に使います。\n\nたとえば再帰的な型：\n```rust\n// リストは「値 + 次のリスト」の繰り返し\nenum List {\n    Cons(i32, Box<List>),  // Boxで次を指す\n    Nil,                   // 終わり\n}\n```\n\nなぜBoxが必要？\n- `List` の中に `List` がある → 無限に大きくなる？\n- `Box` を使うと、サイズが固定（ポインタのサイズ）になる\n\n「中身」ではなく「中身への矢印」を持つイメージです。",
  "rust_lesson4_ex3_slide2_title": "いつ使う？",
  "rust_lesson4_ex3_slide3_content": "ヒープにデータを格納するBoxを学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "rust_lesson4_ex3_slide3_title": "やってみよう！",
  "rust_lesson4_ex3_title": "derive 属性",
  "rust_lesson4_ex4_comment1": "derive でトレイトを自動実装します。",
  "rust_lesson4_ex4_description": "参照カウントでデータを共有しましょう。",
  "rust_lesson4_ex4_slide1_content": "# 覚えておくと便利な5つ\n\n**よく使うderiveトレイト：**\n```rust\nDebug     // {:?} でデバッグ表示できる\nClone     // .clone() でコピーを作れる\nCopy      // 代入時に自動でコピー（小さい型向け）\nPartialEq // == で比較できる\nDefault   // 初期値を自動で作れる\n```\n\n**複数指定もOK：**\n```rust\n#[derive(Debug, Clone, PartialEq)]\nstruct User {\n    name: String,\n    age: u32,\n}\n```\n\n`Debug` は特によく使います。デバッグ時に構造体の中身を見れて便利！",
  "rust_lesson4_ex4_slide1_title": "よく使う derive トレイト",
  "rust_lesson4_ex4_slide2_content": "# 「何人が持っているか」を数える\n\nRcは「今何人がこのデータを持っているか」を数えています。\n\nコード例：\n```rust\nlet a = Rc::new(5);\nprintln!(\"{}\", Rc::strong_count(&a));  // 1\n\nlet b = Rc::clone(&a);\nprintln!(\"{}\", Rc::strong_count(&a));  // 2\n```\n\nいつデータが消える？\n- カウントが0になったとき（誰も持っていないとき）\n- 最後の持ち主がいなくなると自動で片付けられる\n\n`Rc::clone` は「持ち主を1人増やす」操作です。",
  "rust_lesson4_ex4_slide2_title": "参照カウントの仕組み",
  "rust_lesson4_ex4_slide3_content": "参照カウントでデータを共有しましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "rust_lesson4_ex4_slide3_title": "やってみよう！",
  "rust_lesson4_ex4_title": "よく使う derive トレイト",
  "rust_lesson4_ex5_comment1": "insert でキーと値を追加",
  "rust_lesson4_ex5_description": "ヒープにデータを格納するBoxを学びましょう。",
  "rust_lesson4_ex5_slide1_content": "# 名前で引ける「辞書」\n\nHashMap は、「キー（名前）」と「値（データ）」をセットで保存する辞書です。\n\nたとえば：\n- 「青チーム」→ 10点\n- 「赤チーム」→ 15点\n\nコード例：\n```rust\nuse std::collections::HashMap;\n\nlet mut scores = HashMap::new();\nscores.insert(\"Blue\", 10);   // 追加\nscores.insert(\"Red\", 15);    // 追加\n```\n\n`use` で機能を読み込んでから使います。",
  "rust_lesson4_ex5_slide1_title": "HashMap（ハッシュマップ）とは？",
  "rust_lesson4_ex5_slide2_content": "# get で安全に取り出す\n\n`get()` メソッドで値を取り出せます。見つからない可能性があるので、`Option` が返ってきます。\n\nコード例：\n```rust\n// getはOption<&V>を返す\nif let Some(score) = scores.get(\"Blue\") {\n    println!(\"青チームは{}点\", score);\n}\n```\n\nポイント：\n- キーがあれば `Some(値)` が返る\n- キーがなければ `None` が返る\n- `if let` で安全に取り出せる\n\n存在しないキーでアクセスしてもプログラムが落ちない！",
  "rust_lesson4_ex5_slide2_title": "値の取得",
  "rust_lesson4_ex5_slide3_content": "キーと値のペアを格納しましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "rust_lesson4_ex5_slide3_title": "やってみよう！",
  "rust_lesson4_ex5_title": "Box<T>",
  "rust_lesson4_ex6_comment1": "Box::new でヒープに格納します。",
  "rust_lesson4_ex6_description": "一意な値の集合を管理しましょう。",
  "rust_lesson4_ex6_slide1_content": "# サイズが決まらないとき\n\nBoxは、コンパイル時にサイズがわからない型に使います。\n\n**たとえば再帰的な型：**\n```rust\n// リストは「値 + 次のリスト」の繰り返し\nenum List {\n    Cons(i32, Box<List>),  // Boxで次を指す\n    Nil,                   // 終わり\n}\n```\n\n**なぜBoxが必要？**\n- `List` の中に `List` がある → 無限に大きくなる？\n- `Box` を使うと、サイズが固定（ポインタのサイズ）になる\n\n「中身」ではなく「中身への矢印」を持つイメージです。",
  "rust_lesson4_ex6_slide1_title": "いつ使う？",
  "rust_lesson4_ex6_slide2_content": "# 和集合、積集合など\n\n```rust\nset1.union(&set2)\nset1.intersection(&set2)\nset1.difference(&set2)\n```",
  "rust_lesson4_ex6_slide2_title": "集合演算",
  "rust_lesson4_ex6_slide3_content": "一意な値の集合を管理しましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "rust_lesson4_ex6_slide3_title": "やってみよう！",
  "rust_lesson4_ex6_title": "いつ使う？",
  "rust_lesson4_ex7_comment1": "if でマッチガードを追加",
  "rust_lesson4_ex7_description": "参照カウントでデータを共有しましょう。",
  "rust_lesson4_ex7_slide1_content": "# 追加条件\n\n**if** でパターンに追加条件をつけられます。\n\n```rust\nmatch x {\n    n if n < 0 => println!(\"negative\"),\n    n if n > 0 => println!(\"positive\"),\n    _ => println!(\"zero\"),\n}\n```",
  "rust_lesson4_ex7_slide1_title": "match ガードとは？",
  "rust_lesson4_ex7_slide2_content": "# 複雑な条件分岐\n\n```rust\nmatch Some(5) {\n    Some(x) if x % 2 == 0 => println!(\"even\"),\n    Some(x) => println!(\"odd: {}\", x),\n    None => println!(\"none\"),\n}\n```",
  "rust_lesson4_ex7_slide2_title": "使用例",
  "rust_lesson4_ex7_slide3_content": "パターンマッチに条件を追加しましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "rust_lesson4_ex7_slide3_title": "やってみよう！",
  "rust_lesson4_ex7_title": "Rc<T>",
  "rust_lesson4_ex8_comment1": "Rc::clone で参照カウントを増やします。",
  "rust_lesson4_ex8_description": "トレイトを返す関数を簡潔に書きましょう。",
  "rust_lesson4_ex8_slide1_content": "# 「何人が持っているか」を数える\n\nRcは「今何人がこのデータを持っているか」を数えています。\n\n**コード例：**\n```rust\nlet a = Rc::new(5);\nprintln!(\\\"{}\\\", Rc::strong_count(&a));  // 1\n\nlet b = Rc::clone(&a);\nprintln!(\\\"{}\\\", Rc::strong_count(&a));  // 2\n```\n\n**いつデータが消える？**\n- カウントが0になったとき（誰も持っていないとき）\n- 最後の持ち主がいなくなると自動で片付けられる\n\n`Rc::clone` は「持ち主を1人増やす」操作です。",
  "rust_lesson4_ex8_slide1_title": "参照カウントの仕組み",
  "rust_lesson4_ex8_slide2_content": "# ジェネリクスの代わり\n\n```rust\nfn print_all(iter: impl Iterator<Item = i32>) {\n    for x in iter {\n        println!(\"{}\", x);\n    }\n}\n```",
  "rust_lesson4_ex8_slide2_title": "引数にも使える",
  "rust_lesson4_ex8_slide3_content": "トレイトを返す関数を簡潔に書きましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "rust_lesson4_ex8_slide3_title": "やってみよう！",
  "rust_lesson4_ex8_title": "参照カウントの仕組み",
  "rust_lesson4_ex9_comment1": "collect で Vec に変換",
  "rust_lesson4_ex9_description": "キーと値のペアを格納しましょう。",
  "rust_lesson4_ex9_slide1_content": "# イテレータをコレクションに\n\ncollect は、イテレータをVecやHashMapなどに変換します。\n\n```rust\nlet v: Vec<_> = (0..5).collect();\nlet s: String = vec!['a', 'b'].into_iter().collect();\n```",
  "rust_lesson4_ex9_slide1_title": "collect とは？",
  "rust_lesson4_ex9_slide2_content": "# 変換先を指定\n\n```rust\n// ターボフィッシュ構文\nlet v = (0..5).collect::<Vec<_>>();\n\n// 変数の型注釈\nlet v: Vec<i32> = (0..5).collect();\n```",
  "rust_lesson4_ex9_slide2_title": "型ヒント",
  "rust_lesson4_ex9_slide3_content": "イテレータをコレクションに変換しましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "rust_lesson4_ex9_slide3_title": "やってみよう！",
  "rust_lesson4_ex9_title": "HashMap",
  "rust_lesson4_title": "Rust IV - トレイトとスマートポインタ"
}
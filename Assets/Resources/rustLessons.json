{
  "en": {
    "rust_lesson1_course_title": "Introduction to Rust",
    "rust_lesson1_course_description": "Learn the basics of Rust programming.",
    "rust_lesson2_course_title": "Rust II - Intermediate",
    "rust_lesson2_course_description": "Learn intermediate Rust concepts.",
    "rust_lesson3_course_title": "Rust III - Advanced",
    "rust_lesson3_course_description": "Master advanced Rust techniques.",
    "rust_lesson4_course_title": "Rust IV - Expert Level",
    "rust_lesson4_course_description": "Expert-level Rust programming.",
    "rust_lesson1_ex5_slide2_content": "Learn if statements that change behavior based on conditions.\n\n(When you're ready, select \"Start Lesson\".)",
    "rust_lesson4_ex9_title": "Transform with collect",
    "rust_lesson2_ex7_slide1_content": "# \"Maybe exists, maybe not\"\n\nOption<T> is a type that represents a value that \"may or may not exist\".\n\nFor example:\n- Searching for a word in a dictionary → might find it, might not\n- Picking up an item in a game → might be there, might not\n\nTwo states:\n- `Some(value)` → value exists!\n- `None` → no value...\n\nOther languages use `null`, but Rust uses `Option` for safety.",
    "rust_lesson1_ex2_slide1_title": "Variable?",
    "rust_lesson1_ex7_description": "Using \"vectors (Vec)\", you can store lots of data in one \"long box\".",
    "rust_lesson2_ex9_slide2_content": "# Create a promise and keep it\n\n1. Define a \"promise\" with `trait`\n2. Implement the promise with `impl Trait for Type`\n\nCode example:\n```rust\n// 1. Define a trait (promise)\ntrait Speak {\n    fn speak(&self);  // Promise to have a speak method\n}\n\n// 2. Dog struct implements the trait\nstruct Dog;\nimpl Speak for Dog {\n    fn speak(&self) {\n        println!(\"woof\");\n    }\n}\n```\n\n\"Dog can Speak\" is now established.",
    "rust_lesson4_ex4_description": "Share data with reference counting.",
    "rust_lesson4_ex5_slide1_content": "# A \"dictionary\" you can look up by name\n\nHashMap is a dictionary that stores \"key (name)\" and \"value (data)\" pairs.\n\nFor example:\n- \"Blue Team\" → 10 points\n- \"Red Team\" → 15 points\n\nCode example:\n```rust\nuse std::collections::HashMap;\n\nlet mut scores = HashMap::new();\nscores.insert(\"Blue\", 10);   // Add\nscores.insert(\"Red\", 15);    // Add\n```\n\nLoad the feature with `use` before using it.",
    "rust_lesson3_ex4_title": "Transform iterators with map",
    "rust_lesson4_ex1_slide3_content": "Learn traits that define common behaviors.\n\n(When you're ready, select \"Start Lesson\".)",
    "rust_lesson1_ex4_description": "Learn \"+=\" and \"-=\" for easily increasing or decreasing variable values.",
    "rust_lesson1_ex2_description": "Let's use \"variables\" to name and store data. Create variables with let.",
    "rust_lesson4_ex4_slide2_title": "How reference counting works",
    "rust_lesson3_ex8_slide2_title": "unwrap_or_else",
    "rust_lesson4_ex10_comment1": "The first i gets the index, the second item gets the element",
    "rust_lesson3_ex6_slide1_content": "# Cumulative processing\n\nfold accumulates elements one by one with an initial value and a function.\n\n```rust\nlet v = vec![1, 2, 3];\nlet sum = v.iter().fold(0, |acc, x| acc + x);\n// 6\n```",
    "rust_lesson4_ex2_slide2_title": "Commonly used derive traits",
    "rust_lesson3_ex10_slide3_content": "Understand the difference between string types.\n\n(When you're ready, select \"Start Lesson\".)",
    "rust_lesson1_ex4_slide2_content": "Learn \"+=\" and \"-=\" for easily increasing or decreasing variable values.\n\n(When you're ready, select \"Start Lesson\".)",
    "rust_lesson3_ex4_slide3_title": "Let's Try It!",
    "rust_lesson3_ex5_slide1_title": "filter?",
    "rust_lesson4_ex5_description": "Store key-value pairs.",
    "rust_lesson3_ex5_description": "Extract only elements that match a condition.",
    "rust_lesson2_ex2_slide2_content": "# Have a function borrow it\n\nWhen passing data to a function, adding `&` means \"borrow\". The original variable can still be used.\n\nCode example:\n```rust\nfn calc_len(s: &String) -> usize {\n    s.len()  // Return length\n}\n\nfn main() {\n    let text = String::from(\"hello\");\n    let len = calc_len(&text);  // Lend text\n    // text is still usable!\n    println!(\"Length of {} is {}\", text, len);\n}\n```\n\n`&String` means \"borrow a String\".",
    "rust_lesson4_ex7_slide3_content": "Add conditions to pattern matching.\n\n(When you're ready, select \"Start Lesson\".)",
    "rust_lesson3_ex8_slide2_content": "# Lazy evaluation\n\n```rust\n// Compute with closure\nlet value = x.unwrap_or_else(|| expensive_computation());\n```",
    "rust_lesson4_ex7_title": "match guards",
    "rust_lesson3_ex7_title": "Error propagation with ?",
    "rust_lesson4_ex1_description": "Learn traits that define common behaviors.",
    "rust_lesson2_ex1_slide2_content": "# Ownership is \"moved\"\n\nWhen assigning a variable to another variable, ownership moves. The original variable becomes unusable.\n\nCode example:\n```rust\nlet s1 = String::from(\"hello\");  // s1 is the owner\nlet s2 = s1;  // Ownership moves to s2!\n// ↓ s1 can no longer be used (error)\n// println!(\"{}\", s1);  // Error!\nprintln!(\"{}\", s2);  // OK!\n```\n\nImagine:\nIf you give a toy to a friend, you can't use it anymore. This is a move.",
    "rust_lesson1_ex8_slide1_title": "dictionary(HashMap)?",
    "rust_lesson4_ex3_slide2_content": "# When size is unknown\n\nBox is used for types whose size isn't known at compile time.\n\nFor example, recursive types:\n```rust\n// A list is \"value + next list\" repeated\nenum List {\n    Cons(i32, Box<List>),  // Box points to next\n    Nil,                   // End\n}\n```\n\nWhy is Box needed?\n- `List` contains `List` → infinitely large?\n- Using `Box` makes the size fixed (pointer size)\n\nThink of holding \"a pointer to the content\" instead of \"the content itself\".",
    "rust_lesson2_ex10_title": "Let's use generics",
    "rust_lesson2_ex8_slide3_title": "Let's Try It!",
    "rust_lesson3_ex9_slide2_content": "# mut is required\n\n```rust\n// mut is needed\nlet mut v = Vec::new();\nv.push(1);\nv.push(2);\n```",
    "rust_lesson4_ex4_title": "Rc<T>",
    "rust_lesson2_ex3_comment1": "mut makes a mutable variable",
    "rust_lesson4_ex5_slide3_title": "Let's Try It!",
    "rust_lesson2_ex6_slide2_content": "# Enumerate variants\n\nDefine with `enum Name { Variant1, Variant2, ... }`.\n\nCode example:\n```rust\nenum Color {\n    Red,\n    Green,\n    Blue,\n}\nlet c = Color::Red;\n```",
    "rust_lesson1_ex1_comment1": "Display Hello, Rust!",
    "rust_lesson1_ex1_slide1_content": "# A safe and fast modern programming language!\n\nRust is a programming language that's very good at \"preventing mistakes in advance\".\n\nWhat makes Rust great:\n- Finds program mistakes before execution\n- Runs very fast\n- Voted the \"most loved\" language by programmers worldwide\n\nThink of it as:\nA strict but kind teacher. It tells you \"this is wrong\", so you can write programs with confidence!",
    "rust_lesson3_ex8_slide1_content": "# Default for None/Err cases\n\nunwrap_or returns a default value when None or Err.\n\n```rust\nlet x: Option<i32> = None;\nlet value = x.unwrap_or(0);  // 0\n```",
    "rust_lesson2_ex7_slide3_title": "Let's Try It!",
    "rust_lesson2_ex6_title": "Represent states with enum",
    "rust_lesson2_ex8_slide1_content": "# Represents \"success\" or \"failure\"\n\nResult<T, E> is a type that represents whether processing \"succeeded or failed\".\n\nFor example:\n- Opening a file → success (content) or failure (error)\n- Division by 0 → success (answer) or failure (can't divide by 0!)\n\nTwo states:\n- `Ok(value)` → Success! Contains the value\n- `Err(error)` → Failure... Contains error info\n\n`Option` is \"exists or not\", `Result` is \"success or failure\".",
    "rust_lesson2_ex8_slide3_content": "Learn \"Result\" that represents success and failure.\n\n(When you're ready, select \"Start Lesson\".)",
    "rust_lesson4_ex6_slide1_title": "HashSet ?",
    "rust_lesson3_ex9_comment1": "push adds an element",
    "rust_lesson2_ex7_slide2_title": "Option  Usage",
    "rust_lesson3_ex2_title": "Closure basics",
    "rust_lesson3_ex7_slide1_title": "? operator?",
    "rust_lesson4_ex6_comment1": "Import HashSet",
    "rust_lesson2_ex10_slide1_content": "# A \"versatile\" mechanism that works with any type\n\nGenerics is a mechanism to decide the type later.\n\nWhy is it useful?\nYou don't have to write similar functions multiple times.\n\nFor example:\n- A function to get the first element of a number array\n- A function to get the first element of a string array\n\nBoth \"get the first element\" is the same, but writing separate functions just because the type differs is tedious!\n\nWith generics, write `<T>` for \"type decided later\" and create functions that work with any type.",
    "rust_lesson1_ex3_slide1_content": "# The remainder operator \"%\"\n\n`%` (percent) is a special symbol that calculates the \"remainder\" of division.\n\nEasy example:\n- If you divide 10 candies among 3 people?\n- Each person gets 3, with 1 left over\n- Writing `10 % 3` gives the answer `1`\n\nCode example:\n```rust\nprintln!(\"{}\", 10 % 3);  // 1 (remainder 1)\nprintln!(\"{}\", 8 % 4);   // 0 (no remainder = divisible)\n```\n\nUse cases:\n- Check if even or odd (`n % 2` is 0 for even)\n- Clock calculations (wrap around after 24, etc.)",
    "rust_lesson3_ex7_description": "Propagate errors concisely.",
    "rust_lesson3_ex8_comment1": "unwrap_or sets a default value",
    "rust_lesson2_ex8_title": "Error handling with Result<T, E>",
    "rust_lesson2_ex10_comment1": "Use T as a type parameter",
    "rust_lesson2_ex6_comment1": "Define an enumeration type with enum",
    "rust_lesson3_ex3_slide3_content": "Learn iterators that process elements sequentially.\n\n(When you're ready, select \"Start Lesson\".)",
    "rust_lesson4_ex2_comment1": "Automatically implement traits with derive",
    "rust_lesson1_ex8_slide1_content": "# A \"dictionary\" you can search by name\n\nHashMap is a mechanism for storing \"name\" and \"data\" pairs. It works like a real dictionary.\n\nFor example, a fruit color dictionary:\n- \"apple\" → \"red\"\n- \"banana\" → \"yellow\"\n- \"orange\" → \"orange\"\n\nPreparation to use:\n```rust\nuse std::collections::HashMap;  // Load the feature\nlet mut fruits = HashMap::new();  // Create empty dictionary\nfruits.insert(\"apple\", \"red\");  // Add data\n```\n\n`use` is a declaration meaning \"I'll use this feature\".",
    "rust_lesson3_ex9_slide1_title": "push ?",
    "rust_lesson4_ex1_title": "Defining traits",
    "rust_lesson4_ex3_description": "Learn Box that stores data on the heap.",
    "rust_lesson1_ex2_title": "The useful \"box\" variable",
    "rust_lesson1_ex8_comment2": "Retrieve the content",
    "rust_lesson3_ex9_slide3_title": "Let's Try It!",
    "rust_lesson1_ex4_comment3": "Subtract 50 with -=",
    "rust_lesson1_ex6_comment1": "Check both conditions with &&",
    "rust_lesson4_ex1_slide2_title": "Implementing traits",
    "rust_lesson4_ex7_slide3_title": "Let's Try It!",
    "rust_lesson4_title": "Rust IV - Traits and Smart Pointers",
    "rust_lesson4_ex1_comment1": "Define a trait with trait",
    "rust_lesson4_ex4_slide1_content": "# A mechanism allowing multiple \"owners\"\n\nRc<T> stands for \"Reference Counted\" and allows multiple owners to share data.\n\nNormal ownership:\nOnly one person owns it. Once given away, the original can't use it.\n\nUsing Rc:\nMultiple people can be \"owners\" of the same data!\n\nCode example:\n```rust\nuse std::rc::Rc;\n\nlet a = Rc::new(5);       // Wrap with Rc\nlet b = Rc::clone(&a);    // b also becomes an owner\n// Both a and b can be used!\n```",
    "rust_lesson3_ex5_slide1_content": "# Keep only what matches the condition\n\nfilter keeps only elements that satisfy a condition and discards the rest.\n\nFor example:\n- Keep only people with 80+ points\n- Keep only even numbers\n- Keep only names starting with \"A\"\n\nCode example:\n```rust\nlet v = vec![1, 2, 3, 4, 5];\nlet evens: Vec<_> = v.iter()\n    .filter(|x| **x % 2 == 0)  // Only evens\n    .collect();\n// [2, 4]\n```\n\nOnly elements where the condition is `true` remain.",
    "rust_lesson3_ex7_slide3_title": "Let's Try It!",
    "rust_lesson1_ex7_comment2": "Retrieve the second data (index 1)",
    "rust_lesson4_ex8_title": "impl Trait",
    "rust_lesson1_ex5_description": "Learn if statements that change behavior based on conditions.",
    "rust_lesson3_ex4_slide2_title": "Lazy evaluation",
    "rust_lesson3_ex1_slide1_content": "# A mark showing a reference's \"lifespan\"\n\nLifetime is a mark showing how long a reference is valid. Written like `'a` (apostrophe-a).\n\nWhy needed?\nReferences are \"borrowed\". If the original data disappears, the reference becomes unusable.\n\nFor example:\n- A book borrowed from the library → can't read if the library closes\n- Data borrowed via reference → can't use if original data disappears\n\nLifetimes tell the compiler \"this reference is valid within this scope\".",
    "rust_lesson1_ex1_slide1_title": "Rust?",
    "rust_lesson1_ex2_slide2_title": "Operators for calculation",
    "rust_lesson4_ex5_slide2_content": "# Retrieve safely with get\n\nYou can retrieve values with the `get()` method. Since it might not be found, it returns an `Option`.\n\nCode example:\n```rust\n// get returns Option<&V>\nif let Some(score) = scores.get(\"Blue\") {\n    println!(\"Blue team has {} points\", score);\n}\n```\n\nKey points:\n- Returns `Some(value)` if key exists\n- Returns `None` if key doesn't exist\n- Safely extract with `if let`\n\nThe program won't crash even if you access a non-existent key!",
    "rust_lesson4_ex7_slide1_title": "match guards?",
    "rust_lesson3_title": "Rust III - Lifetimes and Iterators",
    "rust_lesson4_ex3_title": "Box<T>",
    "rust_lesson1_ex4_slide1_title": "Compound assignment operators?",
    "rust_lesson2_ex9_comment1": "Define a trait with trait",
    "rust_lesson2_ex1_description": "Learn Rust's unique concept of \"ownership\".",
    "rust_lesson2_ex3_slide3_content": "Learn \"mutable references\" that can change the referenced value.\n\n(When you're ready, select \"Start Lesson\".)",
    "rust_lesson2_ex1_slide3_title": "Let's Try It!",
    "rust_lesson3_ex6_slide2_title": "Various folding operations",
    "rust_lesson4_ex9_slide3_title": "Let's Try It!",
    "rust_lesson2_ex5_title": "Add methods with impl",
    "rust_lesson2_ex6_slide1_content": "# Multiple choices\n\nenum represents that a value is one of several kinds. Each variant can also hold data.",
    "rust_lesson2_ex4_comment1": "Define a struct with struct",
    "rust_lesson1_ex3_title": "Remainder operator (%)",
    "rust_lesson1_ex7_comment1": "Create a vector called colors ('red', 'blue' in order)",
    "rust_lesson1_ex4_slide1_content": "# Convenient symbols for increasing or decreasing values\n\n`+=` (plus equals) and `-=` (minus equals) are convenient symbols for increasing or decreasing variable values.\n\nImportant Rust rule: `mut` is required!\nIn Rust, to change a variable, you need to write `let mut`. `mut` is short for \"mutable\".\n\nCode example:\n```rust\nlet mut score = 100;  // Make mutable with mut\nscore += 10;          // Add 10 → 110\nscore -= 50;          // Subtract 50 → 60\n```\n\nWithout `mut`, Rust will complain \"you can't change this variable!\"",
    "rust_lesson2_ex1_slide2_title": "Move",
    "rust_lesson3_ex4_comment1": "Transform each element with map",
    "rust_lesson3_ex8_slide1_title": "unwrap_or ?",
    "rust_lesson2_ex5_slide1_content": "# Implementation block\n\nWith the impl block, you can add methods to structs. `self` refers to oneself.",
    "rust_lesson2_ex10_slide1_title": "Generics?",
    "rust_lesson1_ex8_slide2_content": "# Retrieve by name (key)\n\nData in a dictionary can be retrieved by specifying the name (key).\n\nCode example:\n```rust\nuse std::collections::HashMap;\nfn main() {\n    let mut fruits = HashMap::new();\n    fruits.insert(\"apple\", \"red\");  // Add\n    fruits.insert(\"banana\", \"yellow\");  // Add\n    \n    println!(\"{}\", fruits[\"apple\"]);  // Displays red\n}\n```\n\nKey points:\n- Add with `insert(name, data)`\n- Retrieve with `dictionary[name]`\n- Convenient to search by \"name\" instead of number!",
    "rust_lesson4_ex9_slide1_content": "# Convert iterator to collection\n\ncollect converts iterators to Vec, HashMap, etc.\n\n```rust\nlet v: Vec<_> = (0..5).collect();\nlet s: String = vec!['a', 'b'].into_iter().collect();\n```",
    "rust_lesson2_ex2_slide3_content": "Learn \"references\" to borrow values without transferring ownership.\n\n(When you're ready, select \"Start Lesson\".)",
    "rust_lesson3_ex2_slide3_content": "Learn \"closures\" - anonymous functions that can use surrounding variables.\n\n(When you're ready, select \"Start Lesson\".)",
    "rust_lesson2_ex4_slide2_content": "# Define with struct keyword\n\nDefine a struct with `struct Name { fields }`. Write the name and type for each field.\n\nCode example:\n```rust\n// Define Point struct\nstruct Point {\n    x: i32,  // x field (integer)\n    y: i32,  // y field (integer)\n}\n\n// Usage\nlet p = Point { x: 10, y: 20 };\nprintln!(\"x={}, y={}\", p.x, p.y);\n```\n\nKey points:\n- Create a struct with `struct Name`\n- Specify what data to hold with `{ field_name: type }`\n- Access with `.field_name`",
    "rust_lesson2_ex10_slide3_content": "Learn \"generics\" that let you decide types later.\n\n(When you're ready, select \"Start Lesson\".)",
    "rust_lesson4_ex6_slide3_title": "Let's Try It!",
    "rust_lesson4_ex6_slide1_content": "# A set of unique values\n\nHashSet is a set of values without duplicates.\n\n```rust\nuse std::collections::HashSet;\n\nlet mut set = HashSet::new();\nset.insert(1);\nset.insert(2);\nset.insert(1); // Duplicate is ignored\n```",
    "rust_lesson4_ex2_title": "derive attribute",
    "rust_lesson4_ex2_slide1_content": "# \"Automatically\" implement traits\n\nUsing #[derive(...)], commonly used traits are automatically implemented without writing them yourself.\n\nFor example:\nWhen you want to display a struct with `println!`, you'd normally need to implement the Display trait, but just writing `#[derive(Debug)]` is enough!\n\nCode example:\n```rust\n#[derive(Debug)]  // Auto-implement Debug trait\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nlet p = Point { x: 1, y: 2 };\nprintln!(\"{:?}\", p);  // Point { x: 1, y: 2 }\n```",
    "rust_lesson1_ex6_slide2_title": "Let's Try It!",
    "rust_lesson3_ex3_slide2_title": "Three iter methods",
    "rust_lesson4_ex7_slide2_content": "# Complex conditions\n\n```rust\nmatch Some(5) {\n    Some(x) if x % 2 == 0 => println!(\"even\"),\n    Some(x) => println!(\"odd: {}\", x),\n    None => println!(\"none\"),\n}\n```",
    "rust_lesson3_ex3_slide1_content": "# A mechanism for extracting elements one by one\n\nAn iterator is a mechanism that extracts data from vectors, etc. \"one by one in order\".\n\nFor example:\n- Calling people in line one by one\n- Taking items from a drawer one by one\n\nCode example:\n```rust\nlet v = vec![1, 2, 3];\nfor x in v.iter() {\n    println!(\"{}\", x);  // Displays 1, 2, 3 in order\n}\n```\n\n`iter()` prepares for \"sequential extraction\", and `for` processes one at a time.",
    "rust_lesson3_ex3_slide1_title": "iterator?",
    "rust_lesson4_ex2_description": "Learn derive for automatically implementing traits.",
    "rust_lesson3_ex4_slide1_content": "# Transform everything the same way\n\n**map** transforms each element of an iterator \"in the same way\".\n\nFor example:\n- Double everyone's height\n- Convert everyone's name to uppercase\n- Square all numbers\n\nCode example:\n```rust\nlet v = vec![1, 2, 3];\nlet doubled: Vec<_> = v.iter()\n    .map(|x| x * 2)  // Double each element\n    .collect();      // Convert back to vector\n// [2, 4, 6]\n```\n\n`|x| x * 2` is a closure that \"receives x and returns x*2\".",
    "rust_lesson1_ex3_slide1_title": "Finding the remainder",
    "rust_lesson3_ex10_slide1_content": "# Difference in ownership\n\nString is an owned string on the heap, &str is a reference.\n\n```rust\nlet s1: String = String::from(\"hello\");\nlet s2: &str = \"hello\";\n```",
    "rust_lesson4_ex2_slide1_title": "derive?",
    "rust_lesson2_ex2_comment1": "Pass a reference with &",
    "rust_lesson4_ex5_slide1_title": "HashMap?",
    "rust_lesson2_ex3_slide2_title": "&mut  Usage",
    "rust_lesson3_ex5_title": "Filtering with filter",
    "rust_lesson4_ex3_slide2_title": "When to use?",
    "rust_lesson2_ex2_title": "References and borrowing",
    "rust_lesson2_ex7_title": "Safe null handling with Option<T>",
    "rust_lesson4_ex10_slide3_title": "Let's Try It!",
    "rust_lesson3_ex5_slide3_title": "Let's Try It!",
    "rust_lesson4_ex10_title": "Indexed iteration with enumerate",
    "rust_lesson2_ex2_slide1_content": "# \"Borrow\" without transferring ownership\n\nUsing references, you can \"see\" data without moving ownership.\n\nThink of it as:\n- Move = giving away a toy (you can't use it)\n- Reference = showing a toy (you can still use it)\n\nCreation:\nAdd `&` (ampersand) to create a reference.\n\n```rust\nlet s = String::from(\"hello\");\nlet r = &s;  // Borrow s (let it be seen)\n// Both s and r can be used!\n```",
    "rust_lesson2_ex5_slide2_content": "# Using &self\n\nThe first argument of a method is `&self`.\n\nCode example:\n```rust\nimpl Rect {\n    fn area(&self) -> i32 {\n        self.width * self.height\n    }\n}\n```",
    "rust_lesson1_ex5_slide2_title": "Let's Try It!",
    "rust_lesson2_ex4_slide3_title": "Let's Try It!",
    "rust_lesson4_ex3_slide3_title": "Let's Try It!",
    "rust_lesson2_ex9_slide3_content": "Learn \"traits\" that define common behaviors.\n\n(When you're ready, select \"Start Lesson\".)",
    "rust_lesson4_ex1_slide2_content": "# Keep the promise with impl\n\nWhen implementing a trait on a struct, that struct \"keeps the promise\".\n\nCode example:\n```rust\nstruct Person { name: String }\n\nimpl Greet for Person {\n    fn greet(&self) -> String {\n        format!(\"Hello, {}\", self.name)\n    }\n}\n```\n\nReading:\n- `impl Greet for Person` → \"Person implements Greet\"\n- Now Person \"can greet\"!",
    "rust_lesson4_ex4_comment1": "Increase reference count with clone",
    "rust_lesson3_ex4_slide2_content": "# map alone doesn't execute!\n\nRust iterators use lazy evaluation, meaning they \"don't process until really needed\".\n\nWhy?\nTo avoid wasteful computation. Even with a million items, if you only want the first 10, just process 10.\n\nExecute with collect():\n```rust\n// Nothing happens with just this\nv.iter().map(|x| x * 2);\n\n// collect() executes and converts to vector\nlet result: Vec<_> = v.iter().map(|x| x * 2).collect();\n```\n\n`collect()` means \"process everything now and give me the result\".",
    "rust_lesson2_ex4_slide2_title": "How to define structs",
    "rust_lesson2_ex3_slide1_content": "# A \"modifiable\" way to borrow\n\nRegular reference `&` is \"view only\", but mutable reference `&mut` is a way to borrow that \"allows modification\".\n\nThink of it as:\n- `&` = borrowing a book (read only)\n- `&mut` = borrowing a notebook (writing OK)\n\nImportant rule:\n- Only one mutable reference at a time!\n- Either \"everyone views\" or \"one person writes\"\n\nThis rule prevents bugs where data is modified simultaneously.",
    "rust_lesson2_ex10_slide3_title": "Let's Try It!",
    "rust_lesson2_ex4_title": "Let's define structs",
    "rust_lesson3_ex10_slide2_content": "# Mutual conversion\n\n```rust\n// &str -> String\nlet s = \"hello\".to_string();\n\n// String -> &str\nlet slice: &str = &s;\n```",
    "rust_lesson4_ex10_slide3_content": "Add indices to iterators.\n\n(When you're ready, select \"Start Lesson\".)",
    "rust_lesson4_ex4_slide2_content": "# Counts \"how many people hold it\"\n\nRc counts \"how many people currently hold this data\".\n\nCode example:\n```rust\nlet a = Rc::new(5);\nprintln!(\"{}\", Rc::strong_count(&a));  // 1\n\nlet b = Rc::clone(&a);\nprintln!(\"{}\", Rc::strong_count(&a));  // 2\n```\n\nWhen is data freed?\n- When count reaches 0 (no one holds it)\n- Automatically cleaned up when the last owner is gone\n\n`Rc::clone` is the operation to \"add one more owner\".",
    "rust_lesson1_ex8_slide2_title": "dictionary Usage",
    "rust_lesson4_ex3_slide1_content": "# A box that puts data on the \"heap\"\n\nBox<T> is a box for putting data in a special place called the \"heap\".\n\nTwo memory locations:\n- Stack: small and fast. For data with known size\n- Heap: large and flexible. For large or variable-size data\n\nCode example:\n```rust\nlet b = Box::new(5);  // Put 5 on heap\nprintln!(\"{}\", *b);   // * extracts content → 5\n```\n\n`*` is the operation to \"open the box and see the content\".",
    "rust_lesson3_ex2_slide2_title": "closure Syntax",
    "rust_lesson4_ex4_slide1_title": "Rc?",
    "rust_lesson4_ex7_slide1_content": "# Additional conditions\n\nYou can add additional conditions to patterns with **if**.\n\n```rust\nmatch x {\n    n if n < 0 => println!(\"negative\"),\n    n if n > 0 => println!(\"positive\"),\n    _ => println!(\"zero\"),\n}\n```",
    "rust_lesson2_ex3_title": "Mutable references",
    "rust_lesson3_ex10_comment1": "Convert to String with to_string",
    "rust_lesson3_ex10_slide2_title": "Conversion",
    "rust_lesson3_ex1_description": "Learn lifetimes that represent reference validity periods.",
    "rust_lesson3_ex2_slide1_content": "# A nameless \"instant\" function\n\nA closure is a function created on the spot without a name. And it has a special ability: it can use surrounding variables!\n\nFor example:\n```rust\nlet x = 5;  // Outer variable\nlet add_x = |n| n + x;  // Closure that uses x\nprintln!(\"{}\", add_x(10));  // 15\n```\n\nDifference from regular functions:\n- Regular function: can only use arguments\n- Closure: can use arguments + surrounding variables\n\nThink of it as a function that \"can read the room\"!",
    "rust_lesson1_ex2_comment1": "Put 10 in x",
    "rust_lesson1_ex7_slide3_title": "Let's Try It!",
    "rust_lesson1_ex5_title": "Let's branch with \"if...then\"",
    "rust_lesson3_ex2_slide3_title": "Let's Try It!",
    "rust_lesson3_ex7_slide2_content": "# Concise error handling\n\n```rust\n// Without using ?\nmatch result {\n    Ok(v) => v,\n    Err(e) => return Err(e),\n}\n\n// Using ?\nresult?\n```",
    "rust_lesson3_ex6_slide3_title": "Let's Try It!",
    "rust_lesson4_ex9_slide3_content": "Convert iterators to collections.\n\n(When you're ready, select \"Start Lesson\".)",
    "rust_lesson3_ex6_description": "Learn fold for combining elements into a single value.",
    "rust_lesson2_ex9_description": "Learn \"traits\" that define common behaviors.",
    "rust_lesson2_ex8_comment1": "Return success with Ok",
    "rust_lesson3_ex5_slide2_content": "# filter receives a reference of a reference\n\nThe closure passed to `filter` receives a reference of a reference (`&&T`). So to use the value, you need to dereference twice with `**x`.\n\nWhy?\n- `iter()` returns references (`&T`)\n- `filter` passes those as further references (`&&T`)\n\nSyntax:\n```rust\n// Extract value with **x\n.filter(|x| **x > 2)\n\n// Or put * on the argument\n.filter(|&x| *x > 2)\n```\n\nIt's confusing at first, but you'll get used to it!",
    "rust_lesson1_ex5_comment1": "Compare with >",
    "rust_lesson2_ex4_description": "Learn \"structs\" for grouping related data.",
    "rust_lesson3_ex5_slide3_content": "Extract only elements that match a condition.\n\n(When you're ready, select \"Start Lesson\".)",
    "rust_lesson1_ex7_slide3_content": "Using \"vectors (Vec)\", you can store lots of data in one \"long box\".\n\n(When you're ready, select \"Start Lesson\".)",
    "rust_lesson4_ex5_slide2_title": "Retrieving values",
    "rust_lesson3_ex1_slide1_title": "Lifetimes?",
    "rust_lesson1_ex3_comment1": "Output the remainder of 10 divided by 3",
    "rust_lesson3_ex1_comment1": "Define a lifetime with 'a",
    "rust_lesson3_ex10_slide1_title": "String vs &str",
    "rust_lesson2_title": "Rust II - Ownership and Traits",
    "rust_lesson2_ex5_slide2_title": "Defining methods",
    "rust_lesson4_ex5_comment1": "Add key and value with insert",
    "rust_lesson2_ex9_slide1_content": "# A promise of \"what can be done\"\n\nA trait defines the promise that \"this type can do this thing\".\n\nFor example, a \"can speak\" promise:\n- A dog barks \"woof\"\n- A cat meows \"meow\"\n- Both have the ability to \"speak\"\n\nA trait is a promise that \"animals that can speak have a method to make a sound\".\n\nComparison with other languages:\n- Java: interface\n- TypeScript: interface\n\nIt's a similar concept.",
    "rust_lesson1_ex2_slide3_title": "Let's Try It!",
    "rust_lesson4_ex8_slide1_content": "# Abstract the return type\n\nWith impl Trait, you can return a type that implements a trait.\n\n```rust\nfn make_iter() -> impl Iterator<Item = i32> {\n    vec![1, 2, 3].into_iter()\n}\n```",
    "rust_lesson1_ex2_slide2_content": "# Four basic arithmetic operations\n\nIn Rust, you can calculate with the same symbols as arithmetic.\n\nFour basic symbols:\n- + (plus): addition\n- - (minus): subtraction\n- * (asterisk): multiplication (instead of ×)\n- / (slash): division (instead of ÷)\n\nCode example:\n```rust\nlet a = 10;\nlet b = 5;\nprintln!(\"{}\", a + b);  // 15 is displayed\n```\n\n`{}` in `println!` is a marker meaning \"put a value here\".",
    "rust_lesson4_ex9_slide2_content": "# Specify the target type\n\n```rust\n// Turbofish syntax\nlet v = (0..5).collect::<Vec<_>>();\n\n// Type annotation on variable\nlet v: Vec<i32> = (0..5).collect();\n```",
    "rust_lesson1_ex8_description": "Using a \"dictionary (HashMap)\", you can save data with a name and retrieve it by that name.",
    "rust_lesson4_ex9_slide2_title": "typeHint",
    "rust_lesson3_ex1_title": "Lifetime basics",
    "rust_lesson2_ex5_description": "Learn \"impl\" for adding methods to structs.",
    "rust_lesson4_ex8_comment1": "Return a type that implements a trait with impl",
    "rust_lesson4_ex8_slide2_title": "Can also be used in arguments",
    "rust_lesson4_ex7_comment1": "Add a match guard with if",
    "rust_lesson2_ex9_slide2_title": "Defining and implementing traits",
    "rust_lesson4_ex10_slide2_title": "When to use?",
    "rust_lesson3_ex7_slide2_title": "Shorthand for match",
    "rust_lesson1_ex6_title": "logicaloperator(&&,||)",
    "rust_lesson3_ex6_comment1": "Fold with fold",
    "rust_lesson2_ex6_description": "Learn \"enumeration types (enum)\" for representing multiple states.",
    "rust_lesson4_ex10_slide1_title": "enumerate?",
    "rust_lesson1_ex7_slide1_title": "Vector (Vec)?",
    "rust_lesson2_ex6_slide3_content": "Learn \"enumeration types (enum)\" for representing multiple states.\n\n(When you're ready, select \"Start Lesson\".)",
    "rust_lesson3_ex3_slide3_title": "Let's Try It!",
    "rust_lesson3_ex4_description": "Learn map for transforming each element.",
    "rust_lesson4_ex1_slide3_title": "Let's Try It!",
    "rust_lesson3_ex9_slide2_title": "mut is required",
    "rust_lesson1_ex6_slide1_content": "# Logical operators\n\nSymbols used when combining two or more conditions.\n\nTwo symbols:\n- `&&` (and-and): \"and\" = when both are true\n- `||` (or-or): \"or\" = when either is true\n\nReal-life examples:\n- Amusement park: can ride if \"18+ AND has ticket\"\n- Snack: OK if \"homework done OR helped out\"\n\nCode example:\n```rust\nif score >= 70 && bonus > 0 {\n    // 70+ points AND bonus exists → Pass!\n    println!(\"Pass!\");\n}\n```",
    "rust_lesson4_ex4_slide3_content": "Share data with reference counting.\n\n(When you're ready, select \"Start Lesson\".)",
    "rust_lesson2_ex6_slide3_title": "Let's Try It!",
    "rust_lesson2_ex5_slide3_content": "Learn \"impl\" for adding methods to structs.\n\n(When you're ready, select \"Start Lesson\".)",
    "rust_lesson3_ex1_slide3_title": "Let's Try It!",
    "rust_lesson1_ex5_slide1_content": "# Make the program \"decide\"\n\nConditional branching is a mechanism for making the program decide \"if this, then do that\".\n\nReal-life examples:\n- If 80+ points → display \"Pass!\"\n- If raining → bring umbrella\n- If HP is 0 → game over\n\nSyntax in Rust:\n```rust\nif score > 80 {\n    println!(\"Pass!\");\n}\n```\n\nReading:\n- `if` → \"if\"\n- `score > 80` → \"score is greater than 80\"\n- Inside `{ }` → \"do this\"",
    "rust_lesson4_ex5_title": "HashMap",
    "rust_lesson1_ex2_slide1_content": "# A \"box\" for storing data\n\nA variable is a \"box\" where you can store numbers or text. You name it and use it later.\n\nFor example:\n- Put \"5\" in a box labeled \"number of apples\"\n- Later, call \"number of apples\" and \"5\" comes out\n\nSyntax in Rust:\n```rust\nlet x = 10;  // Put 10 in a box named x\nprintln!(\"{}\", x);  // Display contents of x (10)\n```\n\n`let` means \"create a box with this name\".",
    "rust_lesson2_ex4_slide3_content": "Learn \"structs\" for grouping related data.\n\n(When you're ready, select \"Start Lesson\".)",
    "rust_lesson2_ex6_slide1_title": "enum ?",
    "rust_lesson2_ex9_title": "Let's define traits",
    "rust_lesson2_ex4_slide1_title": "Struct?",
    "rust_lesson4_ex2_slide2_content": "# Five useful ones to remember\n\nCommonly used derive traits:\n```rust\nDebug     // Can debug print with {:?}\nClone     // Can make copies with .clone()\nCopy      // Auto-copy on assignment (for small types)\nPartialEq // Can compare with ==\nDefault   // Can auto-create initial values\n```\n\nMultiple can be specified:\n```rust\n#[derive(Debug, Clone, PartialEq)]\nstruct User {\n    name: String,\n    age: u32,\n}\n```\n\n`Debug` is especially common. Convenient to see struct contents when debugging!",
    "rust_lesson2_ex1_slide1_content": "# A rule for determining who \"owns\" data\n\nOwnership is Rust's biggest feature. It's a mechanism that clearly determines \"who owns this data\".\n\nRules:\n- Data has exactly one \"owner\"\n- When the owner is gone, data is automatically cleaned up\n\nThink of it as:\n- Only one person can hold a toy\n- When the owner leaves the room, the toy is cleaned up\n\nThanks to this rule, Rust prevents \"memory leaks\" (bugs where data isn't cleaned up)!",
    "rust_lesson1_ex3_slide2_title": "Let's Try It!",
    "rust_lesson3_ex1_slide2_title": "Why is it needed?",
    "rust_lesson3_ex1_slide2_content": "# Prevents dangerous bugs\n\nThere's a dangerous bug called a dangling reference. This is a reference that points to \"data that no longer exists\".\n\nExample:\n```rust\nfn longest<'a>(x: &'a str, y: &'a str) -> &'a str {\n    if x.len() > y.len() { x } else { y }\n}\n```\n\nMeaning of `'a`:\n- Arguments `x` and `y` have the same lifetime `'a`\n- Return value also has the same lifetime `'a`\n- In other words, \"as long as both x and y are valid, the return value is valid\"\n\nRust checks this automatically!",
    "rust_lesson4_ex6_slide2_title": "Set operations",
    "rust_lesson3_ex7_comment1": "Propagate errors with ?",
    "rust_lesson3_ex2_slide2_content": "# Wrap arguments in | |\n\nClosures are written as `|arguments| body`. `||` is called \"pipe\".\n\nVarious syntaxes:\n```rust\n// No arguments\n|| println!(\"Hello\")\n\n// With arguments\n|x, y| x + y\n\n// Multi-line block\n|x| {\n    let y = x * 2;\n    y + 1\n}\n```\n\nKey points:\n- Wrap arguments in `| |` (instead of function's `()`)\n- Types can often be omitted (Rust infers them)",
    "rust_lesson2_ex7_comment1": "Indicate a value exists with Some",
    "rust_lesson3_ex4_slide3_content": "Learn map for transforming each element.\n\n(When you're ready, select \"Start Lesson\".)",
    "rust_lesson1_title": "Challenge Rust!",
    "rust_lesson2_ex8_description": "Learn \"Result\" that represents success and failure.",
    "rust_lesson3_ex8_description": "Set default values for Option/Result.",
    "rust_lesson4_ex2_slide3_title": "Let's Try It!",
    "rust_lesson2_ex5_slide3_title": "Let's Try It!",
    "rust_lesson4_ex9_description": "Convert iterators to collections.",
    "rust_lesson1_ex1_slide2_content": "# Display on screen with println!\n\nTo display text on screen in Rust, use `println!` (print-line-bang).\n\nKey points:\n- The `!` is a Rust feature (called a macro)\n- Programs are written inside `fn main() { }`\n- `fn` is short for \"function\"\n\nCode example:\n```rust\nfn main() {\n    println!(\"Hey!\");\n}\n// \"Hey!\" is displayed on screen\n```\n\nThe `!` in `println!` is a sign of a special feature called a \"macro\". Think of it as a \"magic spell\" for now!",
    "rust_lesson3_ex6_slide1_title": "fold ?",
    "rust_lesson4_ex8_slide1_title": "impl Trait ?",
    "rust_lesson1_ex1_slide2_title": "Rust's \"boilerplate\"",
    "rust_lesson3_ex10_description": "Understand the difference between string types.",
    "rust_lesson3_ex7_slide3_content": "Propagate errors concisely.\n\n(When you're ready, select \"Start Lesson\".)",
    "rust_lesson2_ex1_comment1": "Move ownership of s1",
    "rust_lesson2_ex9_slide1_title": "Trait?",
    "rust_lesson4_ex6_slide2_content": "# Union, intersection, etc.\n\n```rust\nset1.union(&set2)\nset1.intersection(&set2)\nset1.difference(&set2)\n```",
    "rust_lesson4_ex5_slide3_content": "Store key-value pairs.\n\n(When you're ready, select \"Start Lesson\".)",
    "rust_lesson2_ex8_slide1_title": "Result?",
    "rust_lesson4_ex1_slide1_content": "# A promise of \"what can be done\"\n\nA trait is a mechanism that defines methods a type should have.\n\nFor example:\n- \"can greet\" trait → has a greet() method\n- \"can display\" trait → has a display() method\n\nCode example:\n```rust\ntrait Greet {\n    fn greet(&self) -> String;  // Method \"promise\"\n}\n```\n\nThis is a promise that \"types that can Greet have a greet() method\".",
    "rust_lesson4_ex2_slide3_content": "Learn derive for automatically implementing traits.\n\n(When you're ready, select \"Start Lesson\".)",
    "rust_lesson3_ex6_title": "Folding with fold",
    "rust_lesson3_ex9_slide3_content": "Add elements to Vec.\n\n(When you're ready, select \"Start Lesson\".)",
    "rust_lesson2_ex4_slide1_content": "# A \"blueprint\" for grouping related data\n\nA struct is a mechanism for grouping several pieces of data together.\n\nFor example, \"point (coordinate)\" data:\n- x coordinate\n- y coordinate\n\nThese two are related, so it's convenient to group them as \"Point\".\n\nFor example, \"person\" data:\n- name\n- age\n\nThis can also be grouped as \"Person\".\n\nA struct is a blueprint that says \"has this kind of data\".",
    "rust_lesson4_ex1_slide1_title": "Trait? (review)",
    "rust_lesson2_ex3_description": "Learn \"mutable references\" that can change the referenced value.",
    "rust_lesson2_ex7_slide2_content": "# Safely extract with match\n\nUse `match` to handle \"if value exists\" and \"if it doesn't\" separately.\n\nCode example:\n```rust\nlet x: Option<i32> = Some(5);  // Has value\n\nmatch x {\n    Some(n) => println!(\"Value is {}\", n),  // 5\n    None => println!(\"No value\"),\n}\n```\n\nWhy is it safe?\n- No error like \"accessed thinking it existed but it didn't\" as with `null`\n- Compile error if you don't write handling for \"no value\" case\n- Forces you to consider both cases!",
    "rust_lesson4_ex9_comment1": "Convert to Vec with collect",
    "rust_lesson3_ex10_title": "String and &str",
    "rust_lesson2_ex7_slide1_title": "Option?",
    "rust_lesson3_ex9_description": "Add elements to Vec.",
    "rust_lesson2_ex5_comment1": "Implement methods with impl",
    "rust_lesson3_ex1_slide3_content": "Learn lifetimes that represent reference validity periods.\n\n(When you're ready, select \"Start Lesson\".)",
    "rust_lesson1_ex6_slide2_content": "Learn \"&&(and)\" and \"||(or)\" for combining multiple conditions.\n\n(When you're ready, select \"Start Lesson\".)",
    "rust_lesson3_ex5_comment1": "Filter elements matching condition with filter",
    "rust_lesson2_ex7_slide3_content": "Learn \"Option\" that represents whether a value exists or not.\n\n(When you're ready, select \"Start Lesson\".)",
    "rust_lesson3_ex10_slide3_title": "Let's Try It!",
    "rust_lesson4_ex4_slide3_title": "Let's Try It!",
    "rust_lesson3_ex3_comment1": "Get an iterator with iter",
    "rust_lesson3_ex6_slide3_content": "Learn fold for combining elements into a single value.\n\n(When you're ready, select \"Start Lesson\".)",
    "rust_lesson1_ex7_slide2_title": "Vector indices start from \"0\"!",
    "rust_lesson1_ex5_slide1_title": "Conditional branching?",
    "rust_lesson1_ex3_description": "Learn the \"%\" (percent) operator that calculates the remainder of division.",
    "rust_lesson1_ex1_slide3_content": "Let's display text on screen using Rust. We'll use a special function called println!.\n\n(When you're ready, select \"Start Lesson\".)",
    "rust_lesson2_ex10_slide2_content": "# \"Decide type later\" with <T>\n\nAdd `<T>` after the function name and use `T` as the \"type\".\n\nCode example:\n```rust\n// T can be any type\nfn first<T>(arr: &[T]) -> &T {\n    &arr[0]  // Return first element\n}\n\n// Usage\nfirst(&[1, 2, 3]);         // T is i32\nfirst(&[\"a\", \"b\", \"c\"]);   // T is &str\n```\n\nReading:\n- `<T>` → \"I'll use a type named T\"\n- `T` is conventionally the first letter of \"Type\"\n- For multiple types, write `<T, U>`",
    "rust_lesson3_ex2_comment1": "Define closure arguments with |x|",
    "rust_lesson3_ex3_description": "Learn iterators that process elements sequentially.",
    "rust_lesson1_ex1_slide3_title": "Let's Try It!",
    "rust_lesson2_ex6_slide2_title": "Defining enum",
    "rust_lesson2_ex1_title": "Ownership basics",
    "rust_lesson4_ex3_slide1_title": "Box?",
    "rust_lesson2_ex1_slide3_content": "Learn Rust's unique concept of \"ownership\".\n\n(When you're ready, select \"Start Lesson\".)",
    "rust_lesson3_ex8_slide3_content": "Set default values for Option/Result.\n\n(When you're ready, select \"Start Lesson\".)",
    "rust_lesson4_ex7_slide2_title": "Usage example",
    "rust_lesson4_ex10_description": "Add indices to iterators.",
    "rust_lesson4_ex9_slide1_title": "collect ?",
    "rust_lesson4_ex10_slide2_content": "# When you need \"which number\"\n\nConvenient when you need both the index and element.\n\nCode example:\n```rust\nlet v = vec![10, 20, 30];\nfor (idx, val) in v.iter().enumerate() {\n    println!(\"Value at {} is {}\", idx, val);\n}\n// Value at 0 is 10\n// Value at 1 is 20\n// Value at 2 is 30\n```\n\nKey points:\n- Receive a tuple (pair of two) with `(i, x)`\n- `i` gets the index, `x` gets the element\n- Index starts from 0",
    "rust_lesson3_ex2_description": "Learn \"closures\" - anonymous functions that can use surrounding variables.",
    "rust_lesson1_ex4_comment1": "Make changeable with mut",
    "rust_lesson1_ex8_slide3_title": "Let's Try It!",
    "rust_lesson1_ex3_slide2_content": "Learn the \"%\" (percent) operator that calculates the remainder of division.\n\n(When you're ready, select \"Start Lesson\".)",
    "rust_lesson2_ex9_slide3_title": "Let's Try It!",
    "rust_lesson3_ex3_title": "Iterator basics",
    "rust_lesson3_ex9_title": "Vec's push method",
    "rust_lesson1_ex8_comment1": "Create a dictionary (key is 'orange', value is 'orange')",
    "rust_lesson1_ex2_comment3": "Add with +",
    "rust_lesson4_ex8_slide2_content": "# Instead of generics\n\n```rust\nfn print_all(iter: impl Iterator<Item = i32>) {\n    for x in iter {\n        println!(\"{}\", x);\n    }\n}\n```",
    "rust_lesson2_ex2_slide2_title": "reference Usage",
    "rust_lesson1_ex8_slide3_content": "Using a \"dictionary (HashMap)\", you can save data with a name and retrieve it by that name.\n\n(When you're ready, select \"Start Lesson\".)",
    "rust_lesson1_ex7_slide2_content": "# Specify index with [ ]\n\nYou can specify which data to retrieve using `[index]`.\n\nImportant rule: indices start from \"0\"!\n- 1st → `[0]`\n- 2nd → `[1]`\n- 3rd → `[2]`\n\nCode example:\n```rust\nlet fruits = vec![\"apple\", \"banana\", \"orange\"];\n//                ↑0th     ↑1st      ↑2nd\nprintln!(\"{}\", fruits[0]);  // apple\nprintln!(\"{}\", fruits[1]);  // banana\n```\n\n\"Counting from 0\" is a universal rule in programming!",
    "rust_lesson1_ex6_slide1_title": "Combining conditions",
    "rust_lesson2_ex10_slide2_title": "Generic function syntax",
    "rust_lesson1_ex6_description": "Learn \"&&(and)\" and \"||(or)\" for combining multiple conditions.",
    "rust_lesson4_ex6_title": "HashSet",
    "rust_lesson2_ex3_slide2_content": "# mut is needed in two places\n\nTo make changes, `mut` is needed for both the variable and the reference.\n\nCode example:\n```rust\n// 1. Create variable with mut\nlet mut s = String::from(\"hello\");\n\n// 2. Pass mutable reference with &mut\nchange(&mut s);\n\nfn change(s: &mut String) {\n    s.push_str(\" world\");  // Can modify!\n}\n```\n\nKey points:\n- `let mut variable` makes variable mutable\n- `&mut variable` creates a mutable reference\n- Can't modify without both!",
    "rust_lesson2_ex2_slide1_title": "Reference?",
    "rust_lesson3_ex6_slide2_content": "# Sum, product, concatenation, etc.\n\n```rust\n// Product\nv.iter().fold(1, |acc, x| acc * x)\n\n// String concatenation\nwords.iter().fold(String::new(), |acc, s| acc + s)\n```",
    "rust_lesson1_ex1_description": "Let's display text on screen using Rust. We'll use a special function called println!.",
    "rust_lesson3_ex8_slide3_title": "Let's Try It!",
    "rust_lesson4_ex6_description": "Manage a set of unique values.",
    "rust_lesson2_ex5_slide1_title": "impl ?",
    "rust_lesson1_ex8_title": "A \"dictionary\" to look up by name",
    "rust_lesson2_ex7_description": "Learn \"Option\" that represents whether a value exists or not.",
    "rust_lesson1_ex4_slide2_title": "Let's Try It!",
    "rust_lesson1_ex7_title": "Let's group lots of data with \"vectors\"",
    "rust_lesson3_ex7_slide1_content": "# Early return on error\n\n? early returns from the function if Result is Err.\n\n```rust\nfn read_file() -> Result<String, io::Error> {\n    let content = fs::read_to_string(\"file.txt\")?;\n    Ok(content)\n}\n```",
    "rust_lesson3_ex9_slide1_content": "# Add to the end\n\npush adds an element to the end of a Vec.\n\n```rust\nlet mut v = vec![1, 2];\nv.push(3);\n// [1, 2, 3]\n```",
    "rust_lesson4_ex8_slide3_content": "Write functions that return traits concisely.\n\n(When you're ready, select \"Start Lesson\".)",
    "rust_lesson1_ex1_title": "Let's display a message on screen",
    "rust_lesson2_ex8_slide2_title": "Result  Usage",
    "rust_lesson3_ex2_slide1_title": "closure?",
    "rust_lesson3_ex8_title": "Default values with unwrap_or",
    "rust_lesson4_ex10_slide1_content": "# Get index and element together\n\nenumerate is a method that extracts \"which number\" and \"that element\" together.\n\nFor example:\n- 0th: apple\n- 1st: banana\n- 2nd: orange\n\nCode example:\n```rust\nfor (i, x) in vec![\"a\", \"b\", \"c\"].iter().enumerate() {\n    println!(\"{}: {}\", i, x);\n}\n// 0: a\n// 1: b\n// 2: c\n```",
    "rust_lesson1_ex7_slide1_content": "# A \"long box\" for lining up data\n\nA vector (Vec) is a \"long box\" where you can store lots of data in order.\n\nFor example:\n- Group all items in a shopping list\n- Group all test scores\n- Group all friends' names\n\nEven 100 or 1000 items can be managed with one variable!\n\nHow to create:\n```rust\nlet fruits = vec![\"apple\", \"banana\", \"orange\"];\n// vec! creates a vector\n```",
    "rust_lesson4_ex8_slide3_title": "Let's Try It!",
    "rust_lesson4_ex7_description": "Add conditions to pattern matching.",
    "rust_lesson1_ex4_comment2": "Add 20 with +=",
    "rust_lesson1_ex2_comment2": "Put 5 in y",
    "rust_lesson2_ex3_slide3_title": "Let's Try It!",
    "rust_lesson3_ex4_slide1_title": "map(map)?",
    "rust_lesson1_ex2_slide3_content": "Let's use \"variables\" to name and store data. Create variables with let.\n\n(When you're ready, select \"Start Lesson\".)",
    "rust_lesson2_ex8_slide2_content": "# Separate success and failure with match\n\nWrite different handling for \"if succeeded\" and \"if failed\" with `match`.\n\nCode example:\n```rust\nfn divide(a: i32, b: i32) -> Result<i32, String> {\n    if b == 0 {\n        return Err(\"Cannot divide by 0\".to_string());\n    }\n    Ok(a / b)  // Return answer on success\n}\n\nmatch divide(10, 2) {\n    Ok(v) => println!(\"Answer is {}\", v),\n    Err(e) => println!(\"Error: {}\", e),\n}\n```\n\nKey points:\n- Return success with `Ok(value)`\n- Return failure with `Err(error)`",
    "rust_lesson4_ex3_comment1": "Store on heap with Box::new",
    "rust_lesson4_ex8_description": "Write functions that return traits concisely.",
    "rust_lesson2_ex10_description": "Learn \"generics\" that let you decide types later.",
    "rust_lesson2_ex3_slide1_title": "Mutable reference?",
    "rust_lesson2_ex2_description": "Learn \"references\" to borrow values without transferring ownership.",
    "rust_lesson3_ex5_slide2_title": "Note the **!",
    "rust_lesson2_ex2_slide3_title": "Let's Try It!",
    "rust_lesson4_ex3_slide3_content": "Learn Box that stores data on the heap.\n\n(When you're ready, select \"Start Lesson\".)",
    "rust_lesson1_ex4_title": "Compound assignment operators (+=, -=)",
    "rust_lesson3_ex3_slide2_content": "# Borrow or take ownership\n\nThere are 3 types of iter, with different ownership handling.\n\nThree differences:\n```rust\nv.iter()       // Borrow as reference (&T)\nv.iter_mut()   // Borrow as mutable (&mut T)\nv.into_iter()  // Take ownership (T)\n```\n\nWhen to use:\n- `iter()` → just looking (original vector still usable)\n- `iter_mut()` → want to modify contents\n- `into_iter()` → take the whole vector (original unusable)\n\nUsually `iter()` is most common.",
    "rust_lesson2_ex1_slide1_title": "Ownership?",
    "rust_lesson4_ex6_slide3_content": "Manage a set of unique values.\n\n(When you're ready, select \"Start Lesson\".)"
  },
  "ja": {
    "rust_lesson1_title": "Rust (ラスト) に挑戦！",
    "rust_lesson1_course_title": "Rust (ラスト) に挑戦！",
    "rust_lesson1_course_description": "間違いを見つけるのがとても得意な言葉「Rust（ラスト）」のきほんを学びましょう。きっちりしたルールを身につけて、安全なプログラムを作れるようになります。",
    "rust_lesson1_ex1_slide1_title": "Rust（ラスト）とは？",
    "rust_lesson1_ex1_slide1_content": "# 安全で速い！最新のプログラミング言語\n\nRust（ラスト）は、「間違いを事前に防ぐ」ことがとても得意なプログラミング言語です。\n\nRustのすごいところ：\n- プログラムのミスを実行する前に見つけてくれる\n- とても速く動く\n- 世界中のプログラマーが「一番好き！」と選ぶ人気の言語\n\nたとえるなら：\n厳しいけど優しい先生のような言語です。「ここ間違ってるよ」と教えてくれるので、安心してプログラムが書けます！",
    "rust_lesson1_ex1_slide2_title": "Rustの「おまじない」",
    "rust_lesson1_ex1_slide2_content": "# println! で画面に表示\n\nRustで文字を画面に表示するには、`println!`（プリントラインびっくり）を使います。\n\nポイント：\n- `!` がつくのがRustの特徴（マクロと呼ばれます）\n- プログラムは `fn main() { }` の中に書く\n- `fn` は「function（関数）」の略\n\nコード例：\n```rust\nfn main() {\n    println!(\"ヤッホー！\");\n}\n// 「ヤッホー！」と画面に表示される\n```\n\n`println!` の `!` は「マクロ」という特別な機能の印です。今は「おまじない」と思っておけばOK！",
    "rust_lesson1_ex1_slide3_title": "やってみよう！",
    "rust_lesson1_ex1_slide3_content": "Rustを使って画面に文字を表示してみましょう。println! という特別な関数を使います。\n\n（準備ができたら「レッスン開始」を選択してください。）",
    "rust_lesson1_ex1_comment1": "Hello, Rust! と表示する",
    "rust_lesson1_ex1_description": "Rustを使って画面に文字を表示してみましょう。println! という特別な関数を使います。",
    "rust_lesson1_ex1_title": "画面にメッセージを出しましょう",
    "rust_lesson1_ex2_slide1_title": "変数（へんすう）とは？",
    "rust_lesson1_ex2_slide1_content": "# データを保存する「はこ」\n\n変数（へんすう） は、数字や文字を入れておける「はこ」のことです。名前をつけて、あとで使うことができます。\n\nたとえば：\n- 「りんごの数」というラベルの箱に「5」を入れる\n- あとで「りんごの数」と呼べば「5」が出てくる\n\nRustでの書き方：\n```rust\nlet x = 10;  // xという箱に10を入れる\nprintln!(\"{}\", x);  // xの中身（10）を表示\n```\n\n`let` は「この名前で箱を作るよ」という意味です。",
    "rust_lesson1_ex2_slide2_title": "計算の記号（演算子）",
    "rust_lesson1_ex2_slide2_content": "# 四則演算（しそくえんざん）\n\nRustでも算数と同じ記号で計算ができます。\n\n4つの基本記号：\n- +（プラス）: たし算\n- -（マイナス）: ひき算\n- \\*（アスタリスク）: かけ算（×の代わり）\n- /（スラッシュ）: わり算（÷の代わり）\n\nコード例：\n```rust\nlet a = 10;\nlet b = 5;\nprintln!(\"{}\", a + b);  // 15 と表示される\n```\n\n`println!` の `{}` は「ここに値を入れてね」という目印です。",
    "rust_lesson1_ex2_slide3_title": "やってみよう！",
    "rust_lesson1_ex2_slide3_content": "データに名前をつけて保存できる「変数（へんすう）」を使ってみましょう。letで変数を作ります。\n\n（準備ができたら「レッスン開始」を選択してください。）",
    "rust_lesson1_ex2_comment1": "x に 10 を入れる",
    "rust_lesson1_ex2_comment2": "y に 5 を入れる",
    "rust_lesson1_ex2_comment3": "+ でたし算する",
    "rust_lesson1_ex2_description": "データに名前をつけて保存できる「変数（へんすう）」を使ってみましょう。letで変数を作ります。",
    "rust_lesson1_ex2_title": "便利な「はこ」変数（へんすう）",
    "rust_lesson1_ex3_slide1_title": "あまりを求める",
    "rust_lesson1_ex3_slide1_content": "# 剰余演算子（じょうよえんざんし）「%」\n\n`%`（パーセント）は、割り算の 「あまり」 を計算する特別な記号です。\n\nわかりやすい例：\n- 10このアメを3人で分けると？\n- 1人3こずつで、1こあまる\n- これを `10 % 3` と書くと、答えは `1`\n\nコード例：\n```rust\nprintln!(\"{}\", 10 % 3);  // 1（あまり1）\nprintln!(\"{}\", 8 % 4);   // 0（あまりなし＝割り切れる）\n```\n\n使いどころ：\n- 偶数か奇数か調べる（`n % 2` が0なら偶数）\n- 時計の計算（24を超えたら0に戻る、など）",
    "rust_lesson1_ex3_slide2_title": "やってみよう！",
    "rust_lesson1_ex3_slide2_content": "割り算の「あまり」を求める「%」（パーセント）演算子を学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
    "rust_lesson1_ex3_comment1": "10 を 3 で割ったあまりを出力する",
    "rust_lesson1_ex3_description": "割り算の「あまり」を求める「%」（パーセント）演算子を学びましょう。",
    "rust_lesson1_ex3_title": "剰余演算子（%）",
    "rust_lesson1_ex4_slide1_title": "累算代入演算子（るいさんだいにゅう）とは？",
    "rust_lesson1_ex4_slide1_content": "# 値をかんたんに増やす・減らす\n\n`+=`（プラスイコール）と `-=`（マイナスイコール）は、変数の中身を増やしたり減らしたりする便利な記号です。\n\nRustの大事なルール：`mut`が必要！\nRustでは、変数を変更するには `let mut`（レット ミュート）と書く必要があります。`mut` は「mutable（変更できる）」の略です。\n\nコード例：\n```rust\nlet mut score = 100;  // mut をつけて変更可能に\nscore += 10;          // 10を足す → 110に\nscore -= 50;          // 50を引く → 60に\n```\n\n`mut` がないと「この変数は変えちゃダメ！」とRustが怒ります。",
    "rust_lesson1_ex4_slide2_title": "やってみよう！",
    "rust_lesson1_ex4_slide2_content": "変数の値を手軽に増やしたり減らしたりする「+=」「-=」を学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
    "rust_lesson1_ex4_comment1": "mut で変更可能にする",
    "rust_lesson1_ex4_comment2": "+= で 20 を足す",
    "rust_lesson1_ex4_comment3": "-= で 50 を引く",
    "rust_lesson1_ex4_description": "変数の値を手軽に増やしたり減らしたりする「+=」「-=」を学びましょう。",
    "rust_lesson1_ex4_title": "累算代入演算子（+=、-=）",
    "rust_lesson1_ex5_slide1_title": "条件分岐（じょうけんぶんき）とは？",
    "rust_lesson1_ex5_slide1_content": "# プログラムに「判断」させよう\n\n条件分岐 は、「もし〜なら、〇〇する」という判断をプログラムにさせる仕組みです。\n\n身近な例：\n- もし80点以上なら → 「合格！」と表示\n- もし雨なら → 傘を持っていく\n- もしHPが0なら → ゲームオーバー\n\nRustでの書き方：\n```rust\nif score > 80 {\n    println!(\"合格！\");\n}\n```\n\n読み方：\n- `if` →「もし」\n- `score > 80` →「スコアが80より大きいなら」\n- `{ }` の中 →「これをやる」",
    "rust_lesson1_ex5_slide2_title": "やってみよう！",
    "rust_lesson1_ex5_slide2_content": "条件によって動きを変える if文を学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
    "rust_lesson1_ex5_comment1": "> で比較する",
    "rust_lesson1_ex5_description": "条件によって動きを変える if文を学びましょう。",
    "rust_lesson1_ex5_title": "「もし〜なら」で分けましょう",
    "rust_lesson1_ex6_slide1_title": "条件を組み合わせる",
    "rust_lesson1_ex6_slide1_content": "# 論理演算子（ろんりえんざんし）\n\n2つ以上の条件を組み合わせたいときに使う記号です。\n\n2つの記号：\n- `&&`（アンドアンド）：「かつ」＝ 両方とも 正しいとき\n- `||`（オアオア）：「または」＝ どちらか 正しいとき\n\n身近な例：\n- 遊園地：「18歳以上 かつ チケットあり」なら乗れる\n- おやつ：「宿題終わった または お手伝いした」ならOK\n\nコード例：\n```rust\nif score >= 70 && bonus > 0 {\n    // 70点以上 かつ ボーナスあり → 合格！\n    println!(\"合格！\");\n}\n```",
    "rust_lesson1_ex6_slide2_title": "やってみよう！",
    "rust_lesson1_ex6_slide2_content": "複数の条件を組み合わせる「&&（かつ）」と「||（または）」を学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
    "rust_lesson1_ex6_comment1": "&& で両方の条件をチェック",
    "rust_lesson1_ex6_description": "複数の条件を組み合わせる「&&（かつ）」と「||（または）」を学びましょう。",
    "rust_lesson1_ex6_title": "論理演算子（&&、||）",
    "rust_lesson1_ex7_slide1_title": "ベクタ（Vec）とは？",
    "rust_lesson1_ex7_slide1_content": "# データを並べてまとめる「長い箱」\n\nベクタ（Vec） は、たくさんのデータを順番に並べて入れられる「長い箱」です。\n\nたとえば：\n- 買い物リストの商品を全部まとめる\n- テストの点数を全部まとめる\n- 友だちの名前を全部まとめる\n\n100個でも1000個でも、1つの変数でまとめて管理できます！\n\n作り方：\n```rust\nlet fruits = vec![\"りんご\", \"バナナ\", \"みかん\"];\n// vec! で ベクタを作る\n```",
    "rust_lesson1_ex7_slide2_title": "ベクタの番号は「0」から！",
    "rust_lesson1_ex7_slide2_content": "# [ ]で番号を指定して取り出す\n\n`[番号]` で何番目のデータか指定して取り出せます。\n\n大事なルール：番号は「0」から！\n- 1番目 → `[0]`\n- 2番目 → `[1]`\n- 3番目 → `[2]`\n\nコード例：\n```rust\nlet fruits = vec![\"りんご\", \"バナナ\", \"みかん\"];\n//                  ↑0番    ↑1番     ↑2番\nprintln!(\"{}\", fruits[0]);  // りんご\nprintln!(\"{}\", fruits[1]);  // バナナ\n```\n\nプログラミングでは「0から数える」のが世界共通のルールです！",
    "rust_lesson1_ex7_slide3_title": "やってみよう！",
    "rust_lesson1_ex7_slide3_content": "「ベクタ（Vec）」を使うと、たくさんのデータを一つの「長い はこ」にまとめて入れられます。\n\n（準備ができたら「レッスン開始」を選択してください。）",
    "rust_lesson1_ex7_comment1": "colors というベクタを作る（'あか', 'あお'の順）",
    "rust_lesson1_ex7_comment2": "2番目のデータ（1番）を出す",
    "rust_lesson1_ex7_description": "「ベクタ（Vec）」を使うと、たくさんのデータを一つの「長い はこ」にまとめて入れられます。",
    "rust_lesson1_ex7_title": "たくさんのデータをまとめましょう「ベクタ」",
    "rust_lesson1_ex8_slide1_title": "辞書（HashMap）とは？",
    "rust_lesson1_ex8_slide1_content": "# 名前で検索できる「辞書」\n\nHashMap（ハッシュマップ）は、「名前」と「データ」をセットにして保存できる仕組みです。本物の辞書のように使えます。\n\nたとえば果物の色辞書：\n- 「りんご」→「あか」\n- 「バナナ」→「きいろ」\n- 「みかん」→「オレンジ」\n\n使う準備：\n```rust\nuse std::collections::HashMap;  // 機能を読み込む\nlet mut fruits = HashMap::new();  // 空の辞書を作る\nfruits.insert(\"りんご\", \"あか\");  // データを追加\n```\n\n`use` は「この機能を使うよ」という宣言です。",
    "rust_lesson1_ex8_slide2_title": "辞書の使い方",
    "rust_lesson1_ex8_slide2_content": "# 名前（キー）で取り出す\n\n辞書に入れたデータは、名前（キー）を指定して取り出せます。\n\nコード例：\n```rust\nuse std::collections::HashMap;\nfn main() {\n    let mut fruits = HashMap::new();\n    fruits.insert(\"りんご\", \"あか\");  // 追加\n    fruits.insert(\"バナナ\", \"きいろ\");  // 追加\n    \n    println!(\"{}\", fruits[\"りんご\"]);  // あか と表示\n}\n```\n\nポイント：\n- `insert(名前, データ)` で追加\n- `辞書[名前]` で取り出し\n- 番号ではなく「名前」で探せるのが便利！",
    "rust_lesson1_ex8_slide3_title": "やってみよう！",
    "rust_lesson1_ex8_slide3_content": "「辞書（HashMap）」を使うと、名前をつけてデータを保存し、その名前で取り出せます。\n\n（準備ができたら「レッスン開始」を選択してください。）",
    "rust_lesson1_ex8_comment1": "辞書を作る（キーは'みかん'、値は'オレンジ'）",
    "rust_lesson1_ex8_comment2": "中身を出す",
    "rust_lesson1_ex8_description": "「辞書（HashMap）」を使うと、名前をつけてデータを保存し、その名前で取り出せます。",
    "rust_lesson1_ex8_title": "名前で引き出す「辞書」",
    "rust_lesson2_title": "Rust II - 所有権とトレイト",
    "rust_lesson2_course_title": "Rust II - 所有権とトレイト",
    "rust_lesson2_course_description": "Rust最大の特徴「所有権」を中心に、構造体、トレイト、パターンマッチングを学びます。安全で高速なプログラムを書く力を身につけましょう。",
    "rust_lesson2_ex1_slide1_title": "所有権（しょゆうけん）とは？",
    "rust_lesson2_ex1_slide1_content": "# データの「持ち主」を決めるルール\n\n所有権 は、Rust最大の特徴です。「このデータの持ち主は誰か」をはっきりさせる仕組みです。\n\nルール：\n- データには必ず1人だけ「持ち主」がいる\n- 持ち主がいなくなると、データは自動的に片付けられる\n\nたとえるなら：\n- おもちゃは1人しか持てない\n- 持ち主が部屋を出たら、おもちゃは片付けられる\n\nこのルールのおかげで、Rustは「メモリリーク」（データが片付けられないバグ）を防げます！",
    "rust_lesson2_ex1_slide2_title": "ムーブ（移動）",
    "rust_lesson2_ex1_slide2_content": "# 所有権は「移動」する\n\n変数を別の変数に代入すると、所有権が 移動（ムーブ） します。元の変数は使えなくなります。\n\nコード例：\n```rust\nlet s1 = String::from(\"hello\");  // s1 が持ち主\nlet s2 = s1;  // 所有権が s2 に移動！\n// ↓ s1 はもう使えない（エラーになる）\n// println!(\"{}\", s1);  // ダメ！\nprintln!(\"{}\", s2);  // OK！\n```\n\nイメージ：\nおもちゃを友だちにあげたら、自分はもう使えない。これがムーブです。",
    "rust_lesson2_ex1_slide3_title": "やってみよう！",
    "rust_lesson2_ex1_slide3_content": "Rust独自の概念「所有権」を学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
    "rust_lesson2_ex1_comment1": "s1 の所有権を移動",
    "rust_lesson2_ex1_description": "Rust独自の概念「所有権」を学びましょう。",
    "rust_lesson2_ex1_title": "所有権の基本",
    "rust_lesson2_ex2_slide1_title": "参照（さんしょう）とは？",
    "rust_lesson2_ex2_slide1_content": "# 所有権を渡さずに「借りる」\n\n参照 を使うと、所有権を移さずにデータを「見せてもらう」ことができます。\n\nたとえるなら：\n- ムーブ = おもちゃをあげる（自分は使えない）\n- 参照 = おもちゃを見せる（自分も使える）\n\n作り方：\n`&`（アンパサンド）をつけると参照を作れます。\n\n```rust\nlet s = String::from(\"hello\");\nlet r = &s;  // sを借りる（見せてもらう）\n// s も r も使える！\n```",
    "rust_lesson2_ex2_slide2_title": "参照の使い方",
    "rust_lesson2_ex2_slide2_content": "# 関数に借りてもらう\n\n関数にデータを渡すとき、`&` をつけると「借りる」形になります。元の変数はそのまま使い続けられます。\n\nコード例：\n```rust\nfn calc_len(s: &String) -> usize {\n    s.len()  // 長さを返す\n}\n\nfn main() {\n    let text = String::from(\"hello\");\n    let len = calc_len(&text);  // textを貸す\n    // text はまだ使える！\n    println!(\"{}の長さは{}\", text, len);\n}\n```\n\n`&String` は「Stringを借りる」という意味です。",
    "rust_lesson2_ex2_slide3_title": "やってみよう！",
    "rust_lesson2_ex2_slide3_content": "所有権を移さずに値を借りる「参照」を学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
    "rust_lesson2_ex2_comment1": "& で参照を渡す",
    "rust_lesson2_ex2_description": "所有権を移さずに値を借りる「参照」を学びましょう。",
    "rust_lesson2_ex2_title": "参照と借用",
    "rust_lesson2_ex3_slide1_title": "可変参照（かへんさんしょう）とは？",
    "rust_lesson2_ex3_slide1_content": "# 「書き換えできる」借り方\n\n普通の参照 `&` は「見るだけ」ですが、可変参照 `&mut` は「変更もできる」借り方です。\n\nたとえるなら：\n- `&` = 本を見せてもらう（読むだけ）\n- `&mut` = ノートを借りる（書き込みOK）\n\n大事なルール：\n- 可変参照は同時に1つだけ！\n- 「みんなで見る」か「1人で書く」かのどちらか\n\nこのルールで、データが同時に書き換えられるバグを防いでいます。",
    "rust_lesson2_ex3_slide2_title": "&mut の使い方",
    "rust_lesson2_ex3_slide2_content": "# mut が2か所に必要\n\n変更できるようにするには、変数と参照の両方に `mut` が必要です。\n\nコード例：\n```rust\n// 1. 変数を mut で作る\nlet mut s = String::from(\"hello\");\n\n// 2. &mut で可変参照を渡す\nchange(&mut s);\n\nfn change(s: &mut String) {\n    s.push_str(\" world\");  // 変更できる！\n}\n```\n\nポイント：\n- `let mut 変数` で変数を変更可能に\n- `&mut 変数` で可変参照を作る\n- 両方ないと変更できない！",
    "rust_lesson2_ex3_slide3_title": "やってみよう！",
    "rust_lesson2_ex3_slide3_content": "参照先の値を変更できる「可変参照」を学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
    "rust_lesson2_ex3_comment1": "mut で可変変数にする",
    "rust_lesson2_ex3_description": "参照先の値を変更できる「可変参照」を学びましょう。",
    "rust_lesson2_ex3_title": "可変参照",
    "rust_lesson2_ex4_slide1_title": "構造体（こうぞうたい）とは？",
    "rust_lesson2_ex4_slide1_content": "# 関係あるデータをまとめる「設計図」\n\n構造体（struct） は、いくつかのデータをひとまとめにする仕組みです。\n\nたとえば「点（座標）」のデータ：\n- x座標\n- y座標\n\nこの2つは関係があるので、「Point（点）」としてまとめると便利です。\n\nたとえば「人」のデータ：\n- 名前\n- 年齢\n\nこれも「Person（人）」としてまとめられます。\n\n構造体は「こういうデータを持つ」という設計図です。",
    "rust_lesson2_ex4_slide2_title": "struct の定義のしかた",
    "rust_lesson2_ex4_slide2_content": "# struct キーワードで定義\n\n`struct 名前 { フィールド }` で構造体を定義します。フィールドには名前と型を書きます。\n\nコード例：\n```rust\n// Point 構造体を定義\nstruct Point {\n    x: i32,  // xフィールド（整数）\n    y: i32,  // yフィールド（整数）\n}\n\n// 使い方\nlet p = Point { x: 10, y: 20 };\nprintln!(\"x={}, y={}\", p.x, p.y);\n```\n\nポイント：\n- `struct 名前` で構造体を作る\n- `{ フィールド名: 型 }` でどんなデータを持つか決める\n- `.フィールド名` でアクセス",
    "rust_lesson2_ex4_slide3_title": "やってみよう！",
    "rust_lesson2_ex4_slide3_content": "関連するデータをまとめる「構造体」を学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
    "rust_lesson2_ex4_comment1": "struct で構造体を定義",
    "rust_lesson2_ex4_description": "関連するデータをまとめる「構造体」を学びましょう。",
    "rust_lesson2_ex4_title": "構造体を定義しよう",
    "rust_lesson2_ex5_slide1_title": "impl とは？",
    "rust_lesson2_ex5_slide1_content": "# 実装ブロック\n\nimpl ブロックで、構造体にメソッドを追加できます。`self` で自分自身を参照します。",
    "rust_lesson2_ex5_slide2_title": "メソッドの定義",
    "rust_lesson2_ex5_slide2_content": "# &self を使う\n\nメソッドの最初の引数は `&self` です。\n\nコード例：\n```rust\nimpl Rect {\n    fn area(&self) -> i32 {\n        self.width * self.height\n    }\n}\n```",
    "rust_lesson2_ex5_slide3_title": "やってみよう！",
    "rust_lesson2_ex5_slide3_content": "構造体にメソッドを追加する「impl」を学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
    "rust_lesson2_ex5_comment1": "impl でメソッドを実装",
    "rust_lesson2_ex5_description": "構造体にメソッドを追加する「impl」を学びましょう。",
    "rust_lesson2_ex5_title": "impl でメソッドを追加",
    "rust_lesson2_ex6_slide1_title": "enum とは？",
    "rust_lesson2_ex6_slide1_content": "# 複数の選択肢\n\nenum は、値がいくつかの種類のうちの一つであることを表します。各バリアントにデータを持たせることもできます。",
    "rust_lesson2_ex6_slide2_title": "enum の定義",
    "rust_lesson2_ex6_slide2_content": "# バリアントを列挙\n\n`enum 名前 { バリアント1, バリアント2, ... }` で定義します。\n\nコード例：\n```rust\nenum Color {\n    Red,\n    Green,\n    Blue,\n}\nlet c = Color::Red;\n```",
    "rust_lesson2_ex6_slide3_title": "やってみよう！",
    "rust_lesson2_ex6_slide3_content": "複数の状態を表す「列挙型（enum）」を学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
    "rust_lesson2_ex6_comment1": "enum で列挙型を定義",
    "rust_lesson2_ex6_description": "複数の状態を表す「列挙型（enum）」を学びましょう。",
    "rust_lesson2_ex6_title": "enum で状態を表す",
    "rust_lesson2_ex7_slide1_title": "Option（オプション）とは？",
    "rust_lesson2_ex7_slide1_content": "# 「あるかもしれない、ないかもしれない」\n\nOption<T> は、値が「あるかもしれないし、ないかもしれない」ことを表す型です。\n\nたとえば：\n- 辞書で単語を探す → 見つかるかもしれないし、ないかもしれない\n- ゲームでアイテムを拾う → 落ちてるかもしれないし、ないかもしれない\n\n2つの状態：\n- `Some(値)` → 値がある！\n- `None` → 値がない...\n\n他の言語では `null` を使いますが、Rustでは `Option` で安全に扱います。",
    "rust_lesson2_ex7_slide2_title": "Option の使い方",
    "rust_lesson2_ex7_slide2_content": "# match で安全に取り出す\n\n`match` を使って「ある場合」と「ない場合」で処理を分けます。\n\nコード例：\n```rust\nlet x: Option<i32> = Some(5);  // 値あり\n\nmatch x {\n    Some(n) => println!(\"値は{}です\", n),  // 5\n    None => println!(\"値がありません\"),\n}\n```\n\nなぜ安全？\n- `null` のように「あるつもりでアクセスしたら無かった」エラーが起きない\n- 「ない場合」の処理を書かないとコンパイルエラーになる\n- 強制的に両方のケースを考えることになる！",
    "rust_lesson2_ex7_slide3_title": "やってみよう！",
    "rust_lesson2_ex7_slide3_content": "値があるかないかを表す「Option」を学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
    "rust_lesson2_ex7_comment1": "Some で値があることを示す",
    "rust_lesson2_ex7_description": "値があるかないかを表す「Option」を学びましょう。",
    "rust_lesson2_ex7_title": "Option<T> で null を安全に",
    "rust_lesson2_ex8_slide1_title": "Result（リザルト）とは？",
    "rust_lesson2_ex8_slide1_content": "# 「成功」か「失敗」かを表す\n\nResult<T, E> は、処理が「成功したか失敗したか」を表す型です。\n\nたとえば：\n- ファイルを開く → 成功（内容）か失敗（エラー）\n- 0で割り算 → 成功（答え）か失敗（0で割れない！）\n\n2つの状態：\n- `Ok(値)` → 成功！値が入っている\n- `Err(エラー)` → 失敗...エラー情報が入っている\n\n`Option` は「あるか・ないか」、`Result` は「成功か・失敗か」という違いです。",
    "rust_lesson2_ex8_slide2_title": "Result の使い方",
    "rust_lesson2_ex8_slide2_content": "# match で成功と失敗を分ける\n\n`match` で「成功したら」「失敗したら」の処理を書き分けます。\n\nコード例：\n```rust\nfn divide(a: i32, b: i32) -> Result<i32, String> {\n    if b == 0 {\n        return Err(\"0で割れません\".to_string());\n    }\n    Ok(a / b)  // 成功なら答えを返す\n}\n\nmatch divide(10, 2) {\n    Ok(v) => println!(\"答えは{}\", v),\n    Err(e) => println!(\"エラー: {}\", e),\n}\n```\n\nポイント：\n- `Ok(値)` で成功を返す\n- `Err(エラー)` で失敗を返す",
    "rust_lesson2_ex8_slide3_title": "やってみよう！",
    "rust_lesson2_ex8_slide3_content": "成功と失敗を表す「Result」を学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
    "rust_lesson2_ex8_comment1": "Ok で成功を返す",
    "rust_lesson2_ex8_description": "成功と失敗を表す「Result」を学びましょう。",
    "rust_lesson2_ex8_title": "Result<T, E> でエラー処理",
    "rust_lesson2_ex9_slide1_title": "トレイトとは？",
    "rust_lesson2_ex9_slide1_content": "# 「できること」の約束\n\nトレイト は、「この型はこういうことができる」という約束を定義します。\n\nたとえば「鳴ける」という約束：\n- 犬は「ワン」と鳴く\n- 猫は「ニャー」と鳴く\n- 両方とも「鳴ける」能力がある\n\nトレイトは「鳴ける動物は、鳴き声を出すメソッドを持つ」という約束です。\n\n他の言語との比較：\n- Java: インターフェース\n- TypeScript: インターフェース\n\nに似た概念です。",
    "rust_lesson2_ex9_slide2_title": "trait の定義と実装",
    "rust_lesson2_ex9_slide2_content": "# 約束を作って、守る\n\n1. `trait` で「約束」を定義\n2. `impl トレイト for 型` で「約束を守る」実装をする\n\nコード例：\n```rust\n// 1. トレイト（約束）を定義\ntrait Speak {\n    fn speak(&self);  // 鳴くメソッドを持つ約束\n}\n\n// 2. Dog構造体がトレイトを実装\nstruct Dog;\nimpl Speak for Dog {\n    fn speak(&self) {\n        println!(\"woof\");\n    }\n}\n```\n\n「DogはSpeakができる」ということになります。",
    "rust_lesson2_ex9_slide3_title": "やってみよう！",
    "rust_lesson2_ex9_slide3_content": "共通の振る舞いを定義する「トレイト」を学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
    "rust_lesson2_ex9_comment1": "trait でトレイトを定義",
    "rust_lesson2_ex9_description": "共通の振る舞いを定義する「トレイト」を学びましょう。",
    "rust_lesson2_ex9_title": "トレイトを定義しよう",
    "rust_lesson2_ex10_slide1_title": "ジェネリクスとは？",
    "rust_lesson2_ex10_slide1_content": "# どんな型でも使える「万能」の仕組み\n\nジェネリクス は、型を後から決められる仕組みです。\n\nなぜ便利？\n同じような関数を何度も書かなくてすみます。\n\nたとえば：\n- 数字の配列の最初の要素を取る関数\n- 文字列の配列の最初の要素を取る関数\n\n両方とも「最初の要素を取る」のは同じなのに、型が違うだけで別の関数を書くのは大変！\n\nジェネリクスなら、`<T>` で「型は後で決める」と書くだけで、どんな型でも使える関数が作れます。",
    "rust_lesson2_ex10_slide2_title": "ジェネリック関数の書き方",
    "rust_lesson2_ex10_slide2_content": "# <T> で型を「あとで決める」\n\n関数名の後に `<T>` をつけて、`T` を「型」として使います。\n\nコード例：\n```rust\n// Tはどんな型でもOK\nfn first<T>(arr: &[T]) -> &T {\n    &arr[0]  // 最初の要素を返す\n}\n\n// 使い方\nfirst(&[1, 2, 3]);         // Tはi32\nfirst(&[\"a\", \"b\", \"c\"]);   // Tは&str\n```\n\n読み方：\n- `<T>` → 「Tという名前の型を使うよ」\n- `T` は慣習で「Type（型）」の頭文字\n- 複数の型が必要なら `<T, U>` のように書く",
    "rust_lesson2_ex10_slide3_title": "やってみよう！",
    "rust_lesson2_ex10_slide3_content": "型を後から決められる「ジェネリクス」を学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
    "rust_lesson2_ex10_comment1": "T を型パラメータとして使う",
    "rust_lesson2_ex10_description": "型を後から決められる「ジェネリクス」を学びましょう。",
    "rust_lesson2_ex10_title": "ジェネリクスを使おう",
    "rust_lesson3_title": "Rust III - ライフタイムとイテレータ",
    "rust_lesson3_course_title": "Rust III - ライフタイムとイテレータ",
    "rust_lesson3_course_description": "Rustの高度な機能を学びます。ライフタイム、イテレータ、クロージャなど、Rustの真髄を身につけましょう。",
    "rust_lesson3_ex1_slide1_title": "ライフタイムとは？",
    "rust_lesson3_ex1_slide1_content": "# 参照の「寿命」を示す印\n\nライフタイム は、参照がいつまで使えるかを示す印です。`'a`（アポストロフィ・エー）のように書きます。\n\nなぜ必要？\n参照は「借りている」状態。借りた元のデータが消えたら、参照も使えなくなります。\n\nたとえば：\n- 図書館で借りた本 → 図書館が閉まったら読めない\n- 参照で借りたデータ → 元のデータが消えたら使えない\n\nライフタイムは「この参照はこの範囲で有効だよ」とコンパイラに伝える仕組みです。",
    "rust_lesson3_ex1_slide2_title": "なぜ必要？",
    "rust_lesson3_ex1_slide2_content": "# 危険なバグを防ぐ\n\nダングリング参照 という危険なバグがあります。これは「もう存在しないデータ」を指し続けている参照のことです。\n\n例：\n```rust\nfn longest<'a>(x: &'a str, y: &'a str) -> &'a str {\n    if x.len() > y.len() { x } else { y }\n}\n```\n\n`'a` の意味：\n- 引数 `x` と `y` は同じライフタイム `'a` を持つ\n- 戻り値も同じライフタイム `'a` を持つ\n- つまり「xとyが両方有効な間、戻り値も有効」という約束\n\nRustはこれを自動でチェックしてくれます！",
    "rust_lesson3_ex1_slide3_title": "やってみよう！",
    "rust_lesson3_ex1_slide3_content": "参照の有効期間を表すライフタイムを学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
    "rust_lesson3_ex1_comment1": "'a でライフタイムを定義",
    "rust_lesson3_ex1_description": "参照の有効期間を表すライフタイムを学びましょう。",
    "rust_lesson3_ex1_title": "ライフタイムの基本",
    "rust_lesson3_ex2_slide1_title": "クロージャとは？",
    "rust_lesson3_ex2_slide1_content": "# 名前のない「即席」関数\n\nクロージャ は、名前をつけずにその場で作る関数です。そして特別な能力があります：周りの変数を使えるのです！\n\nたとえば：\n```rust\nlet x = 5;  // 外側の変数\nlet add_x = |n| n + x;  // xを使えるクロージャ\nprintln!(\"{}\", add_x(10));  // 15\n```\n\n普通の関数との違い：\n- 普通の関数：引数しか使えない\n- クロージャ：引数 + 周りの変数も使える\n\n「その場の空気を読める」関数というイメージです！",
    "rust_lesson3_ex2_slide2_title": "クロージャの書き方",
    "rust_lesson3_ex2_slide2_content": "# | | で引数を囲む\n\nクロージャは `|引数| 処理` という形で書きます。`||` は「パイプ」と呼ばれます。\n\nいろいろな書き方：\n```rust\n// 引数なし\n|| println!(\"Hello\")\n\n// 引数あり\n|x, y| x + y\n\n// 複数行のブロック\n|x| {\n    let y = x * 2;\n    y + 1\n}\n```\n\nポイント：\n- 引数を `| |` で囲む（関数の `()` の代わり）\n- 型は省略できることが多い（Rustが推測してくれる）",
    "rust_lesson3_ex2_slide3_title": "やってみよう！",
    "rust_lesson3_ex2_slide3_content": "周囲の変数を使える無名関数「クロージャ」を学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
    "rust_lesson3_ex2_comment1": "|x| でクロージャの引数を定義",
    "rust_lesson3_ex2_description": "周囲の変数を使える無名関数「クロージャ」を学びましょう。",
    "rust_lesson3_ex2_title": "クロージャの基本",
    "rust_lesson3_ex3_slide1_title": "イテレータとは？",
    "rust_lesson3_ex3_slide1_content": "# 要素を1つずつ取り出す仕組み\n\nイテレータ は、ベクタなどのデータを「1つずつ順番に」取り出す仕組みです。\n\nたとえば：\n- 行列に並んでいる人を1人ずつ呼ぶ\n- 引き出しの中身を1つずつ出す\n\nコード例：\n```rust\nlet v = vec![1, 2, 3];\nfor x in v.iter() {\n    println!(\"{}\", x);  // 1, 2, 3 と順番に表示\n}\n```\n\n`iter()` で「順番に取り出す準備」をして、`for` で1つずつ処理します。",
    "rust_lesson3_ex3_slide2_title": "3つの iter メソッド",
    "rust_lesson3_ex3_slide2_content": "# 借りるか、もらうか\n\n3種類の iter があり、所有権の扱いが違います。\n\n3つの違い：\n```rust\nv.iter()       // 参照で借りる（&T）\nv.iter_mut()   // 変更可能で借りる（&mut T）\nv.into_iter()  // 所有権をもらう（T）\n```\n\n使い分け：\n- `iter()` → 見るだけ（元のベクタも使える）\n- `iter_mut()` → 中身を変更したい\n- `into_iter()` → ベクタごともらう（元は使えない）\n\n普通は `iter()` を使うことが多いです。",
    "rust_lesson3_ex3_slide3_title": "やってみよう！",
    "rust_lesson3_ex3_slide3_content": "要素を順番に処理するイテレータを学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
    "rust_lesson3_ex3_comment1": "iter でイテレータを取得",
    "rust_lesson3_ex3_description": "要素を順番に処理するイテレータを学びましょう。",
    "rust_lesson3_ex3_title": "イテレータの基本",
    "rust_lesson3_ex4_slide1_title": "map（マップ）とは？",
    "rust_lesson3_ex4_slide1_content": "# 全部を同じように変換する\n\n**map** は、イテレータの各要素を「同じ方法で」変換します。\n\nたとえば：\n- 全員の身長を2倍にする\n- 全員の名前を大文字にする\n- 全部の数を2乗する\n\nコード例：\n```rust\nlet v = vec![1, 2, 3];\nlet doubled: Vec<_> = v.iter()\n    .map(|x| x * 2)  // 各要素を2倍に\n    .collect();      // ベクタに戻す\n// [2, 4, 6]\n```\n\n`|x| x * 2` は「xを受け取って、x*2を返す」クロージャです。",
    "rust_lesson3_ex4_slide2_title": "遅延評価（ちえんひょうか）",
    "rust_lesson3_ex4_slide2_content": "# map だけでは実行されない！\n\nRustのイテレータは 遅延評価 といって、「本当に必要になるまで処理しない」仕組みです。\n\nなぜ？\n無駄な計算を省けるから。100万件あっても、最初の10件だけ欲しいなら10件だけ処理すればいい。\n\ncollect() で実行：\n```rust\n// これだけでは何も起きない\nv.iter().map(|x| x * 2);\n\n// collect() で実行してベクタに変換\nlet result: Vec<_> = v.iter().map(|x| x * 2).collect();\n```\n\n`collect()` は「今すぐ全部処理して結果をちょうだい」という意味です。",
    "rust_lesson3_ex4_slide3_title": "やってみよう！",
    "rust_lesson3_ex4_slide3_content": "各要素を変換するmapを学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
    "rust_lesson3_ex4_comment1": "map で各要素を変換",
    "rust_lesson3_ex4_description": "各要素を変換するmapを学びましょう。",
    "rust_lesson3_ex4_title": "map でイテレータ変換",
    "rust_lesson3_ex5_slide1_title": "filter（フィルター）とは？",
    "rust_lesson3_ex5_slide1_content": "# 条件に合うものだけ残す\n\nfilter は、条件を満たす要素だけを残し、他を捨てます。\n\nたとえば：\n- 80点以上の人だけ残す\n- 偶数だけ残す\n- 「あ」から始まる名前だけ残す\n\nコード例：\n```rust\nlet v = vec![1, 2, 3, 4, 5];\nlet evens: Vec<_> = v.iter()\n    .filter(|x| **x % 2 == 0)  // 偶数だけ\n    .collect();\n// [2, 4]\n```\n\n条件が `true` の要素だけが残ります。",
    "rust_lesson3_ex5_slide2_title": "** に注意！",
    "rust_lesson3_ex5_slide2_content": "# filter は参照の参照を受け取る\n\n`filter` のクロージャは、参照の参照（`&&T`）を受け取ります。そのため、値を使うには `**x` と2回参照を外す必要があります。\n\nなぜ？\n- `iter()` は参照（`&T`）を返す\n- `filter` はそれをさらに参照で渡す（`&&T`）\n\n書き方：\n```rust\n// **x で値を取り出す\n.filter(|x| **x > 2)\n\n// または * を引数につける\n.filter(|&x| *x > 2)\n```\n\n最初は混乱しますが、慣れれば大丈夫！",
    "rust_lesson3_ex5_slide3_title": "やってみよう！",
    "rust_lesson3_ex5_slide3_content": "条件に合う要素だけを取り出しましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
    "rust_lesson3_ex5_comment1": "filter で条件に合う要素を絞り込む",
    "rust_lesson3_ex5_description": "条件に合う要素だけを取り出しましょう。",
    "rust_lesson3_ex5_title": "filter で絞り込み",
    "rust_lesson3_ex6_slide1_title": "fold とは？",
    "rust_lesson3_ex6_slide1_content": "# 累積処理\n\nfold は、初期値と関数で要素を1つずつ畳み込みます。\n\n```rust\nlet v = vec![1, 2, 3];\nlet sum = v.iter().fold(0, |acc, x| acc + x);\n// 6\n```",
    "rust_lesson3_ex6_slide2_title": "様々な畳み込み",
    "rust_lesson3_ex6_slide2_content": "# 合計、積、結合など\n\n```rust\n// 積\nv.iter().fold(1, |acc, x| acc * x)\n\n// 文字列結合\nwords.iter().fold(String::new(), |acc, s| acc + s)\n```",
    "rust_lesson3_ex6_slide3_title": "やってみよう！",
    "rust_lesson3_ex6_slide3_content": "要素を1つの値にまとめるfoldを学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
    "rust_lesson3_ex6_comment1": "fold で畳み込み",
    "rust_lesson3_ex6_description": "要素を1つの値にまとめるfoldを学びましょう。",
    "rust_lesson3_ex6_title": "fold で畳み込み",
    "rust_lesson3_ex7_slide1_title": "? 演算子とは？",
    "rust_lesson3_ex7_slide1_content": "# エラーの早期リターン\n\n? は、Resultが Err の場合に早期リターンします。\n\n```rust\nfn read_file() -> Result<String, io::Error> {\n    let content = fs::read_to_string(\"file.txt\")?;\n    Ok(content)\n}\n```",
    "rust_lesson3_ex7_slide2_title": "match の省略形",
    "rust_lesson3_ex7_slide2_content": "# 簡潔なエラー処理\n\n```rust\n// ? を使わない場合\nmatch result {\n    Ok(v) => v,\n    Err(e) => return Err(e),\n}\n\n// ? を使う\nresult?\n```",
    "rust_lesson3_ex7_slide3_title": "やってみよう！",
    "rust_lesson3_ex7_slide3_content": "エラーを簡潔に伝播させましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
    "rust_lesson3_ex7_comment1": "? でエラーを伝播",
    "rust_lesson3_ex7_description": "エラーを簡潔に伝播させましょう。",
    "rust_lesson3_ex7_title": "? 演算子でエラー伝播",
    "rust_lesson3_ex8_slide1_title": "unwrap_or とは？",
    "rust_lesson3_ex8_slide1_content": "# None/Err の場合のデフォルト\n\nunwrap_or は、None や Err の場合にデフォルト値を返します。\n\n```rust\nlet x: Option<i32> = None;\nlet value = x.unwrap_or(0);  // 0\n```",
    "rust_lesson3_ex8_slide2_title": "unwrap_or_else",
    "rust_lesson3_ex8_slide2_content": "# 遅延評価\n\n```rust\n// クロージャで計算\nlet value = x.unwrap_or_else(|| expensive_computation());\n```",
    "rust_lesson3_ex8_slide3_title": "やってみよう！",
    "rust_lesson3_ex8_slide3_content": "Option/Resultのデフォルト値を設定しましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
    "rust_lesson3_ex8_comment1": "unwrap_or でデフォルト値を設定",
    "rust_lesson3_ex8_description": "Option/Resultのデフォルト値を設定しましょう。",
    "rust_lesson3_ex8_title": "unwrap_or でデフォルト値",
    "rust_lesson3_ex9_slide1_title": "push とは？",
    "rust_lesson3_ex9_slide1_content": "# 末尾に追加\n\npush は、Vecの末尾に要素を追加します。\n\n```rust\nlet mut v = vec![1, 2];\nv.push(3);\n// [1, 2, 3]\n```",
    "rust_lesson3_ex9_slide2_title": "mut が必要",
    "rust_lesson3_ex9_slide2_content": "# 可変参照\n\n```rust\n// mut が必要\nlet mut v = Vec::new();\nv.push(1);\nv.push(2);\n```",
    "rust_lesson3_ex9_slide3_title": "やってみよう！",
    "rust_lesson3_ex9_slide3_content": "Vecに要素を追加しましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
    "rust_lesson3_ex9_comment1": "push で要素を追加",
    "rust_lesson3_ex9_description": "Vecに要素を追加しましょう。",
    "rust_lesson3_ex9_title": "Vec のメソッド push",
    "rust_lesson3_ex10_slide1_title": "String vs &str",
    "rust_lesson3_ex10_slide1_content": "# 所有権の違い\n\nString は所有権を持つヒープ上の文字列、&str は参照です。\n\n```rust\nlet s1: String = String::from(\"hello\");\nlet s2: &str = \"hello\";\n```",
    "rust_lesson3_ex10_slide2_title": "変換",
    "rust_lesson3_ex10_slide2_content": "# 相互変換\n\n```rust\n// &str -> String\nlet s = \"hello\".to_string();\n\n// String -> &str\nlet slice: &str = &s;\n```",
    "rust_lesson3_ex10_slide3_title": "やってみよう！",
    "rust_lesson3_ex10_slide3_content": "文字列型の違いを理解しましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
    "rust_lesson3_ex10_comment1": "to_string で String に変換",
    "rust_lesson3_ex10_description": "文字列型の違いを理解しましょう。",
    "rust_lesson3_ex10_title": "String と &str",
    "rust_lesson4_title": "Rust IV - トレイトとスマートポインタ",
    "rust_lesson4_course_title": "Rust IV - トレイトとスマートポインタ",
    "rust_lesson4_course_description": "Rustのトレイトとスマートポインタを学びます。抽象化と所有権の高度なパターンを身につけましょう。",
    "rust_lesson4_ex1_slide1_title": "トレイトとは？（復習）",
    "rust_lesson4_ex1_slide1_content": "# 「できること」の約束\n\nトレイト は、型が持つべきメソッドを定義する仕組みです。\n\nたとえば：\n- 「あいさつできる」トレイト → greet() メソッドを持つ\n- 「表示できる」トレイト → display() メソッドを持つ\n\nコード例：\n```rust\ntrait Greet {\n    fn greet(&self) -> String;  // メソッドの「約束」\n}\n```\n\nこれは「Greetできる型は、greet()メソッドを持つ」という約束です。",
    "rust_lesson4_ex1_slide2_title": "トレイトの実装",
    "rust_lesson4_ex1_slide2_content": "# impl で約束を守る\n\n構造体にトレイトを実装すると、その構造体は「約束を守る」ことになります。\n\nコード例：\n```rust\nstruct Person { name: String }\n\nimpl Greet for Person {\n    fn greet(&self) -> String {\n        format!(\"Hello, {}\", self.name)\n    }\n}\n```\n\n読み方：\n- `impl Greet for Person` → 「PersonはGreetを実装する」\n- これでPersonは「あいさつできる」ようになった！",
    "rust_lesson4_ex1_slide3_title": "やってみよう！",
    "rust_lesson4_ex1_slide3_content": "共通の振る舞いを定義するトレイトを学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
    "rust_lesson4_ex1_comment1": "trait でトレイトを定義",
    "rust_lesson4_ex1_description": "共通の振る舞いを定義するトレイトを学びましょう。",
    "rust_lesson4_ex1_title": "トレイトの定義",
    "rust_lesson4_ex2_slide1_title": "derive（デライブ）とは？",
    "rust_lesson4_ex2_slide1_content": "# トレイトを「自動で」実装\n\n#[derive(...)] を使うと、よく使うトレイトを自分で書かなくても自動で実装してくれます。\n\nたとえば：\n構造体を `println!` で表示したいとき、普通は Display トレイトを実装する必要がありますが、`#[derive(Debug)]` を書くだけでOK！\n\nコード例：\n```rust\n#[derive(Debug)]  // Debug トレイトを自動実装\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nlet p = Point { x: 1, y: 2 };\nprintln!(\"{:?}\", p);  // Point { x: 1, y: 2 }\n```",
    "rust_lesson4_ex2_slide2_title": "よく使う derive トレイト",
    "rust_lesson4_ex2_slide2_content": "# 覚えておくと便利な5つ\n\nよく使うderiveトレイト：\n```rust\nDebug     // {:?} でデバッグ表示できる\nClone     // .clone() でコピーを作れる\nCopy      // 代入時に自動でコピー（小さい型向け）\nPartialEq // == で比較できる\nDefault   // 初期値を自動で作れる\n```\n\n複数指定もOK：\n```rust\n#[derive(Debug, Clone, PartialEq)]\nstruct User {\n    name: String,\n    age: u32,\n}\n```\n\n`Debug` は特によく使います。デバッグ時に構造体の中身を見れて便利！",
    "rust_lesson4_ex2_slide3_title": "やってみよう！",
    "rust_lesson4_ex2_slide3_content": "トレイトを自動実装するderiveを学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
    "rust_lesson4_ex2_comment1": "derive でトレイトを自動実装",
    "rust_lesson4_ex2_description": "トレイトを自動実装するderiveを学びましょう。",
    "rust_lesson4_ex2_title": "derive 属性",
    "rust_lesson4_ex3_slide1_title": "Box（ボックス）とは？",
    "rust_lesson4_ex3_slide1_content": "# データを「ヒープ」に置く箱\n\nBox<T> は、データを「ヒープ」という特別な場所に置くための箱です。\n\nメモリの2つの場所：\n- スタック：小さくて速い。サイズが決まっているデータ向け\n- ヒープ：大きくて柔軟。サイズが大きいor変わるデータ向け\n\nコード例：\n```rust\nlet b = Box::new(5);  // 5をヒープに置く\nprintln!(\"{}\", *b);   // *で中身を取り出す → 5\n```\n\n`*` は「箱を開けて中身を見る」操作です。",
    "rust_lesson4_ex3_slide2_title": "いつ使う？",
    "rust_lesson4_ex3_slide2_content": "# サイズが決まらないとき\n\nBoxは、コンパイル時にサイズがわからない型に使います。\n\nたとえば再帰的な型：\n```rust\n// リストは「値 + 次のリスト」の繰り返し\nenum List {\n    Cons(i32, Box<List>),  // Boxで次を指す\n    Nil,                   // 終わり\n}\n```\n\nなぜBoxが必要？\n- `List` の中に `List` がある → 無限に大きくなる？\n- `Box` を使うと、サイズが固定（ポインタのサイズ）になる\n\n「中身」ではなく「中身への矢印」を持つイメージです。",
    "rust_lesson4_ex3_slide3_title": "やってみよう！",
    "rust_lesson4_ex3_slide3_content": "ヒープにデータを格納するBoxを学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
    "rust_lesson4_ex3_comment1": "Box::new でヒープに格納",
    "rust_lesson4_ex3_description": "ヒープにデータを格納するBoxを学びましょう。",
    "rust_lesson4_ex3_title": "Box<T>",
    "rust_lesson4_ex4_slide1_title": "Rc（アールシー）とは？",
    "rust_lesson4_ex4_slide1_content": "# 複数の「持ち主」を許可する仕組み\n\nRc<T> は「Reference Counted（参照カウント）」の略で、複数の所有者でデータを共有できます。\n\n普通の所有権：\n1人だけが持ち主。渡したら元の人は使えない。\n\nRc を使うと：\n複数人が同じデータの「持ち主」になれる！\n\nコード例：\n```rust\nuse std::rc::Rc;\n\nlet a = Rc::new(5);       // Rcでラップ\nlet b = Rc::clone(&a);    // bも持ち主になる\n// a も b も使える！\n```",
    "rust_lesson4_ex4_slide2_title": "参照カウントの仕組み",
    "rust_lesson4_ex4_slide2_content": "# 「何人が持っているか」を数える\n\nRcは「今何人がこのデータを持っているか」を数えています。\n\nコード例：\n```rust\nlet a = Rc::new(5);\nprintln!(\"{}\", Rc::strong_count(&a));  // 1\n\nlet b = Rc::clone(&a);\nprintln!(\"{}\", Rc::strong_count(&a));  // 2\n```\n\nいつデータが消える？\n- カウントが0になったとき（誰も持っていないとき）\n- 最後の持ち主がいなくなると自動で片付けられる\n\n`Rc::clone` は「持ち主を1人増やす」操作です。",
    "rust_lesson4_ex4_slide3_title": "やってみよう！",
    "rust_lesson4_ex4_slide3_content": "参照カウントでデータを共有しましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
    "rust_lesson4_ex4_comment1": "clone で参照カウントを増やす",
    "rust_lesson4_ex4_description": "参照カウントでデータを共有しましょう。",
    "rust_lesson4_ex4_title": "Rc<T>",
    "rust_lesson4_ex5_slide1_title": "HashMap（ハッシュマップ）とは？",
    "rust_lesson4_ex5_slide1_content": "# 名前で引ける「辞書」\n\nHashMap は、「キー（名前）」と「値（データ）」をセットで保存する辞書です。\n\nたとえば：\n- 「青チーム」→ 10点\n- 「赤チーム」→ 15点\n\nコード例：\n```rust\nuse std::collections::HashMap;\n\nlet mut scores = HashMap::new();\nscores.insert(\"Blue\", 10);   // 追加\nscores.insert(\"Red\", 15);    // 追加\n```\n\n`use` で機能を読み込んでから使います。",
    "rust_lesson4_ex5_slide2_title": "値の取得",
    "rust_lesson4_ex5_slide2_content": "# get で安全に取り出す\n\n`get()` メソッドで値を取り出せます。見つからない可能性があるので、`Option` が返ってきます。\n\nコード例：\n```rust\n// getはOption<&V>を返す\nif let Some(score) = scores.get(\"Blue\") {\n    println!(\"青チームは{}点\", score);\n}\n```\n\nポイント：\n- キーがあれば `Some(値)` が返る\n- キーがなければ `None` が返る\n- `if let` で安全に取り出せる\n\n存在しないキーでアクセスしてもプログラムが落ちない！",
    "rust_lesson4_ex5_slide3_title": "やってみよう！",
    "rust_lesson4_ex5_slide3_content": "キーと値のペアを格納しましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
    "rust_lesson4_ex5_comment1": "insert でキーと値を追加",
    "rust_lesson4_ex5_description": "キーと値のペアを格納しましょう。",
    "rust_lesson4_ex5_title": "HashMap",
    "rust_lesson4_ex6_slide1_title": "HashSet とは？",
    "rust_lesson4_ex6_slide1_content": "# 一意な値の集合\n\nHashSet は、重複のない値の集合です。\n\n```rust\nuse std::collections::HashSet;\n\nlet mut set = HashSet::new();\nset.insert(1);\nset.insert(2);\nset.insert(1); // 重複は無視\n```",
    "rust_lesson4_ex6_slide2_title": "集合演算",
    "rust_lesson4_ex6_slide2_content": "# 和集合、積集合など\n\n```rust\nset1.union(&set2)\nset1.intersection(&set2)\nset1.difference(&set2)\n```",
    "rust_lesson4_ex6_slide3_title": "やってみよう！",
    "rust_lesson4_ex6_slide3_content": "一意な値の集合を管理しましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
    "rust_lesson4_ex6_comment1": "HashSet をインポート",
    "rust_lesson4_ex6_description": "一意な値の集合を管理しましょう。",
    "rust_lesson4_ex6_title": "HashSet",
    "rust_lesson4_ex7_slide1_title": "match ガードとは？",
    "rust_lesson4_ex7_slide1_content": "# 追加条件\n\n**if** でパターンに追加条件をつけられます。\n\n```rust\nmatch x {\n    n if n < 0 => println!(\"negative\"),\n    n if n > 0 => println!(\"positive\"),\n    _ => println!(\"zero\"),\n}\n```",
    "rust_lesson4_ex7_slide2_title": "使用例",
    "rust_lesson4_ex7_slide2_content": "# 複雑な条件分岐\n\n```rust\nmatch Some(5) {\n    Some(x) if x % 2 == 0 => println!(\"even\"),\n    Some(x) => println!(\"odd: {}\", x),\n    None => println!(\"none\"),\n}\n```",
    "rust_lesson4_ex7_slide3_title": "やってみよう！",
    "rust_lesson4_ex7_slide3_content": "パターンマッチに条件を追加しましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
    "rust_lesson4_ex7_comment1": "if でマッチガードを追加",
    "rust_lesson4_ex7_description": "パターンマッチに条件を追加しましょう。",
    "rust_lesson4_ex7_title": "match ガード",
    "rust_lesson4_ex8_slide1_title": "impl Trait とは？",
    "rust_lesson4_ex8_slide1_content": "# 戻り値の型を抽象化\n\nimpl Trait で、トレイトを実装する型を返せます。\n\n```rust\nfn make_iter() -> impl Iterator<Item = i32> {\n    vec![1, 2, 3].into_iter()\n}\n```",
    "rust_lesson4_ex8_slide2_title": "引数にも使える",
    "rust_lesson4_ex8_slide2_content": "# ジェネリクスの代わり\n\n```rust\nfn print_all(iter: impl Iterator<Item = i32>) {\n    for x in iter {\n        println!(\"{}\", x);\n    }\n}\n```",
    "rust_lesson4_ex8_slide3_title": "やってみよう！",
    "rust_lesson4_ex8_slide3_content": "トレイトを返す関数を簡潔に書きましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
    "rust_lesson4_ex8_comment1": "impl でトレイトを実装する型を返す",
    "rust_lesson4_ex8_description": "トレイトを返す関数を簡潔に書きましょう。",
    "rust_lesson4_ex8_title": "impl Trait",
    "rust_lesson4_ex9_slide1_title": "collect とは？",
    "rust_lesson4_ex9_slide1_content": "# イテレータをコレクションに\n\ncollect は、イテレータをVecやHashMapなどに変換します。\n\n```rust\nlet v: Vec<_> = (0..5).collect();\nlet s: String = vec!['a', 'b'].into_iter().collect();\n```",
    "rust_lesson4_ex9_slide2_title": "型ヒント",
    "rust_lesson4_ex9_slide2_content": "# 変換先を指定\n\n```rust\n// ターボフィッシュ構文\nlet v = (0..5).collect::<Vec<_>>();\n\n// 変数の型注釈\nlet v: Vec<i32> = (0..5).collect();\n```",
    "rust_lesson4_ex9_slide3_title": "やってみよう！",
    "rust_lesson4_ex9_slide3_content": "イテレータをコレクションに変換しましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
    "rust_lesson4_ex9_comment1": "collect で Vec に変換",
    "rust_lesson4_ex9_description": "イテレータをコレクションに変換しましょう。",
    "rust_lesson4_ex9_title": "collect で変換",
    "rust_lesson4_ex10_slide1_title": "enumerate（イニュメレート）とは？",
    "rust_lesson4_ex10_slide1_content": "# 番号と要素を一緒にもらう\n\nenumerate は、「何番目か」と「その要素」をセットで取り出せるメソッドです。\n\nたとえば：\n- 0番目: りんご\n- 1番目: バナナ\n- 2番目: みかん\n\nコード例：\n```rust\nfor (i, x) in vec![\"a\", \"b\", \"c\"].iter().enumerate() {\n    println!(\"{}: {}\", i, x);\n}\n// 0: a\n// 1: b\n// 2: c\n```",
    "rust_lesson4_ex10_slide2_title": "いつ使う？",
    "rust_lesson4_ex10_slide2_content": "# 「何番目か」が必要なとき\n\n番号（インデックス）と要素の両方が必要なときに便利です。\n\nコード例：\n```rust\nlet v = vec![10, 20, 30];\nfor (idx, val) in v.iter().enumerate() {\n    println!(\"{}番目の値は{}\", idx, val);\n}\n// 0番目の値は10\n// 1番目の値は20\n// 2番目の値は30\n```\n\nポイント：\n- `(i, x)` でタプル（2つのセット）を受け取る\n- `i` にインデックス、`x` に要素が入る\n- インデックスは0から始まる",
    "rust_lesson4_ex10_slide3_title": "やってみよう！",
    "rust_lesson4_ex10_slide3_content": "イテレータにインデックスを付けましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
    "rust_lesson4_ex10_comment1": "1番目の i にインデックス、2番目の item に要素が入る",
    "rust_lesson4_ex10_description": "イテレータにインデックスを付けましょう。",
    "rust_lesson4_ex10_title": "enumerate でインデックス付き"
  },
  "cs": {
    "rust_lesson1_course_title": "Introduction to Rust",
    "rust_lesson1_course_description": "Learn the basics of Rust programming.",
    "rust_lesson2_course_title": "Rust II - Intermediate",
    "rust_lesson2_course_description": "Learn intermediate Rust concepts.",
    "rust_lesson3_course_title": "Rust III - Advanced",
    "rust_lesson3_course_description": "Master advanced Rust techniques.",
    "rust_lesson4_course_title": "Rust IV - Expert Level",
    "rust_lesson4_course_description": "Expert-level Rust programming.",
    "rust_lesson1_ex5_slide2_content": "条件によって動きを変える if文を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex9_title": "collect で変換",
    "rust_lesson2_ex7_slide1_content": "# 「あるかもしれない、ないかもしれない」\n\nOption<T> は、valueが「あるかもしれないし、ないかもしれない」ことを表すtypeです。\n\nFor example：\n- dictionaryで単語を探す → 見つかるかもしれないし、ないかもしれない\n- ゲームでアイテムを拾う → 落ちてるかもしれないし、ないかもしれない\n\n2つの状態：\n- `Some(値)` → valueがある！\n- `None` → valueがない...\n\n他の言語では `null` をuseが、Rustでは `Option` で安全に扱います。",
    "rust_lesson1_ex2_slide1_title": "variable（へんすう）?",
    "rust_lesson1_ex7_description": "「ベクタ（Vec）」をuseと、たくさんのデータを一つの「長い はこ」にまとめて入れられます。",
    "rust_lesson2_ex9_slide2_content": "# 約束を作って、守る\n\n1. `trait` で「約束」をdefinition\n2. `impl トレイト for 型` で「約束を守る」implementationをdo\n\ncodeExample：\n```rust\n// 1. トレイト（約束）を定義\ntrait Speak {\n    fn speak(&self);  // 鳴くメソッドを持つ約束\n}\n\n// 2. Dog構造体がトレイトを実装\nstruct Dog;\nimpl Speak for Dog {\n    fn speak(&self) {\n        println!(\"woof\");\n    }\n}\n```\n\n「DogはSpeakができる」ということになります。",
    "rust_lesson4_ex4_description": "referenceカウントでデータを共有しましょう。",
    "rust_lesson4_ex5_slide1_content": "# 名前で引ける「dictionary」\n\nHashMap は、「key（名前）」と「value（データ）」をsetで保存dodictionaryです。\n\nFor example：\n- 「青チーム」→ 10点\n- 「赤チーム」→ 15点\n\ncodeExample：\n```rust\nuse std::collections::HashMap;\n\nlet mut scores = HashMap::new();\nscores.insert(\"Blue\", 10);   // 追加\nscores.insert(\"Red\", 15);    // 追加\n```\n\n`use` で機能を読み込んでからuse。",
    "rust_lesson3_ex4_title": "map でiterator変換",
    "rust_lesson4_ex1_slide3_content": "共通の振る舞いを定義するトレイトを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex4_description": "variableのvalueを手軽に増やしたり減らしたりdo「+=」「-=」を学びましょう。",
    "rust_lesson1_ex2_description": "データに名前をつけて保存できる「variable（へんすう）」を使ってみましょう。letでvariableをcreate。",
    "rust_lesson4_ex4_slide2_title": "referenceカウントの仕組み",
    "rust_lesson3_ex8_slide2_title": "unwrap_or_else",
    "rust_lesson4_ex10_comment1": "1番目の i にindex、2番目の item にelementが入る",
    "rust_lesson3_ex6_slide1_content": "# 累積処理\n\nfold は、初期valueとfunctionでelementを1つずつ畳み込みます。\n\n```rust\nlet v = vec![1, 2, 3];\nlet sum = v.iter().fold(0, |acc, x| acc + x);\n// 6\n```",
    "rust_lesson4_ex2_slide2_title": "よくuse derive トレイト",
    "rust_lesson3_ex10_slide3_content": "文字列型の違いを理解しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex4_slide2_content": "変数の値を手軽に増やしたり減らしたりする「+=」「-=」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex4_slide3_title": "Let's Try It!",
    "rust_lesson3_ex5_slide1_title": "filter（filterー）?",
    "rust_lesson4_ex5_description": "keyとvalueのpairを格納しましょう。",
    "rust_lesson3_ex5_description": "条件に合うelementだけを取り出しましょう。",
    "rust_lesson2_ex2_slide2_content": "# functionに借りてもらう\n\nfunctionにデータを渡すとき、`&` をつけると「借りる」形になります。元のvariableはそのまま使い続けられます。\n\ncodeExample：\n```rust\nfn calc_len(s: &String) -> usize {\n    s.len()  // 長さを返す\n}\n\nfn main() {\n    let text = String::from(\"hello\");\n    let len = calc_len(&text);  // textを貸す\n    // text はまだ使える！\n    println!(\"{}の長さは{}\", text, len);\n}\n```\n\n`&String` は「Stringを借りる」という意味です。",
    "rust_lesson4_ex7_slide3_content": "パターンマッチに条件を追加しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex8_slide2_content": "# 遅延評価\n\n```rust\n// クロージャで計算\nlet value = x.unwrap_or_else(|| expensive_computation());\n```",
    "rust_lesson4_ex7_title": "match ガード",
    "rust_lesson3_ex7_title": "? operatorでerror伝播",
    "rust_lesson4_ex1_description": "共通の振る舞いをdefineトレイトを学びましょう。",
    "rust_lesson2_ex1_slide2_content": "# 所有権は「移動」do\n\nvariableを別のvariableにassignmentdoと、所有権が 移動（ムーブ） します。元のvariableは使えなくなります。\n\ncodeExample：\n```rust\nlet s1 = String::from(\"hello\");  // s1 が持ち主\nlet s2 = s1;  // 所有権が s2 に移動！\n// ↓ s1 はもう使えない（エラーになる）\n// println!(\"{}\", s1);  // ダメ！\nprintln!(\"{}\", s2);  // OK！\n```\n\nイメージ：\nおもちゃを友だちにあげたら、自分はもう使えない。これがムーブです。",
    "rust_lesson1_ex8_slide1_title": "dictionary（HashMap）?",
    "rust_lesson4_ex3_slide2_content": "# サイズが決まらないとき\n\nBoxは、コンパイル時にサイズがわからないtypeにuse。\n\nFor examplerecursion的なtype：\n```rust\n// リストは「値 + 次のリスト」の繰り返し\nenum List {\n    Cons(i32, Box<List>),  // Boxで次を指す\n    Nil,                   // 終わり\n}\n```\n\nなぜBoxが必要？\n- `List` の中に `List` がある → 無限に大きくなる？\n- `Box` をuseと、サイズが固定（pointerのサイズ）になる\n\n「中身」ではなく「中身への矢印」を持つイメージです。",
    "rust_lesson2_ex10_title": "ジェネリクスを使おう",
    "rust_lesson2_ex8_slide3_title": "Let's Try It!",
    "rust_lesson3_ex9_slide2_content": "# 可変reference\n\n```rust\n// mut が必要\nlet mut v = Vec::new();\nv.push(1);\nv.push(2);\n```",
    "rust_lesson4_ex4_title": "Rc<T>",
    "rust_lesson2_ex3_comment1": "mut で可変variableにdo",
    "rust_lesson4_ex5_slide3_title": "Let's Try It!",
    "rust_lesson2_ex6_slide2_content": "# バリアントを列挙\n\n`enum 名前 { バリアント1, バリアント2, ... }` でdefine。\n\ncodeExample：\n```rust\nenum Color {\n    Red,\n    Green,\n    Blue,\n}\nlet c = Color::Red;\n```",
    "rust_lesson1_ex1_comment1": "Hello, Rust! とdisplay",
    "rust_lesson1_ex1_slide1_content": "# 安全で速い！最新のプログラミング言語\n\nRust（ラスト）は、「間違いを事前に防ぐ」ことがとても得意なプログラミング言語です。\n\nRustのすごいところ：\n- programのミスをexecute前に見つけてくれる\n- とても速く動く\n- 世界中のプログラマーが「一番好き！」と選ぶ人気の言語\n\nたとえるなら：\n厳しいけど優しい先生のような言語です。「ここ間違ってるよ」と教えてくれるので、安心してprogramが書けます！",
    "rust_lesson3_ex8_slide1_content": "# None/Err の場合のデフォルト\n\nunwrap_or は、None や Err の場合にデフォルトvalueをreturn。\n\n```rust\nlet x: Option<i32> = None;\nlet value = x.unwrap_or(0);  // 0\n```",
    "rust_lesson2_ex7_slide3_title": "Let's Try It!",
    "rust_lesson2_ex6_title": "enum で状態を表す",
    "rust_lesson2_ex8_slide1_content": "# 「成功」か「失敗」かを表す\n\nResult<T, E> は、処理が「成功したか失敗したか」を表すtypeです。\n\nFor example：\n- fileをopen → 成功（内容）か失敗（error）\n- 0で割り算 → 成功（答え）か失敗（0で割れない！）\n\n2つの状態：\n- `Ok(値)` → 成功！valueが入っている\n- `Err(エラー)` → 失敗...error情報が入っている\n\n`Option` は「あるか・ないか」、`Result` は「成功か・失敗か」という違いです。",
    "rust_lesson2_ex8_slide3_content": "成功と失敗を表す「Result」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex6_slide1_title": "HashSet ?",
    "rust_lesson3_ex9_comment1": "push でelementを追加",
    "rust_lesson2_ex7_slide2_title": "Option  Usage",
    "rust_lesson3_ex2_title": "closureのBasic",
    "rust_lesson3_ex7_slide1_title": "? operator?",
    "rust_lesson4_ex6_comment1": "HashSet をimport",
    "rust_lesson2_ex10_slide1_content": "# どんなtypeでも使える「万能」の仕組み\n\nジェネリクス は、typeを後から決められる仕組みです。\n\nなぜ便利？\n同じようなfunctionを何度も書かなくてすみます。\n\nFor example：\n- 数字のarrayの最初のelementを取るfunction\n- stringのarrayの最初のelementを取るfunction\n\n両方とも「最初のelementを取る」のは同じなのに、typeが違うだけで別のfunctionをwriteのは大変！\n\nジェネリクスなら、`<T>` で「typeは後で決める」とwriteだけで、どんなtypeでも使えるfunctionが作れます。",
    "rust_lesson1_ex3_slide1_content": "# 剰余operator（じょうよえんざんし）「%」\n\n`%`（パーセント）は、割り算の 「あまり」 をcalculate特別な記号です。\n\nわかりやすいExample：\n- 10このアメを3人で分けると？\n- 1人3こずつで、1こあまる\n- これを `10 % 3` とwriteと、答えは `1`\n\ncodeExample：\n```rust\nprintln!(\"{}\", 10 % 3);  // 1（あまり1）\nprintln!(\"{}\", 8 % 4);   // 0（あまりなし＝割り切れる）\n```\n\n使いどころ：\n- 偶数か奇数か調べる（`n % 2` が0なら偶数）\n- 時計の計算（24を超えたら0に戻る、など）",
    "rust_lesson3_ex7_description": "errorを簡潔に伝播させましょう。",
    "rust_lesson3_ex8_comment1": "unwrap_or でデフォルトvalueを設定",
    "rust_lesson2_ex8_title": "Result<T, E> でerror処理",
    "rust_lesson2_ex10_comment1": "T をtypeパラメータとしてuse",
    "rust_lesson2_ex6_comment1": "enum で列挙typeをdefinition",
    "rust_lesson3_ex3_slide3_content": "要素を順番に処理するイテレータを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex2_comment1": "derive でトレイトを自動implementation",
    "rust_lesson1_ex8_slide1_content": "# 名前でsearchできる「dictionary」\n\nHashMap（ハッシュmap）は、「名前」と「データ」をsetにして保存できる仕組みです。本物のdictionaryのように使えます。\n\nFor example果物の色dictionary：\n- 「りんご」→「あか」\n- 「バナナ」→「きいろ」\n- 「みかん」→「オレンジ」\n\nuse準備：\n```rust\nuse std::collections::HashMap;  // 機能を読み込む\nlet mut fruits = HashMap::new();  // 空の辞書を作る\nfruits.insert(\"りんご\", \"あか\");  // データを追加\n```\n\n`use` は「この機能をuseよ」というdeclarationです。",
    "rust_lesson3_ex9_slide1_title": "push ?",
    "rust_lesson4_ex1_title": "トレイトのdefinition",
    "rust_lesson4_ex3_description": "heapにデータを格納doBoxを学びましょう。",
    "rust_lesson1_ex2_title": "便利な「はこ」variable（へんすう）",
    "rust_lesson1_ex8_comment2": "中身を出す",
    "rust_lesson3_ex9_slide3_title": "Let's Try It!",
    "rust_lesson1_ex4_comment3": "-= で 50 を引く",
    "rust_lesson1_ex6_comment1": "&& で両方の条件をチェック",
    "rust_lesson4_ex1_slide2_title": "トレイトのimplementation",
    "rust_lesson4_ex7_slide3_title": "Let's Try It!",
    "rust_lesson4_title": "Rust IV - トレイトとスマートpointer",
    "rust_lesson4_ex1_comment1": "trait でトレイトをdefinition",
    "rust_lesson4_ex4_slide1_content": "# 複数の「持ち主」を許可do仕組み\n\nRc<T> は「Reference Counted（referenceカウント）」の略で、複数の所有者でデータを共有できます。\n\n普通の所有権：\n1人だけが持ち主。渡したら元の人は使えない。\n\nRc をuseと：\n複数人が同じデータの「持ち主」になれる！\n\ncodeExample：\n```rust\nuse std::rc::Rc;\n\nlet a = Rc::new(5);       // Rcでラップ\nlet b = Rc::clone(&a);    // bも持ち主になる\n// a も b も使える！\n```",
    "rust_lesson3_ex5_slide1_content": "# 条件に合うものだけ残す\n\nfilter は、条件を満たすelementだけを残し、他を捨てます。\n\nFor example：\n- 80点以上の人だけ残す\n- 偶数だけ残す\n- 「あ」から始まる名前だけ残す\n\ncodeExample：\n```rust\nlet v = vec![1, 2, 3, 4, 5];\nlet evens: Vec<_> = v.iter()\n    .filter(|x| **x % 2 == 0)  // 偶数だけ\n    .collect();\n// [2, 4]\n```\n\n条件が `true` のelementだけが残ります。",
    "rust_lesson3_ex7_slide3_title": "Let's Try It!",
    "rust_lesson1_ex7_comment2": "2番目のデータ（1番）を出す",
    "rust_lesson4_ex8_title": "impl Trait",
    "rust_lesson1_ex5_description": "条件によって動きを変える if文を学びましょう。",
    "rust_lesson3_ex4_slide2_title": "遅延評価（ちえんひょうか）",
    "rust_lesson3_ex1_slide1_content": "# referenceの「寿命」を示す印\n\nライフタイム は、referenceがいつまで使えるかを示す印です。`'a`（アポストロフィ・エー）のようにwrite。\n\nなぜ必要？\nreferenceは「借りている」状態。借りた元のデータが消えたら、referenceも使えなくなります。\n\nFor example：\n- 図書館で借りた本 → 図書館が閉まったら読めない\n- referenceで借りたデータ → 元のデータが消えたら使えない\n\nライフタイムは「このreferenceはこの範囲で有効だよ」とコンパイラに伝える仕組みです。",
    "rust_lesson1_ex1_slide1_title": "Rust（ラスト）?",
    "rust_lesson1_ex2_slide2_title": "計算の記号（operator）",
    "rust_lesson4_ex5_slide2_content": "# get で安全に取り出す\n\n`get()` methodでvalueを取り出せます。見つからない可能性があるので、`Option` が返ってきます。\n\ncodeExample：\n```rust\n// getはOption<&V>を返す\nif let Some(score) = scores.get(\"Blue\") {\n    println!(\"青チームは{}点\", score);\n}\n```\n\nPoint：\n- keyがあれば `Some(値)` が返る\n- keyがなければ `None` が返る\n- `if let` で安全に取り出せる\n\n存在しないkeyでアクセスしてもprogramが落ちない！",
    "rust_lesson4_ex7_slide1_title": "match ガード?",
    "rust_lesson3_title": "Rust III - ライフタイムとiterator",
    "rust_lesson4_ex3_title": "Box<T>",
    "rust_lesson1_ex4_slide1_title": "累算assignmentoperator（るいさんだいにゅう）?",
    "rust_lesson2_ex9_comment1": "trait でトレイトをdefinition",
    "rust_lesson2_ex1_description": "Rust独自の概念「所有権」を学びましょう。",
    "rust_lesson2_ex3_slide3_content": "参照先の値を変更できる「可変参照」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex1_slide3_title": "Let's Try It!",
    "rust_lesson3_ex6_slide2_title": "様々な畳み込み",
    "rust_lesson4_ex9_slide3_title": "Let's Try It!",
    "rust_lesson2_ex5_title": "impl でmethodを追加",
    "rust_lesson2_ex6_slide1_content": "# 複数の選択肢\n\nenum は、valueがいくつかの種類のうちの一つであることを表します。各バリアントにデータを持たせることもできます。",
    "rust_lesson2_ex4_comment1": "struct で構造体をdefinition",
    "rust_lesson1_ex3_title": "剰余operator（%）",
    "rust_lesson1_ex7_comment1": "colors というベクタをcreate（'あか', 'あお'の順）",
    "rust_lesson1_ex4_slide1_content": "# valueをかんたんに増やす・減らす\n\n`+=`（プラスイコール）と `-=`（マイナスイコール）は、variableの中身を増やしたり減らしたりdo便利な記号です。\n\nRustのImportantなルール：`mut`が必要！\nRustでは、variableをchangeには `let mut`（レット ミュート）とwrite必要があります。`mut` は「mutable（変更できる）」の略です。\n\ncodeExample：\n```rust\nlet mut score = 100;  // mut をつけて変更可能に\nscore += 10;          // 10を足す → 110に\nscore -= 50;          // 50を引く → 60に\n```\n\n`mut` がないと「このvariableは変えちゃダメ！」とRustが怒ります。",
    "rust_lesson2_ex1_slide2_title": "ムーブ（移動）",
    "rust_lesson3_ex4_comment1": "map で各elementを変換",
    "rust_lesson3_ex8_slide1_title": "unwrap_or ?",
    "rust_lesson2_ex5_slide1_content": "# implementationブロック\n\nimpl ブロックで、構造体にmethodを追加できます。`self` で自分自身をreferenceします。",
    "rust_lesson2_ex10_slide1_title": "ジェネリクス?",
    "rust_lesson1_ex8_slide2_content": "# 名前（key）で取り出す\n\ndictionaryに入れたデータは、名前（key）を指定して取り出せます。\n\ncodeExample：\n```rust\nuse std::collections::HashMap;\nfn main() {\n    let mut fruits = HashMap::new();\n    fruits.insert(\"りんご\", \"あか\");  // 追加\n    fruits.insert(\"バナナ\", \"きいろ\");  // 追加\n    \n    println!(\"{}\", fruits[\"りんご\"]);  // あか と表示\n}\n```\n\nPoint：\n- `insert(名前, データ)` で追加\n- `辞書[名前]` で取り出し\n- 番号ではなく「名前」で探せるのが便利！",
    "rust_lesson4_ex9_slide1_content": "# iteratorをコレクションに\n\ncollect は、iteratorをVecやHashMapなどに変換します。\n\n```rust\nlet v: Vec<_> = (0..5).collect();\nlet s: String = vec!['a', 'b'].into_iter().collect();\n```",
    "rust_lesson2_ex2_slide3_content": "所有権を移さずに値を借りる「参照」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex2_slide3_content": "周囲の変数を使える無名関数「クロージャ」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex4_slide2_content": "# struct keyワードでdefinition\n\n`struct 名前 { フィールド }` で構造体をdefine。フィールドには名前とtypeをwrite。\n\ncodeExample：\n```rust\n// Point 構造体を定義\nstruct Point {\n    x: i32,  // xフィールド（整数）\n    y: i32,  // yフィールド（整数）\n}\n\n// 使い方\nlet p = Point { x: 10, y: 20 };\nprintln!(\"x={}, y={}\", p.x, p.y);\n```\n\nPoint：\n- `struct 名前` で構造体をcreate\n- `{ フィールド名: 型 }` でどんなデータを持つか決める\n- `.フィールド名` でアクセス",
    "rust_lesson2_ex10_slide3_content": "型を後から決められる「ジェネリクス」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex6_slide3_title": "Let's Try It!",
    "rust_lesson4_ex6_slide1_content": "# 一意なvalueのset\n\nHashSet は、重複のないvalueのsetです。\n\n```rust\nuse std::collections::HashSet;\n\nlet mut set = HashSet::new();\nset.insert(1);\nset.insert(2);\nset.insert(1); // 重複は無視\n```",
    "rust_lesson4_ex2_title": "derive 属性",
    "rust_lesson4_ex2_slide1_content": "# トレイトを「自動で」implementation\n\n#[derive(...)] をuseと、よくuseトレイトを自分で書かなくても自動でimplementationしてくれます。\n\nFor example：\n構造体を `println!` でdisplayしたいとき、普通は Display トレイトをimplementationdo必要がありますが、`#[derive(Debug)]` をwriteだけでOK！\n\ncodeExample：\n```rust\n#[derive(Debug)]  // Debug トレイトを自動実装\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nlet p = Point { x: 1, y: 2 };\nprintln!(\"{:?}\", p);  // Point { x: 1, y: 2 }\n```",
    "rust_lesson1_ex6_slide2_title": "Let's Try It!",
    "rust_lesson3_ex3_slide2_title": "3つの iter method",
    "rust_lesson4_ex7_slide2_content": "# 複雑なconditional\n\n```rust\nmatch Some(5) {\n    Some(x) if x % 2 == 0 => println!(\"even\"),\n    Some(x) => println!(\"odd: {}\", x),\n    None => println!(\"none\"),\n}\n```",
    "rust_lesson3_ex3_slide1_content": "# elementを1つずつ取り出す仕組み\n\niterator は、ベクタなどのデータを「1つずつ順番に」取り出す仕組みです。\n\nFor example：\n- 行列に並んでいる人を1人ずつ呼ぶ\n- 引き出しの中身を1つずつ出す\n\ncodeExample：\n```rust\nlet v = vec![1, 2, 3];\nfor x in v.iter() {\n    println!(\"{}\", x);  // 1, 2, 3 と順番に表示\n}\n```\n\n`iter()` で「順番に取り出す準備」をして、`for` で1つずつ処理します。",
    "rust_lesson3_ex3_slide1_title": "iterator?",
    "rust_lesson4_ex2_description": "トレイトを自動implementationdoderiveを学びましょう。",
    "rust_lesson3_ex4_slide1_content": "# 全部を同じように変換do\n\n**map** は、iteratorの各elementを「同じ方法で」変換します。\n\nFor example：\n- 全員の身長を2倍にdo\n- 全員の名前を大文字にdo\n- 全部の数を2乗do\n\ncodeExample：\n```rust\nlet v = vec![1, 2, 3];\nlet doubled: Vec<_> = v.iter()\n    .map(|x| x * 2)  // 各要素を2倍に\n    .collect();      // ベクタに戻す\n// [2, 4, 6]\n```\n\n`|x| x * 2` は「xを受け取って、x*2をreturn」closureです。",
    "rust_lesson1_ex3_slide1_title": "あまりを求める",
    "rust_lesson3_ex10_slide1_content": "# 所有権の違い\n\nString は所有権を持つheap上のstring、&str はreferenceです。\n\n```rust\nlet s1: String = String::from(\"hello\");\nlet s2: &str = \"hello\";\n```",
    "rust_lesson4_ex2_slide1_title": "derive（デライブ）?",
    "rust_lesson2_ex2_comment1": "& でreferenceを渡す",
    "rust_lesson4_ex5_slide1_title": "HashMap（ハッシュmap）?",
    "rust_lesson2_ex3_slide2_title": "&mut  Usage",
    "rust_lesson3_ex5_title": "filter で絞り込み",
    "rust_lesson4_ex3_slide2_title": "いつuse？",
    "rust_lesson2_ex2_title": "referenceと借用",
    "rust_lesson2_ex7_title": "Option<T> で null を安全に",
    "rust_lesson4_ex10_slide3_title": "Let's Try It!",
    "rust_lesson3_ex5_slide3_title": "Let's Try It!",
    "rust_lesson4_ex10_title": "enumerate でindex付き",
    "rust_lesson2_ex2_slide1_content": "# 所有権を渡さずに「借りる」\n\nreference をuseと、所有権を移さずにデータを「見せてもらう」ことができます。\n\nたとえるなら：\n- ムーブ = おもちゃをあげる（自分は使えない）\n- reference = おもちゃを見せる（自分も使える）\n\n作り方：\n`&`（アンパサンド）をつけるとreferenceを作れます。\n\n```rust\nlet s = String::from(\"hello\");\nlet r = &s;  // sを借りる（見せてもらう）\n// s も r も使える！\n```",
    "rust_lesson2_ex5_slide2_content": "# &self をuse\n\nmethodの最初のargumentは `&self` です。\n\ncodeExample：\n```rust\nimpl Rect {\n    fn area(&self) -> i32 {\n        self.width * self.height\n    }\n}\n```",
    "rust_lesson1_ex5_slide2_title": "Let's Try It!",
    "rust_lesson2_ex4_slide3_title": "Let's Try It!",
    "rust_lesson4_ex3_slide3_title": "Let's Try It!",
    "rust_lesson2_ex9_slide3_content": "共通の振る舞いを定義する「トレイト」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex1_slide2_content": "# impl で約束を守る\n\n構造体にトレイトをimplementationdoと、その構造体は「約束を守る」ことになります。\n\ncodeExample：\n```rust\nstruct Person { name: String }\n\nimpl Greet for Person {\n    fn greet(&self) -> String {\n        format!(\"Hello, {}\", self.name)\n    }\n}\n```\n\n読み方：\n- `impl Greet for Person` → 「PersonはGreetをimplementationdo」\n- これでPersonは「あいさつできる」ようになった！",
    "rust_lesson4_ex4_comment1": "clone でreferenceカウントを増やす",
    "rust_lesson3_ex4_slide2_content": "# map だけではexecuteされない！\n\nRustのiteratorは 遅延評価 といって、「本当に必要になるまで処理しない」仕組みです。\n\nなぜ？\n無駄な計算を省けるから。100万件あっても、最初の10件だけ欲しいなら10件だけ処理すればいい。\n\ncollect() でexecute：\n```rust\n// これだけでは何も起きない\nv.iter().map(|x| x * 2);\n\n// collect() で実行してベクタに変換\nlet result: Vec<_> = v.iter().map(|x| x * 2).collect();\n```\n\n`collect()` は「今すぐ全部処理してResultをちょうだい」という意味です。",
    "rust_lesson2_ex4_slide2_title": "struct のdefinitionのしかた",
    "rust_lesson2_ex3_slide1_content": "# 「書き換えできる」借り方\n\n普通のreference `&` は「見るだけ」ですが、可変reference `&mut` は「変更もできる」借り方です。\n\nたとえるなら：\n- `&` = 本を見せてもらう（readだけ）\n- `&mut` = ノートを借りる（writeOK）\n\nImportantなルール：\n- 可変referenceは同時に1つだけ！\n- 「みんなで見る」か「1人でwrite」かのどちらか\n\nこのルールで、データが同時に書き換えられるバグを防いでいます。",
    "rust_lesson2_ex10_slide3_title": "Let's Try It!",
    "rust_lesson2_ex4_title": "構造体をdefinitionしよう",
    "rust_lesson3_ex10_slide2_content": "# 相互変換\n\n```rust\n// &str -> String\nlet s = \"hello\".to_string();\n\n// String -> &str\nlet slice: &str = &s;\n```",
    "rust_lesson4_ex10_slide3_content": "イテレータにインデックスを付けましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex4_slide2_content": "# 「何人が持っているか」を数える\n\nRcは「今何人がこのデータを持っているか」を数えています。\n\ncodeExample：\n```rust\nlet a = Rc::new(5);\nprintln!(\"{}\", Rc::strong_count(&a));  // 1\n\nlet b = Rc::clone(&a);\nprintln!(\"{}\", Rc::strong_count(&a));  // 2\n```\n\nいつデータが消える？\n- カウントが0になったとき（誰も持っていないとき）\n- 最後の持ち主がいなくなると自動で片付けられる\n\n`Rc::clone` は「持ち主を1人増やす」操作です。",
    "rust_lesson1_ex8_slide2_title": "dictionary Usage",
    "rust_lesson4_ex3_slide1_content": "# データを「heap」に置く箱\n\nBox<T> は、データを「heap」という特別な場所に置くための箱です。\n\nmemoryの2つの場所：\n- stack：小さくて速い。サイズが決まっているデータ向け\n- heap：大きくて柔軟。サイズが大きいor変わるデータ向け\n\ncodeExample：\n```rust\nlet b = Box::new(5);  // 5をヒープに置く\nprintln!(\"{}\", *b);   // *で中身を取り出す → 5\n```\n\n`*` は「箱を開けて中身を見る」操作です。",
    "rust_lesson3_ex2_slide2_title": "closure Syntax",
    "rust_lesson4_ex4_slide1_title": "Rc（アールシー）?",
    "rust_lesson4_ex7_slide1_content": "# 追加条件\n\n**if** でパターンに追加条件をつけられます。\n\n```rust\nmatch x {\n    n if n < 0 => println!(\"negative\"),\n    n if n > 0 => println!(\"positive\"),\n    _ => println!(\"zero\"),\n}\n```",
    "rust_lesson2_ex3_title": "可変reference",
    "rust_lesson3_ex10_comment1": "to_string で String に変換",
    "rust_lesson3_ex10_slide2_title": "変換",
    "rust_lesson3_ex1_description": "referenceの有効期間を表すライフタイムを学びましょう。",
    "rust_lesson3_ex2_slide1_content": "# 名前のない「即席」function\n\nclosure は、名前をつけずにその場でcreatefunctionです。そして特別な能力があります：周りのvariableを使えるのです！\n\nFor example：\n```rust\nlet x = 5;  // 外側の変数\nlet add_x = |n| n + x;  // xを使えるクロージャ\nprintln!(\"{}\", add_x(10));  // 15\n```\n\n普通のfunctionとの違い：\n- 普通のfunction：argumentしか使えない\n- closure：argument + 周りのvariableも使える\n\n「その場の空気を読める」functionというイメージです！",
    "rust_lesson1_ex2_comment1": "x に 10 を入れる",
    "rust_lesson1_ex7_slide3_title": "Let's Try It!",
    "rust_lesson1_ex5_title": "「もし〜なら」で分けましょう",
    "rust_lesson3_ex2_slide3_title": "Let's Try It!",
    "rust_lesson3_ex7_slide2_content": "# 簡潔なerror処理\n\n```rust\n// ? を使わない場合\nmatch result {\n    Ok(v) => v,\n    Err(e) => return Err(e),\n}\n\n// ? を使う\nresult?\n```",
    "rust_lesson3_ex6_slide3_title": "Let's Try It!",
    "rust_lesson4_ex9_slide3_content": "イテレータをコレクションに変換しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex6_description": "elementを1つのvalueにまとめるfoldを学びましょう。",
    "rust_lesson2_ex9_description": "共通の振る舞いをdefine「トレイト」を学びましょう。",
    "rust_lesson2_ex8_comment1": "Ok で成功をreturn",
    "rust_lesson3_ex5_slide2_content": "# filter はreferenceのreferenceを受け取る\n\n`filter` のclosureは、referenceのreference（`&&T`）を受け取ります。そのため、valueをuseには `**x` と2回referenceを外す必要があります。\n\nなぜ？\n- `iter()` はreference（`&T`）をreturn\n- `filter` はそれをFurthermorereferenceで渡す（`&&T`）\n\nSyntax：\n```rust\n// **x で値を取り出す\n.filter(|x| **x > 2)\n\n// または * を引数につける\n.filter(|&x| *x > 2)\n```\n\n最初は混乱しますが、慣れれば大丈夫！",
    "rust_lesson1_ex5_comment1": "> でcompare",
    "rust_lesson2_ex4_description": "関連doデータをまとめる「構造体」を学びましょう。",
    "rust_lesson3_ex5_slide3_content": "条件に合う要素だけを取り出しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex7_slide3_content": "「ベクタ（Vec）」を使うと、たくさんのデータを一つの「長い はこ」にまとめて入れられます。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex5_slide2_title": "valueの取得",
    "rust_lesson3_ex1_slide1_title": "ライフタイム?",
    "rust_lesson1_ex3_comment1": "10 を 3 で割ったあまりをoutput",
    "rust_lesson3_ex1_comment1": "'a でライフタイムをdefinition",
    "rust_lesson3_ex10_slide1_title": "String vs &str",
    "rust_lesson2_title": "Rust II - 所有権とトレイト",
    "rust_lesson2_ex5_slide2_title": "methodのdefinition",
    "rust_lesson4_ex5_comment1": "insert でkeyとvalueを追加",
    "rust_lesson2_ex9_slide1_content": "# 「できること」の約束\n\nトレイト は、「このtypeはこういうことができる」という約束をdefine。\n\nFor example「鳴ける」という約束：\n- 犬は「ワン」と鳴く\n- 猫は「ニャー」と鳴く\n- 両方とも「鳴ける」能力がある\n\nトレイトは「鳴ける動物は、鳴き声を出すmethodを持つ」という約束です。\n\n他の言語とのcomparison：\n- Java: interface\n- TypeScript: interface\n\nに似た概念です。",
    "rust_lesson1_ex2_slide3_title": "Let's Try It!",
    "rust_lesson4_ex8_slide1_content": "# return valueのtypeをabstract化\n\nimpl Trait で、トレイトをimplementationdotypeを返せます。\n\n```rust\nfn make_iter() -> impl Iterator<Item = i32> {\n    vec![1, 2, 3].into_iter()\n}\n```",
    "rust_lesson1_ex2_slide2_content": "# 四則演算（しそくえんざん）\n\nRustでも算数と同じ記号で計算ができます。\n\n4つのBasic記号：\n- +（プラス）: たし算\n- -（マイナス）: ひき算\n- \\*（アスタリスク）: かけ算（×の代わり）\n- /（スラッシュ）: わり算（÷の代わり）\n\ncodeExample：\n```rust\nlet a = 10;\nlet b = 5;\nprintln!(\"{}\", a + b);  // 15 と表示される\n```\n\n`println!` の `{}` は「ここにvalueを入れてね」という目印です。",
    "rust_lesson4_ex9_slide2_content": "# 変換先を指定\n\n```rust\n// ターボフィッシュ構文\nlet v = (0..5).collect::<Vec<_>>();\n\n// 変数の型注釈\nlet v: Vec<i32> = (0..5).collect();\n```",
    "rust_lesson1_ex8_description": "「dictionary（HashMap）」をuseと、名前をつけてデータを保存し、その名前で取り出せます。",
    "rust_lesson4_ex9_slide2_title": "typeHint",
    "rust_lesson3_ex1_title": "ライフタイムのBasic",
    "rust_lesson2_ex5_description": "構造体にmethodをadd「impl」を学びましょう。",
    "rust_lesson4_ex8_comment1": "impl でトレイトをimplementationdotypeをreturn",
    "rust_lesson4_ex8_slide2_title": "argumentにも使える",
    "rust_lesson4_ex7_comment1": "if でマッチガードを追加",
    "rust_lesson2_ex9_slide2_title": "trait のdefinitionとimplementation",
    "rust_lesson4_ex10_slide2_title": "いつuse？",
    "rust_lesson3_ex7_slide2_title": "match の省略形",
    "rust_lesson1_ex6_title": "logicaloperator（&&、||）",
    "rust_lesson3_ex6_comment1": "fold で畳み込み",
    "rust_lesson2_ex6_description": "複数の状態を表す「列挙type（enum）」を学びましょう。",
    "rust_lesson4_ex10_slide1_title": "enumerate（イニュメレート）?",
    "rust_lesson1_ex7_slide1_title": "ベクタ（Vec）?",
    "rust_lesson2_ex6_slide3_content": "複数の状態を表す「列挙型（enum）」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex3_slide3_title": "Let's Try It!",
    "rust_lesson3_ex4_description": "各elementを変換domapを学びましょう。",
    "rust_lesson4_ex1_slide3_title": "Let's Try It!",
    "rust_lesson3_ex9_slide2_title": "mut が必要",
    "rust_lesson1_ex6_slide1_content": "# logicaloperator（ろんりえんざんし）\n\n2つ以上の条件を組み合わせたいときにuse記号です。\n\n2つの記号：\n- `&&`（アンドアンド）：「かつ」＝ 両方とも 正しいとき\n- `||`（オアオア）：「Alsoは」＝ どちらか 正しいとき\n\n身近なExample：\n- 遊園地：「18歳以上 かつ チケットあり」なら乗れる\n- おやつ：「宿題終わった Alsoは お手伝いした」ならOK\n\ncodeExample：\n```rust\nif score >= 70 && bonus > 0 {\n    // 70点以上 かつ ボーナスあり → 合格！\n    println!(\"合格！\");\n}\n```",
    "rust_lesson4_ex4_slide3_content": "参照カウントでデータを共有しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex6_slide3_title": "Let's Try It!",
    "rust_lesson2_ex5_slide3_content": "構造体にメソッドを追加する「impl」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex1_slide3_title": "Let's Try It!",
    "rust_lesson1_ex5_slide1_content": "# programに「判断」させよう\n\nconditional は、「もし〜なら、〇〇do」という判断をprogramにさせる仕組みです。\n\n身近なExample：\n- もし80点以上なら → 「合格！」とdisplay\n- もし雨なら → 傘を持っていく\n- もしHPが0なら → ゲームオーバー\n\nRustで Syntax：\n```rust\nif score > 80 {\n    println!(\"合格！\");\n}\n```\n\n読み方：\n- `if` →「もし」\n- `score > 80` →「スコアが80より大きいなら」\n- `{ }` の中 →「これをやる」",
    "rust_lesson4_ex5_title": "HashMap",
    "rust_lesson1_ex2_slide1_content": "# データを保存do「はこ」\n\nvariable（へんすう） は、数字や文字を入れておける「はこ」のことです。名前をつけて、あとでuseことができます。\n\nFor example：\n- 「りんごの数」というラベルの箱に「5」を入れる\n- あとで「りんごの数」と呼べば「5」が出てくる\n\nRustで Syntax：\n```rust\nlet x = 10;  // xという箱に10を入れる\nprintln!(\"{}\", x);  // xの中身（10）を表示\n```\n\n`let` は「この名前で箱をcreateよ」という意味です。",
    "rust_lesson2_ex4_slide3_content": "関連するデータをまとめる「構造体」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex6_slide1_title": "enum ?",
    "rust_lesson2_ex9_title": "トレイトをdefinitionしよう",
    "rust_lesson2_ex4_slide1_title": "構造体（こうぞうたい）?",
    "rust_lesson4_ex2_slide2_content": "# 覚えておくと便利な5つ\n\nよくusederiveトレイト：\n```rust\nDebug     // {:?} でデバッグ表示できる\nClone     // .clone() でコピーを作れる\nCopy      // 代入時に自動でコピー（小さい型向け）\nPartialEq // == で比較できる\nDefault   // 初期値を自動で作れる\n```\n\n複数指定もOK：\n```rust\n#[derive(Debug, Clone, PartialEq)]\nstruct User {\n    name: String,\n    age: u32,\n}\n```\n\n`Debug` は特によくuse。debug時に構造体の中身を見れて便利！",
    "rust_lesson2_ex1_slide1_content": "# データの「持ち主」を決めるルール\n\n所有権 は、Rust最大のFeatureです。「このデータの持ち主は誰か」をはっきりさせる仕組みです。\n\nルール：\n- データには必ず1人だけ「持ち主」がいる\n- 持ち主がいなくなると、データは自dynamicに片付けられる\n\nたとえるなら：\n- おもちゃは1人しか持てない\n- 持ち主が部屋を出たら、おもちゃは片付けられる\n\nこのルールのおかげで、Rustは「memoryリーク」（データが片付けられないバグ）を防げます！",
    "rust_lesson1_ex3_slide2_title": "Let's Try It!",
    "rust_lesson3_ex1_slide2_title": "なぜ必要？",
    "rust_lesson3_ex1_slide2_content": "# 危険なバグを防ぐ\n\nダングリングreference という危険なバグがあります。これは「もう存在しないデータ」を指し続けているreferenceのことです。\n\nExample：\n```rust\nfn longest<'a>(x: &'a str, y: &'a str) -> &'a str {\n    if x.len() > y.len() { x } else { y }\n}\n```\n\n`'a` の意味：\n- argument `x` と `y` は同じライフタイム `'a` を持つ\n- return valueも同じライフタイム `'a` を持つ\n- In other words「xとyが両方有効な間、return valueも有効」という約束\n\nRustはこれを自動でチェックしてくれます！",
    "rust_lesson4_ex6_slide2_title": "set演算",
    "rust_lesson3_ex7_comment1": "? でerrorを伝播",
    "rust_lesson3_ex2_slide2_content": "# | | でargumentを囲む\n\nclosureは `|引数| 処理` という形でwrite。`||` は「パイプ」と呼ばれます。\n\nいろいろなSyntax：\n```rust\n// 引数なし\n|| println!(\"Hello\")\n\n// 引数あり\n|x, y| x + y\n\n// 複数行のブロック\n|x| {\n    let y = x * 2;\n    y + 1\n}\n```\n\nPoint：\n- argumentを `| |` で囲む（functionの `()` の代わり）\n- typeは省略できることが多い（Rustが推測してくれる）",
    "rust_lesson2_ex7_comment1": "Some でvalueがあることを示す",
    "rust_lesson3_ex4_slide3_content": "各要素を変換するmapを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_title": "Rust (ラスト) に挑戦！",
    "rust_lesson2_ex8_description": "成功と失敗を表す「Result」を学びましょう。",
    "rust_lesson3_ex8_description": "Option/Resultのデフォルトvalueを設定しましょう。",
    "rust_lesson4_ex2_slide3_title": "Let's Try It!",
    "rust_lesson2_ex5_slide3_title": "Let's Try It!",
    "rust_lesson4_ex9_description": "iteratorをコレクションに変換しましょう。",
    "rust_lesson1_ex1_slide2_content": "# println! でscreenにdisplay\n\nRustで文字をscreenにdisplayには、`println!`（プリントラインびっくり）をuse。\n\nPoint：\n- `!` がつくのがRustのFeature（マクロと呼ばれます）\n- programは `fn main() { }` の中にwrite\n- `fn` は「function（function）」の略\n\ncodeExample：\n```rust\nfn main() {\n    println!(\"ヤッホー！\");\n}\n// 「ヤッホー！」と画面に表示される\n```\n\n`println!` の `!` は「マクロ」という特別な機能の印です。今は「おまじない」と思っておけばOK！",
    "rust_lesson3_ex6_slide1_title": "fold ?",
    "rust_lesson4_ex8_slide1_title": "impl Trait ?",
    "rust_lesson1_ex1_slide2_title": "Rustの「おまじない」",
    "rust_lesson3_ex10_description": "stringtypeの違いを理解しましょう。",
    "rust_lesson3_ex7_slide3_content": "エラーを簡潔に伝播させましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex1_comment1": "s1 の所有権を移動",
    "rust_lesson2_ex9_slide1_title": "トレイト?",
    "rust_lesson4_ex6_slide2_content": "# 和set、積setなど\n\n```rust\nset1.union(&set2)\nset1.intersection(&set2)\nset1.difference(&set2)\n```",
    "rust_lesson4_ex5_slide3_content": "キーと値のペアを格納しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex8_slide1_title": "Result（リザルト）?",
    "rust_lesson4_ex1_slide1_content": "# 「できること」の約束\n\nトレイト は、typeが持つべきmethodをdefine仕組みです。\n\nFor example：\n- 「あいさつできる」トレイト → greet() methodを持つ\n- 「displayできる」トレイト → display() methodを持つ\n\ncodeExample：\n```rust\ntrait Greet {\n    fn greet(&self) -> String;  // メソッドの「約束」\n}\n```\n\nこれは「Greetできるtypeは、greet()methodを持つ」という約束です。",
    "rust_lesson4_ex2_slide3_content": "トレイトを自動実装するderiveを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex6_title": "fold で畳み込み",
    "rust_lesson3_ex9_slide3_content": "Vecに要素を追加しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex4_slide1_content": "# 関係あるデータをまとめる「設計図」\n\n構造体（struct） は、いくつかのデータをひとまとめにdo仕組みです。\n\nFor example「点（座標）」のデータ：\n- x座標\n- y座標\n\nこの2つは関係があるので、「Point（点）」としてまとめると便利です。\n\nFor example「人」のデータ：\n- 名前\n- 年齢\n\nこれも「Person（人）」としてまとめられます。\n\n構造体は「こういうデータを持つ」という設計図です。",
    "rust_lesson4_ex1_slide1_title": "トレイト?（復習）",
    "rust_lesson2_ex3_description": "reference先のvalueを変更できる「可変reference」を学びましょう。",
    "rust_lesson2_ex7_slide2_content": "# match で安全に取り出す\n\n`match` を使って「ある場合」と「ない場合」で処理を分けます。\n\ncodeExample：\n```rust\nlet x: Option<i32> = Some(5);  // 値あり\n\nmatch x {\n    Some(n) => println!(\"値は{}です\", n),  // 5\n    None => println!(\"値がありません\"),\n}\n```\n\nなぜ安全？\n- `null` のように「あるつもりでアクセスしたら無かった」errorが起きない\n- 「ない場合」の処理を書かないとコンパイルerrorになる\n- 強制的に両方のケースを考えることになる！",
    "rust_lesson4_ex9_comment1": "collect で Vec に変換",
    "rust_lesson3_ex10_title": "String と &str",
    "rust_lesson2_ex7_slide1_title": "Option（オプション）?",
    "rust_lesson3_ex9_description": "Vecにelementを追加しましょう。",
    "rust_lesson2_ex5_comment1": "impl でmethodをimplementation",
    "rust_lesson3_ex1_slide3_content": "参照の有効期間を表すライフタイムを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex6_slide2_content": "複数の条件を組み合わせる「&&（かつ）」と「||（または）」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex5_comment1": "filter で条件に合うelementを絞り込む",
    "rust_lesson2_ex7_slide3_content": "値があるかないかを表す「Option」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex10_slide3_title": "Let's Try It!",
    "rust_lesson4_ex4_slide3_title": "Let's Try It!",
    "rust_lesson3_ex3_comment1": "iter でiteratorを取得",
    "rust_lesson3_ex6_slide3_content": "要素を1つの値にまとめるfoldを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex7_slide2_title": "ベクタの番号は「0」から！",
    "rust_lesson1_ex5_slide1_title": "conditional（じょうけんぶんき）?",
    "rust_lesson1_ex3_description": "割り算の「あまり」を求める「%」（パーセント）operatorを学びましょう。",
    "rust_lesson1_ex1_slide3_content": "Rustを使って画面に文字を表示してみましょう。println! という特別な関数を使います。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex10_slide2_content": "# <T> でtypeを「あとで決める」\n\nfunction名の後に `<T>` をつけて、`T` を「type」としてuse。\n\ncodeExample：\n```rust\n// Tはどんな型でもOK\nfn first<T>(arr: &[T]) -> &T {\n    &arr[0]  // 最初の要素を返す\n}\n\n// 使い方\nfirst(&[1, 2, 3]);         // Tはi32\nfirst(&[\"a\", \"b\", \"c\"]);   // Tは&str\n```\n\n読み方：\n- `<T>` → 「Tという名前のtypeをuseよ」\n- `T` は慣習で「Type（type）」の頭文字\n- 複数のtypeが必要なら `<T, U>` のようにwrite",
    "rust_lesson3_ex2_comment1": "|x| でclosureのargumentをdefinition",
    "rust_lesson3_ex3_description": "elementを順番に処理doiteratorを学びましょう。",
    "rust_lesson1_ex1_slide3_title": "Let's Try It!",
    "rust_lesson2_ex6_slide2_title": "enum のdefinition",
    "rust_lesson2_ex1_title": "所有権のBasic",
    "rust_lesson4_ex3_slide1_title": "Box（ボックス）?",
    "rust_lesson2_ex1_slide3_content": "Rust独自の概念「所有権」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex8_slide3_content": "Option/Resultのデフォルト値を設定しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex7_slide2_title": "使用Example",
    "rust_lesson4_ex10_description": "iteratorにindexを付けましょう。",
    "rust_lesson4_ex9_slide1_title": "collect ?",
    "rust_lesson4_ex10_slide2_content": "# 「何番目か」が必要なとき\n\n番号（index）とelementの両方が必要なときに便利です。\n\ncodeExample：\n```rust\nlet v = vec![10, 20, 30];\nfor (idx, val) in v.iter().enumerate() {\n    println!(\"{}番目の値は{}\", idx, val);\n}\n// 0番目の値は10\n// 1番目の値は20\n// 2番目の値は30\n```\n\nPoint：\n- `(i, x)` でtuple（2つのset）を受け取る\n- `i` にindex、`x` にelementが入る\n- indexは0から始まる",
    "rust_lesson3_ex2_description": "周囲のvariableを使えるanonymous function「closure」を学びましょう。",
    "rust_lesson1_ex4_comment1": "mut で変更可能にdo",
    "rust_lesson1_ex8_slide3_title": "Let's Try It!",
    "rust_lesson1_ex3_slide2_content": "割り算の「あまり」を求める「%」（パーセント）演算子を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex9_slide3_title": "Let's Try It!",
    "rust_lesson3_ex3_title": "iteratorのBasic",
    "rust_lesson3_ex9_title": "Vec のmethod push",
    "rust_lesson1_ex8_comment1": "dictionaryをcreate（keyは'みかん'、valueは'オレンジ'）",
    "rust_lesson1_ex2_comment3": "+ でたし算do",
    "rust_lesson4_ex8_slide2_content": "# ジェネリクスの代わり\n\n```rust\nfn print_all(iter: impl Iterator<Item = i32>) {\n    for x in iter {\n        println!(\"{}\", x);\n    }\n}\n```",
    "rust_lesson2_ex2_slide2_title": "reference Usage",
    "rust_lesson1_ex8_slide3_content": "「辞書（HashMap）」を使うと、名前をつけてデータを保存し、その名前で取り出せます。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex7_slide2_content": "# [ ]で番号を指定して取り出す\n\n`[番号]` で何番目のデータか指定して取り出せます。\n\nImportantなルール：番号は「0」から！\n- 1番目 → `[0]`\n- 2番目 → `[1]`\n- 3番目 → `[2]`\n\ncodeExample：\n```rust\nlet fruits = vec![\"りんご\", \"バナナ\", \"みかん\"];\n//                  ↑0番    ↑1番     ↑2番\nprintln!(\"{}\", fruits[0]);  // りんご\nprintln!(\"{}\", fruits[1]);  // バナナ\n```\n\nプログラミングでは「0から数える」のが世界共通のルールです！",
    "rust_lesson1_ex6_slide1_title": "条件を組み合わせる",
    "rust_lesson2_ex10_slide2_title": "ジェネリックfunction Syntax",
    "rust_lesson1_ex6_description": "複数の条件を組み合わせる「&&（かつ）」と「||（Alsoは）」を学びましょう。",
    "rust_lesson4_ex6_title": "HashSet",
    "rust_lesson2_ex3_slide2_content": "# mut が2か所に必要\n\n変更できるようにdoには、variableとreferenceの両方に `mut` が必要です。\n\ncodeExample：\n```rust\n// 1. 変数を mut で作る\nlet mut s = String::from(\"hello\");\n\n// 2. &mut で可変参照を渡す\nchange(&mut s);\n\nfn change(s: &mut String) {\n    s.push_str(\" world\");  // 変更できる！\n}\n```\n\nPoint：\n- `let mut 変数` でvariableを変更可能に\n- `&mut 変数` で可変referenceをcreate\n- 両方ないと変更できない！",
    "rust_lesson2_ex2_slide1_title": "reference（さんしょう）?",
    "rust_lesson3_ex6_slide2_content": "# 合計、積、結合など\n\n```rust\n// 積\nv.iter().fold(1, |acc, x| acc * x)\n\n// 文字列結合\nwords.iter().fold(String::new(), |acc, s| acc + s)\n```",
    "rust_lesson1_ex1_description": "Rustを使ってscreenに文字をdisplayしてみましょう。println! という特別なfunctionをuse。",
    "rust_lesson3_ex8_slide3_title": "Let's Try It!",
    "rust_lesson4_ex6_description": "一意なvalueのsetを管理しましょう。",
    "rust_lesson2_ex5_slide1_title": "impl ?",
    "rust_lesson1_ex8_title": "名前で引き出す「dictionary」",
    "rust_lesson2_ex7_description": "valueがあるかないかを表す「Option」を学びましょう。",
    "rust_lesson1_ex4_slide2_title": "Let's Try It!",
    "rust_lesson1_ex7_title": "たくさんのデータをまとめましょう「ベクタ」",
    "rust_lesson3_ex7_slide1_content": "# errorの早期リターン\n\n? は、Resultが Err の場合に早期リターンします。\n\n```rust\nfn read_file() -> Result<String, io::Error> {\n    let content = fs::read_to_string(\"file.txt\")?;\n    Ok(content)\n}\n```",
    "rust_lesson3_ex9_slide1_content": "# 末尾に追加\n\npush は、Vecの末尾にelementをadd。\n\n```rust\nlet mut v = vec![1, 2];\nv.push(3);\n// [1, 2, 3]\n```",
    "rust_lesson4_ex8_slide3_content": "トレイトを返す関数を簡潔に書きましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex1_title": "screenにメッセージを出しましょう",
    "rust_lesson2_ex8_slide2_title": "Result  Usage",
    "rust_lesson3_ex2_slide1_title": "closure?",
    "rust_lesson3_ex8_title": "unwrap_or でデフォルトvalue",
    "rust_lesson4_ex10_slide1_content": "# 番号とelementを一緒にもらう\n\nenumerate は、「何番目か」と「そのelement」をsetで取り出せるmethodです。\n\nFor example：\n- 0番目: りんご\n- 1番目: バナナ\n- 2番目: みかん\n\ncodeExample：\n```rust\nfor (i, x) in vec![\"a\", \"b\", \"c\"].iter().enumerate() {\n    println!(\"{}: {}\", i, x);\n}\n// 0: a\n// 1: b\n// 2: c\n```",
    "rust_lesson1_ex7_slide1_content": "# データを並べてまとめる「長い箱」\n\nベクタ（Vec） は、たくさんのデータを順番に並べて入れられる「長い箱」です。\n\nFor example：\n- 買い物listの商品を全部まとめる\n- testの点数を全部まとめる\n- 友だちの名前を全部まとめる\n\n100個でも1000個でも、1つのvariableでまとめて管理できます！\n\n作り方：\n```rust\nlet fruits = vec![\"りんご\", \"バナナ\", \"みかん\"];\n// vec! で ベクタを作る\n```",
    "rust_lesson4_ex8_slide3_title": "Let's Try It!",
    "rust_lesson4_ex7_description": "パターンマッチに条件を追加しましょう。",
    "rust_lesson1_ex4_comment2": "+= で 20 を足す",
    "rust_lesson1_ex2_comment2": "y に 5 を入れる",
    "rust_lesson2_ex3_slide3_title": "Let's Try It!",
    "rust_lesson3_ex4_slide1_title": "map（map）?",
    "rust_lesson1_ex2_slide3_content": "データに名前をつけて保存できる「変数（へんすう）」を使ってみましょう。letで変数を作ります。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex8_slide2_content": "# match で成功と失敗を分ける\n\n`match` で「成功したら」「失敗したら」の処理を書き分けます。\n\ncodeExample：\n```rust\nfn divide(a: i32, b: i32) -> Result<i32, String> {\n    if b == 0 {\n        return Err(\"0で割れません\".to_string());\n    }\n    Ok(a / b)  // 成功なら答えを返す\n}\n\nmatch divide(10, 2) {\n    Ok(v) => println!(\"答えは{}\", v),\n    Err(e) => println!(\"エラー: {}\", e),\n}\n```\n\nPoint：\n- `Ok(値)` で成功をreturn\n- `Err(エラー)` で失敗をreturn",
    "rust_lesson4_ex3_comment1": "Box::new でheapに格納",
    "rust_lesson4_ex8_description": "トレイトをreturnfunctionを簡潔に書きましょう。",
    "rust_lesson2_ex10_description": "typeを後から決められる「ジェネリクス」を学びましょう。",
    "rust_lesson2_ex3_slide1_title": "可変reference（かへんさんしょう）?",
    "rust_lesson2_ex2_description": "所有権を移さずにvalueを借りる「reference」を学びましょう。",
    "rust_lesson3_ex5_slide2_title": "** にNote！",
    "rust_lesson2_ex2_slide3_title": "Let's Try It!",
    "rust_lesson4_ex3_slide3_content": "ヒープにデータを格納するBoxを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex4_title": "累算assignmentoperator（+=、-=）",
    "rust_lesson3_ex3_slide2_content": "# 借りるか、もらうか\n\n3種類の iter があり、所有権の扱いが違います。\n\n3つの違い：\n```rust\nv.iter()       // 参照で借りる（&T）\nv.iter_mut()   // 変更可能で借りる（&mut T）\nv.into_iter()  // 所有権をもらう（T）\n```\n\n使い分け：\n- `iter()` → 見るだけ（元のベクタも使える）\n- `iter_mut()` → 中身を変更したい\n- `into_iter()` → ベクタごともらう（元は使えない）\n\n普通は `iter()` をuseことが多いです。",
    "rust_lesson2_ex1_slide1_title": "所有権（しょゆうけん）?",
    "rust_lesson4_ex6_slide3_content": "一意な値の集合を管理しましょう。\n\n（When you're ready, select \"Start Lesson\".）"
  },
  "de": {
    "rust_lesson1_course_title": "Introduction to Rust",
    "rust_lesson1_course_description": "Learn the basics of Rust programming.",
    "rust_lesson2_course_title": "Rust II - Intermediate",
    "rust_lesson2_course_description": "Learn intermediate Rust concepts.",
    "rust_lesson3_course_title": "Rust III - Advanced",
    "rust_lesson3_course_description": "Master advanced Rust techniques.",
    "rust_lesson4_course_title": "Rust IV - Expert Level",
    "rust_lesson4_course_description": "Expert-level Rust programming.",
    "rust_lesson1_ex5_slide2_content": "条件によって動きを変える if文を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex9_title": "collect で変換",
    "rust_lesson2_ex7_slide1_content": "# 「あるかもしれない、ないかもしれない」\n\nOption<T> は、valueが「あるかもしれないし、ないかもしれない」ことを表すtypeです。\n\nFor example：\n- dictionaryで単語を探す → 見つかるかもしれないし、ないかもしれない\n- ゲームでアイテムを拾う → 落ちてるかもしれないし、ないかもしれない\n\n2つの状態：\n- `Some(値)` → valueがある！\n- `None` → valueがない...\n\n他の言語では `null` をuseが、Rustでは `Option` で安全に扱います。",
    "rust_lesson1_ex2_slide1_title": "variable（へんすう）?",
    "rust_lesson1_ex7_description": "「ベクタ（Vec）」をuseと、たくさんのデータを一つの「長い はこ」にまとめて入れられます。",
    "rust_lesson2_ex9_slide2_content": "# 約束を作って、守る\n\n1. `trait` で「約束」をdefinition\n2. `impl トレイト for 型` で「約束を守る」implementationをdo\n\ncodeExample：\n```rust\n// 1. トレイト（約束）を定義\ntrait Speak {\n    fn speak(&self);  // 鳴くメソッドを持つ約束\n}\n\n// 2. Dog構造体がトレイトを実装\nstruct Dog;\nimpl Speak for Dog {\n    fn speak(&self) {\n        println!(\"woof\");\n    }\n}\n```\n\n「DogはSpeakができる」ということになります。",
    "rust_lesson4_ex4_description": "referenceカウントでデータを共有しましょう。",
    "rust_lesson4_ex5_slide1_content": "# 名前で引ける「dictionary」\n\nHashMap は、「key（名前）」と「value（データ）」をsetで保存dodictionaryです。\n\nFor example：\n- 「青チーム」→ 10点\n- 「赤チーム」→ 15点\n\ncodeExample：\n```rust\nuse std::collections::HashMap;\n\nlet mut scores = HashMap::new();\nscores.insert(\"Blue\", 10);   // 追加\nscores.insert(\"Red\", 15);    // 追加\n```\n\n`use` で機能を読み込んでからuse。",
    "rust_lesson3_ex4_title": "map でiterator変換",
    "rust_lesson4_ex1_slide3_content": "共通の振る舞いを定義するトレイトを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex4_description": "variableのvalueを手軽に増やしたり減らしたりdo「+=」「-=」を学びましょう。",
    "rust_lesson1_ex2_description": "データに名前をつけて保存できる「variable（へんすう）」を使ってみましょう。letでvariableをcreate。",
    "rust_lesson4_ex4_slide2_title": "referenceカウントの仕組み",
    "rust_lesson3_ex8_slide2_title": "unwrap_or_else",
    "rust_lesson4_ex10_comment1": "1番目の i にindex、2番目の item にelementが入る",
    "rust_lesson3_ex6_slide1_content": "# 累積処理\n\nfold は、初期valueとfunctionでelementを1つずつ畳み込みます。\n\n```rust\nlet v = vec![1, 2, 3];\nlet sum = v.iter().fold(0, |acc, x| acc + x);\n// 6\n```",
    "rust_lesson4_ex2_slide2_title": "よくuse derive トレイト",
    "rust_lesson3_ex10_slide3_content": "文字列型の違いを理解しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex4_slide2_content": "変数の値を手軽に増やしたり減らしたりする「+=」「-=」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex4_slide3_title": "Let's Try It!",
    "rust_lesson3_ex5_slide1_title": "filter（filterー）?",
    "rust_lesson4_ex5_description": "keyとvalueのpairを格納しましょう。",
    "rust_lesson3_ex5_description": "条件に合うelementだけを取り出しましょう。",
    "rust_lesson2_ex2_slide2_content": "# functionに借りてもらう\n\nfunctionにデータを渡すとき、`&` をつけると「借りる」形になります。元のvariableはそのまま使い続けられます。\n\ncodeExample：\n```rust\nfn calc_len(s: &String) -> usize {\n    s.len()  // 長さを返す\n}\n\nfn main() {\n    let text = String::from(\"hello\");\n    let len = calc_len(&text);  // textを貸す\n    // text はまだ使える！\n    println!(\"{}の長さは{}\", text, len);\n}\n```\n\n`&String` は「Stringを借りる」という意味です。",
    "rust_lesson4_ex7_slide3_content": "パターンマッチに条件を追加しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex8_slide2_content": "# 遅延評価\n\n```rust\n// クロージャで計算\nlet value = x.unwrap_or_else(|| expensive_computation());\n```",
    "rust_lesson4_ex7_title": "match ガード",
    "rust_lesson3_ex7_title": "? operatorでerror伝播",
    "rust_lesson4_ex1_description": "共通の振る舞いをdefineトレイトを学びましょう。",
    "rust_lesson2_ex1_slide2_content": "# 所有権は「移動」do\n\nvariableを別のvariableにassignmentdoと、所有権が 移動（ムーブ） します。元のvariableは使えなくなります。\n\ncodeExample：\n```rust\nlet s1 = String::from(\"hello\");  // s1 が持ち主\nlet s2 = s1;  // 所有権が s2 に移動！\n// ↓ s1 はもう使えない（エラーになる）\n// println!(\"{}\", s1);  // ダメ！\nprintln!(\"{}\", s2);  // OK！\n```\n\nイメージ：\nおもちゃを友だちにあげたら、自分はもう使えない。これがムーブです。",
    "rust_lesson1_ex8_slide1_title": "dictionary（HashMap）?",
    "rust_lesson4_ex3_slide2_content": "# サイズが決まらないとき\n\nBoxは、コンパイル時にサイズがわからないtypeにuse。\n\nFor examplerecursion的なtype：\n```rust\n// リストは「値 + 次のリスト」の繰り返し\nenum List {\n    Cons(i32, Box<List>),  // Boxで次を指す\n    Nil,                   // 終わり\n}\n```\n\nなぜBoxが必要？\n- `List` の中に `List` がある → 無限に大きくなる？\n- `Box` をuseと、サイズが固定（pointerのサイズ）になる\n\n「中身」ではなく「中身への矢印」を持つイメージです。",
    "rust_lesson2_ex10_title": "ジェネリクスを使おう",
    "rust_lesson2_ex8_slide3_title": "Let's Try It!",
    "rust_lesson3_ex9_slide2_content": "# 可変reference\n\n```rust\n// mut が必要\nlet mut v = Vec::new();\nv.push(1);\nv.push(2);\n```",
    "rust_lesson4_ex4_title": "Rc<T>",
    "rust_lesson2_ex3_comment1": "mut で可変variableにdo",
    "rust_lesson4_ex5_slide3_title": "Let's Try It!",
    "rust_lesson2_ex6_slide2_content": "# バリアントを列挙\n\n`enum 名前 { バリアント1, バリアント2, ... }` でdefine。\n\ncodeExample：\n```rust\nenum Color {\n    Red,\n    Green,\n    Blue,\n}\nlet c = Color::Red;\n```",
    "rust_lesson1_ex1_comment1": "Hello, Rust! とdisplay",
    "rust_lesson1_ex1_slide1_content": "# 安全で速い！最新のプログラミング言語\n\nRust（ラスト）は、「間違いを事前に防ぐ」ことがとても得意なプログラミング言語です。\n\nRustのすごいところ：\n- programのミスをexecute前に見つけてくれる\n- とても速く動く\n- 世界中のプログラマーが「一番好き！」と選ぶ人気の言語\n\nたとえるなら：\n厳しいけど優しい先生のような言語です。「ここ間違ってるよ」と教えてくれるので、安心してprogramが書けます！",
    "rust_lesson3_ex8_slide1_content": "# None/Err の場合のデフォルト\n\nunwrap_or は、None や Err の場合にデフォルトvalueをreturn。\n\n```rust\nlet x: Option<i32> = None;\nlet value = x.unwrap_or(0);  // 0\n```",
    "rust_lesson2_ex7_slide3_title": "Let's Try It!",
    "rust_lesson2_ex6_title": "enum で状態を表す",
    "rust_lesson2_ex8_slide1_content": "# 「成功」か「失敗」かを表す\n\nResult<T, E> は、処理が「成功したか失敗したか」を表すtypeです。\n\nFor example：\n- fileをopen → 成功（内容）か失敗（error）\n- 0で割り算 → 成功（答え）か失敗（0で割れない！）\n\n2つの状態：\n- `Ok(値)` → 成功！valueが入っている\n- `Err(エラー)` → 失敗...error情報が入っている\n\n`Option` は「あるか・ないか」、`Result` は「成功か・失敗か」という違いです。",
    "rust_lesson2_ex8_slide3_content": "成功と失敗を表す「Result」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex6_slide1_title": "HashSet ?",
    "rust_lesson3_ex9_comment1": "push でelementを追加",
    "rust_lesson2_ex7_slide2_title": "Option  Usage",
    "rust_lesson3_ex2_title": "closureのBasic",
    "rust_lesson3_ex7_slide1_title": "? operator?",
    "rust_lesson4_ex6_comment1": "HashSet をimport",
    "rust_lesson2_ex10_slide1_content": "# どんなtypeでも使える「万能」の仕組み\n\nジェネリクス は、typeを後から決められる仕組みです。\n\nなぜ便利？\n同じようなfunctionを何度も書かなくてすみます。\n\nFor example：\n- 数字のarrayの最初のelementを取るfunction\n- stringのarrayの最初のelementを取るfunction\n\n両方とも「最初のelementを取る」のは同じなのに、typeが違うだけで別のfunctionをwriteのは大変！\n\nジェネリクスなら、`<T>` で「typeは後で決める」とwriteだけで、どんなtypeでも使えるfunctionが作れます。",
    "rust_lesson1_ex3_slide1_content": "# 剰余operator（じょうよえんざんし）「%」\n\n`%`（パーセント）は、割り算の 「あまり」 をcalculate特別な記号です。\n\nわかりやすいExample：\n- 10このアメを3人で分けると？\n- 1人3こずつで、1こあまる\n- これを `10 % 3` とwriteと、答えは `1`\n\ncodeExample：\n```rust\nprintln!(\"{}\", 10 % 3);  // 1（あまり1）\nprintln!(\"{}\", 8 % 4);   // 0（あまりなし＝割り切れる）\n```\n\n使いどころ：\n- 偶数か奇数か調べる（`n % 2` が0なら偶数）\n- 時計の計算（24を超えたら0に戻る、など）",
    "rust_lesson3_ex7_description": "errorを簡潔に伝播させましょう。",
    "rust_lesson3_ex8_comment1": "unwrap_or でデフォルトvalueを設定",
    "rust_lesson2_ex8_title": "Result<T, E> でerror処理",
    "rust_lesson2_ex10_comment1": "T をtypeパラメータとしてuse",
    "rust_lesson2_ex6_comment1": "enum で列挙typeをdefinition",
    "rust_lesson3_ex3_slide3_content": "要素を順番に処理するイテレータを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex2_comment1": "derive でトレイトを自動implementation",
    "rust_lesson1_ex8_slide1_content": "# 名前でsearchできる「dictionary」\n\nHashMap（ハッシュmap）は、「名前」と「データ」をsetにして保存できる仕組みです。本物のdictionaryのように使えます。\n\nFor example果物の色dictionary：\n- 「りんご」→「あか」\n- 「バナナ」→「きいろ」\n- 「みかん」→「オレンジ」\n\nuse準備：\n```rust\nuse std::collections::HashMap;  // 機能を読み込む\nlet mut fruits = HashMap::new();  // 空の辞書を作る\nfruits.insert(\"りんご\", \"あか\");  // データを追加\n```\n\n`use` は「この機能をuseよ」というdeclarationです。",
    "rust_lesson3_ex9_slide1_title": "push ?",
    "rust_lesson4_ex1_title": "トレイトのdefinition",
    "rust_lesson4_ex3_description": "heapにデータを格納doBoxを学びましょう。",
    "rust_lesson1_ex2_title": "便利な「はこ」variable（へんすう）",
    "rust_lesson1_ex8_comment2": "中身を出す",
    "rust_lesson3_ex9_slide3_title": "Let's Try It!",
    "rust_lesson1_ex4_comment3": "-= で 50 を引く",
    "rust_lesson1_ex6_comment1": "&& で両方の条件をチェック",
    "rust_lesson4_ex1_slide2_title": "トレイトのimplementation",
    "rust_lesson4_ex7_slide3_title": "Let's Try It!",
    "rust_lesson4_title": "Rust IV - トレイトとスマートpointer",
    "rust_lesson4_ex1_comment1": "trait でトレイトをdefinition",
    "rust_lesson4_ex4_slide1_content": "# 複数の「持ち主」を許可do仕組み\n\nRc<T> は「Reference Counted（referenceカウント）」の略で、複数の所有者でデータを共有できます。\n\n普通の所有権：\n1人だけが持ち主。渡したら元の人は使えない。\n\nRc をuseと：\n複数人が同じデータの「持ち主」になれる！\n\ncodeExample：\n```rust\nuse std::rc::Rc;\n\nlet a = Rc::new(5);       // Rcでラップ\nlet b = Rc::clone(&a);    // bも持ち主になる\n// a も b も使える！\n```",
    "rust_lesson3_ex5_slide1_content": "# 条件に合うものだけ残す\n\nfilter は、条件を満たすelementだけを残し、他を捨てます。\n\nFor example：\n- 80点以上の人だけ残す\n- 偶数だけ残す\n- 「あ」から始まる名前だけ残す\n\ncodeExample：\n```rust\nlet v = vec![1, 2, 3, 4, 5];\nlet evens: Vec<_> = v.iter()\n    .filter(|x| **x % 2 == 0)  // 偶数だけ\n    .collect();\n// [2, 4]\n```\n\n条件が `true` のelementだけが残ります。",
    "rust_lesson3_ex7_slide3_title": "Let's Try It!",
    "rust_lesson1_ex7_comment2": "2番目のデータ（1番）を出す",
    "rust_lesson4_ex8_title": "impl Trait",
    "rust_lesson1_ex5_description": "条件によって動きを変える if文を学びましょう。",
    "rust_lesson3_ex4_slide2_title": "遅延評価（ちえんひょうか）",
    "rust_lesson3_ex1_slide1_content": "# referenceの「寿命」を示す印\n\nライフタイム は、referenceがいつまで使えるかを示す印です。`'a`（アポストロフィ・エー）のようにwrite。\n\nなぜ必要？\nreferenceは「借りている」状態。借りた元のデータが消えたら、referenceも使えなくなります。\n\nFor example：\n- 図書館で借りた本 → 図書館が閉まったら読めない\n- referenceで借りたデータ → 元のデータが消えたら使えない\n\nライフタイムは「このreferenceはこの範囲で有効だよ」とコンパイラに伝える仕組みです。",
    "rust_lesson1_ex1_slide1_title": "Rust（ラスト）?",
    "rust_lesson1_ex2_slide2_title": "計算の記号（operator）",
    "rust_lesson4_ex5_slide2_content": "# get で安全に取り出す\n\n`get()` methodでvalueを取り出せます。見つからない可能性があるので、`Option` が返ってきます。\n\ncodeExample：\n```rust\n// getはOption<&V>を返す\nif let Some(score) = scores.get(\"Blue\") {\n    println!(\"青チームは{}点\", score);\n}\n```\n\nPoint：\n- keyがあれば `Some(値)` が返る\n- keyがなければ `None` が返る\n- `if let` で安全に取り出せる\n\n存在しないkeyでアクセスしてもprogramが落ちない！",
    "rust_lesson4_ex7_slide1_title": "match ガード?",
    "rust_lesson3_title": "Rust III - ライフタイムとiterator",
    "rust_lesson4_ex3_title": "Box<T>",
    "rust_lesson1_ex4_slide1_title": "累算assignmentoperator（るいさんだいにゅう）?",
    "rust_lesson2_ex9_comment1": "trait でトレイトをdefinition",
    "rust_lesson2_ex1_description": "Rust独自の概念「所有権」を学びましょう。",
    "rust_lesson2_ex3_slide3_content": "参照先の値を変更できる「可変参照」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex1_slide3_title": "Let's Try It!",
    "rust_lesson3_ex6_slide2_title": "様々な畳み込み",
    "rust_lesson4_ex9_slide3_title": "Let's Try It!",
    "rust_lesson2_ex5_title": "impl でmethodを追加",
    "rust_lesson2_ex6_slide1_content": "# 複数の選択肢\n\nenum は、valueがいくつかの種類のうちの一つであることを表します。各バリアントにデータを持たせることもできます。",
    "rust_lesson2_ex4_comment1": "struct で構造体をdefinition",
    "rust_lesson1_ex3_title": "剰余operator（%）",
    "rust_lesson1_ex7_comment1": "colors というベクタをcreate（'あか', 'あお'の順）",
    "rust_lesson1_ex4_slide1_content": "# valueをかんたんに増やす・減らす\n\n`+=`（プラスイコール）と `-=`（マイナスイコール）は、variableの中身を増やしたり減らしたりdo便利な記号です。\n\nRustのImportantなルール：`mut`が必要！\nRustでは、variableをchangeには `let mut`（レット ミュート）とwrite必要があります。`mut` は「mutable（変更できる）」の略です。\n\ncodeExample：\n```rust\nlet mut score = 100;  // mut をつけて変更可能に\nscore += 10;          // 10を足す → 110に\nscore -= 50;          // 50を引く → 60に\n```\n\n`mut` がないと「このvariableは変えちゃダメ！」とRustが怒ります。",
    "rust_lesson2_ex1_slide2_title": "ムーブ（移動）",
    "rust_lesson3_ex4_comment1": "map で各elementを変換",
    "rust_lesson3_ex8_slide1_title": "unwrap_or ?",
    "rust_lesson2_ex5_slide1_content": "# implementationブロック\n\nimpl ブロックで、構造体にmethodを追加できます。`self` で自分自身をreferenceします。",
    "rust_lesson2_ex10_slide1_title": "ジェネリクス?",
    "rust_lesson1_ex8_slide2_content": "# 名前（key）で取り出す\n\ndictionaryに入れたデータは、名前（key）を指定して取り出せます。\n\ncodeExample：\n```rust\nuse std::collections::HashMap;\nfn main() {\n    let mut fruits = HashMap::new();\n    fruits.insert(\"りんご\", \"あか\");  // 追加\n    fruits.insert(\"バナナ\", \"きいろ\");  // 追加\n    \n    println!(\"{}\", fruits[\"りんご\"]);  // あか と表示\n}\n```\n\nPoint：\n- `insert(名前, データ)` で追加\n- `辞書[名前]` で取り出し\n- 番号ではなく「名前」で探せるのが便利！",
    "rust_lesson4_ex9_slide1_content": "# iteratorをコレクションに\n\ncollect は、iteratorをVecやHashMapなどに変換します。\n\n```rust\nlet v: Vec<_> = (0..5).collect();\nlet s: String = vec!['a', 'b'].into_iter().collect();\n```",
    "rust_lesson2_ex2_slide3_content": "所有権を移さずに値を借りる「参照」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex2_slide3_content": "周囲の変数を使える無名関数「クロージャ」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex4_slide2_content": "# struct keyワードでdefinition\n\n`struct 名前 { フィールド }` で構造体をdefine。フィールドには名前とtypeをwrite。\n\ncodeExample：\n```rust\n// Point 構造体を定義\nstruct Point {\n    x: i32,  // xフィールド（整数）\n    y: i32,  // yフィールド（整数）\n}\n\n// 使い方\nlet p = Point { x: 10, y: 20 };\nprintln!(\"x={}, y={}\", p.x, p.y);\n```\n\nPoint：\n- `struct 名前` で構造体をcreate\n- `{ フィールド名: 型 }` でどんなデータを持つか決める\n- `.フィールド名` でアクセス",
    "rust_lesson2_ex10_slide3_content": "型を後から決められる「ジェネリクス」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex6_slide3_title": "Let's Try It!",
    "rust_lesson4_ex6_slide1_content": "# 一意なvalueのset\n\nHashSet は、重複のないvalueのsetです。\n\n```rust\nuse std::collections::HashSet;\n\nlet mut set = HashSet::new();\nset.insert(1);\nset.insert(2);\nset.insert(1); // 重複は無視\n```",
    "rust_lesson4_ex2_title": "derive 属性",
    "rust_lesson4_ex2_slide1_content": "# トレイトを「自動で」implementation\n\n#[derive(...)] をuseと、よくuseトレイトを自分で書かなくても自動でimplementationしてくれます。\n\nFor example：\n構造体を `println!` でdisplayしたいとき、普通は Display トレイトをimplementationdo必要がありますが、`#[derive(Debug)]` をwriteだけでOK！\n\ncodeExample：\n```rust\n#[derive(Debug)]  // Debug トレイトを自動実装\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nlet p = Point { x: 1, y: 2 };\nprintln!(\"{:?}\", p);  // Point { x: 1, y: 2 }\n```",
    "rust_lesson1_ex6_slide2_title": "Let's Try It!",
    "rust_lesson3_ex3_slide2_title": "3つの iter method",
    "rust_lesson4_ex7_slide2_content": "# 複雑なconditional\n\n```rust\nmatch Some(5) {\n    Some(x) if x % 2 == 0 => println!(\"even\"),\n    Some(x) => println!(\"odd: {}\", x),\n    None => println!(\"none\"),\n}\n```",
    "rust_lesson3_ex3_slide1_content": "# elementを1つずつ取り出す仕組み\n\niterator は、ベクタなどのデータを「1つずつ順番に」取り出す仕組みです。\n\nFor example：\n- 行列に並んでいる人を1人ずつ呼ぶ\n- 引き出しの中身を1つずつ出す\n\ncodeExample：\n```rust\nlet v = vec![1, 2, 3];\nfor x in v.iter() {\n    println!(\"{}\", x);  // 1, 2, 3 と順番に表示\n}\n```\n\n`iter()` で「順番に取り出す準備」をして、`for` で1つずつ処理します。",
    "rust_lesson3_ex3_slide1_title": "iterator?",
    "rust_lesson4_ex2_description": "トレイトを自動implementationdoderiveを学びましょう。",
    "rust_lesson3_ex4_slide1_content": "# 全部を同じように変換do\n\n**map** は、iteratorの各elementを「同じ方法で」変換します。\n\nFor example：\n- 全員の身長を2倍にdo\n- 全員の名前を大文字にdo\n- 全部の数を2乗do\n\ncodeExample：\n```rust\nlet v = vec![1, 2, 3];\nlet doubled: Vec<_> = v.iter()\n    .map(|x| x * 2)  // 各要素を2倍に\n    .collect();      // ベクタに戻す\n// [2, 4, 6]\n```\n\n`|x| x * 2` は「xを受け取って、x*2をreturn」closureです。",
    "rust_lesson1_ex3_slide1_title": "あまりを求める",
    "rust_lesson3_ex10_slide1_content": "# 所有権の違い\n\nString は所有権を持つheap上のstring、&str はreferenceです。\n\n```rust\nlet s1: String = String::from(\"hello\");\nlet s2: &str = \"hello\";\n```",
    "rust_lesson4_ex2_slide1_title": "derive（デライブ）?",
    "rust_lesson2_ex2_comment1": "& でreferenceを渡す",
    "rust_lesson4_ex5_slide1_title": "HashMap（ハッシュmap）?",
    "rust_lesson2_ex3_slide2_title": "&mut  Usage",
    "rust_lesson3_ex5_title": "filter で絞り込み",
    "rust_lesson4_ex3_slide2_title": "いつuse？",
    "rust_lesson2_ex2_title": "referenceと借用",
    "rust_lesson2_ex7_title": "Option<T> で null を安全に",
    "rust_lesson4_ex10_slide3_title": "Let's Try It!",
    "rust_lesson3_ex5_slide3_title": "Let's Try It!",
    "rust_lesson4_ex10_title": "enumerate でindex付き",
    "rust_lesson2_ex2_slide1_content": "# 所有権を渡さずに「借りる」\n\nreference をuseと、所有権を移さずにデータを「見せてもらう」ことができます。\n\nたとえるなら：\n- ムーブ = おもちゃをあげる（自分は使えない）\n- reference = おもちゃを見せる（自分も使える）\n\n作り方：\n`&`（アンパサンド）をつけるとreferenceを作れます。\n\n```rust\nlet s = String::from(\"hello\");\nlet r = &s;  // sを借りる（見せてもらう）\n// s も r も使える！\n```",
    "rust_lesson2_ex5_slide2_content": "# &self をuse\n\nmethodの最初のargumentは `&self` です。\n\ncodeExample：\n```rust\nimpl Rect {\n    fn area(&self) -> i32 {\n        self.width * self.height\n    }\n}\n```",
    "rust_lesson1_ex5_slide2_title": "Let's Try It!",
    "rust_lesson2_ex4_slide3_title": "Let's Try It!",
    "rust_lesson4_ex3_slide3_title": "Let's Try It!",
    "rust_lesson2_ex9_slide3_content": "共通の振る舞いを定義する「トレイト」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex1_slide2_content": "# impl で約束を守る\n\n構造体にトレイトをimplementationdoと、その構造体は「約束を守る」ことになります。\n\ncodeExample：\n```rust\nstruct Person { name: String }\n\nimpl Greet for Person {\n    fn greet(&self) -> String {\n        format!(\"Hello, {}\", self.name)\n    }\n}\n```\n\n読み方：\n- `impl Greet for Person` → 「PersonはGreetをimplementationdo」\n- これでPersonは「あいさつできる」ようになった！",
    "rust_lesson4_ex4_comment1": "clone でreferenceカウントを増やす",
    "rust_lesson3_ex4_slide2_content": "# map だけではexecuteされない！\n\nRustのiteratorは 遅延評価 といって、「本当に必要になるまで処理しない」仕組みです。\n\nなぜ？\n無駄な計算を省けるから。100万件あっても、最初の10件だけ欲しいなら10件だけ処理すればいい。\n\ncollect() でexecute：\n```rust\n// これだけでは何も起きない\nv.iter().map(|x| x * 2);\n\n// collect() で実行してベクタに変換\nlet result: Vec<_> = v.iter().map(|x| x * 2).collect();\n```\n\n`collect()` は「今すぐ全部処理してResultをちょうだい」という意味です。",
    "rust_lesson2_ex4_slide2_title": "struct のdefinitionのしかた",
    "rust_lesson2_ex3_slide1_content": "# 「書き換えできる」借り方\n\n普通のreference `&` は「見るだけ」ですが、可変reference `&mut` は「変更もできる」借り方です。\n\nたとえるなら：\n- `&` = 本を見せてもらう（readだけ）\n- `&mut` = ノートを借りる（writeOK）\n\nImportantなルール：\n- 可変referenceは同時に1つだけ！\n- 「みんなで見る」か「1人でwrite」かのどちらか\n\nこのルールで、データが同時に書き換えられるバグを防いでいます。",
    "rust_lesson2_ex10_slide3_title": "Let's Try It!",
    "rust_lesson2_ex4_title": "構造体をdefinitionしよう",
    "rust_lesson3_ex10_slide2_content": "# 相互変換\n\n```rust\n// &str -> String\nlet s = \"hello\".to_string();\n\n// String -> &str\nlet slice: &str = &s;\n```",
    "rust_lesson4_ex10_slide3_content": "イテレータにインデックスを付けましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex4_slide2_content": "# 「何人が持っているか」を数える\n\nRcは「今何人がこのデータを持っているか」を数えています。\n\ncodeExample：\n```rust\nlet a = Rc::new(5);\nprintln!(\"{}\", Rc::strong_count(&a));  // 1\n\nlet b = Rc::clone(&a);\nprintln!(\"{}\", Rc::strong_count(&a));  // 2\n```\n\nいつデータが消える？\n- カウントが0になったとき（誰も持っていないとき）\n- 最後の持ち主がいなくなると自動で片付けられる\n\n`Rc::clone` は「持ち主を1人増やす」操作です。",
    "rust_lesson1_ex8_slide2_title": "dictionary Usage",
    "rust_lesson4_ex3_slide1_content": "# データを「heap」に置く箱\n\nBox<T> は、データを「heap」という特別な場所に置くための箱です。\n\nmemoryの2つの場所：\n- stack：小さくて速い。サイズが決まっているデータ向け\n- heap：大きくて柔軟。サイズが大きいor変わるデータ向け\n\ncodeExample：\n```rust\nlet b = Box::new(5);  // 5をヒープに置く\nprintln!(\"{}\", *b);   // *で中身を取り出す → 5\n```\n\n`*` は「箱を開けて中身を見る」操作です。",
    "rust_lesson3_ex2_slide2_title": "closure Syntax",
    "rust_lesson4_ex4_slide1_title": "Rc（アールシー）?",
    "rust_lesson4_ex7_slide1_content": "# 追加条件\n\n**if** でパターンに追加条件をつけられます。\n\n```rust\nmatch x {\n    n if n < 0 => println!(\"negative\"),\n    n if n > 0 => println!(\"positive\"),\n    _ => println!(\"zero\"),\n}\n```",
    "rust_lesson2_ex3_title": "可変reference",
    "rust_lesson3_ex10_comment1": "to_string で String に変換",
    "rust_lesson3_ex10_slide2_title": "変換",
    "rust_lesson3_ex1_description": "referenceの有効期間を表すライフタイムを学びましょう。",
    "rust_lesson3_ex2_slide1_content": "# 名前のない「即席」function\n\nclosure は、名前をつけずにその場でcreatefunctionです。そして特別な能力があります：周りのvariableを使えるのです！\n\nFor example：\n```rust\nlet x = 5;  // 外側の変数\nlet add_x = |n| n + x;  // xを使えるクロージャ\nprintln!(\"{}\", add_x(10));  // 15\n```\n\n普通のfunctionとの違い：\n- 普通のfunction：argumentしか使えない\n- closure：argument + 周りのvariableも使える\n\n「その場の空気を読める」functionというイメージです！",
    "rust_lesson1_ex2_comment1": "x に 10 を入れる",
    "rust_lesson1_ex7_slide3_title": "Let's Try It!",
    "rust_lesson1_ex5_title": "「もし〜なら」で分けましょう",
    "rust_lesson3_ex2_slide3_title": "Let's Try It!",
    "rust_lesson3_ex7_slide2_content": "# 簡潔なerror処理\n\n```rust\n// ? を使わない場合\nmatch result {\n    Ok(v) => v,\n    Err(e) => return Err(e),\n}\n\n// ? を使う\nresult?\n```",
    "rust_lesson3_ex6_slide3_title": "Let's Try It!",
    "rust_lesson4_ex9_slide3_content": "イテレータをコレクションに変換しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex6_description": "elementを1つのvalueにまとめるfoldを学びましょう。",
    "rust_lesson2_ex9_description": "共通の振る舞いをdefine「トレイト」を学びましょう。",
    "rust_lesson2_ex8_comment1": "Ok で成功をreturn",
    "rust_lesson3_ex5_slide2_content": "# filter はreferenceのreferenceを受け取る\n\n`filter` のclosureは、referenceのreference（`&&T`）を受け取ります。そのため、valueをuseには `**x` と2回referenceを外す必要があります。\n\nなぜ？\n- `iter()` はreference（`&T`）をreturn\n- `filter` はそれをFurthermorereferenceで渡す（`&&T`）\n\nSyntax：\n```rust\n// **x で値を取り出す\n.filter(|x| **x > 2)\n\n// または * を引数につける\n.filter(|&x| *x > 2)\n```\n\n最初は混乱しますが、慣れれば大丈夫！",
    "rust_lesson1_ex5_comment1": "> でcompare",
    "rust_lesson2_ex4_description": "関連doデータをまとめる「構造体」を学びましょう。",
    "rust_lesson3_ex5_slide3_content": "条件に合う要素だけを取り出しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex7_slide3_content": "「ベクタ（Vec）」を使うと、たくさんのデータを一つの「長い はこ」にまとめて入れられます。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex5_slide2_title": "valueの取得",
    "rust_lesson3_ex1_slide1_title": "ライフタイム?",
    "rust_lesson1_ex3_comment1": "10 を 3 で割ったあまりをoutput",
    "rust_lesson3_ex1_comment1": "'a でライフタイムをdefinition",
    "rust_lesson3_ex10_slide1_title": "String vs &str",
    "rust_lesson2_title": "Rust II - 所有権とトレイト",
    "rust_lesson2_ex5_slide2_title": "methodのdefinition",
    "rust_lesson4_ex5_comment1": "insert でkeyとvalueを追加",
    "rust_lesson2_ex9_slide1_content": "# 「できること」の約束\n\nトレイト は、「このtypeはこういうことができる」という約束をdefine。\n\nFor example「鳴ける」という約束：\n- 犬は「ワン」と鳴く\n- 猫は「ニャー」と鳴く\n- 両方とも「鳴ける」能力がある\n\nトレイトは「鳴ける動物は、鳴き声を出すmethodを持つ」という約束です。\n\n他の言語とのcomparison：\n- Java: interface\n- TypeScript: interface\n\nに似た概念です。",
    "rust_lesson1_ex2_slide3_title": "Let's Try It!",
    "rust_lesson4_ex8_slide1_content": "# return valueのtypeをabstract化\n\nimpl Trait で、トレイトをimplementationdotypeを返せます。\n\n```rust\nfn make_iter() -> impl Iterator<Item = i32> {\n    vec![1, 2, 3].into_iter()\n}\n```",
    "rust_lesson1_ex2_slide2_content": "# 四則演算（しそくえんざん）\n\nRustでも算数と同じ記号で計算ができます。\n\n4つのBasic記号：\n- +（プラス）: たし算\n- -（マイナス）: ひき算\n- \\*（アスタリスク）: かけ算（×の代わり）\n- /（スラッシュ）: わり算（÷の代わり）\n\ncodeExample：\n```rust\nlet a = 10;\nlet b = 5;\nprintln!(\"{}\", a + b);  // 15 と表示される\n```\n\n`println!` の `{}` は「ここにvalueを入れてね」という目印です。",
    "rust_lesson4_ex9_slide2_content": "# 変換先を指定\n\n```rust\n// ターボフィッシュ構文\nlet v = (0..5).collect::<Vec<_>>();\n\n// 変数の型注釈\nlet v: Vec<i32> = (0..5).collect();\n```",
    "rust_lesson1_ex8_description": "「dictionary（HashMap）」をuseと、名前をつけてデータを保存し、その名前で取り出せます。",
    "rust_lesson4_ex9_slide2_title": "typeHint",
    "rust_lesson3_ex1_title": "ライフタイムのBasic",
    "rust_lesson2_ex5_description": "構造体にmethodをadd「impl」を学びましょう。",
    "rust_lesson4_ex8_comment1": "impl でトレイトをimplementationdotypeをreturn",
    "rust_lesson4_ex8_slide2_title": "argumentにも使える",
    "rust_lesson4_ex7_comment1": "if でマッチガードを追加",
    "rust_lesson2_ex9_slide2_title": "trait のdefinitionとimplementation",
    "rust_lesson4_ex10_slide2_title": "いつuse？",
    "rust_lesson3_ex7_slide2_title": "match の省略形",
    "rust_lesson1_ex6_title": "logicaloperator（&&、||）",
    "rust_lesson3_ex6_comment1": "fold で畳み込み",
    "rust_lesson2_ex6_description": "複数の状態を表す「列挙type（enum）」を学びましょう。",
    "rust_lesson4_ex10_slide1_title": "enumerate（イニュメレート）?",
    "rust_lesson1_ex7_slide1_title": "ベクタ（Vec）?",
    "rust_lesson2_ex6_slide3_content": "複数の状態を表す「列挙型（enum）」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex3_slide3_title": "Let's Try It!",
    "rust_lesson3_ex4_description": "各elementを変換domapを学びましょう。",
    "rust_lesson4_ex1_slide3_title": "Let's Try It!",
    "rust_lesson3_ex9_slide2_title": "mut が必要",
    "rust_lesson1_ex6_slide1_content": "# logicaloperator（ろんりえんざんし）\n\n2つ以上の条件を組み合わせたいときにuse記号です。\n\n2つの記号：\n- `&&`（アンドアンド）：「かつ」＝ 両方とも 正しいとき\n- `||`（オアオア）：「Alsoは」＝ どちらか 正しいとき\n\n身近なExample：\n- 遊園地：「18歳以上 かつ チケットあり」なら乗れる\n- おやつ：「宿題終わった Alsoは お手伝いした」ならOK\n\ncodeExample：\n```rust\nif score >= 70 && bonus > 0 {\n    // 70点以上 かつ ボーナスあり → 合格！\n    println!(\"合格！\");\n}\n```",
    "rust_lesson4_ex4_slide3_content": "参照カウントでデータを共有しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex6_slide3_title": "Let's Try It!",
    "rust_lesson2_ex5_slide3_content": "構造体にメソッドを追加する「impl」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex1_slide3_title": "Let's Try It!",
    "rust_lesson1_ex5_slide1_content": "# programに「判断」させよう\n\nconditional は、「もし〜なら、〇〇do」という判断をprogramにさせる仕組みです。\n\n身近なExample：\n- もし80点以上なら → 「合格！」とdisplay\n- もし雨なら → 傘を持っていく\n- もしHPが0なら → ゲームオーバー\n\nRustで Syntax：\n```rust\nif score > 80 {\n    println!(\"合格！\");\n}\n```\n\n読み方：\n- `if` →「もし」\n- `score > 80` →「スコアが80より大きいなら」\n- `{ }` の中 →「これをやる」",
    "rust_lesson4_ex5_title": "HashMap",
    "rust_lesson1_ex2_slide1_content": "# データを保存do「はこ」\n\nvariable（へんすう） は、数字や文字を入れておける「はこ」のことです。名前をつけて、あとでuseことができます。\n\nFor example：\n- 「りんごの数」というラベルの箱に「5」を入れる\n- あとで「りんごの数」と呼べば「5」が出てくる\n\nRustで Syntax：\n```rust\nlet x = 10;  // xという箱に10を入れる\nprintln!(\"{}\", x);  // xの中身（10）を表示\n```\n\n`let` は「この名前で箱をcreateよ」という意味です。",
    "rust_lesson2_ex4_slide3_content": "関連するデータをまとめる「構造体」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex6_slide1_title": "enum ?",
    "rust_lesson2_ex9_title": "トレイトをdefinitionしよう",
    "rust_lesson2_ex4_slide1_title": "構造体（こうぞうたい）?",
    "rust_lesson4_ex2_slide2_content": "# 覚えておくと便利な5つ\n\nよくusederiveトレイト：\n```rust\nDebug     // {:?} でデバッグ表示できる\nClone     // .clone() でコピーを作れる\nCopy      // 代入時に自動でコピー（小さい型向け）\nPartialEq // == で比較できる\nDefault   // 初期値を自動で作れる\n```\n\n複数指定もOK：\n```rust\n#[derive(Debug, Clone, PartialEq)]\nstruct User {\n    name: String,\n    age: u32,\n}\n```\n\n`Debug` は特によくuse。debug時に構造体の中身を見れて便利！",
    "rust_lesson2_ex1_slide1_content": "# データの「持ち主」を決めるルール\n\n所有権 は、Rust最大のFeatureです。「このデータの持ち主は誰か」をはっきりさせる仕組みです。\n\nルール：\n- データには必ず1人だけ「持ち主」がいる\n- 持ち主がいなくなると、データは自dynamicに片付けられる\n\nたとえるなら：\n- おもちゃは1人しか持てない\n- 持ち主が部屋を出たら、おもちゃは片付けられる\n\nこのルールのおかげで、Rustは「memoryリーク」（データが片付けられないバグ）を防げます！",
    "rust_lesson1_ex3_slide2_title": "Let's Try It!",
    "rust_lesson3_ex1_slide2_title": "なぜ必要？",
    "rust_lesson3_ex1_slide2_content": "# 危険なバグを防ぐ\n\nダングリングreference という危険なバグがあります。これは「もう存在しないデータ」を指し続けているreferenceのことです。\n\nExample：\n```rust\nfn longest<'a>(x: &'a str, y: &'a str) -> &'a str {\n    if x.len() > y.len() { x } else { y }\n}\n```\n\n`'a` の意味：\n- argument `x` と `y` は同じライフタイム `'a` を持つ\n- return valueも同じライフタイム `'a` を持つ\n- In other words「xとyが両方有効な間、return valueも有効」という約束\n\nRustはこれを自動でチェックしてくれます！",
    "rust_lesson4_ex6_slide2_title": "set演算",
    "rust_lesson3_ex7_comment1": "? でerrorを伝播",
    "rust_lesson3_ex2_slide2_content": "# | | でargumentを囲む\n\nclosureは `|引数| 処理` という形でwrite。`||` は「パイプ」と呼ばれます。\n\nいろいろなSyntax：\n```rust\n// 引数なし\n|| println!(\"Hello\")\n\n// 引数あり\n|x, y| x + y\n\n// 複数行のブロック\n|x| {\n    let y = x * 2;\n    y + 1\n}\n```\n\nPoint：\n- argumentを `| |` で囲む（functionの `()` の代わり）\n- typeは省略できることが多い（Rustが推測してくれる）",
    "rust_lesson2_ex7_comment1": "Some でvalueがあることを示す",
    "rust_lesson3_ex4_slide3_content": "各要素を変換するmapを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_title": "Rust (ラスト) に挑戦！",
    "rust_lesson2_ex8_description": "成功と失敗を表す「Result」を学びましょう。",
    "rust_lesson3_ex8_description": "Option/Resultのデフォルトvalueを設定しましょう。",
    "rust_lesson4_ex2_slide3_title": "Let's Try It!",
    "rust_lesson2_ex5_slide3_title": "Let's Try It!",
    "rust_lesson4_ex9_description": "iteratorをコレクションに変換しましょう。",
    "rust_lesson1_ex1_slide2_content": "# println! でscreenにdisplay\n\nRustで文字をscreenにdisplayには、`println!`（プリントラインびっくり）をuse。\n\nPoint：\n- `!` がつくのがRustのFeature（マクロと呼ばれます）\n- programは `fn main() { }` の中にwrite\n- `fn` は「function（function）」の略\n\ncodeExample：\n```rust\nfn main() {\n    println!(\"ヤッホー！\");\n}\n// 「ヤッホー！」と画面に表示される\n```\n\n`println!` の `!` は「マクロ」という特別な機能の印です。今は「おまじない」と思っておけばOK！",
    "rust_lesson3_ex6_slide1_title": "fold ?",
    "rust_lesson4_ex8_slide1_title": "impl Trait ?",
    "rust_lesson1_ex1_slide2_title": "Rustの「おまじない」",
    "rust_lesson3_ex10_description": "stringtypeの違いを理解しましょう。",
    "rust_lesson3_ex7_slide3_content": "エラーを簡潔に伝播させましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex1_comment1": "s1 の所有権を移動",
    "rust_lesson2_ex9_slide1_title": "トレイト?",
    "rust_lesson4_ex6_slide2_content": "# 和set、積setなど\n\n```rust\nset1.union(&set2)\nset1.intersection(&set2)\nset1.difference(&set2)\n```",
    "rust_lesson4_ex5_slide3_content": "キーと値のペアを格納しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex8_slide1_title": "Result（リザルト）?",
    "rust_lesson4_ex1_slide1_content": "# 「できること」の約束\n\nトレイト は、typeが持つべきmethodをdefine仕組みです。\n\nFor example：\n- 「あいさつできる」トレイト → greet() methodを持つ\n- 「displayできる」トレイト → display() methodを持つ\n\ncodeExample：\n```rust\ntrait Greet {\n    fn greet(&self) -> String;  // メソッドの「約束」\n}\n```\n\nこれは「Greetできるtypeは、greet()methodを持つ」という約束です。",
    "rust_lesson4_ex2_slide3_content": "トレイトを自動実装するderiveを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex6_title": "fold で畳み込み",
    "rust_lesson3_ex9_slide3_content": "Vecに要素を追加しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex4_slide1_content": "# 関係あるデータをまとめる「設計図」\n\n構造体（struct） は、いくつかのデータをひとまとめにdo仕組みです。\n\nFor example「点（座標）」のデータ：\n- x座標\n- y座標\n\nこの2つは関係があるので、「Point（点）」としてまとめると便利です。\n\nFor example「人」のデータ：\n- 名前\n- 年齢\n\nこれも「Person（人）」としてまとめられます。\n\n構造体は「こういうデータを持つ」という設計図です。",
    "rust_lesson4_ex1_slide1_title": "トレイト?（復習）",
    "rust_lesson2_ex3_description": "reference先のvalueを変更できる「可変reference」を学びましょう。",
    "rust_lesson2_ex7_slide2_content": "# match で安全に取り出す\n\n`match` を使って「ある場合」と「ない場合」で処理を分けます。\n\ncodeExample：\n```rust\nlet x: Option<i32> = Some(5);  // 値あり\n\nmatch x {\n    Some(n) => println!(\"値は{}です\", n),  // 5\n    None => println!(\"値がありません\"),\n}\n```\n\nなぜ安全？\n- `null` のように「あるつもりでアクセスしたら無かった」errorが起きない\n- 「ない場合」の処理を書かないとコンパイルerrorになる\n- 強制的に両方のケースを考えることになる！",
    "rust_lesson4_ex9_comment1": "collect で Vec に変換",
    "rust_lesson3_ex10_title": "String と &str",
    "rust_lesson2_ex7_slide1_title": "Option（オプション）?",
    "rust_lesson3_ex9_description": "Vecにelementを追加しましょう。",
    "rust_lesson2_ex5_comment1": "impl でmethodをimplementation",
    "rust_lesson3_ex1_slide3_content": "参照の有効期間を表すライフタイムを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex6_slide2_content": "複数の条件を組み合わせる「&&（かつ）」と「||（または）」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex5_comment1": "filter で条件に合うelementを絞り込む",
    "rust_lesson2_ex7_slide3_content": "値があるかないかを表す「Option」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex10_slide3_title": "Let's Try It!",
    "rust_lesson4_ex4_slide3_title": "Let's Try It!",
    "rust_lesson3_ex3_comment1": "iter でiteratorを取得",
    "rust_lesson3_ex6_slide3_content": "要素を1つの値にまとめるfoldを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex7_slide2_title": "ベクタの番号は「0」から！",
    "rust_lesson1_ex5_slide1_title": "conditional（じょうけんぶんき）?",
    "rust_lesson1_ex3_description": "割り算の「あまり」を求める「%」（パーセント）operatorを学びましょう。",
    "rust_lesson1_ex1_slide3_content": "Rustを使って画面に文字を表示してみましょう。println! という特別な関数を使います。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex10_slide2_content": "# <T> でtypeを「あとで決める」\n\nfunction名の後に `<T>` をつけて、`T` を「type」としてuse。\n\ncodeExample：\n```rust\n// Tはどんな型でもOK\nfn first<T>(arr: &[T]) -> &T {\n    &arr[0]  // 最初の要素を返す\n}\n\n// 使い方\nfirst(&[1, 2, 3]);         // Tはi32\nfirst(&[\"a\", \"b\", \"c\"]);   // Tは&str\n```\n\n読み方：\n- `<T>` → 「Tという名前のtypeをuseよ」\n- `T` は慣習で「Type（type）」の頭文字\n- 複数のtypeが必要なら `<T, U>` のようにwrite",
    "rust_lesson3_ex2_comment1": "|x| でclosureのargumentをdefinition",
    "rust_lesson3_ex3_description": "elementを順番に処理doiteratorを学びましょう。",
    "rust_lesson1_ex1_slide3_title": "Let's Try It!",
    "rust_lesson2_ex6_slide2_title": "enum のdefinition",
    "rust_lesson2_ex1_title": "所有権のBasic",
    "rust_lesson4_ex3_slide1_title": "Box（ボックス）?",
    "rust_lesson2_ex1_slide3_content": "Rust独自の概念「所有権」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex8_slide3_content": "Option/Resultのデフォルト値を設定しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex7_slide2_title": "使用Example",
    "rust_lesson4_ex10_description": "iteratorにindexを付けましょう。",
    "rust_lesson4_ex9_slide1_title": "collect ?",
    "rust_lesson4_ex10_slide2_content": "# 「何番目か」が必要なとき\n\n番号（index）とelementの両方が必要なときに便利です。\n\ncodeExample：\n```rust\nlet v = vec![10, 20, 30];\nfor (idx, val) in v.iter().enumerate() {\n    println!(\"{}番目の値は{}\", idx, val);\n}\n// 0番目の値は10\n// 1番目の値は20\n// 2番目の値は30\n```\n\nPoint：\n- `(i, x)` でtuple（2つのset）を受け取る\n- `i` にindex、`x` にelementが入る\n- indexは0から始まる",
    "rust_lesson3_ex2_description": "周囲のvariableを使えるanonymous function「closure」を学びましょう。",
    "rust_lesson1_ex4_comment1": "mut で変更可能にdo",
    "rust_lesson1_ex8_slide3_title": "Let's Try It!",
    "rust_lesson1_ex3_slide2_content": "割り算の「あまり」を求める「%」（パーセント）演算子を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex9_slide3_title": "Let's Try It!",
    "rust_lesson3_ex3_title": "iteratorのBasic",
    "rust_lesson3_ex9_title": "Vec のmethod push",
    "rust_lesson1_ex8_comment1": "dictionaryをcreate（keyは'みかん'、valueは'オレンジ'）",
    "rust_lesson1_ex2_comment3": "+ でたし算do",
    "rust_lesson4_ex8_slide2_content": "# ジェネリクスの代わり\n\n```rust\nfn print_all(iter: impl Iterator<Item = i32>) {\n    for x in iter {\n        println!(\"{}\", x);\n    }\n}\n```",
    "rust_lesson2_ex2_slide2_title": "reference Usage",
    "rust_lesson1_ex8_slide3_content": "「辞書（HashMap）」を使うと、名前をつけてデータを保存し、その名前で取り出せます。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex7_slide2_content": "# [ ]で番号を指定して取り出す\n\n`[番号]` で何番目のデータか指定して取り出せます。\n\nImportantなルール：番号は「0」から！\n- 1番目 → `[0]`\n- 2番目 → `[1]`\n- 3番目 → `[2]`\n\ncodeExample：\n```rust\nlet fruits = vec![\"りんご\", \"バナナ\", \"みかん\"];\n//                  ↑0番    ↑1番     ↑2番\nprintln!(\"{}\", fruits[0]);  // りんご\nprintln!(\"{}\", fruits[1]);  // バナナ\n```\n\nプログラミングでは「0から数える」のが世界共通のルールです！",
    "rust_lesson1_ex6_slide1_title": "条件を組み合わせる",
    "rust_lesson2_ex10_slide2_title": "ジェネリックfunction Syntax",
    "rust_lesson1_ex6_description": "複数の条件を組み合わせる「&&（かつ）」と「||（Alsoは）」を学びましょう。",
    "rust_lesson4_ex6_title": "HashSet",
    "rust_lesson2_ex3_slide2_content": "# mut が2か所に必要\n\n変更できるようにdoには、variableとreferenceの両方に `mut` が必要です。\n\ncodeExample：\n```rust\n// 1. 変数を mut で作る\nlet mut s = String::from(\"hello\");\n\n// 2. &mut で可変参照を渡す\nchange(&mut s);\n\nfn change(s: &mut String) {\n    s.push_str(\" world\");  // 変更できる！\n}\n```\n\nPoint：\n- `let mut 変数` でvariableを変更可能に\n- `&mut 変数` で可変referenceをcreate\n- 両方ないと変更できない！",
    "rust_lesson2_ex2_slide1_title": "reference（さんしょう）?",
    "rust_lesson3_ex6_slide2_content": "# 合計、積、結合など\n\n```rust\n// 積\nv.iter().fold(1, |acc, x| acc * x)\n\n// 文字列結合\nwords.iter().fold(String::new(), |acc, s| acc + s)\n```",
    "rust_lesson1_ex1_description": "Rustを使ってscreenに文字をdisplayしてみましょう。println! という特別なfunctionをuse。",
    "rust_lesson3_ex8_slide3_title": "Let's Try It!",
    "rust_lesson4_ex6_description": "一意なvalueのsetを管理しましょう。",
    "rust_lesson2_ex5_slide1_title": "impl ?",
    "rust_lesson1_ex8_title": "名前で引き出す「dictionary」",
    "rust_lesson2_ex7_description": "valueがあるかないかを表す「Option」を学びましょう。",
    "rust_lesson1_ex4_slide2_title": "Let's Try It!",
    "rust_lesson1_ex7_title": "たくさんのデータをまとめましょう「ベクタ」",
    "rust_lesson3_ex7_slide1_content": "# errorの早期リターン\n\n? は、Resultが Err の場合に早期リターンします。\n\n```rust\nfn read_file() -> Result<String, io::Error> {\n    let content = fs::read_to_string(\"file.txt\")?;\n    Ok(content)\n}\n```",
    "rust_lesson3_ex9_slide1_content": "# 末尾に追加\n\npush は、Vecの末尾にelementをadd。\n\n```rust\nlet mut v = vec![1, 2];\nv.push(3);\n// [1, 2, 3]\n```",
    "rust_lesson4_ex8_slide3_content": "トレイトを返す関数を簡潔に書きましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex1_title": "screenにメッセージを出しましょう",
    "rust_lesson2_ex8_slide2_title": "Result  Usage",
    "rust_lesson3_ex2_slide1_title": "closure?",
    "rust_lesson3_ex8_title": "unwrap_or でデフォルトvalue",
    "rust_lesson4_ex10_slide1_content": "# 番号とelementを一緒にもらう\n\nenumerate は、「何番目か」と「そのelement」をsetで取り出せるmethodです。\n\nFor example：\n- 0番目: りんご\n- 1番目: バナナ\n- 2番目: みかん\n\ncodeExample：\n```rust\nfor (i, x) in vec![\"a\", \"b\", \"c\"].iter().enumerate() {\n    println!(\"{}: {}\", i, x);\n}\n// 0: a\n// 1: b\n// 2: c\n```",
    "rust_lesson1_ex7_slide1_content": "# データを並べてまとめる「長い箱」\n\nベクタ（Vec） は、たくさんのデータを順番に並べて入れられる「長い箱」です。\n\nFor example：\n- 買い物listの商品を全部まとめる\n- testの点数を全部まとめる\n- 友だちの名前を全部まとめる\n\n100個でも1000個でも、1つのvariableでまとめて管理できます！\n\n作り方：\n```rust\nlet fruits = vec![\"りんご\", \"バナナ\", \"みかん\"];\n// vec! で ベクタを作る\n```",
    "rust_lesson4_ex8_slide3_title": "Let's Try It!",
    "rust_lesson4_ex7_description": "パターンマッチに条件を追加しましょう。",
    "rust_lesson1_ex4_comment2": "+= で 20 を足す",
    "rust_lesson1_ex2_comment2": "y に 5 を入れる",
    "rust_lesson2_ex3_slide3_title": "Let's Try It!",
    "rust_lesson3_ex4_slide1_title": "map（map）?",
    "rust_lesson1_ex2_slide3_content": "データに名前をつけて保存できる「変数（へんすう）」を使ってみましょう。letで変数を作ります。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex8_slide2_content": "# match で成功と失敗を分ける\n\n`match` で「成功したら」「失敗したら」の処理を書き分けます。\n\ncodeExample：\n```rust\nfn divide(a: i32, b: i32) -> Result<i32, String> {\n    if b == 0 {\n        return Err(\"0で割れません\".to_string());\n    }\n    Ok(a / b)  // 成功なら答えを返す\n}\n\nmatch divide(10, 2) {\n    Ok(v) => println!(\"答えは{}\", v),\n    Err(e) => println!(\"エラー: {}\", e),\n}\n```\n\nPoint：\n- `Ok(値)` で成功をreturn\n- `Err(エラー)` で失敗をreturn",
    "rust_lesson4_ex3_comment1": "Box::new でheapに格納",
    "rust_lesson4_ex8_description": "トレイトをreturnfunctionを簡潔に書きましょう。",
    "rust_lesson2_ex10_description": "typeを後から決められる「ジェネリクス」を学びましょう。",
    "rust_lesson2_ex3_slide1_title": "可変reference（かへんさんしょう）?",
    "rust_lesson2_ex2_description": "所有権を移さずにvalueを借りる「reference」を学びましょう。",
    "rust_lesson3_ex5_slide2_title": "** にNote！",
    "rust_lesson2_ex2_slide3_title": "Let's Try It!",
    "rust_lesson4_ex3_slide3_content": "ヒープにデータを格納するBoxを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex4_title": "累算assignmentoperator（+=、-=）",
    "rust_lesson3_ex3_slide2_content": "# 借りるか、もらうか\n\n3種類の iter があり、所有権の扱いが違います。\n\n3つの違い：\n```rust\nv.iter()       // 参照で借りる（&T）\nv.iter_mut()   // 変更可能で借りる（&mut T）\nv.into_iter()  // 所有権をもらう（T）\n```\n\n使い分け：\n- `iter()` → 見るだけ（元のベクタも使える）\n- `iter_mut()` → 中身を変更したい\n- `into_iter()` → ベクタごともらう（元は使えない）\n\n普通は `iter()` をuseことが多いです。",
    "rust_lesson2_ex1_slide1_title": "所有権（しょゆうけん）?",
    "rust_lesson4_ex6_slide3_content": "一意な値の集合を管理しましょう。\n\n（When you're ready, select \"Start Lesson\".）"
  },
  "nl": {
    "rust_lesson1_course_title": "Introduction to Rust",
    "rust_lesson1_course_description": "Learn the basics of Rust programming.",
    "rust_lesson2_course_title": "Rust II - Intermediate",
    "rust_lesson2_course_description": "Learn intermediate Rust concepts.",
    "rust_lesson3_course_title": "Rust III - Advanced",
    "rust_lesson3_course_description": "Master advanced Rust techniques.",
    "rust_lesson4_course_title": "Rust IV - Expert Level",
    "rust_lesson4_course_description": "Expert-level Rust programming.",
    "rust_lesson1_ex5_slide2_content": "条件によって動きを変える if文を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex9_title": "collect で変換",
    "rust_lesson2_ex7_slide1_content": "# 「あるかもしれない、ないかもしれない」\n\nOption<T> は、valueが「あるかもしれないし、ないかもしれない」ことを表すtypeです。\n\nFor example：\n- dictionaryで単語を探す → 見つかるかもしれないし、ないかもしれない\n- ゲームでアイテムを拾う → 落ちてるかもしれないし、ないかもしれない\n\n2つの状態：\n- `Some(値)` → valueがある！\n- `None` → valueがない...\n\n他の言語では `null` をuseが、Rustでは `Option` で安全に扱います。",
    "rust_lesson1_ex2_slide1_title": "variable（へんすう）?",
    "rust_lesson1_ex7_description": "「ベクタ（Vec）」をuseと、たくさんのデータを一つの「長い はこ」にまとめて入れられます。",
    "rust_lesson2_ex9_slide2_content": "# 約束を作って、守る\n\n1. `trait` で「約束」をdefinition\n2. `impl トレイト for 型` で「約束を守る」implementationをdo\n\ncodeExample：\n```rust\n// 1. トレイト（約束）を定義\ntrait Speak {\n    fn speak(&self);  // 鳴くメソッドを持つ約束\n}\n\n// 2. Dog構造体がトレイトを実装\nstruct Dog;\nimpl Speak for Dog {\n    fn speak(&self) {\n        println!(\"woof\");\n    }\n}\n```\n\n「DogはSpeakができる」ということになります。",
    "rust_lesson4_ex4_description": "referenceカウントでデータを共有しましょう。",
    "rust_lesson4_ex5_slide1_content": "# 名前で引ける「dictionary」\n\nHashMap は、「key（名前）」と「value（データ）」をsetで保存dodictionaryです。\n\nFor example：\n- 「青チーム」→ 10点\n- 「赤チーム」→ 15点\n\ncodeExample：\n```rust\nuse std::collections::HashMap;\n\nlet mut scores = HashMap::new();\nscores.insert(\"Blue\", 10);   // 追加\nscores.insert(\"Red\", 15);    // 追加\n```\n\n`use` で機能を読み込んでからuse。",
    "rust_lesson3_ex4_title": "map でiterator変換",
    "rust_lesson4_ex1_slide3_content": "共通の振る舞いを定義するトレイトを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex4_description": "variableのvalueを手軽に増やしたり減らしたりdo「+=」「-=」を学びましょう。",
    "rust_lesson1_ex2_description": "データに名前をつけて保存できる「variable（へんすう）」を使ってみましょう。letでvariableをcreate。",
    "rust_lesson4_ex4_slide2_title": "referenceカウントの仕組み",
    "rust_lesson3_ex8_slide2_title": "unwrap_or_else",
    "rust_lesson4_ex10_comment1": "1番目の i にindex、2番目の item にelementが入る",
    "rust_lesson3_ex6_slide1_content": "# 累積処理\n\nfold は、初期valueとfunctionでelementを1つずつ畳み込みます。\n\n```rust\nlet v = vec![1, 2, 3];\nlet sum = v.iter().fold(0, |acc, x| acc + x);\n// 6\n```",
    "rust_lesson4_ex2_slide2_title": "よくuse derive トレイト",
    "rust_lesson3_ex10_slide3_content": "文字列型の違いを理解しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex4_slide2_content": "変数の値を手軽に増やしたり減らしたりする「+=」「-=」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex4_slide3_title": "Let's Try It!",
    "rust_lesson3_ex5_slide1_title": "filter（filterー）?",
    "rust_lesson4_ex5_description": "keyとvalueのpairを格納しましょう。",
    "rust_lesson3_ex5_description": "条件に合うelementだけを取り出しましょう。",
    "rust_lesson2_ex2_slide2_content": "# functionに借りてもらう\n\nfunctionにデータを渡すとき、`&` をつけると「借りる」形になります。元のvariableはそのまま使い続けられます。\n\ncodeExample：\n```rust\nfn calc_len(s: &String) -> usize {\n    s.len()  // 長さを返す\n}\n\nfn main() {\n    let text = String::from(\"hello\");\n    let len = calc_len(&text);  // textを貸す\n    // text はまだ使える！\n    println!(\"{}の長さは{}\", text, len);\n}\n```\n\n`&String` は「Stringを借りる」という意味です。",
    "rust_lesson4_ex7_slide3_content": "パターンマッチに条件を追加しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex8_slide2_content": "# 遅延評価\n\n```rust\n// クロージャで計算\nlet value = x.unwrap_or_else(|| expensive_computation());\n```",
    "rust_lesson4_ex7_title": "match ガード",
    "rust_lesson3_ex7_title": "? operatorでerror伝播",
    "rust_lesson4_ex1_description": "共通の振る舞いをdefineトレイトを学びましょう。",
    "rust_lesson2_ex1_slide2_content": "# 所有権は「移動」do\n\nvariableを別のvariableにassignmentdoと、所有権が 移動（ムーブ） します。元のvariableは使えなくなります。\n\ncodeExample：\n```rust\nlet s1 = String::from(\"hello\");  // s1 が持ち主\nlet s2 = s1;  // 所有権が s2 に移動！\n// ↓ s1 はもう使えない（エラーになる）\n// println!(\"{}\", s1);  // ダメ！\nprintln!(\"{}\", s2);  // OK！\n```\n\nイメージ：\nおもちゃを友だちにあげたら、自分はもう使えない。これがムーブです。",
    "rust_lesson1_ex8_slide1_title": "dictionary（HashMap）?",
    "rust_lesson4_ex3_slide2_content": "# サイズが決まらないとき\n\nBoxは、コンパイル時にサイズがわからないtypeにuse。\n\nFor examplerecursion的なtype：\n```rust\n// リストは「値 + 次のリスト」の繰り返し\nenum List {\n    Cons(i32, Box<List>),  // Boxで次を指す\n    Nil,                   // 終わり\n}\n```\n\nなぜBoxが必要？\n- `List` の中に `List` がある → 無限に大きくなる？\n- `Box` をuseと、サイズが固定（pointerのサイズ）になる\n\n「中身」ではなく「中身への矢印」を持つイメージです。",
    "rust_lesson2_ex10_title": "ジェネリクスを使おう",
    "rust_lesson2_ex8_slide3_title": "Let's Try It!",
    "rust_lesson3_ex9_slide2_content": "# 可変reference\n\n```rust\n// mut が必要\nlet mut v = Vec::new();\nv.push(1);\nv.push(2);\n```",
    "rust_lesson4_ex4_title": "Rc<T>",
    "rust_lesson2_ex3_comment1": "mut で可変variableにdo",
    "rust_lesson4_ex5_slide3_title": "Let's Try It!",
    "rust_lesson2_ex6_slide2_content": "# バリアントを列挙\n\n`enum 名前 { バリアント1, バリアント2, ... }` でdefine。\n\ncodeExample：\n```rust\nenum Color {\n    Red,\n    Green,\n    Blue,\n}\nlet c = Color::Red;\n```",
    "rust_lesson1_ex1_comment1": "Hello, Rust! とdisplay",
    "rust_lesson1_ex1_slide1_content": "# 安全で速い！最新のプログラミング言語\n\nRust（ラスト）は、「間違いを事前に防ぐ」ことがとても得意なプログラミング言語です。\n\nRustのすごいところ：\n- programのミスをexecute前に見つけてくれる\n- とても速く動く\n- 世界中のプログラマーが「一番好き！」と選ぶ人気の言語\n\nたとえるなら：\n厳しいけど優しい先生のような言語です。「ここ間違ってるよ」と教えてくれるので、安心してprogramが書けます！",
    "rust_lesson3_ex8_slide1_content": "# None/Err の場合のデフォルト\n\nunwrap_or は、None や Err の場合にデフォルトvalueをreturn。\n\n```rust\nlet x: Option<i32> = None;\nlet value = x.unwrap_or(0);  // 0\n```",
    "rust_lesson2_ex7_slide3_title": "Let's Try It!",
    "rust_lesson2_ex6_title": "enum で状態を表す",
    "rust_lesson2_ex8_slide1_content": "# 「成功」か「失敗」かを表す\n\nResult<T, E> は、処理が「成功したか失敗したか」を表すtypeです。\n\nFor example：\n- fileをopen → 成功（内容）か失敗（error）\n- 0で割り算 → 成功（答え）か失敗（0で割れない！）\n\n2つの状態：\n- `Ok(値)` → 成功！valueが入っている\n- `Err(エラー)` → 失敗...error情報が入っている\n\n`Option` は「あるか・ないか」、`Result` は「成功か・失敗か」という違いです。",
    "rust_lesson2_ex8_slide3_content": "成功と失敗を表す「Result」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex6_slide1_title": "HashSet ?",
    "rust_lesson3_ex9_comment1": "push でelementを追加",
    "rust_lesson2_ex7_slide2_title": "Option  Usage",
    "rust_lesson3_ex2_title": "closureのBasic",
    "rust_lesson3_ex7_slide1_title": "? operator?",
    "rust_lesson4_ex6_comment1": "HashSet をimport",
    "rust_lesson2_ex10_slide1_content": "# どんなtypeでも使える「万能」の仕組み\n\nジェネリクス は、typeを後から決められる仕組みです。\n\nなぜ便利？\n同じようなfunctionを何度も書かなくてすみます。\n\nFor example：\n- 数字のarrayの最初のelementを取るfunction\n- stringのarrayの最初のelementを取るfunction\n\n両方とも「最初のelementを取る」のは同じなのに、typeが違うだけで別のfunctionをwriteのは大変！\n\nジェネリクスなら、`<T>` で「typeは後で決める」とwriteだけで、どんなtypeでも使えるfunctionが作れます。",
    "rust_lesson1_ex3_slide1_content": "# 剰余operator（じょうよえんざんし）「%」\n\n`%`（パーセント）は、割り算の 「あまり」 をcalculate特別な記号です。\n\nわかりやすいExample：\n- 10このアメを3人で分けると？\n- 1人3こずつで、1こあまる\n- これを `10 % 3` とwriteと、答えは `1`\n\ncodeExample：\n```rust\nprintln!(\"{}\", 10 % 3);  // 1（あまり1）\nprintln!(\"{}\", 8 % 4);   // 0（あまりなし＝割り切れる）\n```\n\n使いどころ：\n- 偶数か奇数か調べる（`n % 2` が0なら偶数）\n- 時計の計算（24を超えたら0に戻る、など）",
    "rust_lesson3_ex7_description": "errorを簡潔に伝播させましょう。",
    "rust_lesson3_ex8_comment1": "unwrap_or でデフォルトvalueを設定",
    "rust_lesson2_ex8_title": "Result<T, E> でerror処理",
    "rust_lesson2_ex10_comment1": "T をtypeパラメータとしてuse",
    "rust_lesson2_ex6_comment1": "enum で列挙typeをdefinition",
    "rust_lesson3_ex3_slide3_content": "要素を順番に処理するイテレータを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex2_comment1": "derive でトレイトを自動implementation",
    "rust_lesson1_ex8_slide1_content": "# 名前でsearchできる「dictionary」\n\nHashMap（ハッシュmap）は、「名前」と「データ」をsetにして保存できる仕組みです。本物のdictionaryのように使えます。\n\nFor example果物の色dictionary：\n- 「りんご」→「あか」\n- 「バナナ」→「きいろ」\n- 「みかん」→「オレンジ」\n\nuse準備：\n```rust\nuse std::collections::HashMap;  // 機能を読み込む\nlet mut fruits = HashMap::new();  // 空の辞書を作る\nfruits.insert(\"りんご\", \"あか\");  // データを追加\n```\n\n`use` は「この機能をuseよ」というdeclarationです。",
    "rust_lesson3_ex9_slide1_title": "push ?",
    "rust_lesson4_ex1_title": "トレイトのdefinition",
    "rust_lesson4_ex3_description": "heapにデータを格納doBoxを学びましょう。",
    "rust_lesson1_ex2_title": "便利な「はこ」variable（へんすう）",
    "rust_lesson1_ex8_comment2": "中身を出す",
    "rust_lesson3_ex9_slide3_title": "Let's Try It!",
    "rust_lesson1_ex4_comment3": "-= で 50 を引く",
    "rust_lesson1_ex6_comment1": "&& で両方の条件をチェック",
    "rust_lesson4_ex1_slide2_title": "トレイトのimplementation",
    "rust_lesson4_ex7_slide3_title": "Let's Try It!",
    "rust_lesson4_title": "Rust IV - トレイトとスマートpointer",
    "rust_lesson4_ex1_comment1": "trait でトレイトをdefinition",
    "rust_lesson4_ex4_slide1_content": "# 複数の「持ち主」を許可do仕組み\n\nRc<T> は「Reference Counted（referenceカウント）」の略で、複数の所有者でデータを共有できます。\n\n普通の所有権：\n1人だけが持ち主。渡したら元の人は使えない。\n\nRc をuseと：\n複数人が同じデータの「持ち主」になれる！\n\ncodeExample：\n```rust\nuse std::rc::Rc;\n\nlet a = Rc::new(5);       // Rcでラップ\nlet b = Rc::clone(&a);    // bも持ち主になる\n// a も b も使える！\n```",
    "rust_lesson3_ex5_slide1_content": "# 条件に合うものだけ残す\n\nfilter は、条件を満たすelementだけを残し、他を捨てます。\n\nFor example：\n- 80点以上の人だけ残す\n- 偶数だけ残す\n- 「あ」から始まる名前だけ残す\n\ncodeExample：\n```rust\nlet v = vec![1, 2, 3, 4, 5];\nlet evens: Vec<_> = v.iter()\n    .filter(|x| **x % 2 == 0)  // 偶数だけ\n    .collect();\n// [2, 4]\n```\n\n条件が `true` のelementだけが残ります。",
    "rust_lesson3_ex7_slide3_title": "Let's Try It!",
    "rust_lesson1_ex7_comment2": "2番目のデータ（1番）を出す",
    "rust_lesson4_ex8_title": "impl Trait",
    "rust_lesson1_ex5_description": "条件によって動きを変える if文を学びましょう。",
    "rust_lesson3_ex4_slide2_title": "遅延評価（ちえんひょうか）",
    "rust_lesson3_ex1_slide1_content": "# referenceの「寿命」を示す印\n\nライフタイム は、referenceがいつまで使えるかを示す印です。`'a`（アポストロフィ・エー）のようにwrite。\n\nなぜ必要？\nreferenceは「借りている」状態。借りた元のデータが消えたら、referenceも使えなくなります。\n\nFor example：\n- 図書館で借りた本 → 図書館が閉まったら読めない\n- referenceで借りたデータ → 元のデータが消えたら使えない\n\nライフタイムは「このreferenceはこの範囲で有効だよ」とコンパイラに伝える仕組みです。",
    "rust_lesson1_ex1_slide1_title": "Rust（ラスト）?",
    "rust_lesson1_ex2_slide2_title": "計算の記号（operator）",
    "rust_lesson4_ex5_slide2_content": "# get で安全に取り出す\n\n`get()` methodでvalueを取り出せます。見つからない可能性があるので、`Option` が返ってきます。\n\ncodeExample：\n```rust\n// getはOption<&V>を返す\nif let Some(score) = scores.get(\"Blue\") {\n    println!(\"青チームは{}点\", score);\n}\n```\n\nPoint：\n- keyがあれば `Some(値)` が返る\n- keyがなければ `None` が返る\n- `if let` で安全に取り出せる\n\n存在しないkeyでアクセスしてもprogramが落ちない！",
    "rust_lesson4_ex7_slide1_title": "match ガード?",
    "rust_lesson3_title": "Rust III - ライフタイムとiterator",
    "rust_lesson4_ex3_title": "Box<T>",
    "rust_lesson1_ex4_slide1_title": "累算assignmentoperator（るいさんだいにゅう）?",
    "rust_lesson2_ex9_comment1": "trait でトレイトをdefinition",
    "rust_lesson2_ex1_description": "Rust独自の概念「所有権」を学びましょう。",
    "rust_lesson2_ex3_slide3_content": "参照先の値を変更できる「可変参照」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex1_slide3_title": "Let's Try It!",
    "rust_lesson3_ex6_slide2_title": "様々な畳み込み",
    "rust_lesson4_ex9_slide3_title": "Let's Try It!",
    "rust_lesson2_ex5_title": "impl でmethodを追加",
    "rust_lesson2_ex6_slide1_content": "# 複数の選択肢\n\nenum は、valueがいくつかの種類のうちの一つであることを表します。各バリアントにデータを持たせることもできます。",
    "rust_lesson2_ex4_comment1": "struct で構造体をdefinition",
    "rust_lesson1_ex3_title": "剰余operator（%）",
    "rust_lesson1_ex7_comment1": "colors というベクタをcreate（'あか', 'あお'の順）",
    "rust_lesson1_ex4_slide1_content": "# valueをかんたんに増やす・減らす\n\n`+=`（プラスイコール）と `-=`（マイナスイコール）は、variableの中身を増やしたり減らしたりdo便利な記号です。\n\nRustのImportantなルール：`mut`が必要！\nRustでは、variableをchangeには `let mut`（レット ミュート）とwrite必要があります。`mut` は「mutable（変更できる）」の略です。\n\ncodeExample：\n```rust\nlet mut score = 100;  // mut をつけて変更可能に\nscore += 10;          // 10を足す → 110に\nscore -= 50;          // 50を引く → 60に\n```\n\n`mut` がないと「このvariableは変えちゃダメ！」とRustが怒ります。",
    "rust_lesson2_ex1_slide2_title": "ムーブ（移動）",
    "rust_lesson3_ex4_comment1": "map で各elementを変換",
    "rust_lesson3_ex8_slide1_title": "unwrap_or ?",
    "rust_lesson2_ex5_slide1_content": "# implementationブロック\n\nimpl ブロックで、構造体にmethodを追加できます。`self` で自分自身をreferenceします。",
    "rust_lesson2_ex10_slide1_title": "ジェネリクス?",
    "rust_lesson1_ex8_slide2_content": "# 名前（key）で取り出す\n\ndictionaryに入れたデータは、名前（key）を指定して取り出せます。\n\ncodeExample：\n```rust\nuse std::collections::HashMap;\nfn main() {\n    let mut fruits = HashMap::new();\n    fruits.insert(\"りんご\", \"あか\");  // 追加\n    fruits.insert(\"バナナ\", \"きいろ\");  // 追加\n    \n    println!(\"{}\", fruits[\"りんご\"]);  // あか と表示\n}\n```\n\nPoint：\n- `insert(名前, データ)` で追加\n- `辞書[名前]` で取り出し\n- 番号ではなく「名前」で探せるのが便利！",
    "rust_lesson4_ex9_slide1_content": "# iteratorをコレクションに\n\ncollect は、iteratorをVecやHashMapなどに変換します。\n\n```rust\nlet v: Vec<_> = (0..5).collect();\nlet s: String = vec!['a', 'b'].into_iter().collect();\n```",
    "rust_lesson2_ex2_slide3_content": "所有権を移さずに値を借りる「参照」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex2_slide3_content": "周囲の変数を使える無名関数「クロージャ」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex4_slide2_content": "# struct keyワードでdefinition\n\n`struct 名前 { フィールド }` で構造体をdefine。フィールドには名前とtypeをwrite。\n\ncodeExample：\n```rust\n// Point 構造体を定義\nstruct Point {\n    x: i32,  // xフィールド（整数）\n    y: i32,  // yフィールド（整数）\n}\n\n// 使い方\nlet p = Point { x: 10, y: 20 };\nprintln!(\"x={}, y={}\", p.x, p.y);\n```\n\nPoint：\n- `struct 名前` で構造体をcreate\n- `{ フィールド名: 型 }` でどんなデータを持つか決める\n- `.フィールド名` でアクセス",
    "rust_lesson2_ex10_slide3_content": "型を後から決められる「ジェネリクス」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex6_slide3_title": "Let's Try It!",
    "rust_lesson4_ex6_slide1_content": "# 一意なvalueのset\n\nHashSet は、重複のないvalueのsetです。\n\n```rust\nuse std::collections::HashSet;\n\nlet mut set = HashSet::new();\nset.insert(1);\nset.insert(2);\nset.insert(1); // 重複は無視\n```",
    "rust_lesson4_ex2_title": "derive 属性",
    "rust_lesson4_ex2_slide1_content": "# トレイトを「自動で」implementation\n\n#[derive(...)] をuseと、よくuseトレイトを自分で書かなくても自動でimplementationしてくれます。\n\nFor example：\n構造体を `println!` でdisplayしたいとき、普通は Display トレイトをimplementationdo必要がありますが、`#[derive(Debug)]` をwriteだけでOK！\n\ncodeExample：\n```rust\n#[derive(Debug)]  // Debug トレイトを自動実装\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nlet p = Point { x: 1, y: 2 };\nprintln!(\"{:?}\", p);  // Point { x: 1, y: 2 }\n```",
    "rust_lesson1_ex6_slide2_title": "Let's Try It!",
    "rust_lesson3_ex3_slide2_title": "3つの iter method",
    "rust_lesson4_ex7_slide2_content": "# 複雑なconditional\n\n```rust\nmatch Some(5) {\n    Some(x) if x % 2 == 0 => println!(\"even\"),\n    Some(x) => println!(\"odd: {}\", x),\n    None => println!(\"none\"),\n}\n```",
    "rust_lesson3_ex3_slide1_content": "# elementを1つずつ取り出す仕組み\n\niterator は、ベクタなどのデータを「1つずつ順番に」取り出す仕組みです。\n\nFor example：\n- 行列に並んでいる人を1人ずつ呼ぶ\n- 引き出しの中身を1つずつ出す\n\ncodeExample：\n```rust\nlet v = vec![1, 2, 3];\nfor x in v.iter() {\n    println!(\"{}\", x);  // 1, 2, 3 と順番に表示\n}\n```\n\n`iter()` で「順番に取り出す準備」をして、`for` で1つずつ処理します。",
    "rust_lesson3_ex3_slide1_title": "iterator?",
    "rust_lesson4_ex2_description": "トレイトを自動implementationdoderiveを学びましょう。",
    "rust_lesson3_ex4_slide1_content": "# 全部を同じように変換do\n\n**map** は、iteratorの各elementを「同じ方法で」変換します。\n\nFor example：\n- 全員の身長を2倍にdo\n- 全員の名前を大文字にdo\n- 全部の数を2乗do\n\ncodeExample：\n```rust\nlet v = vec![1, 2, 3];\nlet doubled: Vec<_> = v.iter()\n    .map(|x| x * 2)  // 各要素を2倍に\n    .collect();      // ベクタに戻す\n// [2, 4, 6]\n```\n\n`|x| x * 2` は「xを受け取って、x*2をreturn」closureです。",
    "rust_lesson1_ex3_slide1_title": "あまりを求める",
    "rust_lesson3_ex10_slide1_content": "# 所有権の違い\n\nString は所有権を持つheap上のstring、&str はreferenceです。\n\n```rust\nlet s1: String = String::from(\"hello\");\nlet s2: &str = \"hello\";\n```",
    "rust_lesson4_ex2_slide1_title": "derive（デライブ）?",
    "rust_lesson2_ex2_comment1": "& でreferenceを渡す",
    "rust_lesson4_ex5_slide1_title": "HashMap（ハッシュmap）?",
    "rust_lesson2_ex3_slide2_title": "&mut  Usage",
    "rust_lesson3_ex5_title": "filter で絞り込み",
    "rust_lesson4_ex3_slide2_title": "いつuse？",
    "rust_lesson2_ex2_title": "referenceと借用",
    "rust_lesson2_ex7_title": "Option<T> で null を安全に",
    "rust_lesson4_ex10_slide3_title": "Let's Try It!",
    "rust_lesson3_ex5_slide3_title": "Let's Try It!",
    "rust_lesson4_ex10_title": "enumerate でindex付き",
    "rust_lesson2_ex2_slide1_content": "# 所有権を渡さずに「借りる」\n\nreference をuseと、所有権を移さずにデータを「見せてもらう」ことができます。\n\nたとえるなら：\n- ムーブ = おもちゃをあげる（自分は使えない）\n- reference = おもちゃを見せる（自分も使える）\n\n作り方：\n`&`（アンパサンド）をつけるとreferenceを作れます。\n\n```rust\nlet s = String::from(\"hello\");\nlet r = &s;  // sを借りる（見せてもらう）\n// s も r も使える！\n```",
    "rust_lesson2_ex5_slide2_content": "# &self をuse\n\nmethodの最初のargumentは `&self` です。\n\ncodeExample：\n```rust\nimpl Rect {\n    fn area(&self) -> i32 {\n        self.width * self.height\n    }\n}\n```",
    "rust_lesson1_ex5_slide2_title": "Let's Try It!",
    "rust_lesson2_ex4_slide3_title": "Let's Try It!",
    "rust_lesson4_ex3_slide3_title": "Let's Try It!",
    "rust_lesson2_ex9_slide3_content": "共通の振る舞いを定義する「トレイト」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex1_slide2_content": "# impl で約束を守る\n\n構造体にトレイトをimplementationdoと、その構造体は「約束を守る」ことになります。\n\ncodeExample：\n```rust\nstruct Person { name: String }\n\nimpl Greet for Person {\n    fn greet(&self) -> String {\n        format!(\"Hello, {}\", self.name)\n    }\n}\n```\n\n読み方：\n- `impl Greet for Person` → 「PersonはGreetをimplementationdo」\n- これでPersonは「あいさつできる」ようになった！",
    "rust_lesson4_ex4_comment1": "clone でreferenceカウントを増やす",
    "rust_lesson3_ex4_slide2_content": "# map だけではexecuteされない！\n\nRustのiteratorは 遅延評価 といって、「本当に必要になるまで処理しない」仕組みです。\n\nなぜ？\n無駄な計算を省けるから。100万件あっても、最初の10件だけ欲しいなら10件だけ処理すればいい。\n\ncollect() でexecute：\n```rust\n// これだけでは何も起きない\nv.iter().map(|x| x * 2);\n\n// collect() で実行してベクタに変換\nlet result: Vec<_> = v.iter().map(|x| x * 2).collect();\n```\n\n`collect()` は「今すぐ全部処理してResultをちょうだい」という意味です。",
    "rust_lesson2_ex4_slide2_title": "struct のdefinitionのしかた",
    "rust_lesson2_ex3_slide1_content": "# 「書き換えできる」借り方\n\n普通のreference `&` は「見るだけ」ですが、可変reference `&mut` は「変更もできる」借り方です。\n\nたとえるなら：\n- `&` = 本を見せてもらう（readだけ）\n- `&mut` = ノートを借りる（writeOK）\n\nImportantなルール：\n- 可変referenceは同時に1つだけ！\n- 「みんなで見る」か「1人でwrite」かのどちらか\n\nこのルールで、データが同時に書き換えられるバグを防いでいます。",
    "rust_lesson2_ex10_slide3_title": "Let's Try It!",
    "rust_lesson2_ex4_title": "構造体をdefinitionしよう",
    "rust_lesson3_ex10_slide2_content": "# 相互変換\n\n```rust\n// &str -> String\nlet s = \"hello\".to_string();\n\n// String -> &str\nlet slice: &str = &s;\n```",
    "rust_lesson4_ex10_slide3_content": "イテレータにインデックスを付けましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex4_slide2_content": "# 「何人が持っているか」を数える\n\nRcは「今何人がこのデータを持っているか」を数えています。\n\ncodeExample：\n```rust\nlet a = Rc::new(5);\nprintln!(\"{}\", Rc::strong_count(&a));  // 1\n\nlet b = Rc::clone(&a);\nprintln!(\"{}\", Rc::strong_count(&a));  // 2\n```\n\nいつデータが消える？\n- カウントが0になったとき（誰も持っていないとき）\n- 最後の持ち主がいなくなると自動で片付けられる\n\n`Rc::clone` は「持ち主を1人増やす」操作です。",
    "rust_lesson1_ex8_slide2_title": "dictionary Usage",
    "rust_lesson4_ex3_slide1_content": "# データを「heap」に置く箱\n\nBox<T> は、データを「heap」という特別な場所に置くための箱です。\n\nmemoryの2つの場所：\n- stack：小さくて速い。サイズが決まっているデータ向け\n- heap：大きくて柔軟。サイズが大きいor変わるデータ向け\n\ncodeExample：\n```rust\nlet b = Box::new(5);  // 5をヒープに置く\nprintln!(\"{}\", *b);   // *で中身を取り出す → 5\n```\n\n`*` は「箱を開けて中身を見る」操作です。",
    "rust_lesson3_ex2_slide2_title": "closure Syntax",
    "rust_lesson4_ex4_slide1_title": "Rc（アールシー）?",
    "rust_lesson4_ex7_slide1_content": "# 追加条件\n\n**if** でパターンに追加条件をつけられます。\n\n```rust\nmatch x {\n    n if n < 0 => println!(\"negative\"),\n    n if n > 0 => println!(\"positive\"),\n    _ => println!(\"zero\"),\n}\n```",
    "rust_lesson2_ex3_title": "可変reference",
    "rust_lesson3_ex10_comment1": "to_string で String に変換",
    "rust_lesson3_ex10_slide2_title": "変換",
    "rust_lesson3_ex1_description": "referenceの有効期間を表すライフタイムを学びましょう。",
    "rust_lesson3_ex2_slide1_content": "# 名前のない「即席」function\n\nclosure は、名前をつけずにその場でcreatefunctionです。そして特別な能力があります：周りのvariableを使えるのです！\n\nFor example：\n```rust\nlet x = 5;  // 外側の変数\nlet add_x = |n| n + x;  // xを使えるクロージャ\nprintln!(\"{}\", add_x(10));  // 15\n```\n\n普通のfunctionとの違い：\n- 普通のfunction：argumentしか使えない\n- closure：argument + 周りのvariableも使える\n\n「その場の空気を読める」functionというイメージです！",
    "rust_lesson1_ex2_comment1": "x に 10 を入れる",
    "rust_lesson1_ex7_slide3_title": "Let's Try It!",
    "rust_lesson1_ex5_title": "「もし〜なら」で分けましょう",
    "rust_lesson3_ex2_slide3_title": "Let's Try It!",
    "rust_lesson3_ex7_slide2_content": "# 簡潔なerror処理\n\n```rust\n// ? を使わない場合\nmatch result {\n    Ok(v) => v,\n    Err(e) => return Err(e),\n}\n\n// ? を使う\nresult?\n```",
    "rust_lesson3_ex6_slide3_title": "Let's Try It!",
    "rust_lesson4_ex9_slide3_content": "イテレータをコレクションに変換しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex6_description": "elementを1つのvalueにまとめるfoldを学びましょう。",
    "rust_lesson2_ex9_description": "共通の振る舞いをdefine「トレイト」を学びましょう。",
    "rust_lesson2_ex8_comment1": "Ok で成功をreturn",
    "rust_lesson3_ex5_slide2_content": "# filter はreferenceのreferenceを受け取る\n\n`filter` のclosureは、referenceのreference（`&&T`）を受け取ります。そのため、valueをuseには `**x` と2回referenceを外す必要があります。\n\nなぜ？\n- `iter()` はreference（`&T`）をreturn\n- `filter` はそれをFurthermorereferenceで渡す（`&&T`）\n\nSyntax：\n```rust\n// **x で値を取り出す\n.filter(|x| **x > 2)\n\n// または * を引数につける\n.filter(|&x| *x > 2)\n```\n\n最初は混乱しますが、慣れれば大丈夫！",
    "rust_lesson1_ex5_comment1": "> でcompare",
    "rust_lesson2_ex4_description": "関連doデータをまとめる「構造体」を学びましょう。",
    "rust_lesson3_ex5_slide3_content": "条件に合う要素だけを取り出しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex7_slide3_content": "「ベクタ（Vec）」を使うと、たくさんのデータを一つの「長い はこ」にまとめて入れられます。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex5_slide2_title": "valueの取得",
    "rust_lesson3_ex1_slide1_title": "ライフタイム?",
    "rust_lesson1_ex3_comment1": "10 を 3 で割ったあまりをoutput",
    "rust_lesson3_ex1_comment1": "'a でライフタイムをdefinition",
    "rust_lesson3_ex10_slide1_title": "String vs &str",
    "rust_lesson2_title": "Rust II - 所有権とトレイト",
    "rust_lesson2_ex5_slide2_title": "methodのdefinition",
    "rust_lesson4_ex5_comment1": "insert でkeyとvalueを追加",
    "rust_lesson2_ex9_slide1_content": "# 「できること」の約束\n\nトレイト は、「このtypeはこういうことができる」という約束をdefine。\n\nFor example「鳴ける」という約束：\n- 犬は「ワン」と鳴く\n- 猫は「ニャー」と鳴く\n- 両方とも「鳴ける」能力がある\n\nトレイトは「鳴ける動物は、鳴き声を出すmethodを持つ」という約束です。\n\n他の言語とのcomparison：\n- Java: interface\n- TypeScript: interface\n\nに似た概念です。",
    "rust_lesson1_ex2_slide3_title": "Let's Try It!",
    "rust_lesson4_ex8_slide1_content": "# return valueのtypeをabstract化\n\nimpl Trait で、トレイトをimplementationdotypeを返せます。\n\n```rust\nfn make_iter() -> impl Iterator<Item = i32> {\n    vec![1, 2, 3].into_iter()\n}\n```",
    "rust_lesson1_ex2_slide2_content": "# 四則演算（しそくえんざん）\n\nRustでも算数と同じ記号で計算ができます。\n\n4つのBasic記号：\n- +（プラス）: たし算\n- -（マイナス）: ひき算\n- \\*（アスタリスク）: かけ算（×の代わり）\n- /（スラッシュ）: わり算（÷の代わり）\n\ncodeExample：\n```rust\nlet a = 10;\nlet b = 5;\nprintln!(\"{}\", a + b);  // 15 と表示される\n```\n\n`println!` の `{}` は「ここにvalueを入れてね」という目印です。",
    "rust_lesson4_ex9_slide2_content": "# 変換先を指定\n\n```rust\n// ターボフィッシュ構文\nlet v = (0..5).collect::<Vec<_>>();\n\n// 変数の型注釈\nlet v: Vec<i32> = (0..5).collect();\n```",
    "rust_lesson1_ex8_description": "「dictionary（HashMap）」をuseと、名前をつけてデータを保存し、その名前で取り出せます。",
    "rust_lesson4_ex9_slide2_title": "typeHint",
    "rust_lesson3_ex1_title": "ライフタイムのBasic",
    "rust_lesson2_ex5_description": "構造体にmethodをadd「impl」を学びましょう。",
    "rust_lesson4_ex8_comment1": "impl でトレイトをimplementationdotypeをreturn",
    "rust_lesson4_ex8_slide2_title": "argumentにも使える",
    "rust_lesson4_ex7_comment1": "if でマッチガードを追加",
    "rust_lesson2_ex9_slide2_title": "trait のdefinitionとimplementation",
    "rust_lesson4_ex10_slide2_title": "いつuse？",
    "rust_lesson3_ex7_slide2_title": "match の省略形",
    "rust_lesson1_ex6_title": "logicaloperator（&&、||）",
    "rust_lesson3_ex6_comment1": "fold で畳み込み",
    "rust_lesson2_ex6_description": "複数の状態を表す「列挙type（enum）」を学びましょう。",
    "rust_lesson4_ex10_slide1_title": "enumerate（イニュメレート）?",
    "rust_lesson1_ex7_slide1_title": "ベクタ（Vec）?",
    "rust_lesson2_ex6_slide3_content": "複数の状態を表す「列挙型（enum）」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex3_slide3_title": "Let's Try It!",
    "rust_lesson3_ex4_description": "各elementを変換domapを学びましょう。",
    "rust_lesson4_ex1_slide3_title": "Let's Try It!",
    "rust_lesson3_ex9_slide2_title": "mut が必要",
    "rust_lesson1_ex6_slide1_content": "# logicaloperator（ろんりえんざんし）\n\n2つ以上の条件を組み合わせたいときにuse記号です。\n\n2つの記号：\n- `&&`（アンドアンド）：「かつ」＝ 両方とも 正しいとき\n- `||`（オアオア）：「Alsoは」＝ どちらか 正しいとき\n\n身近なExample：\n- 遊園地：「18歳以上 かつ チケットあり」なら乗れる\n- おやつ：「宿題終わった Alsoは お手伝いした」ならOK\n\ncodeExample：\n```rust\nif score >= 70 && bonus > 0 {\n    // 70点以上 かつ ボーナスあり → 合格！\n    println!(\"合格！\");\n}\n```",
    "rust_lesson4_ex4_slide3_content": "参照カウントでデータを共有しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex6_slide3_title": "Let's Try It!",
    "rust_lesson2_ex5_slide3_content": "構造体にメソッドを追加する「impl」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex1_slide3_title": "Let's Try It!",
    "rust_lesson1_ex5_slide1_content": "# programに「判断」させよう\n\nconditional は、「もし〜なら、〇〇do」という判断をprogramにさせる仕組みです。\n\n身近なExample：\n- もし80点以上なら → 「合格！」とdisplay\n- もし雨なら → 傘を持っていく\n- もしHPが0なら → ゲームオーバー\n\nRustで Syntax：\n```rust\nif score > 80 {\n    println!(\"合格！\");\n}\n```\n\n読み方：\n- `if` →「もし」\n- `score > 80` →「スコアが80より大きいなら」\n- `{ }` の中 →「これをやる」",
    "rust_lesson4_ex5_title": "HashMap",
    "rust_lesson1_ex2_slide1_content": "# データを保存do「はこ」\n\nvariable（へんすう） は、数字や文字を入れておける「はこ」のことです。名前をつけて、あとでuseことができます。\n\nFor example：\n- 「りんごの数」というラベルの箱に「5」を入れる\n- あとで「りんごの数」と呼べば「5」が出てくる\n\nRustで Syntax：\n```rust\nlet x = 10;  // xという箱に10を入れる\nprintln!(\"{}\", x);  // xの中身（10）を表示\n```\n\n`let` は「この名前で箱をcreateよ」という意味です。",
    "rust_lesson2_ex4_slide3_content": "関連するデータをまとめる「構造体」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex6_slide1_title": "enum ?",
    "rust_lesson2_ex9_title": "トレイトをdefinitionしよう",
    "rust_lesson2_ex4_slide1_title": "構造体（こうぞうたい）?",
    "rust_lesson4_ex2_slide2_content": "# 覚えておくと便利な5つ\n\nよくusederiveトレイト：\n```rust\nDebug     // {:?} でデバッグ表示できる\nClone     // .clone() でコピーを作れる\nCopy      // 代入時に自動でコピー（小さい型向け）\nPartialEq // == で比較できる\nDefault   // 初期値を自動で作れる\n```\n\n複数指定もOK：\n```rust\n#[derive(Debug, Clone, PartialEq)]\nstruct User {\n    name: String,\n    age: u32,\n}\n```\n\n`Debug` は特によくuse。debug時に構造体の中身を見れて便利！",
    "rust_lesson2_ex1_slide1_content": "# データの「持ち主」を決めるルール\n\n所有権 は、Rust最大のFeatureです。「このデータの持ち主は誰か」をはっきりさせる仕組みです。\n\nルール：\n- データには必ず1人だけ「持ち主」がいる\n- 持ち主がいなくなると、データは自dynamicに片付けられる\n\nたとえるなら：\n- おもちゃは1人しか持てない\n- 持ち主が部屋を出たら、おもちゃは片付けられる\n\nこのルールのおかげで、Rustは「memoryリーク」（データが片付けられないバグ）を防げます！",
    "rust_lesson1_ex3_slide2_title": "Let's Try It!",
    "rust_lesson3_ex1_slide2_title": "なぜ必要？",
    "rust_lesson3_ex1_slide2_content": "# 危険なバグを防ぐ\n\nダングリングreference という危険なバグがあります。これは「もう存在しないデータ」を指し続けているreferenceのことです。\n\nExample：\n```rust\nfn longest<'a>(x: &'a str, y: &'a str) -> &'a str {\n    if x.len() > y.len() { x } else { y }\n}\n```\n\n`'a` の意味：\n- argument `x` と `y` は同じライフタイム `'a` を持つ\n- return valueも同じライフタイム `'a` を持つ\n- In other words「xとyが両方有効な間、return valueも有効」という約束\n\nRustはこれを自動でチェックしてくれます！",
    "rust_lesson4_ex6_slide2_title": "set演算",
    "rust_lesson3_ex7_comment1": "? でerrorを伝播",
    "rust_lesson3_ex2_slide2_content": "# | | でargumentを囲む\n\nclosureは `|引数| 処理` という形でwrite。`||` は「パイプ」と呼ばれます。\n\nいろいろなSyntax：\n```rust\n// 引数なし\n|| println!(\"Hello\")\n\n// 引数あり\n|x, y| x + y\n\n// 複数行のブロック\n|x| {\n    let y = x * 2;\n    y + 1\n}\n```\n\nPoint：\n- argumentを `| |` で囲む（functionの `()` の代わり）\n- typeは省略できることが多い（Rustが推測してくれる）",
    "rust_lesson2_ex7_comment1": "Some でvalueがあることを示す",
    "rust_lesson3_ex4_slide3_content": "各要素を変換するmapを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_title": "Rust (ラスト) に挑戦！",
    "rust_lesson2_ex8_description": "成功と失敗を表す「Result」を学びましょう。",
    "rust_lesson3_ex8_description": "Option/Resultのデフォルトvalueを設定しましょう。",
    "rust_lesson4_ex2_slide3_title": "Let's Try It!",
    "rust_lesson2_ex5_slide3_title": "Let's Try It!",
    "rust_lesson4_ex9_description": "iteratorをコレクションに変換しましょう。",
    "rust_lesson1_ex1_slide2_content": "# println! でscreenにdisplay\n\nRustで文字をscreenにdisplayには、`println!`（プリントラインびっくり）をuse。\n\nPoint：\n- `!` がつくのがRustのFeature（マクロと呼ばれます）\n- programは `fn main() { }` の中にwrite\n- `fn` は「function（function）」の略\n\ncodeExample：\n```rust\nfn main() {\n    println!(\"ヤッホー！\");\n}\n// 「ヤッホー！」と画面に表示される\n```\n\n`println!` の `!` は「マクロ」という特別な機能の印です。今は「おまじない」と思っておけばOK！",
    "rust_lesson3_ex6_slide1_title": "fold ?",
    "rust_lesson4_ex8_slide1_title": "impl Trait ?",
    "rust_lesson1_ex1_slide2_title": "Rustの「おまじない」",
    "rust_lesson3_ex10_description": "stringtypeの違いを理解しましょう。",
    "rust_lesson3_ex7_slide3_content": "エラーを簡潔に伝播させましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex1_comment1": "s1 の所有権を移動",
    "rust_lesson2_ex9_slide1_title": "トレイト?",
    "rust_lesson4_ex6_slide2_content": "# 和set、積setなど\n\n```rust\nset1.union(&set2)\nset1.intersection(&set2)\nset1.difference(&set2)\n```",
    "rust_lesson4_ex5_slide3_content": "キーと値のペアを格納しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex8_slide1_title": "Result（リザルト）?",
    "rust_lesson4_ex1_slide1_content": "# 「できること」の約束\n\nトレイト は、typeが持つべきmethodをdefine仕組みです。\n\nFor example：\n- 「あいさつできる」トレイト → greet() methodを持つ\n- 「displayできる」トレイト → display() methodを持つ\n\ncodeExample：\n```rust\ntrait Greet {\n    fn greet(&self) -> String;  // メソッドの「約束」\n}\n```\n\nこれは「Greetできるtypeは、greet()methodを持つ」という約束です。",
    "rust_lesson4_ex2_slide3_content": "トレイトを自動実装するderiveを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex6_title": "fold で畳み込み",
    "rust_lesson3_ex9_slide3_content": "Vecに要素を追加しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex4_slide1_content": "# 関係あるデータをまとめる「設計図」\n\n構造体（struct） は、いくつかのデータをひとまとめにdo仕組みです。\n\nFor example「点（座標）」のデータ：\n- x座標\n- y座標\n\nこの2つは関係があるので、「Point（点）」としてまとめると便利です。\n\nFor example「人」のデータ：\n- 名前\n- 年齢\n\nこれも「Person（人）」としてまとめられます。\n\n構造体は「こういうデータを持つ」という設計図です。",
    "rust_lesson4_ex1_slide1_title": "トレイト?（復習）",
    "rust_lesson2_ex3_description": "reference先のvalueを変更できる「可変reference」を学びましょう。",
    "rust_lesson2_ex7_slide2_content": "# match で安全に取り出す\n\n`match` を使って「ある場合」と「ない場合」で処理を分けます。\n\ncodeExample：\n```rust\nlet x: Option<i32> = Some(5);  // 値あり\n\nmatch x {\n    Some(n) => println!(\"値は{}です\", n),  // 5\n    None => println!(\"値がありません\"),\n}\n```\n\nなぜ安全？\n- `null` のように「あるつもりでアクセスしたら無かった」errorが起きない\n- 「ない場合」の処理を書かないとコンパイルerrorになる\n- 強制的に両方のケースを考えることになる！",
    "rust_lesson4_ex9_comment1": "collect で Vec に変換",
    "rust_lesson3_ex10_title": "String と &str",
    "rust_lesson2_ex7_slide1_title": "Option（オプション）?",
    "rust_lesson3_ex9_description": "Vecにelementを追加しましょう。",
    "rust_lesson2_ex5_comment1": "impl でmethodをimplementation",
    "rust_lesson3_ex1_slide3_content": "参照の有効期間を表すライフタイムを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex6_slide2_content": "複数の条件を組み合わせる「&&（かつ）」と「||（または）」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex5_comment1": "filter で条件に合うelementを絞り込む",
    "rust_lesson2_ex7_slide3_content": "値があるかないかを表す「Option」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex10_slide3_title": "Let's Try It!",
    "rust_lesson4_ex4_slide3_title": "Let's Try It!",
    "rust_lesson3_ex3_comment1": "iter でiteratorを取得",
    "rust_lesson3_ex6_slide3_content": "要素を1つの値にまとめるfoldを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex7_slide2_title": "ベクタの番号は「0」から！",
    "rust_lesson1_ex5_slide1_title": "conditional（じょうけんぶんき）?",
    "rust_lesson1_ex3_description": "割り算の「あまり」を求める「%」（パーセント）operatorを学びましょう。",
    "rust_lesson1_ex1_slide3_content": "Rustを使って画面に文字を表示してみましょう。println! という特別な関数を使います。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex10_slide2_content": "# <T> でtypeを「あとで決める」\n\nfunction名の後に `<T>` をつけて、`T` を「type」としてuse。\n\ncodeExample：\n```rust\n// Tはどんな型でもOK\nfn first<T>(arr: &[T]) -> &T {\n    &arr[0]  // 最初の要素を返す\n}\n\n// 使い方\nfirst(&[1, 2, 3]);         // Tはi32\nfirst(&[\"a\", \"b\", \"c\"]);   // Tは&str\n```\n\n読み方：\n- `<T>` → 「Tという名前のtypeをuseよ」\n- `T` は慣習で「Type（type）」の頭文字\n- 複数のtypeが必要なら `<T, U>` のようにwrite",
    "rust_lesson3_ex2_comment1": "|x| でclosureのargumentをdefinition",
    "rust_lesson3_ex3_description": "elementを順番に処理doiteratorを学びましょう。",
    "rust_lesson1_ex1_slide3_title": "Let's Try It!",
    "rust_lesson2_ex6_slide2_title": "enum のdefinition",
    "rust_lesson2_ex1_title": "所有権のBasic",
    "rust_lesson4_ex3_slide1_title": "Box（ボックス）?",
    "rust_lesson2_ex1_slide3_content": "Rust独自の概念「所有権」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex8_slide3_content": "Option/Resultのデフォルト値を設定しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex7_slide2_title": "使用Example",
    "rust_lesson4_ex10_description": "iteratorにindexを付けましょう。",
    "rust_lesson4_ex9_slide1_title": "collect ?",
    "rust_lesson4_ex10_slide2_content": "# 「何番目か」が必要なとき\n\n番号（index）とelementの両方が必要なときに便利です。\n\ncodeExample：\n```rust\nlet v = vec![10, 20, 30];\nfor (idx, val) in v.iter().enumerate() {\n    println!(\"{}番目の値は{}\", idx, val);\n}\n// 0番目の値は10\n// 1番目の値は20\n// 2番目の値は30\n```\n\nPoint：\n- `(i, x)` でtuple（2つのset）を受け取る\n- `i` にindex、`x` にelementが入る\n- indexは0から始まる",
    "rust_lesson3_ex2_description": "周囲のvariableを使えるanonymous function「closure」を学びましょう。",
    "rust_lesson1_ex4_comment1": "mut で変更可能にdo",
    "rust_lesson1_ex8_slide3_title": "Let's Try It!",
    "rust_lesson1_ex3_slide2_content": "割り算の「あまり」を求める「%」（パーセント）演算子を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex9_slide3_title": "Let's Try It!",
    "rust_lesson3_ex3_title": "iteratorのBasic",
    "rust_lesson3_ex9_title": "Vec のmethod push",
    "rust_lesson1_ex8_comment1": "dictionaryをcreate（keyは'みかん'、valueは'オレンジ'）",
    "rust_lesson1_ex2_comment3": "+ でたし算do",
    "rust_lesson4_ex8_slide2_content": "# ジェネリクスの代わり\n\n```rust\nfn print_all(iter: impl Iterator<Item = i32>) {\n    for x in iter {\n        println!(\"{}\", x);\n    }\n}\n```",
    "rust_lesson2_ex2_slide2_title": "reference Usage",
    "rust_lesson1_ex8_slide3_content": "「辞書（HashMap）」を使うと、名前をつけてデータを保存し、その名前で取り出せます。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex7_slide2_content": "# [ ]で番号を指定して取り出す\n\n`[番号]` で何番目のデータか指定して取り出せます。\n\nImportantなルール：番号は「0」から！\n- 1番目 → `[0]`\n- 2番目 → `[1]`\n- 3番目 → `[2]`\n\ncodeExample：\n```rust\nlet fruits = vec![\"りんご\", \"バナナ\", \"みかん\"];\n//                  ↑0番    ↑1番     ↑2番\nprintln!(\"{}\", fruits[0]);  // りんご\nprintln!(\"{}\", fruits[1]);  // バナナ\n```\n\nプログラミングでは「0から数える」のが世界共通のルールです！",
    "rust_lesson1_ex6_slide1_title": "条件を組み合わせる",
    "rust_lesson2_ex10_slide2_title": "ジェネリックfunction Syntax",
    "rust_lesson1_ex6_description": "複数の条件を組み合わせる「&&（かつ）」と「||（Alsoは）」を学びましょう。",
    "rust_lesson4_ex6_title": "HashSet",
    "rust_lesson2_ex3_slide2_content": "# mut が2か所に必要\n\n変更できるようにdoには、variableとreferenceの両方に `mut` が必要です。\n\ncodeExample：\n```rust\n// 1. 変数を mut で作る\nlet mut s = String::from(\"hello\");\n\n// 2. &mut で可変参照を渡す\nchange(&mut s);\n\nfn change(s: &mut String) {\n    s.push_str(\" world\");  // 変更できる！\n}\n```\n\nPoint：\n- `let mut 変数` でvariableを変更可能に\n- `&mut 変数` で可変referenceをcreate\n- 両方ないと変更できない！",
    "rust_lesson2_ex2_slide1_title": "reference（さんしょう）?",
    "rust_lesson3_ex6_slide2_content": "# 合計、積、結合など\n\n```rust\n// 積\nv.iter().fold(1, |acc, x| acc * x)\n\n// 文字列結合\nwords.iter().fold(String::new(), |acc, s| acc + s)\n```",
    "rust_lesson1_ex1_description": "Rustを使ってscreenに文字をdisplayしてみましょう。println! という特別なfunctionをuse。",
    "rust_lesson3_ex8_slide3_title": "Let's Try It!",
    "rust_lesson4_ex6_description": "一意なvalueのsetを管理しましょう。",
    "rust_lesson2_ex5_slide1_title": "impl ?",
    "rust_lesson1_ex8_title": "名前で引き出す「dictionary」",
    "rust_lesson2_ex7_description": "valueがあるかないかを表す「Option」を学びましょう。",
    "rust_lesson1_ex4_slide2_title": "Let's Try It!",
    "rust_lesson1_ex7_title": "たくさんのデータをまとめましょう「ベクタ」",
    "rust_lesson3_ex7_slide1_content": "# errorの早期リターン\n\n? は、Resultが Err の場合に早期リターンします。\n\n```rust\nfn read_file() -> Result<String, io::Error> {\n    let content = fs::read_to_string(\"file.txt\")?;\n    Ok(content)\n}\n```",
    "rust_lesson3_ex9_slide1_content": "# 末尾に追加\n\npush は、Vecの末尾にelementをadd。\n\n```rust\nlet mut v = vec![1, 2];\nv.push(3);\n// [1, 2, 3]\n```",
    "rust_lesson4_ex8_slide3_content": "トレイトを返す関数を簡潔に書きましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex1_title": "screenにメッセージを出しましょう",
    "rust_lesson2_ex8_slide2_title": "Result  Usage",
    "rust_lesson3_ex2_slide1_title": "closure?",
    "rust_lesson3_ex8_title": "unwrap_or でデフォルトvalue",
    "rust_lesson4_ex10_slide1_content": "# 番号とelementを一緒にもらう\n\nenumerate は、「何番目か」と「そのelement」をsetで取り出せるmethodです。\n\nFor example：\n- 0番目: りんご\n- 1番目: バナナ\n- 2番目: みかん\n\ncodeExample：\n```rust\nfor (i, x) in vec![\"a\", \"b\", \"c\"].iter().enumerate() {\n    println!(\"{}: {}\", i, x);\n}\n// 0: a\n// 1: b\n// 2: c\n```",
    "rust_lesson1_ex7_slide1_content": "# データを並べてまとめる「長い箱」\n\nベクタ（Vec） は、たくさんのデータを順番に並べて入れられる「長い箱」です。\n\nFor example：\n- 買い物listの商品を全部まとめる\n- testの点数を全部まとめる\n- 友だちの名前を全部まとめる\n\n100個でも1000個でも、1つのvariableでまとめて管理できます！\n\n作り方：\n```rust\nlet fruits = vec![\"りんご\", \"バナナ\", \"みかん\"];\n// vec! で ベクタを作る\n```",
    "rust_lesson4_ex8_slide3_title": "Let's Try It!",
    "rust_lesson4_ex7_description": "パターンマッチに条件を追加しましょう。",
    "rust_lesson1_ex4_comment2": "+= で 20 を足す",
    "rust_lesson1_ex2_comment2": "y に 5 を入れる",
    "rust_lesson2_ex3_slide3_title": "Let's Try It!",
    "rust_lesson3_ex4_slide1_title": "map（map）?",
    "rust_lesson1_ex2_slide3_content": "データに名前をつけて保存できる「変数（へんすう）」を使ってみましょう。letで変数を作ります。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex8_slide2_content": "# match で成功と失敗を分ける\n\n`match` で「成功したら」「失敗したら」の処理を書き分けます。\n\ncodeExample：\n```rust\nfn divide(a: i32, b: i32) -> Result<i32, String> {\n    if b == 0 {\n        return Err(\"0で割れません\".to_string());\n    }\n    Ok(a / b)  // 成功なら答えを返す\n}\n\nmatch divide(10, 2) {\n    Ok(v) => println!(\"答えは{}\", v),\n    Err(e) => println!(\"エラー: {}\", e),\n}\n```\n\nPoint：\n- `Ok(値)` で成功をreturn\n- `Err(エラー)` で失敗をreturn",
    "rust_lesson4_ex3_comment1": "Box::new でheapに格納",
    "rust_lesson4_ex8_description": "トレイトをreturnfunctionを簡潔に書きましょう。",
    "rust_lesson2_ex10_description": "typeを後から決められる「ジェネリクス」を学びましょう。",
    "rust_lesson2_ex3_slide1_title": "可変reference（かへんさんしょう）?",
    "rust_lesson2_ex2_description": "所有権を移さずにvalueを借りる「reference」を学びましょう。",
    "rust_lesson3_ex5_slide2_title": "** にNote！",
    "rust_lesson2_ex2_slide3_title": "Let's Try It!",
    "rust_lesson4_ex3_slide3_content": "ヒープにデータを格納するBoxを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex4_title": "累算assignmentoperator（+=、-=）",
    "rust_lesson3_ex3_slide2_content": "# 借りるか、もらうか\n\n3種類の iter があり、所有権の扱いが違います。\n\n3つの違い：\n```rust\nv.iter()       // 参照で借りる（&T）\nv.iter_mut()   // 変更可能で借りる（&mut T）\nv.into_iter()  // 所有権をもらう（T）\n```\n\n使い分け：\n- `iter()` → 見るだけ（元のベクタも使える）\n- `iter_mut()` → 中身を変更したい\n- `into_iter()` → ベクタごともらう（元は使えない）\n\n普通は `iter()` をuseことが多いです。",
    "rust_lesson2_ex1_slide1_title": "所有権（しょゆうけん）?",
    "rust_lesson4_ex6_slide3_content": "一意な値の集合を管理しましょう。\n\n（When you're ready, select \"Start Lesson\".）"
  },
  "da": {
    "rust_lesson1_course_title": "Introduction to Rust",
    "rust_lesson1_course_description": "Learn the basics of Rust programming.",
    "rust_lesson2_course_title": "Rust II - Intermediate",
    "rust_lesson2_course_description": "Learn intermediate Rust concepts.",
    "rust_lesson3_course_title": "Rust III - Advanced",
    "rust_lesson3_course_description": "Master advanced Rust techniques.",
    "rust_lesson4_course_title": "Rust IV - Expert Level",
    "rust_lesson4_course_description": "Expert-level Rust programming.",
    "rust_lesson1_ex5_slide2_content": "条件によって動きを変える if文を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex9_title": "collect で変換",
    "rust_lesson2_ex7_slide1_content": "# 「あるかもしれない、ないかもしれない」\n\nOption<T> は、valueが「あるかもしれないし、ないかもしれない」ことを表すtypeです。\n\nFor example：\n- dictionaryで単語を探す → 見つかるかもしれないし、ないかもしれない\n- ゲームでアイテムを拾う → 落ちてるかもしれないし、ないかもしれない\n\n2つの状態：\n- `Some(値)` → valueがある！\n- `None` → valueがない...\n\n他の言語では `null` をuseが、Rustでは `Option` で安全に扱います。",
    "rust_lesson1_ex2_slide1_title": "variable（へんすう）?",
    "rust_lesson1_ex7_description": "「ベクタ（Vec）」をuseと、たくさんのデータを一つの「長い はこ」にまとめて入れられます。",
    "rust_lesson2_ex9_slide2_content": "# 約束を作って、守る\n\n1. `trait` で「約束」をdefinition\n2. `impl トレイト for 型` で「約束を守る」implementationをdo\n\ncodeExample：\n```rust\n// 1. トレイト（約束）を定義\ntrait Speak {\n    fn speak(&self);  // 鳴くメソッドを持つ約束\n}\n\n// 2. Dog構造体がトレイトを実装\nstruct Dog;\nimpl Speak for Dog {\n    fn speak(&self) {\n        println!(\"woof\");\n    }\n}\n```\n\n「DogはSpeakができる」ということになります。",
    "rust_lesson4_ex4_description": "referenceカウントでデータを共有しましょう。",
    "rust_lesson4_ex5_slide1_content": "# 名前で引ける「dictionary」\n\nHashMap は、「key（名前）」と「value（データ）」をsetで保存dodictionaryです。\n\nFor example：\n- 「青チーム」→ 10点\n- 「赤チーム」→ 15点\n\ncodeExample：\n```rust\nuse std::collections::HashMap;\n\nlet mut scores = HashMap::new();\nscores.insert(\"Blue\", 10);   // 追加\nscores.insert(\"Red\", 15);    // 追加\n```\n\n`use` で機能を読み込んでからuse。",
    "rust_lesson3_ex4_title": "map でiterator変換",
    "rust_lesson4_ex1_slide3_content": "共通の振る舞いを定義するトレイトを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex4_description": "variableのvalueを手軽に増やしたり減らしたりdo「+=」「-=」を学びましょう。",
    "rust_lesson1_ex2_description": "データに名前をつけて保存できる「variable（へんすう）」を使ってみましょう。letでvariableをcreate。",
    "rust_lesson4_ex4_slide2_title": "referenceカウントの仕組み",
    "rust_lesson3_ex8_slide2_title": "unwrap_or_else",
    "rust_lesson4_ex10_comment1": "1番目の i にindex、2番目の item にelementが入る",
    "rust_lesson3_ex6_slide1_content": "# 累積処理\n\nfold は、初期valueとfunctionでelementを1つずつ畳み込みます。\n\n```rust\nlet v = vec![1, 2, 3];\nlet sum = v.iter().fold(0, |acc, x| acc + x);\n// 6\n```",
    "rust_lesson4_ex2_slide2_title": "よくuse derive トレイト",
    "rust_lesson3_ex10_slide3_content": "文字列型の違いを理解しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex4_slide2_content": "変数の値を手軽に増やしたり減らしたりする「+=」「-=」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex4_slide3_title": "Let's Try It!",
    "rust_lesson3_ex5_slide1_title": "filter（filterー）?",
    "rust_lesson4_ex5_description": "keyとvalueのpairを格納しましょう。",
    "rust_lesson3_ex5_description": "条件に合うelementだけを取り出しましょう。",
    "rust_lesson2_ex2_slide2_content": "# functionに借りてもらう\n\nfunctionにデータを渡すとき、`&` をつけると「借りる」形になります。元のvariableはそのまま使い続けられます。\n\ncodeExample：\n```rust\nfn calc_len(s: &String) -> usize {\n    s.len()  // 長さを返す\n}\n\nfn main() {\n    let text = String::from(\"hello\");\n    let len = calc_len(&text);  // textを貸す\n    // text はまだ使える！\n    println!(\"{}の長さは{}\", text, len);\n}\n```\n\n`&String` は「Stringを借りる」という意味です。",
    "rust_lesson4_ex7_slide3_content": "パターンマッチに条件を追加しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex8_slide2_content": "# 遅延評価\n\n```rust\n// クロージャで計算\nlet value = x.unwrap_or_else(|| expensive_computation());\n```",
    "rust_lesson4_ex7_title": "match ガード",
    "rust_lesson3_ex7_title": "? operatorでerror伝播",
    "rust_lesson4_ex1_description": "共通の振る舞いをdefineトレイトを学びましょう。",
    "rust_lesson2_ex1_slide2_content": "# 所有権は「移動」do\n\nvariableを別のvariableにassignmentdoと、所有権が 移動（ムーブ） します。元のvariableは使えなくなります。\n\ncodeExample：\n```rust\nlet s1 = String::from(\"hello\");  // s1 が持ち主\nlet s2 = s1;  // 所有権が s2 に移動！\n// ↓ s1 はもう使えない（エラーになる）\n// println!(\"{}\", s1);  // ダメ！\nprintln!(\"{}\", s2);  // OK！\n```\n\nイメージ：\nおもちゃを友だちにあげたら、自分はもう使えない。これがムーブです。",
    "rust_lesson1_ex8_slide1_title": "dictionary（HashMap）?",
    "rust_lesson4_ex3_slide2_content": "# サイズが決まらないとき\n\nBoxは、コンパイル時にサイズがわからないtypeにuse。\n\nFor examplerecursion的なtype：\n```rust\n// リストは「値 + 次のリスト」の繰り返し\nenum List {\n    Cons(i32, Box<List>),  // Boxで次を指す\n    Nil,                   // 終わり\n}\n```\n\nなぜBoxが必要？\n- `List` の中に `List` がある → 無限に大きくなる？\n- `Box` をuseと、サイズが固定（pointerのサイズ）になる\n\n「中身」ではなく「中身への矢印」を持つイメージです。",
    "rust_lesson2_ex10_title": "ジェネリクスを使おう",
    "rust_lesson2_ex8_slide3_title": "Let's Try It!",
    "rust_lesson3_ex9_slide2_content": "# 可変reference\n\n```rust\n// mut が必要\nlet mut v = Vec::new();\nv.push(1);\nv.push(2);\n```",
    "rust_lesson4_ex4_title": "Rc<T>",
    "rust_lesson2_ex3_comment1": "mut で可変variableにdo",
    "rust_lesson4_ex5_slide3_title": "Let's Try It!",
    "rust_lesson2_ex6_slide2_content": "# バリアントを列挙\n\n`enum 名前 { バリアント1, バリアント2, ... }` でdefine。\n\ncodeExample：\n```rust\nenum Color {\n    Red,\n    Green,\n    Blue,\n}\nlet c = Color::Red;\n```",
    "rust_lesson1_ex1_comment1": "Hello, Rust! とdisplay",
    "rust_lesson1_ex1_slide1_content": "# 安全で速い！最新のプログラミング言語\n\nRust（ラスト）は、「間違いを事前に防ぐ」ことがとても得意なプログラミング言語です。\n\nRustのすごいところ：\n- programのミスをexecute前に見つけてくれる\n- とても速く動く\n- 世界中のプログラマーが「一番好き！」と選ぶ人気の言語\n\nたとえるなら：\n厳しいけど優しい先生のような言語です。「ここ間違ってるよ」と教えてくれるので、安心してprogramが書けます！",
    "rust_lesson3_ex8_slide1_content": "# None/Err の場合のデフォルト\n\nunwrap_or は、None や Err の場合にデフォルトvalueをreturn。\n\n```rust\nlet x: Option<i32> = None;\nlet value = x.unwrap_or(0);  // 0\n```",
    "rust_lesson2_ex7_slide3_title": "Let's Try It!",
    "rust_lesson2_ex6_title": "enum で状態を表す",
    "rust_lesson2_ex8_slide1_content": "# 「成功」か「失敗」かを表す\n\nResult<T, E> は、処理が「成功したか失敗したか」を表すtypeです。\n\nFor example：\n- fileをopen → 成功（内容）か失敗（error）\n- 0で割り算 → 成功（答え）か失敗（0で割れない！）\n\n2つの状態：\n- `Ok(値)` → 成功！valueが入っている\n- `Err(エラー)` → 失敗...error情報が入っている\n\n`Option` は「あるか・ないか」、`Result` は「成功か・失敗か」という違いです。",
    "rust_lesson2_ex8_slide3_content": "成功と失敗を表す「Result」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex6_slide1_title": "HashSet ?",
    "rust_lesson3_ex9_comment1": "push でelementを追加",
    "rust_lesson2_ex7_slide2_title": "Option  Usage",
    "rust_lesson3_ex2_title": "closureのBasic",
    "rust_lesson3_ex7_slide1_title": "? operator?",
    "rust_lesson4_ex6_comment1": "HashSet をimport",
    "rust_lesson2_ex10_slide1_content": "# どんなtypeでも使える「万能」の仕組み\n\nジェネリクス は、typeを後から決められる仕組みです。\n\nなぜ便利？\n同じようなfunctionを何度も書かなくてすみます。\n\nFor example：\n- 数字のarrayの最初のelementを取るfunction\n- stringのarrayの最初のelementを取るfunction\n\n両方とも「最初のelementを取る」のは同じなのに、typeが違うだけで別のfunctionをwriteのは大変！\n\nジェネリクスなら、`<T>` で「typeは後で決める」とwriteだけで、どんなtypeでも使えるfunctionが作れます。",
    "rust_lesson1_ex3_slide1_content": "# 剰余operator（じょうよえんざんし）「%」\n\n`%`（パーセント）は、割り算の 「あまり」 をcalculate特別な記号です。\n\nわかりやすいExample：\n- 10このアメを3人で分けると？\n- 1人3こずつで、1こあまる\n- これを `10 % 3` とwriteと、答えは `1`\n\ncodeExample：\n```rust\nprintln!(\"{}\", 10 % 3);  // 1（あまり1）\nprintln!(\"{}\", 8 % 4);   // 0（あまりなし＝割り切れる）\n```\n\n使いどころ：\n- 偶数か奇数か調べる（`n % 2` が0なら偶数）\n- 時計の計算（24を超えたら0に戻る、など）",
    "rust_lesson3_ex7_description": "errorを簡潔に伝播させましょう。",
    "rust_lesson3_ex8_comment1": "unwrap_or でデフォルトvalueを設定",
    "rust_lesson2_ex8_title": "Result<T, E> でerror処理",
    "rust_lesson2_ex10_comment1": "T をtypeパラメータとしてuse",
    "rust_lesson2_ex6_comment1": "enum で列挙typeをdefinition",
    "rust_lesson3_ex3_slide3_content": "要素を順番に処理するイテレータを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex2_comment1": "derive でトレイトを自動implementation",
    "rust_lesson1_ex8_slide1_content": "# 名前でsearchできる「dictionary」\n\nHashMap（ハッシュmap）は、「名前」と「データ」をsetにして保存できる仕組みです。本物のdictionaryのように使えます。\n\nFor example果物の色dictionary：\n- 「りんご」→「あか」\n- 「バナナ」→「きいろ」\n- 「みかん」→「オレンジ」\n\nuse準備：\n```rust\nuse std::collections::HashMap;  // 機能を読み込む\nlet mut fruits = HashMap::new();  // 空の辞書を作る\nfruits.insert(\"りんご\", \"あか\");  // データを追加\n```\n\n`use` は「この機能をuseよ」というdeclarationです。",
    "rust_lesson3_ex9_slide1_title": "push ?",
    "rust_lesson4_ex1_title": "トレイトのdefinition",
    "rust_lesson4_ex3_description": "heapにデータを格納doBoxを学びましょう。",
    "rust_lesson1_ex2_title": "便利な「はこ」variable（へんすう）",
    "rust_lesson1_ex8_comment2": "中身を出す",
    "rust_lesson3_ex9_slide3_title": "Let's Try It!",
    "rust_lesson1_ex4_comment3": "-= で 50 を引く",
    "rust_lesson1_ex6_comment1": "&& で両方の条件をチェック",
    "rust_lesson4_ex1_slide2_title": "トレイトのimplementation",
    "rust_lesson4_ex7_slide3_title": "Let's Try It!",
    "rust_lesson4_title": "Rust IV - トレイトとスマートpointer",
    "rust_lesson4_ex1_comment1": "trait でトレイトをdefinition",
    "rust_lesson4_ex4_slide1_content": "# 複数の「持ち主」を許可do仕組み\n\nRc<T> は「Reference Counted（referenceカウント）」の略で、複数の所有者でデータを共有できます。\n\n普通の所有権：\n1人だけが持ち主。渡したら元の人は使えない。\n\nRc をuseと：\n複数人が同じデータの「持ち主」になれる！\n\ncodeExample：\n```rust\nuse std::rc::Rc;\n\nlet a = Rc::new(5);       // Rcでラップ\nlet b = Rc::clone(&a);    // bも持ち主になる\n// a も b も使える！\n```",
    "rust_lesson3_ex5_slide1_content": "# 条件に合うものだけ残す\n\nfilter は、条件を満たすelementだけを残し、他を捨てます。\n\nFor example：\n- 80点以上の人だけ残す\n- 偶数だけ残す\n- 「あ」から始まる名前だけ残す\n\ncodeExample：\n```rust\nlet v = vec![1, 2, 3, 4, 5];\nlet evens: Vec<_> = v.iter()\n    .filter(|x| **x % 2 == 0)  // 偶数だけ\n    .collect();\n// [2, 4]\n```\n\n条件が `true` のelementだけが残ります。",
    "rust_lesson3_ex7_slide3_title": "Let's Try It!",
    "rust_lesson1_ex7_comment2": "2番目のデータ（1番）を出す",
    "rust_lesson4_ex8_title": "impl Trait",
    "rust_lesson1_ex5_description": "条件によって動きを変える if文を学びましょう。",
    "rust_lesson3_ex4_slide2_title": "遅延評価（ちえんひょうか）",
    "rust_lesson3_ex1_slide1_content": "# referenceの「寿命」を示す印\n\nライフタイム は、referenceがいつまで使えるかを示す印です。`'a`（アポストロフィ・エー）のようにwrite。\n\nなぜ必要？\nreferenceは「借りている」状態。借りた元のデータが消えたら、referenceも使えなくなります。\n\nFor example：\n- 図書館で借りた本 → 図書館が閉まったら読めない\n- referenceで借りたデータ → 元のデータが消えたら使えない\n\nライフタイムは「このreferenceはこの範囲で有効だよ」とコンパイラに伝える仕組みです。",
    "rust_lesson1_ex1_slide1_title": "Rust（ラスト）?",
    "rust_lesson1_ex2_slide2_title": "計算の記号（operator）",
    "rust_lesson4_ex5_slide2_content": "# get で安全に取り出す\n\n`get()` methodでvalueを取り出せます。見つからない可能性があるので、`Option` が返ってきます。\n\ncodeExample：\n```rust\n// getはOption<&V>を返す\nif let Some(score) = scores.get(\"Blue\") {\n    println!(\"青チームは{}点\", score);\n}\n```\n\nPoint：\n- keyがあれば `Some(値)` が返る\n- keyがなければ `None` が返る\n- `if let` で安全に取り出せる\n\n存在しないkeyでアクセスしてもprogramが落ちない！",
    "rust_lesson4_ex7_slide1_title": "match ガード?",
    "rust_lesson3_title": "Rust III - ライフタイムとiterator",
    "rust_lesson4_ex3_title": "Box<T>",
    "rust_lesson1_ex4_slide1_title": "累算assignmentoperator（るいさんだいにゅう）?",
    "rust_lesson2_ex9_comment1": "trait でトレイトをdefinition",
    "rust_lesson2_ex1_description": "Rust独自の概念「所有権」を学びましょう。",
    "rust_lesson2_ex3_slide3_content": "参照先の値を変更できる「可変参照」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex1_slide3_title": "Let's Try It!",
    "rust_lesson3_ex6_slide2_title": "様々な畳み込み",
    "rust_lesson4_ex9_slide3_title": "Let's Try It!",
    "rust_lesson2_ex5_title": "impl でmethodを追加",
    "rust_lesson2_ex6_slide1_content": "# 複数の選択肢\n\nenum は、valueがいくつかの種類のうちの一つであることを表します。各バリアントにデータを持たせることもできます。",
    "rust_lesson2_ex4_comment1": "struct で構造体をdefinition",
    "rust_lesson1_ex3_title": "剰余operator（%）",
    "rust_lesson1_ex7_comment1": "colors というベクタをcreate（'あか', 'あお'の順）",
    "rust_lesson1_ex4_slide1_content": "# valueをかんたんに増やす・減らす\n\n`+=`（プラスイコール）と `-=`（マイナスイコール）は、variableの中身を増やしたり減らしたりdo便利な記号です。\n\nRustのImportantなルール：`mut`が必要！\nRustでは、variableをchangeには `let mut`（レット ミュート）とwrite必要があります。`mut` は「mutable（変更できる）」の略です。\n\ncodeExample：\n```rust\nlet mut score = 100;  // mut をつけて変更可能に\nscore += 10;          // 10を足す → 110に\nscore -= 50;          // 50を引く → 60に\n```\n\n`mut` がないと「このvariableは変えちゃダメ！」とRustが怒ります。",
    "rust_lesson2_ex1_slide2_title": "ムーブ（移動）",
    "rust_lesson3_ex4_comment1": "map で各elementを変換",
    "rust_lesson3_ex8_slide1_title": "unwrap_or ?",
    "rust_lesson2_ex5_slide1_content": "# implementationブロック\n\nimpl ブロックで、構造体にmethodを追加できます。`self` で自分自身をreferenceします。",
    "rust_lesson2_ex10_slide1_title": "ジェネリクス?",
    "rust_lesson1_ex8_slide2_content": "# 名前（key）で取り出す\n\ndictionaryに入れたデータは、名前（key）を指定して取り出せます。\n\ncodeExample：\n```rust\nuse std::collections::HashMap;\nfn main() {\n    let mut fruits = HashMap::new();\n    fruits.insert(\"りんご\", \"あか\");  // 追加\n    fruits.insert(\"バナナ\", \"きいろ\");  // 追加\n    \n    println!(\"{}\", fruits[\"りんご\"]);  // あか と表示\n}\n```\n\nPoint：\n- `insert(名前, データ)` で追加\n- `辞書[名前]` で取り出し\n- 番号ではなく「名前」で探せるのが便利！",
    "rust_lesson4_ex9_slide1_content": "# iteratorをコレクションに\n\ncollect は、iteratorをVecやHashMapなどに変換します。\n\n```rust\nlet v: Vec<_> = (0..5).collect();\nlet s: String = vec!['a', 'b'].into_iter().collect();\n```",
    "rust_lesson2_ex2_slide3_content": "所有権を移さずに値を借りる「参照」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex2_slide3_content": "周囲の変数を使える無名関数「クロージャ」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex4_slide2_content": "# struct keyワードでdefinition\n\n`struct 名前 { フィールド }` で構造体をdefine。フィールドには名前とtypeをwrite。\n\ncodeExample：\n```rust\n// Point 構造体を定義\nstruct Point {\n    x: i32,  // xフィールド（整数）\n    y: i32,  // yフィールド（整数）\n}\n\n// 使い方\nlet p = Point { x: 10, y: 20 };\nprintln!(\"x={}, y={}\", p.x, p.y);\n```\n\nPoint：\n- `struct 名前` で構造体をcreate\n- `{ フィールド名: 型 }` でどんなデータを持つか決める\n- `.フィールド名` でアクセス",
    "rust_lesson2_ex10_slide3_content": "型を後から決められる「ジェネリクス」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex6_slide3_title": "Let's Try It!",
    "rust_lesson4_ex6_slide1_content": "# 一意なvalueのset\n\nHashSet は、重複のないvalueのsetです。\n\n```rust\nuse std::collections::HashSet;\n\nlet mut set = HashSet::new();\nset.insert(1);\nset.insert(2);\nset.insert(1); // 重複は無視\n```",
    "rust_lesson4_ex2_title": "derive 属性",
    "rust_lesson4_ex2_slide1_content": "# トレイトを「自動で」implementation\n\n#[derive(...)] をuseと、よくuseトレイトを自分で書かなくても自動でimplementationしてくれます。\n\nFor example：\n構造体を `println!` でdisplayしたいとき、普通は Display トレイトをimplementationdo必要がありますが、`#[derive(Debug)]` をwriteだけでOK！\n\ncodeExample：\n```rust\n#[derive(Debug)]  // Debug トレイトを自動実装\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nlet p = Point { x: 1, y: 2 };\nprintln!(\"{:?}\", p);  // Point { x: 1, y: 2 }\n```",
    "rust_lesson1_ex6_slide2_title": "Let's Try It!",
    "rust_lesson3_ex3_slide2_title": "3つの iter method",
    "rust_lesson4_ex7_slide2_content": "# 複雑なconditional\n\n```rust\nmatch Some(5) {\n    Some(x) if x % 2 == 0 => println!(\"even\"),\n    Some(x) => println!(\"odd: {}\", x),\n    None => println!(\"none\"),\n}\n```",
    "rust_lesson3_ex3_slide1_content": "# elementを1つずつ取り出す仕組み\n\niterator は、ベクタなどのデータを「1つずつ順番に」取り出す仕組みです。\n\nFor example：\n- 行列に並んでいる人を1人ずつ呼ぶ\n- 引き出しの中身を1つずつ出す\n\ncodeExample：\n```rust\nlet v = vec![1, 2, 3];\nfor x in v.iter() {\n    println!(\"{}\", x);  // 1, 2, 3 と順番に表示\n}\n```\n\n`iter()` で「順番に取り出す準備」をして、`for` で1つずつ処理します。",
    "rust_lesson3_ex3_slide1_title": "iterator?",
    "rust_lesson4_ex2_description": "トレイトを自動implementationdoderiveを学びましょう。",
    "rust_lesson3_ex4_slide1_content": "# 全部を同じように変換do\n\n**map** は、iteratorの各elementを「同じ方法で」変換します。\n\nFor example：\n- 全員の身長を2倍にdo\n- 全員の名前を大文字にdo\n- 全部の数を2乗do\n\ncodeExample：\n```rust\nlet v = vec![1, 2, 3];\nlet doubled: Vec<_> = v.iter()\n    .map(|x| x * 2)  // 各要素を2倍に\n    .collect();      // ベクタに戻す\n// [2, 4, 6]\n```\n\n`|x| x * 2` は「xを受け取って、x*2をreturn」closureです。",
    "rust_lesson1_ex3_slide1_title": "あまりを求める",
    "rust_lesson3_ex10_slide1_content": "# 所有権の違い\n\nString は所有権を持つheap上のstring、&str はreferenceです。\n\n```rust\nlet s1: String = String::from(\"hello\");\nlet s2: &str = \"hello\";\n```",
    "rust_lesson4_ex2_slide1_title": "derive（デライブ）?",
    "rust_lesson2_ex2_comment1": "& でreferenceを渡す",
    "rust_lesson4_ex5_slide1_title": "HashMap（ハッシュmap）?",
    "rust_lesson2_ex3_slide2_title": "&mut  Usage",
    "rust_lesson3_ex5_title": "filter で絞り込み",
    "rust_lesson4_ex3_slide2_title": "いつuse？",
    "rust_lesson2_ex2_title": "referenceと借用",
    "rust_lesson2_ex7_title": "Option<T> で null を安全に",
    "rust_lesson4_ex10_slide3_title": "Let's Try It!",
    "rust_lesson3_ex5_slide3_title": "Let's Try It!",
    "rust_lesson4_ex10_title": "enumerate でindex付き",
    "rust_lesson2_ex2_slide1_content": "# 所有権を渡さずに「借りる」\n\nreference をuseと、所有権を移さずにデータを「見せてもらう」ことができます。\n\nたとえるなら：\n- ムーブ = おもちゃをあげる（自分は使えない）\n- reference = おもちゃを見せる（自分も使える）\n\n作り方：\n`&`（アンパサンド）をつけるとreferenceを作れます。\n\n```rust\nlet s = String::from(\"hello\");\nlet r = &s;  // sを借りる（見せてもらう）\n// s も r も使える！\n```",
    "rust_lesson2_ex5_slide2_content": "# &self をuse\n\nmethodの最初のargumentは `&self` です。\n\ncodeExample：\n```rust\nimpl Rect {\n    fn area(&self) -> i32 {\n        self.width * self.height\n    }\n}\n```",
    "rust_lesson1_ex5_slide2_title": "Let's Try It!",
    "rust_lesson2_ex4_slide3_title": "Let's Try It!",
    "rust_lesson4_ex3_slide3_title": "Let's Try It!",
    "rust_lesson2_ex9_slide3_content": "共通の振る舞いを定義する「トレイト」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex1_slide2_content": "# impl で約束を守る\n\n構造体にトレイトをimplementationdoと、その構造体は「約束を守る」ことになります。\n\ncodeExample：\n```rust\nstruct Person { name: String }\n\nimpl Greet for Person {\n    fn greet(&self) -> String {\n        format!(\"Hello, {}\", self.name)\n    }\n}\n```\n\n読み方：\n- `impl Greet for Person` → 「PersonはGreetをimplementationdo」\n- これでPersonは「あいさつできる」ようになった！",
    "rust_lesson4_ex4_comment1": "clone でreferenceカウントを増やす",
    "rust_lesson3_ex4_slide2_content": "# map だけではexecuteされない！\n\nRustのiteratorは 遅延評価 といって、「本当に必要になるまで処理しない」仕組みです。\n\nなぜ？\n無駄な計算を省けるから。100万件あっても、最初の10件だけ欲しいなら10件だけ処理すればいい。\n\ncollect() でexecute：\n```rust\n// これだけでは何も起きない\nv.iter().map(|x| x * 2);\n\n// collect() で実行してベクタに変換\nlet result: Vec<_> = v.iter().map(|x| x * 2).collect();\n```\n\n`collect()` は「今すぐ全部処理してResultをちょうだい」という意味です。",
    "rust_lesson2_ex4_slide2_title": "struct のdefinitionのしかた",
    "rust_lesson2_ex3_slide1_content": "# 「書き換えできる」借り方\n\n普通のreference `&` は「見るだけ」ですが、可変reference `&mut` は「変更もできる」借り方です。\n\nたとえるなら：\n- `&` = 本を見せてもらう（readだけ）\n- `&mut` = ノートを借りる（writeOK）\n\nImportantなルール：\n- 可変referenceは同時に1つだけ！\n- 「みんなで見る」か「1人でwrite」かのどちらか\n\nこのルールで、データが同時に書き換えられるバグを防いでいます。",
    "rust_lesson2_ex10_slide3_title": "Let's Try It!",
    "rust_lesson2_ex4_title": "構造体をdefinitionしよう",
    "rust_lesson3_ex10_slide2_content": "# 相互変換\n\n```rust\n// &str -> String\nlet s = \"hello\".to_string();\n\n// String -> &str\nlet slice: &str = &s;\n```",
    "rust_lesson4_ex10_slide3_content": "イテレータにインデックスを付けましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex4_slide2_content": "# 「何人が持っているか」を数える\n\nRcは「今何人がこのデータを持っているか」を数えています。\n\ncodeExample：\n```rust\nlet a = Rc::new(5);\nprintln!(\"{}\", Rc::strong_count(&a));  // 1\n\nlet b = Rc::clone(&a);\nprintln!(\"{}\", Rc::strong_count(&a));  // 2\n```\n\nいつデータが消える？\n- カウントが0になったとき（誰も持っていないとき）\n- 最後の持ち主がいなくなると自動で片付けられる\n\n`Rc::clone` は「持ち主を1人増やす」操作です。",
    "rust_lesson1_ex8_slide2_title": "dictionary Usage",
    "rust_lesson4_ex3_slide1_content": "# データを「heap」に置く箱\n\nBox<T> は、データを「heap」という特別な場所に置くための箱です。\n\nmemoryの2つの場所：\n- stack：小さくて速い。サイズが決まっているデータ向け\n- heap：大きくて柔軟。サイズが大きいor変わるデータ向け\n\ncodeExample：\n```rust\nlet b = Box::new(5);  // 5をヒープに置く\nprintln!(\"{}\", *b);   // *で中身を取り出す → 5\n```\n\n`*` は「箱を開けて中身を見る」操作です。",
    "rust_lesson3_ex2_slide2_title": "closure Syntax",
    "rust_lesson4_ex4_slide1_title": "Rc（アールシー）?",
    "rust_lesson4_ex7_slide1_content": "# 追加条件\n\n**if** でパターンに追加条件をつけられます。\n\n```rust\nmatch x {\n    n if n < 0 => println!(\"negative\"),\n    n if n > 0 => println!(\"positive\"),\n    _ => println!(\"zero\"),\n}\n```",
    "rust_lesson2_ex3_title": "可変reference",
    "rust_lesson3_ex10_comment1": "to_string で String に変換",
    "rust_lesson3_ex10_slide2_title": "変換",
    "rust_lesson3_ex1_description": "referenceの有効期間を表すライフタイムを学びましょう。",
    "rust_lesson3_ex2_slide1_content": "# 名前のない「即席」function\n\nclosure は、名前をつけずにその場でcreatefunctionです。そして特別な能力があります：周りのvariableを使えるのです！\n\nFor example：\n```rust\nlet x = 5;  // 外側の変数\nlet add_x = |n| n + x;  // xを使えるクロージャ\nprintln!(\"{}\", add_x(10));  // 15\n```\n\n普通のfunctionとの違い：\n- 普通のfunction：argumentしか使えない\n- closure：argument + 周りのvariableも使える\n\n「その場の空気を読める」functionというイメージです！",
    "rust_lesson1_ex2_comment1": "x に 10 を入れる",
    "rust_lesson1_ex7_slide3_title": "Let's Try It!",
    "rust_lesson1_ex5_title": "「もし〜なら」で分けましょう",
    "rust_lesson3_ex2_slide3_title": "Let's Try It!",
    "rust_lesson3_ex7_slide2_content": "# 簡潔なerror処理\n\n```rust\n// ? を使わない場合\nmatch result {\n    Ok(v) => v,\n    Err(e) => return Err(e),\n}\n\n// ? を使う\nresult?\n```",
    "rust_lesson3_ex6_slide3_title": "Let's Try It!",
    "rust_lesson4_ex9_slide3_content": "イテレータをコレクションに変換しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex6_description": "elementを1つのvalueにまとめるfoldを学びましょう。",
    "rust_lesson2_ex9_description": "共通の振る舞いをdefine「トレイト」を学びましょう。",
    "rust_lesson2_ex8_comment1": "Ok で成功をreturn",
    "rust_lesson3_ex5_slide2_content": "# filter はreferenceのreferenceを受け取る\n\n`filter` のclosureは、referenceのreference（`&&T`）を受け取ります。そのため、valueをuseには `**x` と2回referenceを外す必要があります。\n\nなぜ？\n- `iter()` はreference（`&T`）をreturn\n- `filter` はそれをFurthermorereferenceで渡す（`&&T`）\n\nSyntax：\n```rust\n// **x で値を取り出す\n.filter(|x| **x > 2)\n\n// または * を引数につける\n.filter(|&x| *x > 2)\n```\n\n最初は混乱しますが、慣れれば大丈夫！",
    "rust_lesson1_ex5_comment1": "> でcompare",
    "rust_lesson2_ex4_description": "関連doデータをまとめる「構造体」を学びましょう。",
    "rust_lesson3_ex5_slide3_content": "条件に合う要素だけを取り出しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex7_slide3_content": "「ベクタ（Vec）」を使うと、たくさんのデータを一つの「長い はこ」にまとめて入れられます。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex5_slide2_title": "valueの取得",
    "rust_lesson3_ex1_slide1_title": "ライフタイム?",
    "rust_lesson1_ex3_comment1": "10 を 3 で割ったあまりをoutput",
    "rust_lesson3_ex1_comment1": "'a でライフタイムをdefinition",
    "rust_lesson3_ex10_slide1_title": "String vs &str",
    "rust_lesson2_title": "Rust II - 所有権とトレイト",
    "rust_lesson2_ex5_slide2_title": "methodのdefinition",
    "rust_lesson4_ex5_comment1": "insert でkeyとvalueを追加",
    "rust_lesson2_ex9_slide1_content": "# 「できること」の約束\n\nトレイト は、「このtypeはこういうことができる」という約束をdefine。\n\nFor example「鳴ける」という約束：\n- 犬は「ワン」と鳴く\n- 猫は「ニャー」と鳴く\n- 両方とも「鳴ける」能力がある\n\nトレイトは「鳴ける動物は、鳴き声を出すmethodを持つ」という約束です。\n\n他の言語とのcomparison：\n- Java: interface\n- TypeScript: interface\n\nに似た概念です。",
    "rust_lesson1_ex2_slide3_title": "Let's Try It!",
    "rust_lesson4_ex8_slide1_content": "# return valueのtypeをabstract化\n\nimpl Trait で、トレイトをimplementationdotypeを返せます。\n\n```rust\nfn make_iter() -> impl Iterator<Item = i32> {\n    vec![1, 2, 3].into_iter()\n}\n```",
    "rust_lesson1_ex2_slide2_content": "# 四則演算（しそくえんざん）\n\nRustでも算数と同じ記号で計算ができます。\n\n4つのBasic記号：\n- +（プラス）: たし算\n- -（マイナス）: ひき算\n- \\*（アスタリスク）: かけ算（×の代わり）\n- /（スラッシュ）: わり算（÷の代わり）\n\ncodeExample：\n```rust\nlet a = 10;\nlet b = 5;\nprintln!(\"{}\", a + b);  // 15 と表示される\n```\n\n`println!` の `{}` は「ここにvalueを入れてね」という目印です。",
    "rust_lesson4_ex9_slide2_content": "# 変換先を指定\n\n```rust\n// ターボフィッシュ構文\nlet v = (0..5).collect::<Vec<_>>();\n\n// 変数の型注釈\nlet v: Vec<i32> = (0..5).collect();\n```",
    "rust_lesson1_ex8_description": "「dictionary（HashMap）」をuseと、名前をつけてデータを保存し、その名前で取り出せます。",
    "rust_lesson4_ex9_slide2_title": "typeHint",
    "rust_lesson3_ex1_title": "ライフタイムのBasic",
    "rust_lesson2_ex5_description": "構造体にmethodをadd「impl」を学びましょう。",
    "rust_lesson4_ex8_comment1": "impl でトレイトをimplementationdotypeをreturn",
    "rust_lesson4_ex8_slide2_title": "argumentにも使える",
    "rust_lesson4_ex7_comment1": "if でマッチガードを追加",
    "rust_lesson2_ex9_slide2_title": "trait のdefinitionとimplementation",
    "rust_lesson4_ex10_slide2_title": "いつuse？",
    "rust_lesson3_ex7_slide2_title": "match の省略形",
    "rust_lesson1_ex6_title": "logicaloperator（&&、||）",
    "rust_lesson3_ex6_comment1": "fold で畳み込み",
    "rust_lesson2_ex6_description": "複数の状態を表す「列挙type（enum）」を学びましょう。",
    "rust_lesson4_ex10_slide1_title": "enumerate（イニュメレート）?",
    "rust_lesson1_ex7_slide1_title": "ベクタ（Vec）?",
    "rust_lesson2_ex6_slide3_content": "複数の状態を表す「列挙型（enum）」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex3_slide3_title": "Let's Try It!",
    "rust_lesson3_ex4_description": "各elementを変換domapを学びましょう。",
    "rust_lesson4_ex1_slide3_title": "Let's Try It!",
    "rust_lesson3_ex9_slide2_title": "mut が必要",
    "rust_lesson1_ex6_slide1_content": "# logicaloperator（ろんりえんざんし）\n\n2つ以上の条件を組み合わせたいときにuse記号です。\n\n2つの記号：\n- `&&`（アンドアンド）：「かつ」＝ 両方とも 正しいとき\n- `||`（オアオア）：「Alsoは」＝ どちらか 正しいとき\n\n身近なExample：\n- 遊園地：「18歳以上 かつ チケットあり」なら乗れる\n- おやつ：「宿題終わった Alsoは お手伝いした」ならOK\n\ncodeExample：\n```rust\nif score >= 70 && bonus > 0 {\n    // 70点以上 かつ ボーナスあり → 合格！\n    println!(\"合格！\");\n}\n```",
    "rust_lesson4_ex4_slide3_content": "参照カウントでデータを共有しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex6_slide3_title": "Let's Try It!",
    "rust_lesson2_ex5_slide3_content": "構造体にメソッドを追加する「impl」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex1_slide3_title": "Let's Try It!",
    "rust_lesson1_ex5_slide1_content": "# programに「判断」させよう\n\nconditional は、「もし〜なら、〇〇do」という判断をprogramにさせる仕組みです。\n\n身近なExample：\n- もし80点以上なら → 「合格！」とdisplay\n- もし雨なら → 傘を持っていく\n- もしHPが0なら → ゲームオーバー\n\nRustで Syntax：\n```rust\nif score > 80 {\n    println!(\"合格！\");\n}\n```\n\n読み方：\n- `if` →「もし」\n- `score > 80` →「スコアが80より大きいなら」\n- `{ }` の中 →「これをやる」",
    "rust_lesson4_ex5_title": "HashMap",
    "rust_lesson1_ex2_slide1_content": "# データを保存do「はこ」\n\nvariable（へんすう） は、数字や文字を入れておける「はこ」のことです。名前をつけて、あとでuseことができます。\n\nFor example：\n- 「りんごの数」というラベルの箱に「5」を入れる\n- あとで「りんごの数」と呼べば「5」が出てくる\n\nRustで Syntax：\n```rust\nlet x = 10;  // xという箱に10を入れる\nprintln!(\"{}\", x);  // xの中身（10）を表示\n```\n\n`let` は「この名前で箱をcreateよ」という意味です。",
    "rust_lesson2_ex4_slide3_content": "関連するデータをまとめる「構造体」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex6_slide1_title": "enum ?",
    "rust_lesson2_ex9_title": "トレイトをdefinitionしよう",
    "rust_lesson2_ex4_slide1_title": "構造体（こうぞうたい）?",
    "rust_lesson4_ex2_slide2_content": "# 覚えておくと便利な5つ\n\nよくusederiveトレイト：\n```rust\nDebug     // {:?} でデバッグ表示できる\nClone     // .clone() でコピーを作れる\nCopy      // 代入時に自動でコピー（小さい型向け）\nPartialEq // == で比較できる\nDefault   // 初期値を自動で作れる\n```\n\n複数指定もOK：\n```rust\n#[derive(Debug, Clone, PartialEq)]\nstruct User {\n    name: String,\n    age: u32,\n}\n```\n\n`Debug` は特によくuse。debug時に構造体の中身を見れて便利！",
    "rust_lesson2_ex1_slide1_content": "# データの「持ち主」を決めるルール\n\n所有権 は、Rust最大のFeatureです。「このデータの持ち主は誰か」をはっきりさせる仕組みです。\n\nルール：\n- データには必ず1人だけ「持ち主」がいる\n- 持ち主がいなくなると、データは自dynamicに片付けられる\n\nたとえるなら：\n- おもちゃは1人しか持てない\n- 持ち主が部屋を出たら、おもちゃは片付けられる\n\nこのルールのおかげで、Rustは「memoryリーク」（データが片付けられないバグ）を防げます！",
    "rust_lesson1_ex3_slide2_title": "Let's Try It!",
    "rust_lesson3_ex1_slide2_title": "なぜ必要？",
    "rust_lesson3_ex1_slide2_content": "# 危険なバグを防ぐ\n\nダングリングreference という危険なバグがあります。これは「もう存在しないデータ」を指し続けているreferenceのことです。\n\nExample：\n```rust\nfn longest<'a>(x: &'a str, y: &'a str) -> &'a str {\n    if x.len() > y.len() { x } else { y }\n}\n```\n\n`'a` の意味：\n- argument `x` と `y` は同じライフタイム `'a` を持つ\n- return valueも同じライフタイム `'a` を持つ\n- In other words「xとyが両方有効な間、return valueも有効」という約束\n\nRustはこれを自動でチェックしてくれます！",
    "rust_lesson4_ex6_slide2_title": "set演算",
    "rust_lesson3_ex7_comment1": "? でerrorを伝播",
    "rust_lesson3_ex2_slide2_content": "# | | でargumentを囲む\n\nclosureは `|引数| 処理` という形でwrite。`||` は「パイプ」と呼ばれます。\n\nいろいろなSyntax：\n```rust\n// 引数なし\n|| println!(\"Hello\")\n\n// 引数あり\n|x, y| x + y\n\n// 複数行のブロック\n|x| {\n    let y = x * 2;\n    y + 1\n}\n```\n\nPoint：\n- argumentを `| |` で囲む（functionの `()` の代わり）\n- typeは省略できることが多い（Rustが推測してくれる）",
    "rust_lesson2_ex7_comment1": "Some でvalueがあることを示す",
    "rust_lesson3_ex4_slide3_content": "各要素を変換するmapを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_title": "Rust (ラスト) に挑戦！",
    "rust_lesson2_ex8_description": "成功と失敗を表す「Result」を学びましょう。",
    "rust_lesson3_ex8_description": "Option/Resultのデフォルトvalueを設定しましょう。",
    "rust_lesson4_ex2_slide3_title": "Let's Try It!",
    "rust_lesson2_ex5_slide3_title": "Let's Try It!",
    "rust_lesson4_ex9_description": "iteratorをコレクションに変換しましょう。",
    "rust_lesson1_ex1_slide2_content": "# println! でscreenにdisplay\n\nRustで文字をscreenにdisplayには、`println!`（プリントラインびっくり）をuse。\n\nPoint：\n- `!` がつくのがRustのFeature（マクロと呼ばれます）\n- programは `fn main() { }` の中にwrite\n- `fn` は「function（function）」の略\n\ncodeExample：\n```rust\nfn main() {\n    println!(\"ヤッホー！\");\n}\n// 「ヤッホー！」と画面に表示される\n```\n\n`println!` の `!` は「マクロ」という特別な機能の印です。今は「おまじない」と思っておけばOK！",
    "rust_lesson3_ex6_slide1_title": "fold ?",
    "rust_lesson4_ex8_slide1_title": "impl Trait ?",
    "rust_lesson1_ex1_slide2_title": "Rustの「おまじない」",
    "rust_lesson3_ex10_description": "stringtypeの違いを理解しましょう。",
    "rust_lesson3_ex7_slide3_content": "エラーを簡潔に伝播させましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex1_comment1": "s1 の所有権を移動",
    "rust_lesson2_ex9_slide1_title": "トレイト?",
    "rust_lesson4_ex6_slide2_content": "# 和set、積setなど\n\n```rust\nset1.union(&set2)\nset1.intersection(&set2)\nset1.difference(&set2)\n```",
    "rust_lesson4_ex5_slide3_content": "キーと値のペアを格納しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex8_slide1_title": "Result（リザルト）?",
    "rust_lesson4_ex1_slide1_content": "# 「できること」の約束\n\nトレイト は、typeが持つべきmethodをdefine仕組みです。\n\nFor example：\n- 「あいさつできる」トレイト → greet() methodを持つ\n- 「displayできる」トレイト → display() methodを持つ\n\ncodeExample：\n```rust\ntrait Greet {\n    fn greet(&self) -> String;  // メソッドの「約束」\n}\n```\n\nこれは「Greetできるtypeは、greet()methodを持つ」という約束です。",
    "rust_lesson4_ex2_slide3_content": "トレイトを自動実装するderiveを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex6_title": "fold で畳み込み",
    "rust_lesson3_ex9_slide3_content": "Vecに要素を追加しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex4_slide1_content": "# 関係あるデータをまとめる「設計図」\n\n構造体（struct） は、いくつかのデータをひとまとめにdo仕組みです。\n\nFor example「点（座標）」のデータ：\n- x座標\n- y座標\n\nこの2つは関係があるので、「Point（点）」としてまとめると便利です。\n\nFor example「人」のデータ：\n- 名前\n- 年齢\n\nこれも「Person（人）」としてまとめられます。\n\n構造体は「こういうデータを持つ」という設計図です。",
    "rust_lesson4_ex1_slide1_title": "トレイト?（復習）",
    "rust_lesson2_ex3_description": "reference先のvalueを変更できる「可変reference」を学びましょう。",
    "rust_lesson2_ex7_slide2_content": "# match で安全に取り出す\n\n`match` を使って「ある場合」と「ない場合」で処理を分けます。\n\ncodeExample：\n```rust\nlet x: Option<i32> = Some(5);  // 値あり\n\nmatch x {\n    Some(n) => println!(\"値は{}です\", n),  // 5\n    None => println!(\"値がありません\"),\n}\n```\n\nなぜ安全？\n- `null` のように「あるつもりでアクセスしたら無かった」errorが起きない\n- 「ない場合」の処理を書かないとコンパイルerrorになる\n- 強制的に両方のケースを考えることになる！",
    "rust_lesson4_ex9_comment1": "collect で Vec に変換",
    "rust_lesson3_ex10_title": "String と &str",
    "rust_lesson2_ex7_slide1_title": "Option（オプション）?",
    "rust_lesson3_ex9_description": "Vecにelementを追加しましょう。",
    "rust_lesson2_ex5_comment1": "impl でmethodをimplementation",
    "rust_lesson3_ex1_slide3_content": "参照の有効期間を表すライフタイムを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex6_slide2_content": "複数の条件を組み合わせる「&&（かつ）」と「||（または）」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex5_comment1": "filter で条件に合うelementを絞り込む",
    "rust_lesson2_ex7_slide3_content": "値があるかないかを表す「Option」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex10_slide3_title": "Let's Try It!",
    "rust_lesson4_ex4_slide3_title": "Let's Try It!",
    "rust_lesson3_ex3_comment1": "iter でiteratorを取得",
    "rust_lesson3_ex6_slide3_content": "要素を1つの値にまとめるfoldを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex7_slide2_title": "ベクタの番号は「0」から！",
    "rust_lesson1_ex5_slide1_title": "conditional（じょうけんぶんき）?",
    "rust_lesson1_ex3_description": "割り算の「あまり」を求める「%」（パーセント）operatorを学びましょう。",
    "rust_lesson1_ex1_slide3_content": "Rustを使って画面に文字を表示してみましょう。println! という特別な関数を使います。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex10_slide2_content": "# <T> でtypeを「あとで決める」\n\nfunction名の後に `<T>` をつけて、`T` を「type」としてuse。\n\ncodeExample：\n```rust\n// Tはどんな型でもOK\nfn first<T>(arr: &[T]) -> &T {\n    &arr[0]  // 最初の要素を返す\n}\n\n// 使い方\nfirst(&[1, 2, 3]);         // Tはi32\nfirst(&[\"a\", \"b\", \"c\"]);   // Tは&str\n```\n\n読み方：\n- `<T>` → 「Tという名前のtypeをuseよ」\n- `T` は慣習で「Type（type）」の頭文字\n- 複数のtypeが必要なら `<T, U>` のようにwrite",
    "rust_lesson3_ex2_comment1": "|x| でclosureのargumentをdefinition",
    "rust_lesson3_ex3_description": "elementを順番に処理doiteratorを学びましょう。",
    "rust_lesson1_ex1_slide3_title": "Let's Try It!",
    "rust_lesson2_ex6_slide2_title": "enum のdefinition",
    "rust_lesson2_ex1_title": "所有権のBasic",
    "rust_lesson4_ex3_slide1_title": "Box（ボックス）?",
    "rust_lesson2_ex1_slide3_content": "Rust独自の概念「所有権」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex8_slide3_content": "Option/Resultのデフォルト値を設定しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex7_slide2_title": "使用Example",
    "rust_lesson4_ex10_description": "iteratorにindexを付けましょう。",
    "rust_lesson4_ex9_slide1_title": "collect ?",
    "rust_lesson4_ex10_slide2_content": "# 「何番目か」が必要なとき\n\n番号（index）とelementの両方が必要なときに便利です。\n\ncodeExample：\n```rust\nlet v = vec![10, 20, 30];\nfor (idx, val) in v.iter().enumerate() {\n    println!(\"{}番目の値は{}\", idx, val);\n}\n// 0番目の値は10\n// 1番目の値は20\n// 2番目の値は30\n```\n\nPoint：\n- `(i, x)` でtuple（2つのset）を受け取る\n- `i` にindex、`x` にelementが入る\n- indexは0から始まる",
    "rust_lesson3_ex2_description": "周囲のvariableを使えるanonymous function「closure」を学びましょう。",
    "rust_lesson1_ex4_comment1": "mut で変更可能にdo",
    "rust_lesson1_ex8_slide3_title": "Let's Try It!",
    "rust_lesson1_ex3_slide2_content": "割り算の「あまり」を求める「%」（パーセント）演算子を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex9_slide3_title": "Let's Try It!",
    "rust_lesson3_ex3_title": "iteratorのBasic",
    "rust_lesson3_ex9_title": "Vec のmethod push",
    "rust_lesson1_ex8_comment1": "dictionaryをcreate（keyは'みかん'、valueは'オレンジ'）",
    "rust_lesson1_ex2_comment3": "+ でたし算do",
    "rust_lesson4_ex8_slide2_content": "# ジェネリクスの代わり\n\n```rust\nfn print_all(iter: impl Iterator<Item = i32>) {\n    for x in iter {\n        println!(\"{}\", x);\n    }\n}\n```",
    "rust_lesson2_ex2_slide2_title": "reference Usage",
    "rust_lesson1_ex8_slide3_content": "「辞書（HashMap）」を使うと、名前をつけてデータを保存し、その名前で取り出せます。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex7_slide2_content": "# [ ]で番号を指定して取り出す\n\n`[番号]` で何番目のデータか指定して取り出せます。\n\nImportantなルール：番号は「0」から！\n- 1番目 → `[0]`\n- 2番目 → `[1]`\n- 3番目 → `[2]`\n\ncodeExample：\n```rust\nlet fruits = vec![\"りんご\", \"バナナ\", \"みかん\"];\n//                  ↑0番    ↑1番     ↑2番\nprintln!(\"{}\", fruits[0]);  // りんご\nprintln!(\"{}\", fruits[1]);  // バナナ\n```\n\nプログラミングでは「0から数える」のが世界共通のルールです！",
    "rust_lesson1_ex6_slide1_title": "条件を組み合わせる",
    "rust_lesson2_ex10_slide2_title": "ジェネリックfunction Syntax",
    "rust_lesson1_ex6_description": "複数の条件を組み合わせる「&&（かつ）」と「||（Alsoは）」を学びましょう。",
    "rust_lesson4_ex6_title": "HashSet",
    "rust_lesson2_ex3_slide2_content": "# mut が2か所に必要\n\n変更できるようにdoには、variableとreferenceの両方に `mut` が必要です。\n\ncodeExample：\n```rust\n// 1. 変数を mut で作る\nlet mut s = String::from(\"hello\");\n\n// 2. &mut で可変参照を渡す\nchange(&mut s);\n\nfn change(s: &mut String) {\n    s.push_str(\" world\");  // 変更できる！\n}\n```\n\nPoint：\n- `let mut 変数` でvariableを変更可能に\n- `&mut 変数` で可変referenceをcreate\n- 両方ないと変更できない！",
    "rust_lesson2_ex2_slide1_title": "reference（さんしょう）?",
    "rust_lesson3_ex6_slide2_content": "# 合計、積、結合など\n\n```rust\n// 積\nv.iter().fold(1, |acc, x| acc * x)\n\n// 文字列結合\nwords.iter().fold(String::new(), |acc, s| acc + s)\n```",
    "rust_lesson1_ex1_description": "Rustを使ってscreenに文字をdisplayしてみましょう。println! という特別なfunctionをuse。",
    "rust_lesson3_ex8_slide3_title": "Let's Try It!",
    "rust_lesson4_ex6_description": "一意なvalueのsetを管理しましょう。",
    "rust_lesson2_ex5_slide1_title": "impl ?",
    "rust_lesson1_ex8_title": "名前で引き出す「dictionary」",
    "rust_lesson2_ex7_description": "valueがあるかないかを表す「Option」を学びましょう。",
    "rust_lesson1_ex4_slide2_title": "Let's Try It!",
    "rust_lesson1_ex7_title": "たくさんのデータをまとめましょう「ベクタ」",
    "rust_lesson3_ex7_slide1_content": "# errorの早期リターン\n\n? は、Resultが Err の場合に早期リターンします。\n\n```rust\nfn read_file() -> Result<String, io::Error> {\n    let content = fs::read_to_string(\"file.txt\")?;\n    Ok(content)\n}\n```",
    "rust_lesson3_ex9_slide1_content": "# 末尾に追加\n\npush は、Vecの末尾にelementをadd。\n\n```rust\nlet mut v = vec![1, 2];\nv.push(3);\n// [1, 2, 3]\n```",
    "rust_lesson4_ex8_slide3_content": "トレイトを返す関数を簡潔に書きましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex1_title": "screenにメッセージを出しましょう",
    "rust_lesson2_ex8_slide2_title": "Result  Usage",
    "rust_lesson3_ex2_slide1_title": "closure?",
    "rust_lesson3_ex8_title": "unwrap_or でデフォルトvalue",
    "rust_lesson4_ex10_slide1_content": "# 番号とelementを一緒にもらう\n\nenumerate は、「何番目か」と「そのelement」をsetで取り出せるmethodです。\n\nFor example：\n- 0番目: りんご\n- 1番目: バナナ\n- 2番目: みかん\n\ncodeExample：\n```rust\nfor (i, x) in vec![\"a\", \"b\", \"c\"].iter().enumerate() {\n    println!(\"{}: {}\", i, x);\n}\n// 0: a\n// 1: b\n// 2: c\n```",
    "rust_lesson1_ex7_slide1_content": "# データを並べてまとめる「長い箱」\n\nベクタ（Vec） は、たくさんのデータを順番に並べて入れられる「長い箱」です。\n\nFor example：\n- 買い物listの商品を全部まとめる\n- testの点数を全部まとめる\n- 友だちの名前を全部まとめる\n\n100個でも1000個でも、1つのvariableでまとめて管理できます！\n\n作り方：\n```rust\nlet fruits = vec![\"りんご\", \"バナナ\", \"みかん\"];\n// vec! で ベクタを作る\n```",
    "rust_lesson4_ex8_slide3_title": "Let's Try It!",
    "rust_lesson4_ex7_description": "パターンマッチに条件を追加しましょう。",
    "rust_lesson1_ex4_comment2": "+= で 20 を足す",
    "rust_lesson1_ex2_comment2": "y に 5 を入れる",
    "rust_lesson2_ex3_slide3_title": "Let's Try It!",
    "rust_lesson3_ex4_slide1_title": "map（map）?",
    "rust_lesson1_ex2_slide3_content": "データに名前をつけて保存できる「変数（へんすう）」を使ってみましょう。letで変数を作ります。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex8_slide2_content": "# match で成功と失敗を分ける\n\n`match` で「成功したら」「失敗したら」の処理を書き分けます。\n\ncodeExample：\n```rust\nfn divide(a: i32, b: i32) -> Result<i32, String> {\n    if b == 0 {\n        return Err(\"0で割れません\".to_string());\n    }\n    Ok(a / b)  // 成功なら答えを返す\n}\n\nmatch divide(10, 2) {\n    Ok(v) => println!(\"答えは{}\", v),\n    Err(e) => println!(\"エラー: {}\", e),\n}\n```\n\nPoint：\n- `Ok(値)` で成功をreturn\n- `Err(エラー)` で失敗をreturn",
    "rust_lesson4_ex3_comment1": "Box::new でheapに格納",
    "rust_lesson4_ex8_description": "トレイトをreturnfunctionを簡潔に書きましょう。",
    "rust_lesson2_ex10_description": "typeを後から決められる「ジェネリクス」を学びましょう。",
    "rust_lesson2_ex3_slide1_title": "可変reference（かへんさんしょう）?",
    "rust_lesson2_ex2_description": "所有権を移さずにvalueを借りる「reference」を学びましょう。",
    "rust_lesson3_ex5_slide2_title": "** にNote！",
    "rust_lesson2_ex2_slide3_title": "Let's Try It!",
    "rust_lesson4_ex3_slide3_content": "ヒープにデータを格納するBoxを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex4_title": "累算assignmentoperator（+=、-=）",
    "rust_lesson3_ex3_slide2_content": "# 借りるか、もらうか\n\n3種類の iter があり、所有権の扱いが違います。\n\n3つの違い：\n```rust\nv.iter()       // 参照で借りる（&T）\nv.iter_mut()   // 変更可能で借りる（&mut T）\nv.into_iter()  // 所有権をもらう（T）\n```\n\n使い分け：\n- `iter()` → 見るだけ（元のベクタも使える）\n- `iter_mut()` → 中身を変更したい\n- `into_iter()` → ベクタごともらう（元は使えない）\n\n普通は `iter()` をuseことが多いです。",
    "rust_lesson2_ex1_slide1_title": "所有権（しょゆうけん）?",
    "rust_lesson4_ex6_slide3_content": "一意な値の集合を管理しましょう。\n\n（When you're ready, select \"Start Lesson\".）"
  },
  "el": {
    "rust_lesson1_course_title": "Introduction to Rust",
    "rust_lesson1_course_description": "Learn the basics of Rust programming.",
    "rust_lesson2_course_title": "Rust II - Intermediate",
    "rust_lesson2_course_description": "Learn intermediate Rust concepts.",
    "rust_lesson3_course_title": "Rust III - Advanced",
    "rust_lesson3_course_description": "Master advanced Rust techniques.",
    "rust_lesson4_course_title": "Rust IV - Expert Level",
    "rust_lesson4_course_description": "Expert-level Rust programming.",
    "rust_lesson1_ex5_slide2_content": "条件によって動きを変える if文を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex9_title": "collect で変換",
    "rust_lesson2_ex7_slide1_content": "# 「あるかもしれない、ないかもしれない」\n\nOption<T> は、valueが「あるかもしれないし、ないかもしれない」ことを表すtypeです。\n\nFor example：\n- dictionaryで単語を探す → 見つかるかもしれないし、ないかもしれない\n- ゲームでアイテムを拾う → 落ちてるかもしれないし、ないかもしれない\n\n2つの状態：\n- `Some(値)` → valueがある！\n- `None` → valueがない...\n\n他の言語では `null` をuseが、Rustでは `Option` で安全に扱います。",
    "rust_lesson1_ex2_slide1_title": "variable（へんすう）?",
    "rust_lesson1_ex7_description": "「ベクタ（Vec）」をuseと、たくさんのデータを一つの「長い はこ」にまとめて入れられます。",
    "rust_lesson2_ex9_slide2_content": "# 約束を作って、守る\n\n1. `trait` で「約束」をdefinition\n2. `impl トレイト for 型` で「約束を守る」implementationをdo\n\ncodeExample：\n```rust\n// 1. トレイト（約束）を定義\ntrait Speak {\n    fn speak(&self);  // 鳴くメソッドを持つ約束\n}\n\n// 2. Dog構造体がトレイトを実装\nstruct Dog;\nimpl Speak for Dog {\n    fn speak(&self) {\n        println!(\"woof\");\n    }\n}\n```\n\n「DogはSpeakができる」ということになります。",
    "rust_lesson4_ex4_description": "referenceカウントでデータを共有しましょう。",
    "rust_lesson4_ex5_slide1_content": "# 名前で引ける「dictionary」\n\nHashMap は、「key（名前）」と「value（データ）」をsetで保存dodictionaryです。\n\nFor example：\n- 「青チーム」→ 10点\n- 「赤チーム」→ 15点\n\ncodeExample：\n```rust\nuse std::collections::HashMap;\n\nlet mut scores = HashMap::new();\nscores.insert(\"Blue\", 10);   // 追加\nscores.insert(\"Red\", 15);    // 追加\n```\n\n`use` で機能を読み込んでからuse。",
    "rust_lesson3_ex4_title": "map でiterator変換",
    "rust_lesson4_ex1_slide3_content": "共通の振る舞いを定義するトレイトを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex4_description": "variableのvalueを手軽に増やしたり減らしたりdo「+=」「-=」を学びましょう。",
    "rust_lesson1_ex2_description": "データに名前をつけて保存できる「variable（へんすう）」を使ってみましょう。letでvariableをcreate。",
    "rust_lesson4_ex4_slide2_title": "referenceカウントの仕組み",
    "rust_lesson3_ex8_slide2_title": "unwrap_or_else",
    "rust_lesson4_ex10_comment1": "1番目の i にindex、2番目の item にelementが入る",
    "rust_lesson3_ex6_slide1_content": "# 累積処理\n\nfold は、初期valueとfunctionでelementを1つずつ畳み込みます。\n\n```rust\nlet v = vec![1, 2, 3];\nlet sum = v.iter().fold(0, |acc, x| acc + x);\n// 6\n```",
    "rust_lesson4_ex2_slide2_title": "よくuse derive トレイト",
    "rust_lesson3_ex10_slide3_content": "文字列型の違いを理解しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex4_slide2_content": "変数の値を手軽に増やしたり減らしたりする「+=」「-=」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex4_slide3_title": "Let's Try It!",
    "rust_lesson3_ex5_slide1_title": "filter（filterー）?",
    "rust_lesson4_ex5_description": "keyとvalueのpairを格納しましょう。",
    "rust_lesson3_ex5_description": "条件に合うelementだけを取り出しましょう。",
    "rust_lesson2_ex2_slide2_content": "# functionに借りてもらう\n\nfunctionにデータを渡すとき、`&` をつけると「借りる」形になります。元のvariableはそのまま使い続けられます。\n\ncodeExample：\n```rust\nfn calc_len(s: &String) -> usize {\n    s.len()  // 長さを返す\n}\n\nfn main() {\n    let text = String::from(\"hello\");\n    let len = calc_len(&text);  // textを貸す\n    // text はまだ使える！\n    println!(\"{}の長さは{}\", text, len);\n}\n```\n\n`&String` は「Stringを借りる」という意味です。",
    "rust_lesson4_ex7_slide3_content": "パターンマッチに条件を追加しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex8_slide2_content": "# 遅延評価\n\n```rust\n// クロージャで計算\nlet value = x.unwrap_or_else(|| expensive_computation());\n```",
    "rust_lesson4_ex7_title": "match ガード",
    "rust_lesson3_ex7_title": "? operatorでerror伝播",
    "rust_lesson4_ex1_description": "共通の振る舞いをdefineトレイトを学びましょう。",
    "rust_lesson2_ex1_slide2_content": "# 所有権は「移動」do\n\nvariableを別のvariableにassignmentdoと、所有権が 移動（ムーブ） します。元のvariableは使えなくなります。\n\ncodeExample：\n```rust\nlet s1 = String::from(\"hello\");  // s1 が持ち主\nlet s2 = s1;  // 所有権が s2 に移動！\n// ↓ s1 はもう使えない（エラーになる）\n// println!(\"{}\", s1);  // ダメ！\nprintln!(\"{}\", s2);  // OK！\n```\n\nイメージ：\nおもちゃを友だちにあげたら、自分はもう使えない。これがムーブです。",
    "rust_lesson1_ex8_slide1_title": "dictionary（HashMap）?",
    "rust_lesson4_ex3_slide2_content": "# サイズが決まらないとき\n\nBoxは、コンパイル時にサイズがわからないtypeにuse。\n\nFor examplerecursion的なtype：\n```rust\n// リストは「値 + 次のリスト」の繰り返し\nenum List {\n    Cons(i32, Box<List>),  // Boxで次を指す\n    Nil,                   // 終わり\n}\n```\n\nなぜBoxが必要？\n- `List` の中に `List` がある → 無限に大きくなる？\n- `Box` をuseと、サイズが固定（pointerのサイズ）になる\n\n「中身」ではなく「中身への矢印」を持つイメージです。",
    "rust_lesson2_ex10_title": "ジェネリクスを使おう",
    "rust_lesson2_ex8_slide3_title": "Let's Try It!",
    "rust_lesson3_ex9_slide2_content": "# 可変reference\n\n```rust\n// mut が必要\nlet mut v = Vec::new();\nv.push(1);\nv.push(2);\n```",
    "rust_lesson4_ex4_title": "Rc<T>",
    "rust_lesson2_ex3_comment1": "mut で可変variableにdo",
    "rust_lesson4_ex5_slide3_title": "Let's Try It!",
    "rust_lesson2_ex6_slide2_content": "# バリアントを列挙\n\n`enum 名前 { バリアント1, バリアント2, ... }` でdefine。\n\ncodeExample：\n```rust\nenum Color {\n    Red,\n    Green,\n    Blue,\n}\nlet c = Color::Red;\n```",
    "rust_lesson1_ex1_comment1": "Hello, Rust! とdisplay",
    "rust_lesson1_ex1_slide1_content": "# 安全で速い！最新のプログラミング言語\n\nRust（ラスト）は、「間違いを事前に防ぐ」ことがとても得意なプログラミング言語です。\n\nRustのすごいところ：\n- programのミスをexecute前に見つけてくれる\n- とても速く動く\n- 世界中のプログラマーが「一番好き！」と選ぶ人気の言語\n\nたとえるなら：\n厳しいけど優しい先生のような言語です。「ここ間違ってるよ」と教えてくれるので、安心してprogramが書けます！",
    "rust_lesson3_ex8_slide1_content": "# None/Err の場合のデフォルト\n\nunwrap_or は、None や Err の場合にデフォルトvalueをreturn。\n\n```rust\nlet x: Option<i32> = None;\nlet value = x.unwrap_or(0);  // 0\n```",
    "rust_lesson2_ex7_slide3_title": "Let's Try It!",
    "rust_lesson2_ex6_title": "enum で状態を表す",
    "rust_lesson2_ex8_slide1_content": "# 「成功」か「失敗」かを表す\n\nResult<T, E> は、処理が「成功したか失敗したか」を表すtypeです。\n\nFor example：\n- fileをopen → 成功（内容）か失敗（error）\n- 0で割り算 → 成功（答え）か失敗（0で割れない！）\n\n2つの状態：\n- `Ok(値)` → 成功！valueが入っている\n- `Err(エラー)` → 失敗...error情報が入っている\n\n`Option` は「あるか・ないか」、`Result` は「成功か・失敗か」という違いです。",
    "rust_lesson2_ex8_slide3_content": "成功と失敗を表す「Result」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex6_slide1_title": "HashSet ?",
    "rust_lesson3_ex9_comment1": "push でelementを追加",
    "rust_lesson2_ex7_slide2_title": "Option  Usage",
    "rust_lesson3_ex2_title": "closureのBasic",
    "rust_lesson3_ex7_slide1_title": "? operator?",
    "rust_lesson4_ex6_comment1": "HashSet をimport",
    "rust_lesson2_ex10_slide1_content": "# どんなtypeでも使える「万能」の仕組み\n\nジェネリクス は、typeを後から決められる仕組みです。\n\nなぜ便利？\n同じようなfunctionを何度も書かなくてすみます。\n\nFor example：\n- 数字のarrayの最初のelementを取るfunction\n- stringのarrayの最初のelementを取るfunction\n\n両方とも「最初のelementを取る」のは同じなのに、typeが違うだけで別のfunctionをwriteのは大変！\n\nジェネリクスなら、`<T>` で「typeは後で決める」とwriteだけで、どんなtypeでも使えるfunctionが作れます。",
    "rust_lesson1_ex3_slide1_content": "# 剰余operator（じょうよえんざんし）「%」\n\n`%`（パーセント）は、割り算の 「あまり」 をcalculate特別な記号です。\n\nわかりやすいExample：\n- 10このアメを3人で分けると？\n- 1人3こずつで、1こあまる\n- これを `10 % 3` とwriteと、答えは `1`\n\ncodeExample：\n```rust\nprintln!(\"{}\", 10 % 3);  // 1（あまり1）\nprintln!(\"{}\", 8 % 4);   // 0（あまりなし＝割り切れる）\n```\n\n使いどころ：\n- 偶数か奇数か調べる（`n % 2` が0なら偶数）\n- 時計の計算（24を超えたら0に戻る、など）",
    "rust_lesson3_ex7_description": "errorを簡潔に伝播させましょう。",
    "rust_lesson3_ex8_comment1": "unwrap_or でデフォルトvalueを設定",
    "rust_lesson2_ex8_title": "Result<T, E> でerror処理",
    "rust_lesson2_ex10_comment1": "T をtypeパラメータとしてuse",
    "rust_lesson2_ex6_comment1": "enum で列挙typeをdefinition",
    "rust_lesson3_ex3_slide3_content": "要素を順番に処理するイテレータを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex2_comment1": "derive でトレイトを自動implementation",
    "rust_lesson1_ex8_slide1_content": "# 名前でsearchできる「dictionary」\n\nHashMap（ハッシュmap）は、「名前」と「データ」をsetにして保存できる仕組みです。本物のdictionaryのように使えます。\n\nFor example果物の色dictionary：\n- 「りんご」→「あか」\n- 「バナナ」→「きいろ」\n- 「みかん」→「オレンジ」\n\nuse準備：\n```rust\nuse std::collections::HashMap;  // 機能を読み込む\nlet mut fruits = HashMap::new();  // 空の辞書を作る\nfruits.insert(\"りんご\", \"あか\");  // データを追加\n```\n\n`use` は「この機能をuseよ」というdeclarationです。",
    "rust_lesson3_ex9_slide1_title": "push ?",
    "rust_lesson4_ex1_title": "トレイトのdefinition",
    "rust_lesson4_ex3_description": "heapにデータを格納doBoxを学びましょう。",
    "rust_lesson1_ex2_title": "便利な「はこ」variable（へんすう）",
    "rust_lesson1_ex8_comment2": "中身を出す",
    "rust_lesson3_ex9_slide3_title": "Let's Try It!",
    "rust_lesson1_ex4_comment3": "-= で 50 を引く",
    "rust_lesson1_ex6_comment1": "&& で両方の条件をチェック",
    "rust_lesson4_ex1_slide2_title": "トレイトのimplementation",
    "rust_lesson4_ex7_slide3_title": "Let's Try It!",
    "rust_lesson4_title": "Rust IV - トレイトとスマートpointer",
    "rust_lesson4_ex1_comment1": "trait でトレイトをdefinition",
    "rust_lesson4_ex4_slide1_content": "# 複数の「持ち主」を許可do仕組み\n\nRc<T> は「Reference Counted（referenceカウント）」の略で、複数の所有者でデータを共有できます。\n\n普通の所有権：\n1人だけが持ち主。渡したら元の人は使えない。\n\nRc をuseと：\n複数人が同じデータの「持ち主」になれる！\n\ncodeExample：\n```rust\nuse std::rc::Rc;\n\nlet a = Rc::new(5);       // Rcでラップ\nlet b = Rc::clone(&a);    // bも持ち主になる\n// a も b も使える！\n```",
    "rust_lesson3_ex5_slide1_content": "# 条件に合うものだけ残す\n\nfilter は、条件を満たすelementだけを残し、他を捨てます。\n\nFor example：\n- 80点以上の人だけ残す\n- 偶数だけ残す\n- 「あ」から始まる名前だけ残す\n\ncodeExample：\n```rust\nlet v = vec![1, 2, 3, 4, 5];\nlet evens: Vec<_> = v.iter()\n    .filter(|x| **x % 2 == 0)  // 偶数だけ\n    .collect();\n// [2, 4]\n```\n\n条件が `true` のelementだけが残ります。",
    "rust_lesson3_ex7_slide3_title": "Let's Try It!",
    "rust_lesson1_ex7_comment2": "2番目のデータ（1番）を出す",
    "rust_lesson4_ex8_title": "impl Trait",
    "rust_lesson1_ex5_description": "条件によって動きを変える if文を学びましょう。",
    "rust_lesson3_ex4_slide2_title": "遅延評価（ちえんひょうか）",
    "rust_lesson3_ex1_slide1_content": "# referenceの「寿命」を示す印\n\nライフタイム は、referenceがいつまで使えるかを示す印です。`'a`（アポストロフィ・エー）のようにwrite。\n\nなぜ必要？\nreferenceは「借りている」状態。借りた元のデータが消えたら、referenceも使えなくなります。\n\nFor example：\n- 図書館で借りた本 → 図書館が閉まったら読めない\n- referenceで借りたデータ → 元のデータが消えたら使えない\n\nライフタイムは「このreferenceはこの範囲で有効だよ」とコンパイラに伝える仕組みです。",
    "rust_lesson1_ex1_slide1_title": "Rust（ラスト）?",
    "rust_lesson1_ex2_slide2_title": "計算の記号（operator）",
    "rust_lesson4_ex5_slide2_content": "# get で安全に取り出す\n\n`get()` methodでvalueを取り出せます。見つからない可能性があるので、`Option` が返ってきます。\n\ncodeExample：\n```rust\n// getはOption<&V>を返す\nif let Some(score) = scores.get(\"Blue\") {\n    println!(\"青チームは{}点\", score);\n}\n```\n\nPoint：\n- keyがあれば `Some(値)` が返る\n- keyがなければ `None` が返る\n- `if let` で安全に取り出せる\n\n存在しないkeyでアクセスしてもprogramが落ちない！",
    "rust_lesson4_ex7_slide1_title": "match ガード?",
    "rust_lesson3_title": "Rust III - ライフタイムとiterator",
    "rust_lesson4_ex3_title": "Box<T>",
    "rust_lesson1_ex4_slide1_title": "累算assignmentoperator（るいさんだいにゅう）?",
    "rust_lesson2_ex9_comment1": "trait でトレイトをdefinition",
    "rust_lesson2_ex1_description": "Rust独自の概念「所有権」を学びましょう。",
    "rust_lesson2_ex3_slide3_content": "参照先の値を変更できる「可変参照」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex1_slide3_title": "Let's Try It!",
    "rust_lesson3_ex6_slide2_title": "様々な畳み込み",
    "rust_lesson4_ex9_slide3_title": "Let's Try It!",
    "rust_lesson2_ex5_title": "impl でmethodを追加",
    "rust_lesson2_ex6_slide1_content": "# 複数の選択肢\n\nenum は、valueがいくつかの種類のうちの一つであることを表します。各バリアントにデータを持たせることもできます。",
    "rust_lesson2_ex4_comment1": "struct で構造体をdefinition",
    "rust_lesson1_ex3_title": "剰余operator（%）",
    "rust_lesson1_ex7_comment1": "colors というベクタをcreate（'あか', 'あお'の順）",
    "rust_lesson1_ex4_slide1_content": "# valueをかんたんに増やす・減らす\n\n`+=`（プラスイコール）と `-=`（マイナスイコール）は、variableの中身を増やしたり減らしたりdo便利な記号です。\n\nRustのImportantなルール：`mut`が必要！\nRustでは、variableをchangeには `let mut`（レット ミュート）とwrite必要があります。`mut` は「mutable（変更できる）」の略です。\n\ncodeExample：\n```rust\nlet mut score = 100;  // mut をつけて変更可能に\nscore += 10;          // 10を足す → 110に\nscore -= 50;          // 50を引く → 60に\n```\n\n`mut` がないと「このvariableは変えちゃダメ！」とRustが怒ります。",
    "rust_lesson2_ex1_slide2_title": "ムーブ（移動）",
    "rust_lesson3_ex4_comment1": "map で各elementを変換",
    "rust_lesson3_ex8_slide1_title": "unwrap_or ?",
    "rust_lesson2_ex5_slide1_content": "# implementationブロック\n\nimpl ブロックで、構造体にmethodを追加できます。`self` で自分自身をreferenceします。",
    "rust_lesson2_ex10_slide1_title": "ジェネリクス?",
    "rust_lesson1_ex8_slide2_content": "# 名前（key）で取り出す\n\ndictionaryに入れたデータは、名前（key）を指定して取り出せます。\n\ncodeExample：\n```rust\nuse std::collections::HashMap;\nfn main() {\n    let mut fruits = HashMap::new();\n    fruits.insert(\"りんご\", \"あか\");  // 追加\n    fruits.insert(\"バナナ\", \"きいろ\");  // 追加\n    \n    println!(\"{}\", fruits[\"りんご\"]);  // あか と表示\n}\n```\n\nPoint：\n- `insert(名前, データ)` で追加\n- `辞書[名前]` で取り出し\n- 番号ではなく「名前」で探せるのが便利！",
    "rust_lesson4_ex9_slide1_content": "# iteratorをコレクションに\n\ncollect は、iteratorをVecやHashMapなどに変換します。\n\n```rust\nlet v: Vec<_> = (0..5).collect();\nlet s: String = vec!['a', 'b'].into_iter().collect();\n```",
    "rust_lesson2_ex2_slide3_content": "所有権を移さずに値を借りる「参照」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex2_slide3_content": "周囲の変数を使える無名関数「クロージャ」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex4_slide2_content": "# struct keyワードでdefinition\n\n`struct 名前 { フィールド }` で構造体をdefine。フィールドには名前とtypeをwrite。\n\ncodeExample：\n```rust\n// Point 構造体を定義\nstruct Point {\n    x: i32,  // xフィールド（整数）\n    y: i32,  // yフィールド（整数）\n}\n\n// 使い方\nlet p = Point { x: 10, y: 20 };\nprintln!(\"x={}, y={}\", p.x, p.y);\n```\n\nPoint：\n- `struct 名前` で構造体をcreate\n- `{ フィールド名: 型 }` でどんなデータを持つか決める\n- `.フィールド名` でアクセス",
    "rust_lesson2_ex10_slide3_content": "型を後から決められる「ジェネリクス」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex6_slide3_title": "Let's Try It!",
    "rust_lesson4_ex6_slide1_content": "# 一意なvalueのset\n\nHashSet は、重複のないvalueのsetです。\n\n```rust\nuse std::collections::HashSet;\n\nlet mut set = HashSet::new();\nset.insert(1);\nset.insert(2);\nset.insert(1); // 重複は無視\n```",
    "rust_lesson4_ex2_title": "derive 属性",
    "rust_lesson4_ex2_slide1_content": "# トレイトを「自動で」implementation\n\n#[derive(...)] をuseと、よくuseトレイトを自分で書かなくても自動でimplementationしてくれます。\n\nFor example：\n構造体を `println!` でdisplayしたいとき、普通は Display トレイトをimplementationdo必要がありますが、`#[derive(Debug)]` をwriteだけでOK！\n\ncodeExample：\n```rust\n#[derive(Debug)]  // Debug トレイトを自動実装\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nlet p = Point { x: 1, y: 2 };\nprintln!(\"{:?}\", p);  // Point { x: 1, y: 2 }\n```",
    "rust_lesson1_ex6_slide2_title": "Let's Try It!",
    "rust_lesson3_ex3_slide2_title": "3つの iter method",
    "rust_lesson4_ex7_slide2_content": "# 複雑なconditional\n\n```rust\nmatch Some(5) {\n    Some(x) if x % 2 == 0 => println!(\"even\"),\n    Some(x) => println!(\"odd: {}\", x),\n    None => println!(\"none\"),\n}\n```",
    "rust_lesson3_ex3_slide1_content": "# elementを1つずつ取り出す仕組み\n\niterator は、ベクタなどのデータを「1つずつ順番に」取り出す仕組みです。\n\nFor example：\n- 行列に並んでいる人を1人ずつ呼ぶ\n- 引き出しの中身を1つずつ出す\n\ncodeExample：\n```rust\nlet v = vec![1, 2, 3];\nfor x in v.iter() {\n    println!(\"{}\", x);  // 1, 2, 3 と順番に表示\n}\n```\n\n`iter()` で「順番に取り出す準備」をして、`for` で1つずつ処理します。",
    "rust_lesson3_ex3_slide1_title": "iterator?",
    "rust_lesson4_ex2_description": "トレイトを自動implementationdoderiveを学びましょう。",
    "rust_lesson3_ex4_slide1_content": "# 全部を同じように変換do\n\n**map** は、iteratorの各elementを「同じ方法で」変換します。\n\nFor example：\n- 全員の身長を2倍にdo\n- 全員の名前を大文字にdo\n- 全部の数を2乗do\n\ncodeExample：\n```rust\nlet v = vec![1, 2, 3];\nlet doubled: Vec<_> = v.iter()\n    .map(|x| x * 2)  // 各要素を2倍に\n    .collect();      // ベクタに戻す\n// [2, 4, 6]\n```\n\n`|x| x * 2` は「xを受け取って、x*2をreturn」closureです。",
    "rust_lesson1_ex3_slide1_title": "あまりを求める",
    "rust_lesson3_ex10_slide1_content": "# 所有権の違い\n\nString は所有権を持つheap上のstring、&str はreferenceです。\n\n```rust\nlet s1: String = String::from(\"hello\");\nlet s2: &str = \"hello\";\n```",
    "rust_lesson4_ex2_slide1_title": "derive（デライブ）?",
    "rust_lesson2_ex2_comment1": "& でreferenceを渡す",
    "rust_lesson4_ex5_slide1_title": "HashMap（ハッシュmap）?",
    "rust_lesson2_ex3_slide2_title": "&mut  Usage",
    "rust_lesson3_ex5_title": "filter で絞り込み",
    "rust_lesson4_ex3_slide2_title": "いつuse？",
    "rust_lesson2_ex2_title": "referenceと借用",
    "rust_lesson2_ex7_title": "Option<T> で null を安全に",
    "rust_lesson4_ex10_slide3_title": "Let's Try It!",
    "rust_lesson3_ex5_slide3_title": "Let's Try It!",
    "rust_lesson4_ex10_title": "enumerate でindex付き",
    "rust_lesson2_ex2_slide1_content": "# 所有権を渡さずに「借りる」\n\nreference をuseと、所有権を移さずにデータを「見せてもらう」ことができます。\n\nたとえるなら：\n- ムーブ = おもちゃをあげる（自分は使えない）\n- reference = おもちゃを見せる（自分も使える）\n\n作り方：\n`&`（アンパサンド）をつけるとreferenceを作れます。\n\n```rust\nlet s = String::from(\"hello\");\nlet r = &s;  // sを借りる（見せてもらう）\n// s も r も使える！\n```",
    "rust_lesson2_ex5_slide2_content": "# &self をuse\n\nmethodの最初のargumentは `&self` です。\n\ncodeExample：\n```rust\nimpl Rect {\n    fn area(&self) -> i32 {\n        self.width * self.height\n    }\n}\n```",
    "rust_lesson1_ex5_slide2_title": "Let's Try It!",
    "rust_lesson2_ex4_slide3_title": "Let's Try It!",
    "rust_lesson4_ex3_slide3_title": "Let's Try It!",
    "rust_lesson2_ex9_slide3_content": "共通の振る舞いを定義する「トレイト」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex1_slide2_content": "# impl で約束を守る\n\n構造体にトレイトをimplementationdoと、その構造体は「約束を守る」ことになります。\n\ncodeExample：\n```rust\nstruct Person { name: String }\n\nimpl Greet for Person {\n    fn greet(&self) -> String {\n        format!(\"Hello, {}\", self.name)\n    }\n}\n```\n\n読み方：\n- `impl Greet for Person` → 「PersonはGreetをimplementationdo」\n- これでPersonは「あいさつできる」ようになった！",
    "rust_lesson4_ex4_comment1": "clone でreferenceカウントを増やす",
    "rust_lesson3_ex4_slide2_content": "# map だけではexecuteされない！\n\nRustのiteratorは 遅延評価 といって、「本当に必要になるまで処理しない」仕組みです。\n\nなぜ？\n無駄な計算を省けるから。100万件あっても、最初の10件だけ欲しいなら10件だけ処理すればいい。\n\ncollect() でexecute：\n```rust\n// これだけでは何も起きない\nv.iter().map(|x| x * 2);\n\n// collect() で実行してベクタに変換\nlet result: Vec<_> = v.iter().map(|x| x * 2).collect();\n```\n\n`collect()` は「今すぐ全部処理してResultをちょうだい」という意味です。",
    "rust_lesson2_ex4_slide2_title": "struct のdefinitionのしかた",
    "rust_lesson2_ex3_slide1_content": "# 「書き換えできる」借り方\n\n普通のreference `&` は「見るだけ」ですが、可変reference `&mut` は「変更もできる」借り方です。\n\nたとえるなら：\n- `&` = 本を見せてもらう（readだけ）\n- `&mut` = ノートを借りる（writeOK）\n\nImportantなルール：\n- 可変referenceは同時に1つだけ！\n- 「みんなで見る」か「1人でwrite」かのどちらか\n\nこのルールで、データが同時に書き換えられるバグを防いでいます。",
    "rust_lesson2_ex10_slide3_title": "Let's Try It!",
    "rust_lesson2_ex4_title": "構造体をdefinitionしよう",
    "rust_lesson3_ex10_slide2_content": "# 相互変換\n\n```rust\n// &str -> String\nlet s = \"hello\".to_string();\n\n// String -> &str\nlet slice: &str = &s;\n```",
    "rust_lesson4_ex10_slide3_content": "イテレータにインデックスを付けましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex4_slide2_content": "# 「何人が持っているか」を数える\n\nRcは「今何人がこのデータを持っているか」を数えています。\n\ncodeExample：\n```rust\nlet a = Rc::new(5);\nprintln!(\"{}\", Rc::strong_count(&a));  // 1\n\nlet b = Rc::clone(&a);\nprintln!(\"{}\", Rc::strong_count(&a));  // 2\n```\n\nいつデータが消える？\n- カウントが0になったとき（誰も持っていないとき）\n- 最後の持ち主がいなくなると自動で片付けられる\n\n`Rc::clone` は「持ち主を1人増やす」操作です。",
    "rust_lesson1_ex8_slide2_title": "dictionary Usage",
    "rust_lesson4_ex3_slide1_content": "# データを「heap」に置く箱\n\nBox<T> は、データを「heap」という特別な場所に置くための箱です。\n\nmemoryの2つの場所：\n- stack：小さくて速い。サイズが決まっているデータ向け\n- heap：大きくて柔軟。サイズが大きいor変わるデータ向け\n\ncodeExample：\n```rust\nlet b = Box::new(5);  // 5をヒープに置く\nprintln!(\"{}\", *b);   // *で中身を取り出す → 5\n```\n\n`*` は「箱を開けて中身を見る」操作です。",
    "rust_lesson3_ex2_slide2_title": "closure Syntax",
    "rust_lesson4_ex4_slide1_title": "Rc（アールシー）?",
    "rust_lesson4_ex7_slide1_content": "# 追加条件\n\n**if** でパターンに追加条件をつけられます。\n\n```rust\nmatch x {\n    n if n < 0 => println!(\"negative\"),\n    n if n > 0 => println!(\"positive\"),\n    _ => println!(\"zero\"),\n}\n```",
    "rust_lesson2_ex3_title": "可変reference",
    "rust_lesson3_ex10_comment1": "to_string で String に変換",
    "rust_lesson3_ex10_slide2_title": "変換",
    "rust_lesson3_ex1_description": "referenceの有効期間を表すライフタイムを学びましょう。",
    "rust_lesson3_ex2_slide1_content": "# 名前のない「即席」function\n\nclosure は、名前をつけずにその場でcreatefunctionです。そして特別な能力があります：周りのvariableを使えるのです！\n\nFor example：\n```rust\nlet x = 5;  // 外側の変数\nlet add_x = |n| n + x;  // xを使えるクロージャ\nprintln!(\"{}\", add_x(10));  // 15\n```\n\n普通のfunctionとの違い：\n- 普通のfunction：argumentしか使えない\n- closure：argument + 周りのvariableも使える\n\n「その場の空気を読める」functionというイメージです！",
    "rust_lesson1_ex2_comment1": "x に 10 を入れる",
    "rust_lesson1_ex7_slide3_title": "Let's Try It!",
    "rust_lesson1_ex5_title": "「もし〜なら」で分けましょう",
    "rust_lesson3_ex2_slide3_title": "Let's Try It!",
    "rust_lesson3_ex7_slide2_content": "# 簡潔なerror処理\n\n```rust\n// ? を使わない場合\nmatch result {\n    Ok(v) => v,\n    Err(e) => return Err(e),\n}\n\n// ? を使う\nresult?\n```",
    "rust_lesson3_ex6_slide3_title": "Let's Try It!",
    "rust_lesson4_ex9_slide3_content": "イテレータをコレクションに変換しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex6_description": "elementを1つのvalueにまとめるfoldを学びましょう。",
    "rust_lesson2_ex9_description": "共通の振る舞いをdefine「トレイト」を学びましょう。",
    "rust_lesson2_ex8_comment1": "Ok で成功をreturn",
    "rust_lesson3_ex5_slide2_content": "# filter はreferenceのreferenceを受け取る\n\n`filter` のclosureは、referenceのreference（`&&T`）を受け取ります。そのため、valueをuseには `**x` と2回referenceを外す必要があります。\n\nなぜ？\n- `iter()` はreference（`&T`）をreturn\n- `filter` はそれをFurthermorereferenceで渡す（`&&T`）\n\nSyntax：\n```rust\n// **x で値を取り出す\n.filter(|x| **x > 2)\n\n// または * を引数につける\n.filter(|&x| *x > 2)\n```\n\n最初は混乱しますが、慣れれば大丈夫！",
    "rust_lesson1_ex5_comment1": "> でcompare",
    "rust_lesson2_ex4_description": "関連doデータをまとめる「構造体」を学びましょう。",
    "rust_lesson3_ex5_slide3_content": "条件に合う要素だけを取り出しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex7_slide3_content": "「ベクタ（Vec）」を使うと、たくさんのデータを一つの「長い はこ」にまとめて入れられます。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex5_slide2_title": "valueの取得",
    "rust_lesson3_ex1_slide1_title": "ライフタイム?",
    "rust_lesson1_ex3_comment1": "10 を 3 で割ったあまりをoutput",
    "rust_lesson3_ex1_comment1": "'a でライフタイムをdefinition",
    "rust_lesson3_ex10_slide1_title": "String vs &str",
    "rust_lesson2_title": "Rust II - 所有権とトレイト",
    "rust_lesson2_ex5_slide2_title": "methodのdefinition",
    "rust_lesson4_ex5_comment1": "insert でkeyとvalueを追加",
    "rust_lesson2_ex9_slide1_content": "# 「できること」の約束\n\nトレイト は、「このtypeはこういうことができる」という約束をdefine。\n\nFor example「鳴ける」という約束：\n- 犬は「ワン」と鳴く\n- 猫は「ニャー」と鳴く\n- 両方とも「鳴ける」能力がある\n\nトレイトは「鳴ける動物は、鳴き声を出すmethodを持つ」という約束です。\n\n他の言語とのcomparison：\n- Java: interface\n- TypeScript: interface\n\nに似た概念です。",
    "rust_lesson1_ex2_slide3_title": "Let's Try It!",
    "rust_lesson4_ex8_slide1_content": "# return valueのtypeをabstract化\n\nimpl Trait で、トレイトをimplementationdotypeを返せます。\n\n```rust\nfn make_iter() -> impl Iterator<Item = i32> {\n    vec![1, 2, 3].into_iter()\n}\n```",
    "rust_lesson1_ex2_slide2_content": "# 四則演算（しそくえんざん）\n\nRustでも算数と同じ記号で計算ができます。\n\n4つのBasic記号：\n- +（プラス）: たし算\n- -（マイナス）: ひき算\n- \\*（アスタリスク）: かけ算（×の代わり）\n- /（スラッシュ）: わり算（÷の代わり）\n\ncodeExample：\n```rust\nlet a = 10;\nlet b = 5;\nprintln!(\"{}\", a + b);  // 15 と表示される\n```\n\n`println!` の `{}` は「ここにvalueを入れてね」という目印です。",
    "rust_lesson4_ex9_slide2_content": "# 変換先を指定\n\n```rust\n// ターボフィッシュ構文\nlet v = (0..5).collect::<Vec<_>>();\n\n// 変数の型注釈\nlet v: Vec<i32> = (0..5).collect();\n```",
    "rust_lesson1_ex8_description": "「dictionary（HashMap）」をuseと、名前をつけてデータを保存し、その名前で取り出せます。",
    "rust_lesson4_ex9_slide2_title": "typeHint",
    "rust_lesson3_ex1_title": "ライフタイムのBasic",
    "rust_lesson2_ex5_description": "構造体にmethodをadd「impl」を学びましょう。",
    "rust_lesson4_ex8_comment1": "impl でトレイトをimplementationdotypeをreturn",
    "rust_lesson4_ex8_slide2_title": "argumentにも使える",
    "rust_lesson4_ex7_comment1": "if でマッチガードを追加",
    "rust_lesson2_ex9_slide2_title": "trait のdefinitionとimplementation",
    "rust_lesson4_ex10_slide2_title": "いつuse？",
    "rust_lesson3_ex7_slide2_title": "match の省略形",
    "rust_lesson1_ex6_title": "logicaloperator（&&、||）",
    "rust_lesson3_ex6_comment1": "fold で畳み込み",
    "rust_lesson2_ex6_description": "複数の状態を表す「列挙type（enum）」を学びましょう。",
    "rust_lesson4_ex10_slide1_title": "enumerate（イニュメレート）?",
    "rust_lesson1_ex7_slide1_title": "ベクタ（Vec）?",
    "rust_lesson2_ex6_slide3_content": "複数の状態を表す「列挙型（enum）」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex3_slide3_title": "Let's Try It!",
    "rust_lesson3_ex4_description": "各elementを変換domapを学びましょう。",
    "rust_lesson4_ex1_slide3_title": "Let's Try It!",
    "rust_lesson3_ex9_slide2_title": "mut が必要",
    "rust_lesson1_ex6_slide1_content": "# logicaloperator（ろんりえんざんし）\n\n2つ以上の条件を組み合わせたいときにuse記号です。\n\n2つの記号：\n- `&&`（アンドアンド）：「かつ」＝ 両方とも 正しいとき\n- `||`（オアオア）：「Alsoは」＝ どちらか 正しいとき\n\n身近なExample：\n- 遊園地：「18歳以上 かつ チケットあり」なら乗れる\n- おやつ：「宿題終わった Alsoは お手伝いした」ならOK\n\ncodeExample：\n```rust\nif score >= 70 && bonus > 0 {\n    // 70点以上 かつ ボーナスあり → 合格！\n    println!(\"合格！\");\n}\n```",
    "rust_lesson4_ex4_slide3_content": "参照カウントでデータを共有しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex6_slide3_title": "Let's Try It!",
    "rust_lesson2_ex5_slide3_content": "構造体にメソッドを追加する「impl」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex1_slide3_title": "Let's Try It!",
    "rust_lesson1_ex5_slide1_content": "# programに「判断」させよう\n\nconditional は、「もし〜なら、〇〇do」という判断をprogramにさせる仕組みです。\n\n身近なExample：\n- もし80点以上なら → 「合格！」とdisplay\n- もし雨なら → 傘を持っていく\n- もしHPが0なら → ゲームオーバー\n\nRustで Syntax：\n```rust\nif score > 80 {\n    println!(\"合格！\");\n}\n```\n\n読み方：\n- `if` →「もし」\n- `score > 80` →「スコアが80より大きいなら」\n- `{ }` の中 →「これをやる」",
    "rust_lesson4_ex5_title": "HashMap",
    "rust_lesson1_ex2_slide1_content": "# データを保存do「はこ」\n\nvariable（へんすう） は、数字や文字を入れておける「はこ」のことです。名前をつけて、あとでuseことができます。\n\nFor example：\n- 「りんごの数」というラベルの箱に「5」を入れる\n- あとで「りんごの数」と呼べば「5」が出てくる\n\nRustで Syntax：\n```rust\nlet x = 10;  // xという箱に10を入れる\nprintln!(\"{}\", x);  // xの中身（10）を表示\n```\n\n`let` は「この名前で箱をcreateよ」という意味です。",
    "rust_lesson2_ex4_slide3_content": "関連するデータをまとめる「構造体」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex6_slide1_title": "enum ?",
    "rust_lesson2_ex9_title": "トレイトをdefinitionしよう",
    "rust_lesson2_ex4_slide1_title": "構造体（こうぞうたい）?",
    "rust_lesson4_ex2_slide2_content": "# 覚えておくと便利な5つ\n\nよくusederiveトレイト：\n```rust\nDebug     // {:?} でデバッグ表示できる\nClone     // .clone() でコピーを作れる\nCopy      // 代入時に自動でコピー（小さい型向け）\nPartialEq // == で比較できる\nDefault   // 初期値を自動で作れる\n```\n\n複数指定もOK：\n```rust\n#[derive(Debug, Clone, PartialEq)]\nstruct User {\n    name: String,\n    age: u32,\n}\n```\n\n`Debug` は特によくuse。debug時に構造体の中身を見れて便利！",
    "rust_lesson2_ex1_slide1_content": "# データの「持ち主」を決めるルール\n\n所有権 は、Rust最大のFeatureです。「このデータの持ち主は誰か」をはっきりさせる仕組みです。\n\nルール：\n- データには必ず1人だけ「持ち主」がいる\n- 持ち主がいなくなると、データは自dynamicに片付けられる\n\nたとえるなら：\n- おもちゃは1人しか持てない\n- 持ち主が部屋を出たら、おもちゃは片付けられる\n\nこのルールのおかげで、Rustは「memoryリーク」（データが片付けられないバグ）を防げます！",
    "rust_lesson1_ex3_slide2_title": "Let's Try It!",
    "rust_lesson3_ex1_slide2_title": "なぜ必要？",
    "rust_lesson3_ex1_slide2_content": "# 危険なバグを防ぐ\n\nダングリングreference という危険なバグがあります。これは「もう存在しないデータ」を指し続けているreferenceのことです。\n\nExample：\n```rust\nfn longest<'a>(x: &'a str, y: &'a str) -> &'a str {\n    if x.len() > y.len() { x } else { y }\n}\n```\n\n`'a` の意味：\n- argument `x` と `y` は同じライフタイム `'a` を持つ\n- return valueも同じライフタイム `'a` を持つ\n- In other words「xとyが両方有効な間、return valueも有効」という約束\n\nRustはこれを自動でチェックしてくれます！",
    "rust_lesson4_ex6_slide2_title": "set演算",
    "rust_lesson3_ex7_comment1": "? でerrorを伝播",
    "rust_lesson3_ex2_slide2_content": "# | | でargumentを囲む\n\nclosureは `|引数| 処理` という形でwrite。`||` は「パイプ」と呼ばれます。\n\nいろいろなSyntax：\n```rust\n// 引数なし\n|| println!(\"Hello\")\n\n// 引数あり\n|x, y| x + y\n\n// 複数行のブロック\n|x| {\n    let y = x * 2;\n    y + 1\n}\n```\n\nPoint：\n- argumentを `| |` で囲む（functionの `()` の代わり）\n- typeは省略できることが多い（Rustが推測してくれる）",
    "rust_lesson2_ex7_comment1": "Some でvalueがあることを示す",
    "rust_lesson3_ex4_slide3_content": "各要素を変換するmapを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_title": "Rust (ラスト) に挑戦！",
    "rust_lesson2_ex8_description": "成功と失敗を表す「Result」を学びましょう。",
    "rust_lesson3_ex8_description": "Option/Resultのデフォルトvalueを設定しましょう。",
    "rust_lesson4_ex2_slide3_title": "Let's Try It!",
    "rust_lesson2_ex5_slide3_title": "Let's Try It!",
    "rust_lesson4_ex9_description": "iteratorをコレクションに変換しましょう。",
    "rust_lesson1_ex1_slide2_content": "# println! でscreenにdisplay\n\nRustで文字をscreenにdisplayには、`println!`（プリントラインびっくり）をuse。\n\nPoint：\n- `!` がつくのがRustのFeature（マクロと呼ばれます）\n- programは `fn main() { }` の中にwrite\n- `fn` は「function（function）」の略\n\ncodeExample：\n```rust\nfn main() {\n    println!(\"ヤッホー！\");\n}\n// 「ヤッホー！」と画面に表示される\n```\n\n`println!` の `!` は「マクロ」という特別な機能の印です。今は「おまじない」と思っておけばOK！",
    "rust_lesson3_ex6_slide1_title": "fold ?",
    "rust_lesson4_ex8_slide1_title": "impl Trait ?",
    "rust_lesson1_ex1_slide2_title": "Rustの「おまじない」",
    "rust_lesson3_ex10_description": "stringtypeの違いを理解しましょう。",
    "rust_lesson3_ex7_slide3_content": "エラーを簡潔に伝播させましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex1_comment1": "s1 の所有権を移動",
    "rust_lesson2_ex9_slide1_title": "トレイト?",
    "rust_lesson4_ex6_slide2_content": "# 和set、積setなど\n\n```rust\nset1.union(&set2)\nset1.intersection(&set2)\nset1.difference(&set2)\n```",
    "rust_lesson4_ex5_slide3_content": "キーと値のペアを格納しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex8_slide1_title": "Result（リザルト）?",
    "rust_lesson4_ex1_slide1_content": "# 「できること」の約束\n\nトレイト は、typeが持つべきmethodをdefine仕組みです。\n\nFor example：\n- 「あいさつできる」トレイト → greet() methodを持つ\n- 「displayできる」トレイト → display() methodを持つ\n\ncodeExample：\n```rust\ntrait Greet {\n    fn greet(&self) -> String;  // メソッドの「約束」\n}\n```\n\nこれは「Greetできるtypeは、greet()methodを持つ」という約束です。",
    "rust_lesson4_ex2_slide3_content": "トレイトを自動実装するderiveを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex6_title": "fold で畳み込み",
    "rust_lesson3_ex9_slide3_content": "Vecに要素を追加しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex4_slide1_content": "# 関係あるデータをまとめる「設計図」\n\n構造体（struct） は、いくつかのデータをひとまとめにdo仕組みです。\n\nFor example「点（座標）」のデータ：\n- x座標\n- y座標\n\nこの2つは関係があるので、「Point（点）」としてまとめると便利です。\n\nFor example「人」のデータ：\n- 名前\n- 年齢\n\nこれも「Person（人）」としてまとめられます。\n\n構造体は「こういうデータを持つ」という設計図です。",
    "rust_lesson4_ex1_slide1_title": "トレイト?（復習）",
    "rust_lesson2_ex3_description": "reference先のvalueを変更できる「可変reference」を学びましょう。",
    "rust_lesson2_ex7_slide2_content": "# match で安全に取り出す\n\n`match` を使って「ある場合」と「ない場合」で処理を分けます。\n\ncodeExample：\n```rust\nlet x: Option<i32> = Some(5);  // 値あり\n\nmatch x {\n    Some(n) => println!(\"値は{}です\", n),  // 5\n    None => println!(\"値がありません\"),\n}\n```\n\nなぜ安全？\n- `null` のように「あるつもりでアクセスしたら無かった」errorが起きない\n- 「ない場合」の処理を書かないとコンパイルerrorになる\n- 強制的に両方のケースを考えることになる！",
    "rust_lesson4_ex9_comment1": "collect で Vec に変換",
    "rust_lesson3_ex10_title": "String と &str",
    "rust_lesson2_ex7_slide1_title": "Option（オプション）?",
    "rust_lesson3_ex9_description": "Vecにelementを追加しましょう。",
    "rust_lesson2_ex5_comment1": "impl でmethodをimplementation",
    "rust_lesson3_ex1_slide3_content": "参照の有効期間を表すライフタイムを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex6_slide2_content": "複数の条件を組み合わせる「&&（かつ）」と「||（または）」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex5_comment1": "filter で条件に合うelementを絞り込む",
    "rust_lesson2_ex7_slide3_content": "値があるかないかを表す「Option」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex10_slide3_title": "Let's Try It!",
    "rust_lesson4_ex4_slide3_title": "Let's Try It!",
    "rust_lesson3_ex3_comment1": "iter でiteratorを取得",
    "rust_lesson3_ex6_slide3_content": "要素を1つの値にまとめるfoldを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex7_slide2_title": "ベクタの番号は「0」から！",
    "rust_lesson1_ex5_slide1_title": "conditional（じょうけんぶんき）?",
    "rust_lesson1_ex3_description": "割り算の「あまり」を求める「%」（パーセント）operatorを学びましょう。",
    "rust_lesson1_ex1_slide3_content": "Rustを使って画面に文字を表示してみましょう。println! という特別な関数を使います。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex10_slide2_content": "# <T> でtypeを「あとで決める」\n\nfunction名の後に `<T>` をつけて、`T` を「type」としてuse。\n\ncodeExample：\n```rust\n// Tはどんな型でもOK\nfn first<T>(arr: &[T]) -> &T {\n    &arr[0]  // 最初の要素を返す\n}\n\n// 使い方\nfirst(&[1, 2, 3]);         // Tはi32\nfirst(&[\"a\", \"b\", \"c\"]);   // Tは&str\n```\n\n読み方：\n- `<T>` → 「Tという名前のtypeをuseよ」\n- `T` は慣習で「Type（type）」の頭文字\n- 複数のtypeが必要なら `<T, U>` のようにwrite",
    "rust_lesson3_ex2_comment1": "|x| でclosureのargumentをdefinition",
    "rust_lesson3_ex3_description": "elementを順番に処理doiteratorを学びましょう。",
    "rust_lesson1_ex1_slide3_title": "Let's Try It!",
    "rust_lesson2_ex6_slide2_title": "enum のdefinition",
    "rust_lesson2_ex1_title": "所有権のBasic",
    "rust_lesson4_ex3_slide1_title": "Box（ボックス）?",
    "rust_lesson2_ex1_slide3_content": "Rust独自の概念「所有権」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex8_slide3_content": "Option/Resultのデフォルト値を設定しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex7_slide2_title": "使用Example",
    "rust_lesson4_ex10_description": "iteratorにindexを付けましょう。",
    "rust_lesson4_ex9_slide1_title": "collect ?",
    "rust_lesson4_ex10_slide2_content": "# 「何番目か」が必要なとき\n\n番号（index）とelementの両方が必要なときに便利です。\n\ncodeExample：\n```rust\nlet v = vec![10, 20, 30];\nfor (idx, val) in v.iter().enumerate() {\n    println!(\"{}番目の値は{}\", idx, val);\n}\n// 0番目の値は10\n// 1番目の値は20\n// 2番目の値は30\n```\n\nPoint：\n- `(i, x)` でtuple（2つのset）を受け取る\n- `i` にindex、`x` にelementが入る\n- indexは0から始まる",
    "rust_lesson3_ex2_description": "周囲のvariableを使えるanonymous function「closure」を学びましょう。",
    "rust_lesson1_ex4_comment1": "mut で変更可能にdo",
    "rust_lesson1_ex8_slide3_title": "Let's Try It!",
    "rust_lesson1_ex3_slide2_content": "割り算の「あまり」を求める「%」（パーセント）演算子を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex9_slide3_title": "Let's Try It!",
    "rust_lesson3_ex3_title": "iteratorのBasic",
    "rust_lesson3_ex9_title": "Vec のmethod push",
    "rust_lesson1_ex8_comment1": "dictionaryをcreate（keyは'みかん'、valueは'オレンジ'）",
    "rust_lesson1_ex2_comment3": "+ でたし算do",
    "rust_lesson4_ex8_slide2_content": "# ジェネリクスの代わり\n\n```rust\nfn print_all(iter: impl Iterator<Item = i32>) {\n    for x in iter {\n        println!(\"{}\", x);\n    }\n}\n```",
    "rust_lesson2_ex2_slide2_title": "reference Usage",
    "rust_lesson1_ex8_slide3_content": "「辞書（HashMap）」を使うと、名前をつけてデータを保存し、その名前で取り出せます。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex7_slide2_content": "# [ ]で番号を指定して取り出す\n\n`[番号]` で何番目のデータか指定して取り出せます。\n\nImportantなルール：番号は「0」から！\n- 1番目 → `[0]`\n- 2番目 → `[1]`\n- 3番目 → `[2]`\n\ncodeExample：\n```rust\nlet fruits = vec![\"りんご\", \"バナナ\", \"みかん\"];\n//                  ↑0番    ↑1番     ↑2番\nprintln!(\"{}\", fruits[0]);  // りんご\nprintln!(\"{}\", fruits[1]);  // バナナ\n```\n\nプログラミングでは「0から数える」のが世界共通のルールです！",
    "rust_lesson1_ex6_slide1_title": "条件を組み合わせる",
    "rust_lesson2_ex10_slide2_title": "ジェネリックfunction Syntax",
    "rust_lesson1_ex6_description": "複数の条件を組み合わせる「&&（かつ）」と「||（Alsoは）」を学びましょう。",
    "rust_lesson4_ex6_title": "HashSet",
    "rust_lesson2_ex3_slide2_content": "# mut が2か所に必要\n\n変更できるようにdoには、variableとreferenceの両方に `mut` が必要です。\n\ncodeExample：\n```rust\n// 1. 変数を mut で作る\nlet mut s = String::from(\"hello\");\n\n// 2. &mut で可変参照を渡す\nchange(&mut s);\n\nfn change(s: &mut String) {\n    s.push_str(\" world\");  // 変更できる！\n}\n```\n\nPoint：\n- `let mut 変数` でvariableを変更可能に\n- `&mut 変数` で可変referenceをcreate\n- 両方ないと変更できない！",
    "rust_lesson2_ex2_slide1_title": "reference（さんしょう）?",
    "rust_lesson3_ex6_slide2_content": "# 合計、積、結合など\n\n```rust\n// 積\nv.iter().fold(1, |acc, x| acc * x)\n\n// 文字列結合\nwords.iter().fold(String::new(), |acc, s| acc + s)\n```",
    "rust_lesson1_ex1_description": "Rustを使ってscreenに文字をdisplayしてみましょう。println! という特別なfunctionをuse。",
    "rust_lesson3_ex8_slide3_title": "Let's Try It!",
    "rust_lesson4_ex6_description": "一意なvalueのsetを管理しましょう。",
    "rust_lesson2_ex5_slide1_title": "impl ?",
    "rust_lesson1_ex8_title": "名前で引き出す「dictionary」",
    "rust_lesson2_ex7_description": "valueがあるかないかを表す「Option」を学びましょう。",
    "rust_lesson1_ex4_slide2_title": "Let's Try It!",
    "rust_lesson1_ex7_title": "たくさんのデータをまとめましょう「ベクタ」",
    "rust_lesson3_ex7_slide1_content": "# errorの早期リターン\n\n? は、Resultが Err の場合に早期リターンします。\n\n```rust\nfn read_file() -> Result<String, io::Error> {\n    let content = fs::read_to_string(\"file.txt\")?;\n    Ok(content)\n}\n```",
    "rust_lesson3_ex9_slide1_content": "# 末尾に追加\n\npush は、Vecの末尾にelementをadd。\n\n```rust\nlet mut v = vec![1, 2];\nv.push(3);\n// [1, 2, 3]\n```",
    "rust_lesson4_ex8_slide3_content": "トレイトを返す関数を簡潔に書きましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex1_title": "screenにメッセージを出しましょう",
    "rust_lesson2_ex8_slide2_title": "Result  Usage",
    "rust_lesson3_ex2_slide1_title": "closure?",
    "rust_lesson3_ex8_title": "unwrap_or でデフォルトvalue",
    "rust_lesson4_ex10_slide1_content": "# 番号とelementを一緒にもらう\n\nenumerate は、「何番目か」と「そのelement」をsetで取り出せるmethodです。\n\nFor example：\n- 0番目: りんご\n- 1番目: バナナ\n- 2番目: みかん\n\ncodeExample：\n```rust\nfor (i, x) in vec![\"a\", \"b\", \"c\"].iter().enumerate() {\n    println!(\"{}: {}\", i, x);\n}\n// 0: a\n// 1: b\n// 2: c\n```",
    "rust_lesson1_ex7_slide1_content": "# データを並べてまとめる「長い箱」\n\nベクタ（Vec） は、たくさんのデータを順番に並べて入れられる「長い箱」です。\n\nFor example：\n- 買い物listの商品を全部まとめる\n- testの点数を全部まとめる\n- 友だちの名前を全部まとめる\n\n100個でも1000個でも、1つのvariableでまとめて管理できます！\n\n作り方：\n```rust\nlet fruits = vec![\"りんご\", \"バナナ\", \"みかん\"];\n// vec! で ベクタを作る\n```",
    "rust_lesson4_ex8_slide3_title": "Let's Try It!",
    "rust_lesson4_ex7_description": "パターンマッチに条件を追加しましょう。",
    "rust_lesson1_ex4_comment2": "+= で 20 を足す",
    "rust_lesson1_ex2_comment2": "y に 5 を入れる",
    "rust_lesson2_ex3_slide3_title": "Let's Try It!",
    "rust_lesson3_ex4_slide1_title": "map（map）?",
    "rust_lesson1_ex2_slide3_content": "データに名前をつけて保存できる「変数（へんすう）」を使ってみましょう。letで変数を作ります。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex8_slide2_content": "# match で成功と失敗を分ける\n\n`match` で「成功したら」「失敗したら」の処理を書き分けます。\n\ncodeExample：\n```rust\nfn divide(a: i32, b: i32) -> Result<i32, String> {\n    if b == 0 {\n        return Err(\"0で割れません\".to_string());\n    }\n    Ok(a / b)  // 成功なら答えを返す\n}\n\nmatch divide(10, 2) {\n    Ok(v) => println!(\"答えは{}\", v),\n    Err(e) => println!(\"エラー: {}\", e),\n}\n```\n\nPoint：\n- `Ok(値)` で成功をreturn\n- `Err(エラー)` で失敗をreturn",
    "rust_lesson4_ex3_comment1": "Box::new でheapに格納",
    "rust_lesson4_ex8_description": "トレイトをreturnfunctionを簡潔に書きましょう。",
    "rust_lesson2_ex10_description": "typeを後から決められる「ジェネリクス」を学びましょう。",
    "rust_lesson2_ex3_slide1_title": "可変reference（かへんさんしょう）?",
    "rust_lesson2_ex2_description": "所有権を移さずにvalueを借りる「reference」を学びましょう。",
    "rust_lesson3_ex5_slide2_title": "** にNote！",
    "rust_lesson2_ex2_slide3_title": "Let's Try It!",
    "rust_lesson4_ex3_slide3_content": "ヒープにデータを格納するBoxを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex4_title": "累算assignmentoperator（+=、-=）",
    "rust_lesson3_ex3_slide2_content": "# 借りるか、もらうか\n\n3種類の iter があり、所有権の扱いが違います。\n\n3つの違い：\n```rust\nv.iter()       // 参照で借りる（&T）\nv.iter_mut()   // 変更可能で借りる（&mut T）\nv.into_iter()  // 所有権をもらう（T）\n```\n\n使い分け：\n- `iter()` → 見るだけ（元のベクタも使える）\n- `iter_mut()` → 中身を変更したい\n- `into_iter()` → ベクタごともらう（元は使えない）\n\n普通は `iter()` をuseことが多いです。",
    "rust_lesson2_ex1_slide1_title": "所有権（しょゆうけん）?",
    "rust_lesson4_ex6_slide3_content": "一意な値の集合を管理しましょう。\n\n（When you're ready, select \"Start Lesson\".）"
  },
  "fi": {
    "rust_lesson1_course_title": "Introduction to Rust",
    "rust_lesson1_course_description": "Learn the basics of Rust programming.",
    "rust_lesson2_course_title": "Rust II - Intermediate",
    "rust_lesson2_course_description": "Learn intermediate Rust concepts.",
    "rust_lesson3_course_title": "Rust III - Advanced",
    "rust_lesson3_course_description": "Master advanced Rust techniques.",
    "rust_lesson4_course_title": "Rust IV - Expert Level",
    "rust_lesson4_course_description": "Expert-level Rust programming.",
    "rust_lesson1_ex5_slide2_content": "条件によって動きを変える if文を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex9_title": "collect で変換",
    "rust_lesson2_ex7_slide1_content": "# 「あるかもしれない、ないかもしれない」\n\nOption<T> は、valueが「あるかもしれないし、ないかもしれない」ことを表すtypeです。\n\nFor example：\n- dictionaryで単語を探す → 見つかるかもしれないし、ないかもしれない\n- ゲームでアイテムを拾う → 落ちてるかもしれないし、ないかもしれない\n\n2つの状態：\n- `Some(値)` → valueがある！\n- `None` → valueがない...\n\n他の言語では `null` をuseが、Rustでは `Option` で安全に扱います。",
    "rust_lesson1_ex2_slide1_title": "variable（へんすう）?",
    "rust_lesson1_ex7_description": "「ベクタ（Vec）」をuseと、たくさんのデータを一つの「長い はこ」にまとめて入れられます。",
    "rust_lesson2_ex9_slide2_content": "# 約束を作って、守る\n\n1. `trait` で「約束」をdefinition\n2. `impl トレイト for 型` で「約束を守る」implementationをdo\n\ncodeExample：\n```rust\n// 1. トレイト（約束）を定義\ntrait Speak {\n    fn speak(&self);  // 鳴くメソッドを持つ約束\n}\n\n// 2. Dog構造体がトレイトを実装\nstruct Dog;\nimpl Speak for Dog {\n    fn speak(&self) {\n        println!(\"woof\");\n    }\n}\n```\n\n「DogはSpeakができる」ということになります。",
    "rust_lesson4_ex4_description": "referenceカウントでデータを共有しましょう。",
    "rust_lesson4_ex5_slide1_content": "# 名前で引ける「dictionary」\n\nHashMap は、「key（名前）」と「value（データ）」をsetで保存dodictionaryです。\n\nFor example：\n- 「青チーム」→ 10点\n- 「赤チーム」→ 15点\n\ncodeExample：\n```rust\nuse std::collections::HashMap;\n\nlet mut scores = HashMap::new();\nscores.insert(\"Blue\", 10);   // 追加\nscores.insert(\"Red\", 15);    // 追加\n```\n\n`use` で機能を読み込んでからuse。",
    "rust_lesson3_ex4_title": "map でiterator変換",
    "rust_lesson4_ex1_slide3_content": "共通の振る舞いを定義するトレイトを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex4_description": "variableのvalueを手軽に増やしたり減らしたりdo「+=」「-=」を学びましょう。",
    "rust_lesson1_ex2_description": "データに名前をつけて保存できる「variable（へんすう）」を使ってみましょう。letでvariableをcreate。",
    "rust_lesson4_ex4_slide2_title": "referenceカウントの仕組み",
    "rust_lesson3_ex8_slide2_title": "unwrap_or_else",
    "rust_lesson4_ex10_comment1": "1番目の i にindex、2番目の item にelementが入る",
    "rust_lesson3_ex6_slide1_content": "# 累積処理\n\nfold は、初期valueとfunctionでelementを1つずつ畳み込みます。\n\n```rust\nlet v = vec![1, 2, 3];\nlet sum = v.iter().fold(0, |acc, x| acc + x);\n// 6\n```",
    "rust_lesson4_ex2_slide2_title": "よくuse derive トレイト",
    "rust_lesson3_ex10_slide3_content": "文字列型の違いを理解しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex4_slide2_content": "変数の値を手軽に増やしたり減らしたりする「+=」「-=」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex4_slide3_title": "Let's Try It!",
    "rust_lesson3_ex5_slide1_title": "filter（filterー）?",
    "rust_lesson4_ex5_description": "keyとvalueのpairを格納しましょう。",
    "rust_lesson3_ex5_description": "条件に合うelementだけを取り出しましょう。",
    "rust_lesson2_ex2_slide2_content": "# functionに借りてもらう\n\nfunctionにデータを渡すとき、`&` をつけると「借りる」形になります。元のvariableはそのまま使い続けられます。\n\ncodeExample：\n```rust\nfn calc_len(s: &String) -> usize {\n    s.len()  // 長さを返す\n}\n\nfn main() {\n    let text = String::from(\"hello\");\n    let len = calc_len(&text);  // textを貸す\n    // text はまだ使える！\n    println!(\"{}の長さは{}\", text, len);\n}\n```\n\n`&String` は「Stringを借りる」という意味です。",
    "rust_lesson4_ex7_slide3_content": "パターンマッチに条件を追加しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex8_slide2_content": "# 遅延評価\n\n```rust\n// クロージャで計算\nlet value = x.unwrap_or_else(|| expensive_computation());\n```",
    "rust_lesson4_ex7_title": "match ガード",
    "rust_lesson3_ex7_title": "? operatorでerror伝播",
    "rust_lesson4_ex1_description": "共通の振る舞いをdefineトレイトを学びましょう。",
    "rust_lesson2_ex1_slide2_content": "# 所有権は「移動」do\n\nvariableを別のvariableにassignmentdoと、所有権が 移動（ムーブ） します。元のvariableは使えなくなります。\n\ncodeExample：\n```rust\nlet s1 = String::from(\"hello\");  // s1 が持ち主\nlet s2 = s1;  // 所有権が s2 に移動！\n// ↓ s1 はもう使えない（エラーになる）\n// println!(\"{}\", s1);  // ダメ！\nprintln!(\"{}\", s2);  // OK！\n```\n\nイメージ：\nおもちゃを友だちにあげたら、自分はもう使えない。これがムーブです。",
    "rust_lesson1_ex8_slide1_title": "dictionary（HashMap）?",
    "rust_lesson4_ex3_slide2_content": "# サイズが決まらないとき\n\nBoxは、コンパイル時にサイズがわからないtypeにuse。\n\nFor examplerecursion的なtype：\n```rust\n// リストは「値 + 次のリスト」の繰り返し\nenum List {\n    Cons(i32, Box<List>),  // Boxで次を指す\n    Nil,                   // 終わり\n}\n```\n\nなぜBoxが必要？\n- `List` の中に `List` がある → 無限に大きくなる？\n- `Box` をuseと、サイズが固定（pointerのサイズ）になる\n\n「中身」ではなく「中身への矢印」を持つイメージです。",
    "rust_lesson2_ex10_title": "ジェネリクスを使おう",
    "rust_lesson2_ex8_slide3_title": "Let's Try It!",
    "rust_lesson3_ex9_slide2_content": "# 可変reference\n\n```rust\n// mut が必要\nlet mut v = Vec::new();\nv.push(1);\nv.push(2);\n```",
    "rust_lesson4_ex4_title": "Rc<T>",
    "rust_lesson2_ex3_comment1": "mut で可変variableにdo",
    "rust_lesson4_ex5_slide3_title": "Let's Try It!",
    "rust_lesson2_ex6_slide2_content": "# バリアントを列挙\n\n`enum 名前 { バリアント1, バリアント2, ... }` でdefine。\n\ncodeExample：\n```rust\nenum Color {\n    Red,\n    Green,\n    Blue,\n}\nlet c = Color::Red;\n```",
    "rust_lesson1_ex1_comment1": "Hello, Rust! とdisplay",
    "rust_lesson1_ex1_slide1_content": "# 安全で速い！最新のプログラミング言語\n\nRust（ラスト）は、「間違いを事前に防ぐ」ことがとても得意なプログラミング言語です。\n\nRustのすごいところ：\n- programのミスをexecute前に見つけてくれる\n- とても速く動く\n- 世界中のプログラマーが「一番好き！」と選ぶ人気の言語\n\nたとえるなら：\n厳しいけど優しい先生のような言語です。「ここ間違ってるよ」と教えてくれるので、安心してprogramが書けます！",
    "rust_lesson3_ex8_slide1_content": "# None/Err の場合のデフォルト\n\nunwrap_or は、None や Err の場合にデフォルトvalueをreturn。\n\n```rust\nlet x: Option<i32> = None;\nlet value = x.unwrap_or(0);  // 0\n```",
    "rust_lesson2_ex7_slide3_title": "Let's Try It!",
    "rust_lesson2_ex6_title": "enum で状態を表す",
    "rust_lesson2_ex8_slide1_content": "# 「成功」か「失敗」かを表す\n\nResult<T, E> は、処理が「成功したか失敗したか」を表すtypeです。\n\nFor example：\n- fileをopen → 成功（内容）か失敗（error）\n- 0で割り算 → 成功（答え）か失敗（0で割れない！）\n\n2つの状態：\n- `Ok(値)` → 成功！valueが入っている\n- `Err(エラー)` → 失敗...error情報が入っている\n\n`Option` は「あるか・ないか」、`Result` は「成功か・失敗か」という違いです。",
    "rust_lesson2_ex8_slide3_content": "成功と失敗を表す「Result」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex6_slide1_title": "HashSet ?",
    "rust_lesson3_ex9_comment1": "push でelementを追加",
    "rust_lesson2_ex7_slide2_title": "Option  Usage",
    "rust_lesson3_ex2_title": "closureのBasic",
    "rust_lesson3_ex7_slide1_title": "? operator?",
    "rust_lesson4_ex6_comment1": "HashSet をimport",
    "rust_lesson2_ex10_slide1_content": "# どんなtypeでも使える「万能」の仕組み\n\nジェネリクス は、typeを後から決められる仕組みです。\n\nなぜ便利？\n同じようなfunctionを何度も書かなくてすみます。\n\nFor example：\n- 数字のarrayの最初のelementを取るfunction\n- stringのarrayの最初のelementを取るfunction\n\n両方とも「最初のelementを取る」のは同じなのに、typeが違うだけで別のfunctionをwriteのは大変！\n\nジェネリクスなら、`<T>` で「typeは後で決める」とwriteだけで、どんなtypeでも使えるfunctionが作れます。",
    "rust_lesson1_ex3_slide1_content": "# 剰余operator（じょうよえんざんし）「%」\n\n`%`（パーセント）は、割り算の 「あまり」 をcalculate特別な記号です。\n\nわかりやすいExample：\n- 10このアメを3人で分けると？\n- 1人3こずつで、1こあまる\n- これを `10 % 3` とwriteと、答えは `1`\n\ncodeExample：\n```rust\nprintln!(\"{}\", 10 % 3);  // 1（あまり1）\nprintln!(\"{}\", 8 % 4);   // 0（あまりなし＝割り切れる）\n```\n\n使いどころ：\n- 偶数か奇数か調べる（`n % 2` が0なら偶数）\n- 時計の計算（24を超えたら0に戻る、など）",
    "rust_lesson3_ex7_description": "errorを簡潔に伝播させましょう。",
    "rust_lesson3_ex8_comment1": "unwrap_or でデフォルトvalueを設定",
    "rust_lesson2_ex8_title": "Result<T, E> でerror処理",
    "rust_lesson2_ex10_comment1": "T をtypeパラメータとしてuse",
    "rust_lesson2_ex6_comment1": "enum で列挙typeをdefinition",
    "rust_lesson3_ex3_slide3_content": "要素を順番に処理するイテレータを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex2_comment1": "derive でトレイトを自動implementation",
    "rust_lesson1_ex8_slide1_content": "# 名前でsearchできる「dictionary」\n\nHashMap（ハッシュmap）は、「名前」と「データ」をsetにして保存できる仕組みです。本物のdictionaryのように使えます。\n\nFor example果物の色dictionary：\n- 「りんご」→「あか」\n- 「バナナ」→「きいろ」\n- 「みかん」→「オレンジ」\n\nuse準備：\n```rust\nuse std::collections::HashMap;  // 機能を読み込む\nlet mut fruits = HashMap::new();  // 空の辞書を作る\nfruits.insert(\"りんご\", \"あか\");  // データを追加\n```\n\n`use` は「この機能をuseよ」というdeclarationです。",
    "rust_lesson3_ex9_slide1_title": "push ?",
    "rust_lesson4_ex1_title": "トレイトのdefinition",
    "rust_lesson4_ex3_description": "heapにデータを格納doBoxを学びましょう。",
    "rust_lesson1_ex2_title": "便利な「はこ」variable（へんすう）",
    "rust_lesson1_ex8_comment2": "中身を出す",
    "rust_lesson3_ex9_slide3_title": "Let's Try It!",
    "rust_lesson1_ex4_comment3": "-= で 50 を引く",
    "rust_lesson1_ex6_comment1": "&& で両方の条件をチェック",
    "rust_lesson4_ex1_slide2_title": "トレイトのimplementation",
    "rust_lesson4_ex7_slide3_title": "Let's Try It!",
    "rust_lesson4_title": "Rust IV - トレイトとスマートpointer",
    "rust_lesson4_ex1_comment1": "trait でトレイトをdefinition",
    "rust_lesson4_ex4_slide1_content": "# 複数の「持ち主」を許可do仕組み\n\nRc<T> は「Reference Counted（referenceカウント）」の略で、複数の所有者でデータを共有できます。\n\n普通の所有権：\n1人だけが持ち主。渡したら元の人は使えない。\n\nRc をuseと：\n複数人が同じデータの「持ち主」になれる！\n\ncodeExample：\n```rust\nuse std::rc::Rc;\n\nlet a = Rc::new(5);       // Rcでラップ\nlet b = Rc::clone(&a);    // bも持ち主になる\n// a も b も使える！\n```",
    "rust_lesson3_ex5_slide1_content": "# 条件に合うものだけ残す\n\nfilter は、条件を満たすelementだけを残し、他を捨てます。\n\nFor example：\n- 80点以上の人だけ残す\n- 偶数だけ残す\n- 「あ」から始まる名前だけ残す\n\ncodeExample：\n```rust\nlet v = vec![1, 2, 3, 4, 5];\nlet evens: Vec<_> = v.iter()\n    .filter(|x| **x % 2 == 0)  // 偶数だけ\n    .collect();\n// [2, 4]\n```\n\n条件が `true` のelementだけが残ります。",
    "rust_lesson3_ex7_slide3_title": "Let's Try It!",
    "rust_lesson1_ex7_comment2": "2番目のデータ（1番）を出す",
    "rust_lesson4_ex8_title": "impl Trait",
    "rust_lesson1_ex5_description": "条件によって動きを変える if文を学びましょう。",
    "rust_lesson3_ex4_slide2_title": "遅延評価（ちえんひょうか）",
    "rust_lesson3_ex1_slide1_content": "# referenceの「寿命」を示す印\n\nライフタイム は、referenceがいつまで使えるかを示す印です。`'a`（アポストロフィ・エー）のようにwrite。\n\nなぜ必要？\nreferenceは「借りている」状態。借りた元のデータが消えたら、referenceも使えなくなります。\n\nFor example：\n- 図書館で借りた本 → 図書館が閉まったら読めない\n- referenceで借りたデータ → 元のデータが消えたら使えない\n\nライフタイムは「このreferenceはこの範囲で有効だよ」とコンパイラに伝える仕組みです。",
    "rust_lesson1_ex1_slide1_title": "Rust（ラスト）?",
    "rust_lesson1_ex2_slide2_title": "計算の記号（operator）",
    "rust_lesson4_ex5_slide2_content": "# get で安全に取り出す\n\n`get()` methodでvalueを取り出せます。見つからない可能性があるので、`Option` が返ってきます。\n\ncodeExample：\n```rust\n// getはOption<&V>を返す\nif let Some(score) = scores.get(\"Blue\") {\n    println!(\"青チームは{}点\", score);\n}\n```\n\nPoint：\n- keyがあれば `Some(値)` が返る\n- keyがなければ `None` が返る\n- `if let` で安全に取り出せる\n\n存在しないkeyでアクセスしてもprogramが落ちない！",
    "rust_lesson4_ex7_slide1_title": "match ガード?",
    "rust_lesson3_title": "Rust III - ライフタイムとiterator",
    "rust_lesson4_ex3_title": "Box<T>",
    "rust_lesson1_ex4_slide1_title": "累算assignmentoperator（るいさんだいにゅう）?",
    "rust_lesson2_ex9_comment1": "trait でトレイトをdefinition",
    "rust_lesson2_ex1_description": "Rust独自の概念「所有権」を学びましょう。",
    "rust_lesson2_ex3_slide3_content": "参照先の値を変更できる「可変参照」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex1_slide3_title": "Let's Try It!",
    "rust_lesson3_ex6_slide2_title": "様々な畳み込み",
    "rust_lesson4_ex9_slide3_title": "Let's Try It!",
    "rust_lesson2_ex5_title": "impl でmethodを追加",
    "rust_lesson2_ex6_slide1_content": "# 複数の選択肢\n\nenum は、valueがいくつかの種類のうちの一つであることを表します。各バリアントにデータを持たせることもできます。",
    "rust_lesson2_ex4_comment1": "struct で構造体をdefinition",
    "rust_lesson1_ex3_title": "剰余operator（%）",
    "rust_lesson1_ex7_comment1": "colors というベクタをcreate（'あか', 'あお'の順）",
    "rust_lesson1_ex4_slide1_content": "# valueをかんたんに増やす・減らす\n\n`+=`（プラスイコール）と `-=`（マイナスイコール）は、variableの中身を増やしたり減らしたりdo便利な記号です。\n\nRustのImportantなルール：`mut`が必要！\nRustでは、variableをchangeには `let mut`（レット ミュート）とwrite必要があります。`mut` は「mutable（変更できる）」の略です。\n\ncodeExample：\n```rust\nlet mut score = 100;  // mut をつけて変更可能に\nscore += 10;          // 10を足す → 110に\nscore -= 50;          // 50を引く → 60に\n```\n\n`mut` がないと「このvariableは変えちゃダメ！」とRustが怒ります。",
    "rust_lesson2_ex1_slide2_title": "ムーブ（移動）",
    "rust_lesson3_ex4_comment1": "map で各elementを変換",
    "rust_lesson3_ex8_slide1_title": "unwrap_or ?",
    "rust_lesson2_ex5_slide1_content": "# implementationブロック\n\nimpl ブロックで、構造体にmethodを追加できます。`self` で自分自身をreferenceします。",
    "rust_lesson2_ex10_slide1_title": "ジェネリクス?",
    "rust_lesson1_ex8_slide2_content": "# 名前（key）で取り出す\n\ndictionaryに入れたデータは、名前（key）を指定して取り出せます。\n\ncodeExample：\n```rust\nuse std::collections::HashMap;\nfn main() {\n    let mut fruits = HashMap::new();\n    fruits.insert(\"りんご\", \"あか\");  // 追加\n    fruits.insert(\"バナナ\", \"きいろ\");  // 追加\n    \n    println!(\"{}\", fruits[\"りんご\"]);  // あか と表示\n}\n```\n\nPoint：\n- `insert(名前, データ)` で追加\n- `辞書[名前]` で取り出し\n- 番号ではなく「名前」で探せるのが便利！",
    "rust_lesson4_ex9_slide1_content": "# iteratorをコレクションに\n\ncollect は、iteratorをVecやHashMapなどに変換します。\n\n```rust\nlet v: Vec<_> = (0..5).collect();\nlet s: String = vec!['a', 'b'].into_iter().collect();\n```",
    "rust_lesson2_ex2_slide3_content": "所有権を移さずに値を借りる「参照」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex2_slide3_content": "周囲の変数を使える無名関数「クロージャ」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex4_slide2_content": "# struct keyワードでdefinition\n\n`struct 名前 { フィールド }` で構造体をdefine。フィールドには名前とtypeをwrite。\n\ncodeExample：\n```rust\n// Point 構造体を定義\nstruct Point {\n    x: i32,  // xフィールド（整数）\n    y: i32,  // yフィールド（整数）\n}\n\n// 使い方\nlet p = Point { x: 10, y: 20 };\nprintln!(\"x={}, y={}\", p.x, p.y);\n```\n\nPoint：\n- `struct 名前` で構造体をcreate\n- `{ フィールド名: 型 }` でどんなデータを持つか決める\n- `.フィールド名` でアクセス",
    "rust_lesson2_ex10_slide3_content": "型を後から決められる「ジェネリクス」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex6_slide3_title": "Let's Try It!",
    "rust_lesson4_ex6_slide1_content": "# 一意なvalueのset\n\nHashSet は、重複のないvalueのsetです。\n\n```rust\nuse std::collections::HashSet;\n\nlet mut set = HashSet::new();\nset.insert(1);\nset.insert(2);\nset.insert(1); // 重複は無視\n```",
    "rust_lesson4_ex2_title": "derive 属性",
    "rust_lesson4_ex2_slide1_content": "# トレイトを「自動で」implementation\n\n#[derive(...)] をuseと、よくuseトレイトを自分で書かなくても自動でimplementationしてくれます。\n\nFor example：\n構造体を `println!` でdisplayしたいとき、普通は Display トレイトをimplementationdo必要がありますが、`#[derive(Debug)]` をwriteだけでOK！\n\ncodeExample：\n```rust\n#[derive(Debug)]  // Debug トレイトを自動実装\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nlet p = Point { x: 1, y: 2 };\nprintln!(\"{:?}\", p);  // Point { x: 1, y: 2 }\n```",
    "rust_lesson1_ex6_slide2_title": "Let's Try It!",
    "rust_lesson3_ex3_slide2_title": "3つの iter method",
    "rust_lesson4_ex7_slide2_content": "# 複雑なconditional\n\n```rust\nmatch Some(5) {\n    Some(x) if x % 2 == 0 => println!(\"even\"),\n    Some(x) => println!(\"odd: {}\", x),\n    None => println!(\"none\"),\n}\n```",
    "rust_lesson3_ex3_slide1_content": "# elementを1つずつ取り出す仕組み\n\niterator は、ベクタなどのデータを「1つずつ順番に」取り出す仕組みです。\n\nFor example：\n- 行列に並んでいる人を1人ずつ呼ぶ\n- 引き出しの中身を1つずつ出す\n\ncodeExample：\n```rust\nlet v = vec![1, 2, 3];\nfor x in v.iter() {\n    println!(\"{}\", x);  // 1, 2, 3 と順番に表示\n}\n```\n\n`iter()` で「順番に取り出す準備」をして、`for` で1つずつ処理します。",
    "rust_lesson3_ex3_slide1_title": "iterator?",
    "rust_lesson4_ex2_description": "トレイトを自動implementationdoderiveを学びましょう。",
    "rust_lesson3_ex4_slide1_content": "# 全部を同じように変換do\n\n**map** は、iteratorの各elementを「同じ方法で」変換します。\n\nFor example：\n- 全員の身長を2倍にdo\n- 全員の名前を大文字にdo\n- 全部の数を2乗do\n\ncodeExample：\n```rust\nlet v = vec![1, 2, 3];\nlet doubled: Vec<_> = v.iter()\n    .map(|x| x * 2)  // 各要素を2倍に\n    .collect();      // ベクタに戻す\n// [2, 4, 6]\n```\n\n`|x| x * 2` は「xを受け取って、x*2をreturn」closureです。",
    "rust_lesson1_ex3_slide1_title": "あまりを求める",
    "rust_lesson3_ex10_slide1_content": "# 所有権の違い\n\nString は所有権を持つheap上のstring、&str はreferenceです。\n\n```rust\nlet s1: String = String::from(\"hello\");\nlet s2: &str = \"hello\";\n```",
    "rust_lesson4_ex2_slide1_title": "derive（デライブ）?",
    "rust_lesson2_ex2_comment1": "& でreferenceを渡す",
    "rust_lesson4_ex5_slide1_title": "HashMap（ハッシュmap）?",
    "rust_lesson2_ex3_slide2_title": "&mut  Usage",
    "rust_lesson3_ex5_title": "filter で絞り込み",
    "rust_lesson4_ex3_slide2_title": "いつuse？",
    "rust_lesson2_ex2_title": "referenceと借用",
    "rust_lesson2_ex7_title": "Option<T> で null を安全に",
    "rust_lesson4_ex10_slide3_title": "Let's Try It!",
    "rust_lesson3_ex5_slide3_title": "Let's Try It!",
    "rust_lesson4_ex10_title": "enumerate でindex付き",
    "rust_lesson2_ex2_slide1_content": "# 所有権を渡さずに「借りる」\n\nreference をuseと、所有権を移さずにデータを「見せてもらう」ことができます。\n\nたとえるなら：\n- ムーブ = おもちゃをあげる（自分は使えない）\n- reference = おもちゃを見せる（自分も使える）\n\n作り方：\n`&`（アンパサンド）をつけるとreferenceを作れます。\n\n```rust\nlet s = String::from(\"hello\");\nlet r = &s;  // sを借りる（見せてもらう）\n// s も r も使える！\n```",
    "rust_lesson2_ex5_slide2_content": "# &self をuse\n\nmethodの最初のargumentは `&self` です。\n\ncodeExample：\n```rust\nimpl Rect {\n    fn area(&self) -> i32 {\n        self.width * self.height\n    }\n}\n```",
    "rust_lesson1_ex5_slide2_title": "Let's Try It!",
    "rust_lesson2_ex4_slide3_title": "Let's Try It!",
    "rust_lesson4_ex3_slide3_title": "Let's Try It!",
    "rust_lesson2_ex9_slide3_content": "共通の振る舞いを定義する「トレイト」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex1_slide2_content": "# impl で約束を守る\n\n構造体にトレイトをimplementationdoと、その構造体は「約束を守る」ことになります。\n\ncodeExample：\n```rust\nstruct Person { name: String }\n\nimpl Greet for Person {\n    fn greet(&self) -> String {\n        format!(\"Hello, {}\", self.name)\n    }\n}\n```\n\n読み方：\n- `impl Greet for Person` → 「PersonはGreetをimplementationdo」\n- これでPersonは「あいさつできる」ようになった！",
    "rust_lesson4_ex4_comment1": "clone でreferenceカウントを増やす",
    "rust_lesson3_ex4_slide2_content": "# map だけではexecuteされない！\n\nRustのiteratorは 遅延評価 といって、「本当に必要になるまで処理しない」仕組みです。\n\nなぜ？\n無駄な計算を省けるから。100万件あっても、最初の10件だけ欲しいなら10件だけ処理すればいい。\n\ncollect() でexecute：\n```rust\n// これだけでは何も起きない\nv.iter().map(|x| x * 2);\n\n// collect() で実行してベクタに変換\nlet result: Vec<_> = v.iter().map(|x| x * 2).collect();\n```\n\n`collect()` は「今すぐ全部処理してResultをちょうだい」という意味です。",
    "rust_lesson2_ex4_slide2_title": "struct のdefinitionのしかた",
    "rust_lesson2_ex3_slide1_content": "# 「書き換えできる」借り方\n\n普通のreference `&` は「見るだけ」ですが、可変reference `&mut` は「変更もできる」借り方です。\n\nたとえるなら：\n- `&` = 本を見せてもらう（readだけ）\n- `&mut` = ノートを借りる（writeOK）\n\nImportantなルール：\n- 可変referenceは同時に1つだけ！\n- 「みんなで見る」か「1人でwrite」かのどちらか\n\nこのルールで、データが同時に書き換えられるバグを防いでいます。",
    "rust_lesson2_ex10_slide3_title": "Let's Try It!",
    "rust_lesson2_ex4_title": "構造体をdefinitionしよう",
    "rust_lesson3_ex10_slide2_content": "# 相互変換\n\n```rust\n// &str -> String\nlet s = \"hello\".to_string();\n\n// String -> &str\nlet slice: &str = &s;\n```",
    "rust_lesson4_ex10_slide3_content": "イテレータにインデックスを付けましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex4_slide2_content": "# 「何人が持っているか」を数える\n\nRcは「今何人がこのデータを持っているか」を数えています。\n\ncodeExample：\n```rust\nlet a = Rc::new(5);\nprintln!(\"{}\", Rc::strong_count(&a));  // 1\n\nlet b = Rc::clone(&a);\nprintln!(\"{}\", Rc::strong_count(&a));  // 2\n```\n\nいつデータが消える？\n- カウントが0になったとき（誰も持っていないとき）\n- 最後の持ち主がいなくなると自動で片付けられる\n\n`Rc::clone` は「持ち主を1人増やす」操作です。",
    "rust_lesson1_ex8_slide2_title": "dictionary Usage",
    "rust_lesson4_ex3_slide1_content": "# データを「heap」に置く箱\n\nBox<T> は、データを「heap」という特別な場所に置くための箱です。\n\nmemoryの2つの場所：\n- stack：小さくて速い。サイズが決まっているデータ向け\n- heap：大きくて柔軟。サイズが大きいor変わるデータ向け\n\ncodeExample：\n```rust\nlet b = Box::new(5);  // 5をヒープに置く\nprintln!(\"{}\", *b);   // *で中身を取り出す → 5\n```\n\n`*` は「箱を開けて中身を見る」操作です。",
    "rust_lesson3_ex2_slide2_title": "closure Syntax",
    "rust_lesson4_ex4_slide1_title": "Rc（アールシー）?",
    "rust_lesson4_ex7_slide1_content": "# 追加条件\n\n**if** でパターンに追加条件をつけられます。\n\n```rust\nmatch x {\n    n if n < 0 => println!(\"negative\"),\n    n if n > 0 => println!(\"positive\"),\n    _ => println!(\"zero\"),\n}\n```",
    "rust_lesson2_ex3_title": "可変reference",
    "rust_lesson3_ex10_comment1": "to_string で String に変換",
    "rust_lesson3_ex10_slide2_title": "変換",
    "rust_lesson3_ex1_description": "referenceの有効期間を表すライフタイムを学びましょう。",
    "rust_lesson3_ex2_slide1_content": "# 名前のない「即席」function\n\nclosure は、名前をつけずにその場でcreatefunctionです。そして特別な能力があります：周りのvariableを使えるのです！\n\nFor example：\n```rust\nlet x = 5;  // 外側の変数\nlet add_x = |n| n + x;  // xを使えるクロージャ\nprintln!(\"{}\", add_x(10));  // 15\n```\n\n普通のfunctionとの違い：\n- 普通のfunction：argumentしか使えない\n- closure：argument + 周りのvariableも使える\n\n「その場の空気を読める」functionというイメージです！",
    "rust_lesson1_ex2_comment1": "x に 10 を入れる",
    "rust_lesson1_ex7_slide3_title": "Let's Try It!",
    "rust_lesson1_ex5_title": "「もし〜なら」で分けましょう",
    "rust_lesson3_ex2_slide3_title": "Let's Try It!",
    "rust_lesson3_ex7_slide2_content": "# 簡潔なerror処理\n\n```rust\n// ? を使わない場合\nmatch result {\n    Ok(v) => v,\n    Err(e) => return Err(e),\n}\n\n// ? を使う\nresult?\n```",
    "rust_lesson3_ex6_slide3_title": "Let's Try It!",
    "rust_lesson4_ex9_slide3_content": "イテレータをコレクションに変換しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex6_description": "elementを1つのvalueにまとめるfoldを学びましょう。",
    "rust_lesson2_ex9_description": "共通の振る舞いをdefine「トレイト」を学びましょう。",
    "rust_lesson2_ex8_comment1": "Ok で成功をreturn",
    "rust_lesson3_ex5_slide2_content": "# filter はreferenceのreferenceを受け取る\n\n`filter` のclosureは、referenceのreference（`&&T`）を受け取ります。そのため、valueをuseには `**x` と2回referenceを外す必要があります。\n\nなぜ？\n- `iter()` はreference（`&T`）をreturn\n- `filter` はそれをFurthermorereferenceで渡す（`&&T`）\n\nSyntax：\n```rust\n// **x で値を取り出す\n.filter(|x| **x > 2)\n\n// または * を引数につける\n.filter(|&x| *x > 2)\n```\n\n最初は混乱しますが、慣れれば大丈夫！",
    "rust_lesson1_ex5_comment1": "> でcompare",
    "rust_lesson2_ex4_description": "関連doデータをまとめる「構造体」を学びましょう。",
    "rust_lesson3_ex5_slide3_content": "条件に合う要素だけを取り出しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex7_slide3_content": "「ベクタ（Vec）」を使うと、たくさんのデータを一つの「長い はこ」にまとめて入れられます。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex5_slide2_title": "valueの取得",
    "rust_lesson3_ex1_slide1_title": "ライフタイム?",
    "rust_lesson1_ex3_comment1": "10 を 3 で割ったあまりをoutput",
    "rust_lesson3_ex1_comment1": "'a でライフタイムをdefinition",
    "rust_lesson3_ex10_slide1_title": "String vs &str",
    "rust_lesson2_title": "Rust II - 所有権とトレイト",
    "rust_lesson2_ex5_slide2_title": "methodのdefinition",
    "rust_lesson4_ex5_comment1": "insert でkeyとvalueを追加",
    "rust_lesson2_ex9_slide1_content": "# 「できること」の約束\n\nトレイト は、「このtypeはこういうことができる」という約束をdefine。\n\nFor example「鳴ける」という約束：\n- 犬は「ワン」と鳴く\n- 猫は「ニャー」と鳴く\n- 両方とも「鳴ける」能力がある\n\nトレイトは「鳴ける動物は、鳴き声を出すmethodを持つ」という約束です。\n\n他の言語とのcomparison：\n- Java: interface\n- TypeScript: interface\n\nに似た概念です。",
    "rust_lesson1_ex2_slide3_title": "Let's Try It!",
    "rust_lesson4_ex8_slide1_content": "# return valueのtypeをabstract化\n\nimpl Trait で、トレイトをimplementationdotypeを返せます。\n\n```rust\nfn make_iter() -> impl Iterator<Item = i32> {\n    vec![1, 2, 3].into_iter()\n}\n```",
    "rust_lesson1_ex2_slide2_content": "# 四則演算（しそくえんざん）\n\nRustでも算数と同じ記号で計算ができます。\n\n4つのBasic記号：\n- +（プラス）: たし算\n- -（マイナス）: ひき算\n- \\*（アスタリスク）: かけ算（×の代わり）\n- /（スラッシュ）: わり算（÷の代わり）\n\ncodeExample：\n```rust\nlet a = 10;\nlet b = 5;\nprintln!(\"{}\", a + b);  // 15 と表示される\n```\n\n`println!` の `{}` は「ここにvalueを入れてね」という目印です。",
    "rust_lesson4_ex9_slide2_content": "# 変換先を指定\n\n```rust\n// ターボフィッシュ構文\nlet v = (0..5).collect::<Vec<_>>();\n\n// 変数の型注釈\nlet v: Vec<i32> = (0..5).collect();\n```",
    "rust_lesson1_ex8_description": "「dictionary（HashMap）」をuseと、名前をつけてデータを保存し、その名前で取り出せます。",
    "rust_lesson4_ex9_slide2_title": "typeHint",
    "rust_lesson3_ex1_title": "ライフタイムのBasic",
    "rust_lesson2_ex5_description": "構造体にmethodをadd「impl」を学びましょう。",
    "rust_lesson4_ex8_comment1": "impl でトレイトをimplementationdotypeをreturn",
    "rust_lesson4_ex8_slide2_title": "argumentにも使える",
    "rust_lesson4_ex7_comment1": "if でマッチガードを追加",
    "rust_lesson2_ex9_slide2_title": "trait のdefinitionとimplementation",
    "rust_lesson4_ex10_slide2_title": "いつuse？",
    "rust_lesson3_ex7_slide2_title": "match の省略形",
    "rust_lesson1_ex6_title": "logicaloperator（&&、||）",
    "rust_lesson3_ex6_comment1": "fold で畳み込み",
    "rust_lesson2_ex6_description": "複数の状態を表す「列挙type（enum）」を学びましょう。",
    "rust_lesson4_ex10_slide1_title": "enumerate（イニュメレート）?",
    "rust_lesson1_ex7_slide1_title": "ベクタ（Vec）?",
    "rust_lesson2_ex6_slide3_content": "複数の状態を表す「列挙型（enum）」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex3_slide3_title": "Let's Try It!",
    "rust_lesson3_ex4_description": "各elementを変換domapを学びましょう。",
    "rust_lesson4_ex1_slide3_title": "Let's Try It!",
    "rust_lesson3_ex9_slide2_title": "mut が必要",
    "rust_lesson1_ex6_slide1_content": "# logicaloperator（ろんりえんざんし）\n\n2つ以上の条件を組み合わせたいときにuse記号です。\n\n2つの記号：\n- `&&`（アンドアンド）：「かつ」＝ 両方とも 正しいとき\n- `||`（オアオア）：「Alsoは」＝ どちらか 正しいとき\n\n身近なExample：\n- 遊園地：「18歳以上 かつ チケットあり」なら乗れる\n- おやつ：「宿題終わった Alsoは お手伝いした」ならOK\n\ncodeExample：\n```rust\nif score >= 70 && bonus > 0 {\n    // 70点以上 かつ ボーナスあり → 合格！\n    println!(\"合格！\");\n}\n```",
    "rust_lesson4_ex4_slide3_content": "参照カウントでデータを共有しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex6_slide3_title": "Let's Try It!",
    "rust_lesson2_ex5_slide3_content": "構造体にメソッドを追加する「impl」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex1_slide3_title": "Let's Try It!",
    "rust_lesson1_ex5_slide1_content": "# programに「判断」させよう\n\nconditional は、「もし〜なら、〇〇do」という判断をprogramにさせる仕組みです。\n\n身近なExample：\n- もし80点以上なら → 「合格！」とdisplay\n- もし雨なら → 傘を持っていく\n- もしHPが0なら → ゲームオーバー\n\nRustで Syntax：\n```rust\nif score > 80 {\n    println!(\"合格！\");\n}\n```\n\n読み方：\n- `if` →「もし」\n- `score > 80` →「スコアが80より大きいなら」\n- `{ }` の中 →「これをやる」",
    "rust_lesson4_ex5_title": "HashMap",
    "rust_lesson1_ex2_slide1_content": "# データを保存do「はこ」\n\nvariable（へんすう） は、数字や文字を入れておける「はこ」のことです。名前をつけて、あとでuseことができます。\n\nFor example：\n- 「りんごの数」というラベルの箱に「5」を入れる\n- あとで「りんごの数」と呼べば「5」が出てくる\n\nRustで Syntax：\n```rust\nlet x = 10;  // xという箱に10を入れる\nprintln!(\"{}\", x);  // xの中身（10）を表示\n```\n\n`let` は「この名前で箱をcreateよ」という意味です。",
    "rust_lesson2_ex4_slide3_content": "関連するデータをまとめる「構造体」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex6_slide1_title": "enum ?",
    "rust_lesson2_ex9_title": "トレイトをdefinitionしよう",
    "rust_lesson2_ex4_slide1_title": "構造体（こうぞうたい）?",
    "rust_lesson4_ex2_slide2_content": "# 覚えておくと便利な5つ\n\nよくusederiveトレイト：\n```rust\nDebug     // {:?} でデバッグ表示できる\nClone     // .clone() でコピーを作れる\nCopy      // 代入時に自動でコピー（小さい型向け）\nPartialEq // == で比較できる\nDefault   // 初期値を自動で作れる\n```\n\n複数指定もOK：\n```rust\n#[derive(Debug, Clone, PartialEq)]\nstruct User {\n    name: String,\n    age: u32,\n}\n```\n\n`Debug` は特によくuse。debug時に構造体の中身を見れて便利！",
    "rust_lesson2_ex1_slide1_content": "# データの「持ち主」を決めるルール\n\n所有権 は、Rust最大のFeatureです。「このデータの持ち主は誰か」をはっきりさせる仕組みです。\n\nルール：\n- データには必ず1人だけ「持ち主」がいる\n- 持ち主がいなくなると、データは自dynamicに片付けられる\n\nたとえるなら：\n- おもちゃは1人しか持てない\n- 持ち主が部屋を出たら、おもちゃは片付けられる\n\nこのルールのおかげで、Rustは「memoryリーク」（データが片付けられないバグ）を防げます！",
    "rust_lesson1_ex3_slide2_title": "Let's Try It!",
    "rust_lesson3_ex1_slide2_title": "なぜ必要？",
    "rust_lesson3_ex1_slide2_content": "# 危険なバグを防ぐ\n\nダングリングreference という危険なバグがあります。これは「もう存在しないデータ」を指し続けているreferenceのことです。\n\nExample：\n```rust\nfn longest<'a>(x: &'a str, y: &'a str) -> &'a str {\n    if x.len() > y.len() { x } else { y }\n}\n```\n\n`'a` の意味：\n- argument `x` と `y` は同じライフタイム `'a` を持つ\n- return valueも同じライフタイム `'a` を持つ\n- In other words「xとyが両方有効な間、return valueも有効」という約束\n\nRustはこれを自動でチェックしてくれます！",
    "rust_lesson4_ex6_slide2_title": "set演算",
    "rust_lesson3_ex7_comment1": "? でerrorを伝播",
    "rust_lesson3_ex2_slide2_content": "# | | でargumentを囲む\n\nclosureは `|引数| 処理` という形でwrite。`||` は「パイプ」と呼ばれます。\n\nいろいろなSyntax：\n```rust\n// 引数なし\n|| println!(\"Hello\")\n\n// 引数あり\n|x, y| x + y\n\n// 複数行のブロック\n|x| {\n    let y = x * 2;\n    y + 1\n}\n```\n\nPoint：\n- argumentを `| |` で囲む（functionの `()` の代わり）\n- typeは省略できることが多い（Rustが推測してくれる）",
    "rust_lesson2_ex7_comment1": "Some でvalueがあることを示す",
    "rust_lesson3_ex4_slide3_content": "各要素を変換するmapを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_title": "Rust (ラスト) に挑戦！",
    "rust_lesson2_ex8_description": "成功と失敗を表す「Result」を学びましょう。",
    "rust_lesson3_ex8_description": "Option/Resultのデフォルトvalueを設定しましょう。",
    "rust_lesson4_ex2_slide3_title": "Let's Try It!",
    "rust_lesson2_ex5_slide3_title": "Let's Try It!",
    "rust_lesson4_ex9_description": "iteratorをコレクションに変換しましょう。",
    "rust_lesson1_ex1_slide2_content": "# println! でscreenにdisplay\n\nRustで文字をscreenにdisplayには、`println!`（プリントラインびっくり）をuse。\n\nPoint：\n- `!` がつくのがRustのFeature（マクロと呼ばれます）\n- programは `fn main() { }` の中にwrite\n- `fn` は「function（function）」の略\n\ncodeExample：\n```rust\nfn main() {\n    println!(\"ヤッホー！\");\n}\n// 「ヤッホー！」と画面に表示される\n```\n\n`println!` の `!` は「マクロ」という特別な機能の印です。今は「おまじない」と思っておけばOK！",
    "rust_lesson3_ex6_slide1_title": "fold ?",
    "rust_lesson4_ex8_slide1_title": "impl Trait ?",
    "rust_lesson1_ex1_slide2_title": "Rustの「おまじない」",
    "rust_lesson3_ex10_description": "stringtypeの違いを理解しましょう。",
    "rust_lesson3_ex7_slide3_content": "エラーを簡潔に伝播させましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex1_comment1": "s1 の所有権を移動",
    "rust_lesson2_ex9_slide1_title": "トレイト?",
    "rust_lesson4_ex6_slide2_content": "# 和set、積setなど\n\n```rust\nset1.union(&set2)\nset1.intersection(&set2)\nset1.difference(&set2)\n```",
    "rust_lesson4_ex5_slide3_content": "キーと値のペアを格納しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex8_slide1_title": "Result（リザルト）?",
    "rust_lesson4_ex1_slide1_content": "# 「できること」の約束\n\nトレイト は、typeが持つべきmethodをdefine仕組みです。\n\nFor example：\n- 「あいさつできる」トレイト → greet() methodを持つ\n- 「displayできる」トレイト → display() methodを持つ\n\ncodeExample：\n```rust\ntrait Greet {\n    fn greet(&self) -> String;  // メソッドの「約束」\n}\n```\n\nこれは「Greetできるtypeは、greet()methodを持つ」という約束です。",
    "rust_lesson4_ex2_slide3_content": "トレイトを自動実装するderiveを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex6_title": "fold で畳み込み",
    "rust_lesson3_ex9_slide3_content": "Vecに要素を追加しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex4_slide1_content": "# 関係あるデータをまとめる「設計図」\n\n構造体（struct） は、いくつかのデータをひとまとめにdo仕組みです。\n\nFor example「点（座標）」のデータ：\n- x座標\n- y座標\n\nこの2つは関係があるので、「Point（点）」としてまとめると便利です。\n\nFor example「人」のデータ：\n- 名前\n- 年齢\n\nこれも「Person（人）」としてまとめられます。\n\n構造体は「こういうデータを持つ」という設計図です。",
    "rust_lesson4_ex1_slide1_title": "トレイト?（復習）",
    "rust_lesson2_ex3_description": "reference先のvalueを変更できる「可変reference」を学びましょう。",
    "rust_lesson2_ex7_slide2_content": "# match で安全に取り出す\n\n`match` を使って「ある場合」と「ない場合」で処理を分けます。\n\ncodeExample：\n```rust\nlet x: Option<i32> = Some(5);  // 値あり\n\nmatch x {\n    Some(n) => println!(\"値は{}です\", n),  // 5\n    None => println!(\"値がありません\"),\n}\n```\n\nなぜ安全？\n- `null` のように「あるつもりでアクセスしたら無かった」errorが起きない\n- 「ない場合」の処理を書かないとコンパイルerrorになる\n- 強制的に両方のケースを考えることになる！",
    "rust_lesson4_ex9_comment1": "collect で Vec に変換",
    "rust_lesson3_ex10_title": "String と &str",
    "rust_lesson2_ex7_slide1_title": "Option（オプション）?",
    "rust_lesson3_ex9_description": "Vecにelementを追加しましょう。",
    "rust_lesson2_ex5_comment1": "impl でmethodをimplementation",
    "rust_lesson3_ex1_slide3_content": "参照の有効期間を表すライフタイムを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex6_slide2_content": "複数の条件を組み合わせる「&&（かつ）」と「||（または）」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex5_comment1": "filter で条件に合うelementを絞り込む",
    "rust_lesson2_ex7_slide3_content": "値があるかないかを表す「Option」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex10_slide3_title": "Let's Try It!",
    "rust_lesson4_ex4_slide3_title": "Let's Try It!",
    "rust_lesson3_ex3_comment1": "iter でiteratorを取得",
    "rust_lesson3_ex6_slide3_content": "要素を1つの値にまとめるfoldを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex7_slide2_title": "ベクタの番号は「0」から！",
    "rust_lesson1_ex5_slide1_title": "conditional（じょうけんぶんき）?",
    "rust_lesson1_ex3_description": "割り算の「あまり」を求める「%」（パーセント）operatorを学びましょう。",
    "rust_lesson1_ex1_slide3_content": "Rustを使って画面に文字を表示してみましょう。println! という特別な関数を使います。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex10_slide2_content": "# <T> でtypeを「あとで決める」\n\nfunction名の後に `<T>` をつけて、`T` を「type」としてuse。\n\ncodeExample：\n```rust\n// Tはどんな型でもOK\nfn first<T>(arr: &[T]) -> &T {\n    &arr[0]  // 最初の要素を返す\n}\n\n// 使い方\nfirst(&[1, 2, 3]);         // Tはi32\nfirst(&[\"a\", \"b\", \"c\"]);   // Tは&str\n```\n\n読み方：\n- `<T>` → 「Tという名前のtypeをuseよ」\n- `T` は慣習で「Type（type）」の頭文字\n- 複数のtypeが必要なら `<T, U>` のようにwrite",
    "rust_lesson3_ex2_comment1": "|x| でclosureのargumentをdefinition",
    "rust_lesson3_ex3_description": "elementを順番に処理doiteratorを学びましょう。",
    "rust_lesson1_ex1_slide3_title": "Let's Try It!",
    "rust_lesson2_ex6_slide2_title": "enum のdefinition",
    "rust_lesson2_ex1_title": "所有権のBasic",
    "rust_lesson4_ex3_slide1_title": "Box（ボックス）?",
    "rust_lesson2_ex1_slide3_content": "Rust独自の概念「所有権」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex8_slide3_content": "Option/Resultのデフォルト値を設定しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex7_slide2_title": "使用Example",
    "rust_lesson4_ex10_description": "iteratorにindexを付けましょう。",
    "rust_lesson4_ex9_slide1_title": "collect ?",
    "rust_lesson4_ex10_slide2_content": "# 「何番目か」が必要なとき\n\n番号（index）とelementの両方が必要なときに便利です。\n\ncodeExample：\n```rust\nlet v = vec![10, 20, 30];\nfor (idx, val) in v.iter().enumerate() {\n    println!(\"{}番目の値は{}\", idx, val);\n}\n// 0番目の値は10\n// 1番目の値は20\n// 2番目の値は30\n```\n\nPoint：\n- `(i, x)` でtuple（2つのset）を受け取る\n- `i` にindex、`x` にelementが入る\n- indexは0から始まる",
    "rust_lesson3_ex2_description": "周囲のvariableを使えるanonymous function「closure」を学びましょう。",
    "rust_lesson1_ex4_comment1": "mut で変更可能にdo",
    "rust_lesson1_ex8_slide3_title": "Let's Try It!",
    "rust_lesson1_ex3_slide2_content": "割り算の「あまり」を求める「%」（パーセント）演算子を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex9_slide3_title": "Let's Try It!",
    "rust_lesson3_ex3_title": "iteratorのBasic",
    "rust_lesson3_ex9_title": "Vec のmethod push",
    "rust_lesson1_ex8_comment1": "dictionaryをcreate（keyは'みかん'、valueは'オレンジ'）",
    "rust_lesson1_ex2_comment3": "+ でたし算do",
    "rust_lesson4_ex8_slide2_content": "# ジェネリクスの代わり\n\n```rust\nfn print_all(iter: impl Iterator<Item = i32>) {\n    for x in iter {\n        println!(\"{}\", x);\n    }\n}\n```",
    "rust_lesson2_ex2_slide2_title": "reference Usage",
    "rust_lesson1_ex8_slide3_content": "「辞書（HashMap）」を使うと、名前をつけてデータを保存し、その名前で取り出せます。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex7_slide2_content": "# [ ]で番号を指定して取り出す\n\n`[番号]` で何番目のデータか指定して取り出せます。\n\nImportantなルール：番号は「0」から！\n- 1番目 → `[0]`\n- 2番目 → `[1]`\n- 3番目 → `[2]`\n\ncodeExample：\n```rust\nlet fruits = vec![\"りんご\", \"バナナ\", \"みかん\"];\n//                  ↑0番    ↑1番     ↑2番\nprintln!(\"{}\", fruits[0]);  // りんご\nprintln!(\"{}\", fruits[1]);  // バナナ\n```\n\nプログラミングでは「0から数える」のが世界共通のルールです！",
    "rust_lesson1_ex6_slide1_title": "条件を組み合わせる",
    "rust_lesson2_ex10_slide2_title": "ジェネリックfunction Syntax",
    "rust_lesson1_ex6_description": "複数の条件を組み合わせる「&&（かつ）」と「||（Alsoは）」を学びましょう。",
    "rust_lesson4_ex6_title": "HashSet",
    "rust_lesson2_ex3_slide2_content": "# mut が2か所に必要\n\n変更できるようにdoには、variableとreferenceの両方に `mut` が必要です。\n\ncodeExample：\n```rust\n// 1. 変数を mut で作る\nlet mut s = String::from(\"hello\");\n\n// 2. &mut で可変参照を渡す\nchange(&mut s);\n\nfn change(s: &mut String) {\n    s.push_str(\" world\");  // 変更できる！\n}\n```\n\nPoint：\n- `let mut 変数` でvariableを変更可能に\n- `&mut 変数` で可変referenceをcreate\n- 両方ないと変更できない！",
    "rust_lesson2_ex2_slide1_title": "reference（さんしょう）?",
    "rust_lesson3_ex6_slide2_content": "# 合計、積、結合など\n\n```rust\n// 積\nv.iter().fold(1, |acc, x| acc * x)\n\n// 文字列結合\nwords.iter().fold(String::new(), |acc, s| acc + s)\n```",
    "rust_lesson1_ex1_description": "Rustを使ってscreenに文字をdisplayしてみましょう。println! という特別なfunctionをuse。",
    "rust_lesson3_ex8_slide3_title": "Let's Try It!",
    "rust_lesson4_ex6_description": "一意なvalueのsetを管理しましょう。",
    "rust_lesson2_ex5_slide1_title": "impl ?",
    "rust_lesson1_ex8_title": "名前で引き出す「dictionary」",
    "rust_lesson2_ex7_description": "valueがあるかないかを表す「Option」を学びましょう。",
    "rust_lesson1_ex4_slide2_title": "Let's Try It!",
    "rust_lesson1_ex7_title": "たくさんのデータをまとめましょう「ベクタ」",
    "rust_lesson3_ex7_slide1_content": "# errorの早期リターン\n\n? は、Resultが Err の場合に早期リターンします。\n\n```rust\nfn read_file() -> Result<String, io::Error> {\n    let content = fs::read_to_string(\"file.txt\")?;\n    Ok(content)\n}\n```",
    "rust_lesson3_ex9_slide1_content": "# 末尾に追加\n\npush は、Vecの末尾にelementをadd。\n\n```rust\nlet mut v = vec![1, 2];\nv.push(3);\n// [1, 2, 3]\n```",
    "rust_lesson4_ex8_slide3_content": "トレイトを返す関数を簡潔に書きましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex1_title": "screenにメッセージを出しましょう",
    "rust_lesson2_ex8_slide2_title": "Result  Usage",
    "rust_lesson3_ex2_slide1_title": "closure?",
    "rust_lesson3_ex8_title": "unwrap_or でデフォルトvalue",
    "rust_lesson4_ex10_slide1_content": "# 番号とelementを一緒にもらう\n\nenumerate は、「何番目か」と「そのelement」をsetで取り出せるmethodです。\n\nFor example：\n- 0番目: りんご\n- 1番目: バナナ\n- 2番目: みかん\n\ncodeExample：\n```rust\nfor (i, x) in vec![\"a\", \"b\", \"c\"].iter().enumerate() {\n    println!(\"{}: {}\", i, x);\n}\n// 0: a\n// 1: b\n// 2: c\n```",
    "rust_lesson1_ex7_slide1_content": "# データを並べてまとめる「長い箱」\n\nベクタ（Vec） は、たくさんのデータを順番に並べて入れられる「長い箱」です。\n\nFor example：\n- 買い物listの商品を全部まとめる\n- testの点数を全部まとめる\n- 友だちの名前を全部まとめる\n\n100個でも1000個でも、1つのvariableでまとめて管理できます！\n\n作り方：\n```rust\nlet fruits = vec![\"りんご\", \"バナナ\", \"みかん\"];\n// vec! で ベクタを作る\n```",
    "rust_lesson4_ex8_slide3_title": "Let's Try It!",
    "rust_lesson4_ex7_description": "パターンマッチに条件を追加しましょう。",
    "rust_lesson1_ex4_comment2": "+= で 20 を足す",
    "rust_lesson1_ex2_comment2": "y に 5 を入れる",
    "rust_lesson2_ex3_slide3_title": "Let's Try It!",
    "rust_lesson3_ex4_slide1_title": "map（map）?",
    "rust_lesson1_ex2_slide3_content": "データに名前をつけて保存できる「変数（へんすう）」を使ってみましょう。letで変数を作ります。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex8_slide2_content": "# match で成功と失敗を分ける\n\n`match` で「成功したら」「失敗したら」の処理を書き分けます。\n\ncodeExample：\n```rust\nfn divide(a: i32, b: i32) -> Result<i32, String> {\n    if b == 0 {\n        return Err(\"0で割れません\".to_string());\n    }\n    Ok(a / b)  // 成功なら答えを返す\n}\n\nmatch divide(10, 2) {\n    Ok(v) => println!(\"答えは{}\", v),\n    Err(e) => println!(\"エラー: {}\", e),\n}\n```\n\nPoint：\n- `Ok(値)` で成功をreturn\n- `Err(エラー)` で失敗をreturn",
    "rust_lesson4_ex3_comment1": "Box::new でheapに格納",
    "rust_lesson4_ex8_description": "トレイトをreturnfunctionを簡潔に書きましょう。",
    "rust_lesson2_ex10_description": "typeを後から決められる「ジェネリクス」を学びましょう。",
    "rust_lesson2_ex3_slide1_title": "可変reference（かへんさんしょう）?",
    "rust_lesson2_ex2_description": "所有権を移さずにvalueを借りる「reference」を学びましょう。",
    "rust_lesson3_ex5_slide2_title": "** にNote！",
    "rust_lesson2_ex2_slide3_title": "Let's Try It!",
    "rust_lesson4_ex3_slide3_content": "ヒープにデータを格納するBoxを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex4_title": "累算assignmentoperator（+=、-=）",
    "rust_lesson3_ex3_slide2_content": "# 借りるか、もらうか\n\n3種類の iter があり、所有権の扱いが違います。\n\n3つの違い：\n```rust\nv.iter()       // 参照で借りる（&T）\nv.iter_mut()   // 変更可能で借りる（&mut T）\nv.into_iter()  // 所有権をもらう（T）\n```\n\n使い分け：\n- `iter()` → 見るだけ（元のベクタも使える）\n- `iter_mut()` → 中身を変更したい\n- `into_iter()` → ベクタごともらう（元は使えない）\n\n普通は `iter()` をuseことが多いです。",
    "rust_lesson2_ex1_slide1_title": "所有権（しょゆうけん）?",
    "rust_lesson4_ex6_slide3_content": "一意な値の集合を管理しましょう。\n\n（When you're ready, select \"Start Lesson\".）"
  },
  "fr": {
    "rust_lesson1_course_title": "Introduction to Rust",
    "rust_lesson1_course_description": "Learn the basics of Rust programming.",
    "rust_lesson2_course_title": "Rust II - Intermediate",
    "rust_lesson2_course_description": "Learn intermediate Rust concepts.",
    "rust_lesson3_course_title": "Rust III - Advanced",
    "rust_lesson3_course_description": "Master advanced Rust techniques.",
    "rust_lesson4_course_title": "Rust IV - Expert Level",
    "rust_lesson4_course_description": "Expert-level Rust programming.",
    "rust_lesson1_ex5_slide2_content": "条件によって動きを変える if文を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex9_title": "collect で変換",
    "rust_lesson2_ex7_slide1_content": "# 「あるかもしれない、ないかもしれない」\n\nOption<T> は、valueが「あるかもしれないし、ないかもしれない」ことを表すtypeです。\n\nFor example：\n- dictionaryで単語を探す → 見つかるかもしれないし、ないかもしれない\n- ゲームでアイテムを拾う → 落ちてるかもしれないし、ないかもしれない\n\n2つの状態：\n- `Some(値)` → valueがある！\n- `None` → valueがない...\n\n他の言語では `null` をuseが、Rustでは `Option` で安全に扱います。",
    "rust_lesson1_ex2_slide1_title": "variable（へんすう）?",
    "rust_lesson1_ex7_description": "「ベクタ（Vec）」をuseと、たくさんのデータを一つの「長い はこ」にまとめて入れられます。",
    "rust_lesson2_ex9_slide2_content": "# 約束を作って、守る\n\n1. `trait` で「約束」をdefinition\n2. `impl トレイト for 型` で「約束を守る」implementationをdo\n\ncodeExample：\n```rust\n// 1. トレイト（約束）を定義\ntrait Speak {\n    fn speak(&self);  // 鳴くメソッドを持つ約束\n}\n\n// 2. Dog構造体がトレイトを実装\nstruct Dog;\nimpl Speak for Dog {\n    fn speak(&self) {\n        println!(\"woof\");\n    }\n}\n```\n\n「DogはSpeakができる」ということになります。",
    "rust_lesson4_ex4_description": "referenceカウントでデータを共有しましょう。",
    "rust_lesson4_ex5_slide1_content": "# 名前で引ける「dictionary」\n\nHashMap は、「key（名前）」と「value（データ）」をsetで保存dodictionaryです。\n\nFor example：\n- 「青チーム」→ 10点\n- 「赤チーム」→ 15点\n\ncodeExample：\n```rust\nuse std::collections::HashMap;\n\nlet mut scores = HashMap::new();\nscores.insert(\"Blue\", 10);   // 追加\nscores.insert(\"Red\", 15);    // 追加\n```\n\n`use` で機能を読み込んでからuse。",
    "rust_lesson3_ex4_title": "map でiterator変換",
    "rust_lesson4_ex1_slide3_content": "共通の振る舞いを定義するトレイトを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex4_description": "variableのvalueを手軽に増やしたり減らしたりdo「+=」「-=」を学びましょう。",
    "rust_lesson1_ex2_description": "データに名前をつけて保存できる「variable（へんすう）」を使ってみましょう。letでvariableをcreate。",
    "rust_lesson4_ex4_slide2_title": "referenceカウントの仕組み",
    "rust_lesson3_ex8_slide2_title": "unwrap_or_else",
    "rust_lesson4_ex10_comment1": "1番目の i にindex、2番目の item にelementが入る",
    "rust_lesson3_ex6_slide1_content": "# 累積処理\n\nfold は、初期valueとfunctionでelementを1つずつ畳み込みます。\n\n```rust\nlet v = vec![1, 2, 3];\nlet sum = v.iter().fold(0, |acc, x| acc + x);\n// 6\n```",
    "rust_lesson4_ex2_slide2_title": "よくuse derive トレイト",
    "rust_lesson3_ex10_slide3_content": "文字列型の違いを理解しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex4_slide2_content": "変数の値を手軽に増やしたり減らしたりする「+=」「-=」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex4_slide3_title": "Let's Try It!",
    "rust_lesson3_ex5_slide1_title": "filter（filterー）?",
    "rust_lesson4_ex5_description": "keyとvalueのpairを格納しましょう。",
    "rust_lesson3_ex5_description": "条件に合うelementだけを取り出しましょう。",
    "rust_lesson2_ex2_slide2_content": "# functionに借りてもらう\n\nfunctionにデータを渡すとき、`&` をつけると「借りる」形になります。元のvariableはそのまま使い続けられます。\n\ncodeExample：\n```rust\nfn calc_len(s: &String) -> usize {\n    s.len()  // 長さを返す\n}\n\nfn main() {\n    let text = String::from(\"hello\");\n    let len = calc_len(&text);  // textを貸す\n    // text はまだ使える！\n    println!(\"{}の長さは{}\", text, len);\n}\n```\n\n`&String` は「Stringを借りる」という意味です。",
    "rust_lesson4_ex7_slide3_content": "パターンマッチに条件を追加しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex8_slide2_content": "# 遅延評価\n\n```rust\n// クロージャで計算\nlet value = x.unwrap_or_else(|| expensive_computation());\n```",
    "rust_lesson4_ex7_title": "match ガード",
    "rust_lesson3_ex7_title": "? operatorでerror伝播",
    "rust_lesson4_ex1_description": "共通の振る舞いをdefineトレイトを学びましょう。",
    "rust_lesson2_ex1_slide2_content": "# 所有権は「移動」do\n\nvariableを別のvariableにassignmentdoと、所有権が 移動（ムーブ） します。元のvariableは使えなくなります。\n\ncodeExample：\n```rust\nlet s1 = String::from(\"hello\");  // s1 が持ち主\nlet s2 = s1;  // 所有権が s2 に移動！\n// ↓ s1 はもう使えない（エラーになる）\n// println!(\"{}\", s1);  // ダメ！\nprintln!(\"{}\", s2);  // OK！\n```\n\nイメージ：\nおもちゃを友だちにあげたら、自分はもう使えない。これがムーブです。",
    "rust_lesson1_ex8_slide1_title": "dictionary（HashMap）?",
    "rust_lesson4_ex3_slide2_content": "# サイズが決まらないとき\n\nBoxは、コンパイル時にサイズがわからないtypeにuse。\n\nFor examplerecursion的なtype：\n```rust\n// リストは「値 + 次のリスト」の繰り返し\nenum List {\n    Cons(i32, Box<List>),  // Boxで次を指す\n    Nil,                   // 終わり\n}\n```\n\nなぜBoxが必要？\n- `List` の中に `List` がある → 無限に大きくなる？\n- `Box` をuseと、サイズが固定（pointerのサイズ）になる\n\n「中身」ではなく「中身への矢印」を持つイメージです。",
    "rust_lesson2_ex10_title": "ジェネリクスを使おう",
    "rust_lesson2_ex8_slide3_title": "Let's Try It!",
    "rust_lesson3_ex9_slide2_content": "# 可変reference\n\n```rust\n// mut が必要\nlet mut v = Vec::new();\nv.push(1);\nv.push(2);\n```",
    "rust_lesson4_ex4_title": "Rc<T>",
    "rust_lesson2_ex3_comment1": "mut で可変variableにdo",
    "rust_lesson4_ex5_slide3_title": "Let's Try It!",
    "rust_lesson2_ex6_slide2_content": "# バリアントを列挙\n\n`enum 名前 { バリアント1, バリアント2, ... }` でdefine。\n\ncodeExample：\n```rust\nenum Color {\n    Red,\n    Green,\n    Blue,\n}\nlet c = Color::Red;\n```",
    "rust_lesson1_ex1_comment1": "Hello, Rust! とdisplay",
    "rust_lesson1_ex1_slide1_content": "# 安全で速い！最新のプログラミング言語\n\nRust（ラスト）は、「間違いを事前に防ぐ」ことがとても得意なプログラミング言語です。\n\nRustのすごいところ：\n- programのミスをexecute前に見つけてくれる\n- とても速く動く\n- 世界中のプログラマーが「一番好き！」と選ぶ人気の言語\n\nたとえるなら：\n厳しいけど優しい先生のような言語です。「ここ間違ってるよ」と教えてくれるので、安心してprogramが書けます！",
    "rust_lesson3_ex8_slide1_content": "# None/Err の場合のデフォルト\n\nunwrap_or は、None や Err の場合にデフォルトvalueをreturn。\n\n```rust\nlet x: Option<i32> = None;\nlet value = x.unwrap_or(0);  // 0\n```",
    "rust_lesson2_ex7_slide3_title": "Let's Try It!",
    "rust_lesson2_ex6_title": "enum で状態を表す",
    "rust_lesson2_ex8_slide1_content": "# 「成功」か「失敗」かを表す\n\nResult<T, E> は、処理が「成功したか失敗したか」を表すtypeです。\n\nFor example：\n- fileをopen → 成功（内容）か失敗（error）\n- 0で割り算 → 成功（答え）か失敗（0で割れない！）\n\n2つの状態：\n- `Ok(値)` → 成功！valueが入っている\n- `Err(エラー)` → 失敗...error情報が入っている\n\n`Option` は「あるか・ないか」、`Result` は「成功か・失敗か」という違いです。",
    "rust_lesson2_ex8_slide3_content": "成功と失敗を表す「Result」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex6_slide1_title": "HashSet ?",
    "rust_lesson3_ex9_comment1": "push でelementを追加",
    "rust_lesson2_ex7_slide2_title": "Option  Usage",
    "rust_lesson3_ex2_title": "closureのBasic",
    "rust_lesson3_ex7_slide1_title": "? operator?",
    "rust_lesson4_ex6_comment1": "HashSet をimport",
    "rust_lesson2_ex10_slide1_content": "# どんなtypeでも使える「万能」の仕組み\n\nジェネリクス は、typeを後から決められる仕組みです。\n\nなぜ便利？\n同じようなfunctionを何度も書かなくてすみます。\n\nFor example：\n- 数字のarrayの最初のelementを取るfunction\n- stringのarrayの最初のelementを取るfunction\n\n両方とも「最初のelementを取る」のは同じなのに、typeが違うだけで別のfunctionをwriteのは大変！\n\nジェネリクスなら、`<T>` で「typeは後で決める」とwriteだけで、どんなtypeでも使えるfunctionが作れます。",
    "rust_lesson1_ex3_slide1_content": "# 剰余operator（じょうよえんざんし）「%」\n\n`%`（パーセント）は、割り算の 「あまり」 をcalculate特別な記号です。\n\nわかりやすいExample：\n- 10このアメを3人で分けると？\n- 1人3こずつで、1こあまる\n- これを `10 % 3` とwriteと、答えは `1`\n\ncodeExample：\n```rust\nprintln!(\"{}\", 10 % 3);  // 1（あまり1）\nprintln!(\"{}\", 8 % 4);   // 0（あまりなし＝割り切れる）\n```\n\n使いどころ：\n- 偶数か奇数か調べる（`n % 2` が0なら偶数）\n- 時計の計算（24を超えたら0に戻る、など）",
    "rust_lesson3_ex7_description": "errorを簡潔に伝播させましょう。",
    "rust_lesson3_ex8_comment1": "unwrap_or でデフォルトvalueを設定",
    "rust_lesson2_ex8_title": "Result<T, E> でerror処理",
    "rust_lesson2_ex10_comment1": "T をtypeパラメータとしてuse",
    "rust_lesson2_ex6_comment1": "enum で列挙typeをdefinition",
    "rust_lesson3_ex3_slide3_content": "要素を順番に処理するイテレータを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex2_comment1": "derive でトレイトを自動implementation",
    "rust_lesson1_ex8_slide1_content": "# 名前でsearchできる「dictionary」\n\nHashMap（ハッシュmap）は、「名前」と「データ」をsetにして保存できる仕組みです。本物のdictionaryのように使えます。\n\nFor example果物の色dictionary：\n- 「りんご」→「あか」\n- 「バナナ」→「きいろ」\n- 「みかん」→「オレンジ」\n\nuse準備：\n```rust\nuse std::collections::HashMap;  // 機能を読み込む\nlet mut fruits = HashMap::new();  // 空の辞書を作る\nfruits.insert(\"りんご\", \"あか\");  // データを追加\n```\n\n`use` は「この機能をuseよ」というdeclarationです。",
    "rust_lesson3_ex9_slide1_title": "push ?",
    "rust_lesson4_ex1_title": "トレイトのdefinition",
    "rust_lesson4_ex3_description": "heapにデータを格納doBoxを学びましょう。",
    "rust_lesson1_ex2_title": "便利な「はこ」variable（へんすう）",
    "rust_lesson1_ex8_comment2": "中身を出す",
    "rust_lesson3_ex9_slide3_title": "Let's Try It!",
    "rust_lesson1_ex4_comment3": "-= で 50 を引く",
    "rust_lesson1_ex6_comment1": "&& で両方の条件をチェック",
    "rust_lesson4_ex1_slide2_title": "トレイトのimplementation",
    "rust_lesson4_ex7_slide3_title": "Let's Try It!",
    "rust_lesson4_title": "Rust IV - トレイトとスマートpointer",
    "rust_lesson4_ex1_comment1": "trait でトレイトをdefinition",
    "rust_lesson4_ex4_slide1_content": "# 複数の「持ち主」を許可do仕組み\n\nRc<T> は「Reference Counted（referenceカウント）」の略で、複数の所有者でデータを共有できます。\n\n普通の所有権：\n1人だけが持ち主。渡したら元の人は使えない。\n\nRc をuseと：\n複数人が同じデータの「持ち主」になれる！\n\ncodeExample：\n```rust\nuse std::rc::Rc;\n\nlet a = Rc::new(5);       // Rcでラップ\nlet b = Rc::clone(&a);    // bも持ち主になる\n// a も b も使える！\n```",
    "rust_lesson3_ex5_slide1_content": "# 条件に合うものだけ残す\n\nfilter は、条件を満たすelementだけを残し、他を捨てます。\n\nFor example：\n- 80点以上の人だけ残す\n- 偶数だけ残す\n- 「あ」から始まる名前だけ残す\n\ncodeExample：\n```rust\nlet v = vec![1, 2, 3, 4, 5];\nlet evens: Vec<_> = v.iter()\n    .filter(|x| **x % 2 == 0)  // 偶数だけ\n    .collect();\n// [2, 4]\n```\n\n条件が `true` のelementだけが残ります。",
    "rust_lesson3_ex7_slide3_title": "Let's Try It!",
    "rust_lesson1_ex7_comment2": "2番目のデータ（1番）を出す",
    "rust_lesson4_ex8_title": "impl Trait",
    "rust_lesson1_ex5_description": "条件によって動きを変える if文を学びましょう。",
    "rust_lesson3_ex4_slide2_title": "遅延評価（ちえんひょうか）",
    "rust_lesson3_ex1_slide1_content": "# referenceの「寿命」を示す印\n\nライフタイム は、referenceがいつまで使えるかを示す印です。`'a`（アポストロフィ・エー）のようにwrite。\n\nなぜ必要？\nreferenceは「借りている」状態。借りた元のデータが消えたら、referenceも使えなくなります。\n\nFor example：\n- 図書館で借りた本 → 図書館が閉まったら読めない\n- referenceで借りたデータ → 元のデータが消えたら使えない\n\nライフタイムは「このreferenceはこの範囲で有効だよ」とコンパイラに伝える仕組みです。",
    "rust_lesson1_ex1_slide1_title": "Rust（ラスト）?",
    "rust_lesson1_ex2_slide2_title": "計算の記号（operator）",
    "rust_lesson4_ex5_slide2_content": "# get で安全に取り出す\n\n`get()` methodでvalueを取り出せます。見つからない可能性があるので、`Option` が返ってきます。\n\ncodeExample：\n```rust\n// getはOption<&V>を返す\nif let Some(score) = scores.get(\"Blue\") {\n    println!(\"青チームは{}点\", score);\n}\n```\n\nPoint：\n- keyがあれば `Some(値)` が返る\n- keyがなければ `None` が返る\n- `if let` で安全に取り出せる\n\n存在しないkeyでアクセスしてもprogramが落ちない！",
    "rust_lesson4_ex7_slide1_title": "match ガード?",
    "rust_lesson3_title": "Rust III - ライフタイムとiterator",
    "rust_lesson4_ex3_title": "Box<T>",
    "rust_lesson1_ex4_slide1_title": "累算assignmentoperator（るいさんだいにゅう）?",
    "rust_lesson2_ex9_comment1": "trait でトレイトをdefinition",
    "rust_lesson2_ex1_description": "Rust独自の概念「所有権」を学びましょう。",
    "rust_lesson2_ex3_slide3_content": "参照先の値を変更できる「可変参照」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex1_slide3_title": "Let's Try It!",
    "rust_lesson3_ex6_slide2_title": "様々な畳み込み",
    "rust_lesson4_ex9_slide3_title": "Let's Try It!",
    "rust_lesson2_ex5_title": "impl でmethodを追加",
    "rust_lesson2_ex6_slide1_content": "# 複数の選択肢\n\nenum は、valueがいくつかの種類のうちの一つであることを表します。各バリアントにデータを持たせることもできます。",
    "rust_lesson2_ex4_comment1": "struct で構造体をdefinition",
    "rust_lesson1_ex3_title": "剰余operator（%）",
    "rust_lesson1_ex7_comment1": "colors というベクタをcreate（'あか', 'あお'の順）",
    "rust_lesson1_ex4_slide1_content": "# valueをかんたんに増やす・減らす\n\n`+=`（プラスイコール）と `-=`（マイナスイコール）は、variableの中身を増やしたり減らしたりdo便利な記号です。\n\nRustのImportantなルール：`mut`が必要！\nRustでは、variableをchangeには `let mut`（レット ミュート）とwrite必要があります。`mut` は「mutable（変更できる）」の略です。\n\ncodeExample：\n```rust\nlet mut score = 100;  // mut をつけて変更可能に\nscore += 10;          // 10を足す → 110に\nscore -= 50;          // 50を引く → 60に\n```\n\n`mut` がないと「このvariableは変えちゃダメ！」とRustが怒ります。",
    "rust_lesson2_ex1_slide2_title": "ムーブ（移動）",
    "rust_lesson3_ex4_comment1": "map で各elementを変換",
    "rust_lesson3_ex8_slide1_title": "unwrap_or ?",
    "rust_lesson2_ex5_slide1_content": "# implementationブロック\n\nimpl ブロックで、構造体にmethodを追加できます。`self` で自分自身をreferenceします。",
    "rust_lesson2_ex10_slide1_title": "ジェネリクス?",
    "rust_lesson1_ex8_slide2_content": "# 名前（key）で取り出す\n\ndictionaryに入れたデータは、名前（key）を指定して取り出せます。\n\ncodeExample：\n```rust\nuse std::collections::HashMap;\nfn main() {\n    let mut fruits = HashMap::new();\n    fruits.insert(\"りんご\", \"あか\");  // 追加\n    fruits.insert(\"バナナ\", \"きいろ\");  // 追加\n    \n    println!(\"{}\", fruits[\"りんご\"]);  // あか と表示\n}\n```\n\nPoint：\n- `insert(名前, データ)` で追加\n- `辞書[名前]` で取り出し\n- 番号ではなく「名前」で探せるのが便利！",
    "rust_lesson4_ex9_slide1_content": "# iteratorをコレクションに\n\ncollect は、iteratorをVecやHashMapなどに変換します。\n\n```rust\nlet v: Vec<_> = (0..5).collect();\nlet s: String = vec!['a', 'b'].into_iter().collect();\n```",
    "rust_lesson2_ex2_slide3_content": "所有権を移さずに値を借りる「参照」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex2_slide3_content": "周囲の変数を使える無名関数「クロージャ」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex4_slide2_content": "# struct keyワードでdefinition\n\n`struct 名前 { フィールド }` で構造体をdefine。フィールドには名前とtypeをwrite。\n\ncodeExample：\n```rust\n// Point 構造体を定義\nstruct Point {\n    x: i32,  // xフィールド（整数）\n    y: i32,  // yフィールド（整数）\n}\n\n// 使い方\nlet p = Point { x: 10, y: 20 };\nprintln!(\"x={}, y={}\", p.x, p.y);\n```\n\nPoint：\n- `struct 名前` で構造体をcreate\n- `{ フィールド名: 型 }` でどんなデータを持つか決める\n- `.フィールド名` でアクセス",
    "rust_lesson2_ex10_slide3_content": "型を後から決められる「ジェネリクス」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex6_slide3_title": "Let's Try It!",
    "rust_lesson4_ex6_slide1_content": "# 一意なvalueのset\n\nHashSet は、重複のないvalueのsetです。\n\n```rust\nuse std::collections::HashSet;\n\nlet mut set = HashSet::new();\nset.insert(1);\nset.insert(2);\nset.insert(1); // 重複は無視\n```",
    "rust_lesson4_ex2_title": "derive 属性",
    "rust_lesson4_ex2_slide1_content": "# トレイトを「自動で」implementation\n\n#[derive(...)] をuseと、よくuseトレイトを自分で書かなくても自動でimplementationしてくれます。\n\nFor example：\n構造体を `println!` でdisplayしたいとき、普通は Display トレイトをimplementationdo必要がありますが、`#[derive(Debug)]` をwriteだけでOK！\n\ncodeExample：\n```rust\n#[derive(Debug)]  // Debug トレイトを自動実装\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nlet p = Point { x: 1, y: 2 };\nprintln!(\"{:?}\", p);  // Point { x: 1, y: 2 }\n```",
    "rust_lesson1_ex6_slide2_title": "Let's Try It!",
    "rust_lesson3_ex3_slide2_title": "3つの iter method",
    "rust_lesson4_ex7_slide2_content": "# 複雑なconditional\n\n```rust\nmatch Some(5) {\n    Some(x) if x % 2 == 0 => println!(\"even\"),\n    Some(x) => println!(\"odd: {}\", x),\n    None => println!(\"none\"),\n}\n```",
    "rust_lesson3_ex3_slide1_content": "# elementを1つずつ取り出す仕組み\n\niterator は、ベクタなどのデータを「1つずつ順番に」取り出す仕組みです。\n\nFor example：\n- 行列に並んでいる人を1人ずつ呼ぶ\n- 引き出しの中身を1つずつ出す\n\ncodeExample：\n```rust\nlet v = vec![1, 2, 3];\nfor x in v.iter() {\n    println!(\"{}\", x);  // 1, 2, 3 と順番に表示\n}\n```\n\n`iter()` で「順番に取り出す準備」をして、`for` で1つずつ処理します。",
    "rust_lesson3_ex3_slide1_title": "iterator?",
    "rust_lesson4_ex2_description": "トレイトを自動implementationdoderiveを学びましょう。",
    "rust_lesson3_ex4_slide1_content": "# 全部を同じように変換do\n\n**map** は、iteratorの各elementを「同じ方法で」変換します。\n\nFor example：\n- 全員の身長を2倍にdo\n- 全員の名前を大文字にdo\n- 全部の数を2乗do\n\ncodeExample：\n```rust\nlet v = vec![1, 2, 3];\nlet doubled: Vec<_> = v.iter()\n    .map(|x| x * 2)  // 各要素を2倍に\n    .collect();      // ベクタに戻す\n// [2, 4, 6]\n```\n\n`|x| x * 2` は「xを受け取って、x*2をreturn」closureです。",
    "rust_lesson1_ex3_slide1_title": "あまりを求める",
    "rust_lesson3_ex10_slide1_content": "# 所有権の違い\n\nString は所有権を持つheap上のstring、&str はreferenceです。\n\n```rust\nlet s1: String = String::from(\"hello\");\nlet s2: &str = \"hello\";\n```",
    "rust_lesson4_ex2_slide1_title": "derive（デライブ）?",
    "rust_lesson2_ex2_comment1": "& でreferenceを渡す",
    "rust_lesson4_ex5_slide1_title": "HashMap（ハッシュmap）?",
    "rust_lesson2_ex3_slide2_title": "&mut  Usage",
    "rust_lesson3_ex5_title": "filter で絞り込み",
    "rust_lesson4_ex3_slide2_title": "いつuse？",
    "rust_lesson2_ex2_title": "referenceと借用",
    "rust_lesson2_ex7_title": "Option<T> で null を安全に",
    "rust_lesson4_ex10_slide3_title": "Let's Try It!",
    "rust_lesson3_ex5_slide3_title": "Let's Try It!",
    "rust_lesson4_ex10_title": "enumerate でindex付き",
    "rust_lesson2_ex2_slide1_content": "# 所有権を渡さずに「借りる」\n\nreference をuseと、所有権を移さずにデータを「見せてもらう」ことができます。\n\nたとえるなら：\n- ムーブ = おもちゃをあげる（自分は使えない）\n- reference = おもちゃを見せる（自分も使える）\n\n作り方：\n`&`（アンパサンド）をつけるとreferenceを作れます。\n\n```rust\nlet s = String::from(\"hello\");\nlet r = &s;  // sを借りる（見せてもらう）\n// s も r も使える！\n```",
    "rust_lesson2_ex5_slide2_content": "# &self をuse\n\nmethodの最初のargumentは `&self` です。\n\ncodeExample：\n```rust\nimpl Rect {\n    fn area(&self) -> i32 {\n        self.width * self.height\n    }\n}\n```",
    "rust_lesson1_ex5_slide2_title": "Let's Try It!",
    "rust_lesson2_ex4_slide3_title": "Let's Try It!",
    "rust_lesson4_ex3_slide3_title": "Let's Try It!",
    "rust_lesson2_ex9_slide3_content": "共通の振る舞いを定義する「トレイト」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex1_slide2_content": "# impl で約束を守る\n\n構造体にトレイトをimplementationdoと、その構造体は「約束を守る」ことになります。\n\ncodeExample：\n```rust\nstruct Person { name: String }\n\nimpl Greet for Person {\n    fn greet(&self) -> String {\n        format!(\"Hello, {}\", self.name)\n    }\n}\n```\n\n読み方：\n- `impl Greet for Person` → 「PersonはGreetをimplementationdo」\n- これでPersonは「あいさつできる」ようになった！",
    "rust_lesson4_ex4_comment1": "clone でreferenceカウントを増やす",
    "rust_lesson3_ex4_slide2_content": "# map だけではexecuteされない！\n\nRustのiteratorは 遅延評価 といって、「本当に必要になるまで処理しない」仕組みです。\n\nなぜ？\n無駄な計算を省けるから。100万件あっても、最初の10件だけ欲しいなら10件だけ処理すればいい。\n\ncollect() でexecute：\n```rust\n// これだけでは何も起きない\nv.iter().map(|x| x * 2);\n\n// collect() で実行してベクタに変換\nlet result: Vec<_> = v.iter().map(|x| x * 2).collect();\n```\n\n`collect()` は「今すぐ全部処理してResultをちょうだい」という意味です。",
    "rust_lesson2_ex4_slide2_title": "struct のdefinitionのしかた",
    "rust_lesson2_ex3_slide1_content": "# 「書き換えできる」借り方\n\n普通のreference `&` は「見るだけ」ですが、可変reference `&mut` は「変更もできる」借り方です。\n\nたとえるなら：\n- `&` = 本を見せてもらう（readだけ）\n- `&mut` = ノートを借りる（writeOK）\n\nImportantなルール：\n- 可変referenceは同時に1つだけ！\n- 「みんなで見る」か「1人でwrite」かのどちらか\n\nこのルールで、データが同時に書き換えられるバグを防いでいます。",
    "rust_lesson2_ex10_slide3_title": "Let's Try It!",
    "rust_lesson2_ex4_title": "構造体をdefinitionしよう",
    "rust_lesson3_ex10_slide2_content": "# 相互変換\n\n```rust\n// &str -> String\nlet s = \"hello\".to_string();\n\n// String -> &str\nlet slice: &str = &s;\n```",
    "rust_lesson4_ex10_slide3_content": "イテレータにインデックスを付けましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex4_slide2_content": "# 「何人が持っているか」を数える\n\nRcは「今何人がこのデータを持っているか」を数えています。\n\ncodeExample：\n```rust\nlet a = Rc::new(5);\nprintln!(\"{}\", Rc::strong_count(&a));  // 1\n\nlet b = Rc::clone(&a);\nprintln!(\"{}\", Rc::strong_count(&a));  // 2\n```\n\nいつデータが消える？\n- カウントが0になったとき（誰も持っていないとき）\n- 最後の持ち主がいなくなると自動で片付けられる\n\n`Rc::clone` は「持ち主を1人増やす」操作です。",
    "rust_lesson1_ex8_slide2_title": "dictionary Usage",
    "rust_lesson4_ex3_slide1_content": "# データを「heap」に置く箱\n\nBox<T> は、データを「heap」という特別な場所に置くための箱です。\n\nmemoryの2つの場所：\n- stack：小さくて速い。サイズが決まっているデータ向け\n- heap：大きくて柔軟。サイズが大きいor変わるデータ向け\n\ncodeExample：\n```rust\nlet b = Box::new(5);  // 5をヒープに置く\nprintln!(\"{}\", *b);   // *で中身を取り出す → 5\n```\n\n`*` は「箱を開けて中身を見る」操作です。",
    "rust_lesson3_ex2_slide2_title": "closure Syntax",
    "rust_lesson4_ex4_slide1_title": "Rc（アールシー）?",
    "rust_lesson4_ex7_slide1_content": "# 追加条件\n\n**if** でパターンに追加条件をつけられます。\n\n```rust\nmatch x {\n    n if n < 0 => println!(\"negative\"),\n    n if n > 0 => println!(\"positive\"),\n    _ => println!(\"zero\"),\n}\n```",
    "rust_lesson2_ex3_title": "可変reference",
    "rust_lesson3_ex10_comment1": "to_string で String に変換",
    "rust_lesson3_ex10_slide2_title": "変換",
    "rust_lesson3_ex1_description": "referenceの有効期間を表すライフタイムを学びましょう。",
    "rust_lesson3_ex2_slide1_content": "# 名前のない「即席」function\n\nclosure は、名前をつけずにその場でcreatefunctionです。そして特別な能力があります：周りのvariableを使えるのです！\n\nFor example：\n```rust\nlet x = 5;  // 外側の変数\nlet add_x = |n| n + x;  // xを使えるクロージャ\nprintln!(\"{}\", add_x(10));  // 15\n```\n\n普通のfunctionとの違い：\n- 普通のfunction：argumentしか使えない\n- closure：argument + 周りのvariableも使える\n\n「その場の空気を読める」functionというイメージです！",
    "rust_lesson1_ex2_comment1": "x に 10 を入れる",
    "rust_lesson1_ex7_slide3_title": "Let's Try It!",
    "rust_lesson1_ex5_title": "「もし〜なら」で分けましょう",
    "rust_lesson3_ex2_slide3_title": "Let's Try It!",
    "rust_lesson3_ex7_slide2_content": "# 簡潔なerror処理\n\n```rust\n// ? を使わない場合\nmatch result {\n    Ok(v) => v,\n    Err(e) => return Err(e),\n}\n\n// ? を使う\nresult?\n```",
    "rust_lesson3_ex6_slide3_title": "Let's Try It!",
    "rust_lesson4_ex9_slide3_content": "イテレータをコレクションに変換しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex6_description": "elementを1つのvalueにまとめるfoldを学びましょう。",
    "rust_lesson2_ex9_description": "共通の振る舞いをdefine「トレイト」を学びましょう。",
    "rust_lesson2_ex8_comment1": "Ok で成功をreturn",
    "rust_lesson3_ex5_slide2_content": "# filter はreferenceのreferenceを受け取る\n\n`filter` のclosureは、referenceのreference（`&&T`）を受け取ります。そのため、valueをuseには `**x` と2回referenceを外す必要があります。\n\nなぜ？\n- `iter()` はreference（`&T`）をreturn\n- `filter` はそれをFurthermorereferenceで渡す（`&&T`）\n\nSyntax：\n```rust\n// **x で値を取り出す\n.filter(|x| **x > 2)\n\n// または * を引数につける\n.filter(|&x| *x > 2)\n```\n\n最初は混乱しますが、慣れれば大丈夫！",
    "rust_lesson1_ex5_comment1": "> でcompare",
    "rust_lesson2_ex4_description": "関連doデータをまとめる「構造体」を学びましょう。",
    "rust_lesson3_ex5_slide3_content": "条件に合う要素だけを取り出しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex7_slide3_content": "「ベクタ（Vec）」を使うと、たくさんのデータを一つの「長い はこ」にまとめて入れられます。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex5_slide2_title": "valueの取得",
    "rust_lesson3_ex1_slide1_title": "ライフタイム?",
    "rust_lesson1_ex3_comment1": "10 を 3 で割ったあまりをoutput",
    "rust_lesson3_ex1_comment1": "'a でライフタイムをdefinition",
    "rust_lesson3_ex10_slide1_title": "String vs &str",
    "rust_lesson2_title": "Rust II - 所有権とトレイト",
    "rust_lesson2_ex5_slide2_title": "methodのdefinition",
    "rust_lesson4_ex5_comment1": "insert でkeyとvalueを追加",
    "rust_lesson2_ex9_slide1_content": "# 「できること」の約束\n\nトレイト は、「このtypeはこういうことができる」という約束をdefine。\n\nFor example「鳴ける」という約束：\n- 犬は「ワン」と鳴く\n- 猫は「ニャー」と鳴く\n- 両方とも「鳴ける」能力がある\n\nトレイトは「鳴ける動物は、鳴き声を出すmethodを持つ」という約束です。\n\n他の言語とのcomparison：\n- Java: interface\n- TypeScript: interface\n\nに似た概念です。",
    "rust_lesson1_ex2_slide3_title": "Let's Try It!",
    "rust_lesson4_ex8_slide1_content": "# return valueのtypeをabstract化\n\nimpl Trait で、トレイトをimplementationdotypeを返せます。\n\n```rust\nfn make_iter() -> impl Iterator<Item = i32> {\n    vec![1, 2, 3].into_iter()\n}\n```",
    "rust_lesson1_ex2_slide2_content": "# 四則演算（しそくえんざん）\n\nRustでも算数と同じ記号で計算ができます。\n\n4つのBasic記号：\n- +（プラス）: たし算\n- -（マイナス）: ひき算\n- \\*（アスタリスク）: かけ算（×の代わり）\n- /（スラッシュ）: わり算（÷の代わり）\n\ncodeExample：\n```rust\nlet a = 10;\nlet b = 5;\nprintln!(\"{}\", a + b);  // 15 と表示される\n```\n\n`println!` の `{}` は「ここにvalueを入れてね」という目印です。",
    "rust_lesson4_ex9_slide2_content": "# 変換先を指定\n\n```rust\n// ターボフィッシュ構文\nlet v = (0..5).collect::<Vec<_>>();\n\n// 変数の型注釈\nlet v: Vec<i32> = (0..5).collect();\n```",
    "rust_lesson1_ex8_description": "「dictionary（HashMap）」をuseと、名前をつけてデータを保存し、その名前で取り出せます。",
    "rust_lesson4_ex9_slide2_title": "typeHint",
    "rust_lesson3_ex1_title": "ライフタイムのBasic",
    "rust_lesson2_ex5_description": "構造体にmethodをadd「impl」を学びましょう。",
    "rust_lesson4_ex8_comment1": "impl でトレイトをimplementationdotypeをreturn",
    "rust_lesson4_ex8_slide2_title": "argumentにも使える",
    "rust_lesson4_ex7_comment1": "if でマッチガードを追加",
    "rust_lesson2_ex9_slide2_title": "trait のdefinitionとimplementation",
    "rust_lesson4_ex10_slide2_title": "いつuse？",
    "rust_lesson3_ex7_slide2_title": "match の省略形",
    "rust_lesson1_ex6_title": "logicaloperator（&&、||）",
    "rust_lesson3_ex6_comment1": "fold で畳み込み",
    "rust_lesson2_ex6_description": "複数の状態を表す「列挙type（enum）」を学びましょう。",
    "rust_lesson4_ex10_slide1_title": "enumerate（イニュメレート）?",
    "rust_lesson1_ex7_slide1_title": "ベクタ（Vec）?",
    "rust_lesson2_ex6_slide3_content": "複数の状態を表す「列挙型（enum）」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex3_slide3_title": "Let's Try It!",
    "rust_lesson3_ex4_description": "各elementを変換domapを学びましょう。",
    "rust_lesson4_ex1_slide3_title": "Let's Try It!",
    "rust_lesson3_ex9_slide2_title": "mut が必要",
    "rust_lesson1_ex6_slide1_content": "# logicaloperator（ろんりえんざんし）\n\n2つ以上の条件を組み合わせたいときにuse記号です。\n\n2つの記号：\n- `&&`（アンドアンド）：「かつ」＝ 両方とも 正しいとき\n- `||`（オアオア）：「Alsoは」＝ どちらか 正しいとき\n\n身近なExample：\n- 遊園地：「18歳以上 かつ チケットあり」なら乗れる\n- おやつ：「宿題終わった Alsoは お手伝いした」ならOK\n\ncodeExample：\n```rust\nif score >= 70 && bonus > 0 {\n    // 70点以上 かつ ボーナスあり → 合格！\n    println!(\"合格！\");\n}\n```",
    "rust_lesson4_ex4_slide3_content": "参照カウントでデータを共有しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex6_slide3_title": "Let's Try It!",
    "rust_lesson2_ex5_slide3_content": "構造体にメソッドを追加する「impl」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex1_slide3_title": "Let's Try It!",
    "rust_lesson1_ex5_slide1_content": "# programに「判断」させよう\n\nconditional は、「もし〜なら、〇〇do」という判断をprogramにさせる仕組みです。\n\n身近なExample：\n- もし80点以上なら → 「合格！」とdisplay\n- もし雨なら → 傘を持っていく\n- もしHPが0なら → ゲームオーバー\n\nRustで Syntax：\n```rust\nif score > 80 {\n    println!(\"合格！\");\n}\n```\n\n読み方：\n- `if` →「もし」\n- `score > 80` →「スコアが80より大きいなら」\n- `{ }` の中 →「これをやる」",
    "rust_lesson4_ex5_title": "HashMap",
    "rust_lesson1_ex2_slide1_content": "# データを保存do「はこ」\n\nvariable（へんすう） は、数字や文字を入れておける「はこ」のことです。名前をつけて、あとでuseことができます。\n\nFor example：\n- 「りんごの数」というラベルの箱に「5」を入れる\n- あとで「りんごの数」と呼べば「5」が出てくる\n\nRustで Syntax：\n```rust\nlet x = 10;  // xという箱に10を入れる\nprintln!(\"{}\", x);  // xの中身（10）を表示\n```\n\n`let` は「この名前で箱をcreateよ」という意味です。",
    "rust_lesson2_ex4_slide3_content": "関連するデータをまとめる「構造体」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex6_slide1_title": "enum ?",
    "rust_lesson2_ex9_title": "トレイトをdefinitionしよう",
    "rust_lesson2_ex4_slide1_title": "構造体（こうぞうたい）?",
    "rust_lesson4_ex2_slide2_content": "# 覚えておくと便利な5つ\n\nよくusederiveトレイト：\n```rust\nDebug     // {:?} でデバッグ表示できる\nClone     // .clone() でコピーを作れる\nCopy      // 代入時に自動でコピー（小さい型向け）\nPartialEq // == で比較できる\nDefault   // 初期値を自動で作れる\n```\n\n複数指定もOK：\n```rust\n#[derive(Debug, Clone, PartialEq)]\nstruct User {\n    name: String,\n    age: u32,\n}\n```\n\n`Debug` は特によくuse。debug時に構造体の中身を見れて便利！",
    "rust_lesson2_ex1_slide1_content": "# データの「持ち主」を決めるルール\n\n所有権 は、Rust最大のFeatureです。「このデータの持ち主は誰か」をはっきりさせる仕組みです。\n\nルール：\n- データには必ず1人だけ「持ち主」がいる\n- 持ち主がいなくなると、データは自dynamicに片付けられる\n\nたとえるなら：\n- おもちゃは1人しか持てない\n- 持ち主が部屋を出たら、おもちゃは片付けられる\n\nこのルールのおかげで、Rustは「memoryリーク」（データが片付けられないバグ）を防げます！",
    "rust_lesson1_ex3_slide2_title": "Let's Try It!",
    "rust_lesson3_ex1_slide2_title": "なぜ必要？",
    "rust_lesson3_ex1_slide2_content": "# 危険なバグを防ぐ\n\nダングリングreference という危険なバグがあります。これは「もう存在しないデータ」を指し続けているreferenceのことです。\n\nExample：\n```rust\nfn longest<'a>(x: &'a str, y: &'a str) -> &'a str {\n    if x.len() > y.len() { x } else { y }\n}\n```\n\n`'a` の意味：\n- argument `x` と `y` は同じライフタイム `'a` を持つ\n- return valueも同じライフタイム `'a` を持つ\n- In other words「xとyが両方有効な間、return valueも有効」という約束\n\nRustはこれを自動でチェックしてくれます！",
    "rust_lesson4_ex6_slide2_title": "set演算",
    "rust_lesson3_ex7_comment1": "? でerrorを伝播",
    "rust_lesson3_ex2_slide2_content": "# | | でargumentを囲む\n\nclosureは `|引数| 処理` という形でwrite。`||` は「パイプ」と呼ばれます。\n\nいろいろなSyntax：\n```rust\n// 引数なし\n|| println!(\"Hello\")\n\n// 引数あり\n|x, y| x + y\n\n// 複数行のブロック\n|x| {\n    let y = x * 2;\n    y + 1\n}\n```\n\nPoint：\n- argumentを `| |` で囲む（functionの `()` の代わり）\n- typeは省略できることが多い（Rustが推測してくれる）",
    "rust_lesson2_ex7_comment1": "Some でvalueがあることを示す",
    "rust_lesson3_ex4_slide3_content": "各要素を変換するmapを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_title": "Rust (ラスト) に挑戦！",
    "rust_lesson2_ex8_description": "成功と失敗を表す「Result」を学びましょう。",
    "rust_lesson3_ex8_description": "Option/Resultのデフォルトvalueを設定しましょう。",
    "rust_lesson4_ex2_slide3_title": "Let's Try It!",
    "rust_lesson2_ex5_slide3_title": "Let's Try It!",
    "rust_lesson4_ex9_description": "iteratorをコレクションに変換しましょう。",
    "rust_lesson1_ex1_slide2_content": "# println! でscreenにdisplay\n\nRustで文字をscreenにdisplayには、`println!`（プリントラインびっくり）をuse。\n\nPoint：\n- `!` がつくのがRustのFeature（マクロと呼ばれます）\n- programは `fn main() { }` の中にwrite\n- `fn` は「function（function）」の略\n\ncodeExample：\n```rust\nfn main() {\n    println!(\"ヤッホー！\");\n}\n// 「ヤッホー！」と画面に表示される\n```\n\n`println!` の `!` は「マクロ」という特別な機能の印です。今は「おまじない」と思っておけばOK！",
    "rust_lesson3_ex6_slide1_title": "fold ?",
    "rust_lesson4_ex8_slide1_title": "impl Trait ?",
    "rust_lesson1_ex1_slide2_title": "Rustの「おまじない」",
    "rust_lesson3_ex10_description": "stringtypeの違いを理解しましょう。",
    "rust_lesson3_ex7_slide3_content": "エラーを簡潔に伝播させましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex1_comment1": "s1 の所有権を移動",
    "rust_lesson2_ex9_slide1_title": "トレイト?",
    "rust_lesson4_ex6_slide2_content": "# 和set、積setなど\n\n```rust\nset1.union(&set2)\nset1.intersection(&set2)\nset1.difference(&set2)\n```",
    "rust_lesson4_ex5_slide3_content": "キーと値のペアを格納しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex8_slide1_title": "Result（リザルト）?",
    "rust_lesson4_ex1_slide1_content": "# 「できること」の約束\n\nトレイト は、typeが持つべきmethodをdefine仕組みです。\n\nFor example：\n- 「あいさつできる」トレイト → greet() methodを持つ\n- 「displayできる」トレイト → display() methodを持つ\n\ncodeExample：\n```rust\ntrait Greet {\n    fn greet(&self) -> String;  // メソッドの「約束」\n}\n```\n\nこれは「Greetできるtypeは、greet()methodを持つ」という約束です。",
    "rust_lesson4_ex2_slide3_content": "トレイトを自動実装するderiveを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex6_title": "fold で畳み込み",
    "rust_lesson3_ex9_slide3_content": "Vecに要素を追加しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex4_slide1_content": "# 関係あるデータをまとめる「設計図」\n\n構造体（struct） は、いくつかのデータをひとまとめにdo仕組みです。\n\nFor example「点（座標）」のデータ：\n- x座標\n- y座標\n\nこの2つは関係があるので、「Point（点）」としてまとめると便利です。\n\nFor example「人」のデータ：\n- 名前\n- 年齢\n\nこれも「Person（人）」としてまとめられます。\n\n構造体は「こういうデータを持つ」という設計図です。",
    "rust_lesson4_ex1_slide1_title": "トレイト?（復習）",
    "rust_lesson2_ex3_description": "reference先のvalueを変更できる「可変reference」を学びましょう。",
    "rust_lesson2_ex7_slide2_content": "# match で安全に取り出す\n\n`match` を使って「ある場合」と「ない場合」で処理を分けます。\n\ncodeExample：\n```rust\nlet x: Option<i32> = Some(5);  // 値あり\n\nmatch x {\n    Some(n) => println!(\"値は{}です\", n),  // 5\n    None => println!(\"値がありません\"),\n}\n```\n\nなぜ安全？\n- `null` のように「あるつもりでアクセスしたら無かった」errorが起きない\n- 「ない場合」の処理を書かないとコンパイルerrorになる\n- 強制的に両方のケースを考えることになる！",
    "rust_lesson4_ex9_comment1": "collect で Vec に変換",
    "rust_lesson3_ex10_title": "String と &str",
    "rust_lesson2_ex7_slide1_title": "Option（オプション）?",
    "rust_lesson3_ex9_description": "Vecにelementを追加しましょう。",
    "rust_lesson2_ex5_comment1": "impl でmethodをimplementation",
    "rust_lesson3_ex1_slide3_content": "参照の有効期間を表すライフタイムを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex6_slide2_content": "複数の条件を組み合わせる「&&（かつ）」と「||（または）」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex5_comment1": "filter で条件に合うelementを絞り込む",
    "rust_lesson2_ex7_slide3_content": "値があるかないかを表す「Option」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex10_slide3_title": "Let's Try It!",
    "rust_lesson4_ex4_slide3_title": "Let's Try It!",
    "rust_lesson3_ex3_comment1": "iter でiteratorを取得",
    "rust_lesson3_ex6_slide3_content": "要素を1つの値にまとめるfoldを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex7_slide2_title": "ベクタの番号は「0」から！",
    "rust_lesson1_ex5_slide1_title": "conditional（じょうけんぶんき）?",
    "rust_lesson1_ex3_description": "割り算の「あまり」を求める「%」（パーセント）operatorを学びましょう。",
    "rust_lesson1_ex1_slide3_content": "Rustを使って画面に文字を表示してみましょう。println! という特別な関数を使います。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex10_slide2_content": "# <T> でtypeを「あとで決める」\n\nfunction名の後に `<T>` をつけて、`T` を「type」としてuse。\n\ncodeExample：\n```rust\n// Tはどんな型でもOK\nfn first<T>(arr: &[T]) -> &T {\n    &arr[0]  // 最初の要素を返す\n}\n\n// 使い方\nfirst(&[1, 2, 3]);         // Tはi32\nfirst(&[\"a\", \"b\", \"c\"]);   // Tは&str\n```\n\n読み方：\n- `<T>` → 「Tという名前のtypeをuseよ」\n- `T` は慣習で「Type（type）」の頭文字\n- 複数のtypeが必要なら `<T, U>` のようにwrite",
    "rust_lesson3_ex2_comment1": "|x| でclosureのargumentをdefinition",
    "rust_lesson3_ex3_description": "elementを順番に処理doiteratorを学びましょう。",
    "rust_lesson1_ex1_slide3_title": "Let's Try It!",
    "rust_lesson2_ex6_slide2_title": "enum のdefinition",
    "rust_lesson2_ex1_title": "所有権のBasic",
    "rust_lesson4_ex3_slide1_title": "Box（ボックス）?",
    "rust_lesson2_ex1_slide3_content": "Rust独自の概念「所有権」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex8_slide3_content": "Option/Resultのデフォルト値を設定しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex7_slide2_title": "使用Example",
    "rust_lesson4_ex10_description": "iteratorにindexを付けましょう。",
    "rust_lesson4_ex9_slide1_title": "collect ?",
    "rust_lesson4_ex10_slide2_content": "# 「何番目か」が必要なとき\n\n番号（index）とelementの両方が必要なときに便利です。\n\ncodeExample：\n```rust\nlet v = vec![10, 20, 30];\nfor (idx, val) in v.iter().enumerate() {\n    println!(\"{}番目の値は{}\", idx, val);\n}\n// 0番目の値は10\n// 1番目の値は20\n// 2番目の値は30\n```\n\nPoint：\n- `(i, x)` でtuple（2つのset）を受け取る\n- `i` にindex、`x` にelementが入る\n- indexは0から始まる",
    "rust_lesson3_ex2_description": "周囲のvariableを使えるanonymous function「closure」を学びましょう。",
    "rust_lesson1_ex4_comment1": "mut で変更可能にdo",
    "rust_lesson1_ex8_slide3_title": "Let's Try It!",
    "rust_lesson1_ex3_slide2_content": "割り算の「あまり」を求める「%」（パーセント）演算子を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex9_slide3_title": "Let's Try It!",
    "rust_lesson3_ex3_title": "iteratorのBasic",
    "rust_lesson3_ex9_title": "Vec のmethod push",
    "rust_lesson1_ex8_comment1": "dictionaryをcreate（keyは'みかん'、valueは'オレンジ'）",
    "rust_lesson1_ex2_comment3": "+ でたし算do",
    "rust_lesson4_ex8_slide2_content": "# ジェネリクスの代わり\n\n```rust\nfn print_all(iter: impl Iterator<Item = i32>) {\n    for x in iter {\n        println!(\"{}\", x);\n    }\n}\n```",
    "rust_lesson2_ex2_slide2_title": "reference Usage",
    "rust_lesson1_ex8_slide3_content": "「辞書（HashMap）」を使うと、名前をつけてデータを保存し、その名前で取り出せます。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex7_slide2_content": "# [ ]で番号を指定して取り出す\n\n`[番号]` で何番目のデータか指定して取り出せます。\n\nImportantなルール：番号は「0」から！\n- 1番目 → `[0]`\n- 2番目 → `[1]`\n- 3番目 → `[2]`\n\ncodeExample：\n```rust\nlet fruits = vec![\"りんご\", \"バナナ\", \"みかん\"];\n//                  ↑0番    ↑1番     ↑2番\nprintln!(\"{}\", fruits[0]);  // りんご\nprintln!(\"{}\", fruits[1]);  // バナナ\n```\n\nプログラミングでは「0から数える」のが世界共通のルールです！",
    "rust_lesson1_ex6_slide1_title": "条件を組み合わせる",
    "rust_lesson2_ex10_slide2_title": "ジェネリックfunction Syntax",
    "rust_lesson1_ex6_description": "複数の条件を組み合わせる「&&（かつ）」と「||（Alsoは）」を学びましょう。",
    "rust_lesson4_ex6_title": "HashSet",
    "rust_lesson2_ex3_slide2_content": "# mut が2か所に必要\n\n変更できるようにdoには、variableとreferenceの両方に `mut` が必要です。\n\ncodeExample：\n```rust\n// 1. 変数を mut で作る\nlet mut s = String::from(\"hello\");\n\n// 2. &mut で可変参照を渡す\nchange(&mut s);\n\nfn change(s: &mut String) {\n    s.push_str(\" world\");  // 変更できる！\n}\n```\n\nPoint：\n- `let mut 変数` でvariableを変更可能に\n- `&mut 変数` で可変referenceをcreate\n- 両方ないと変更できない！",
    "rust_lesson2_ex2_slide1_title": "reference（さんしょう）?",
    "rust_lesson3_ex6_slide2_content": "# 合計、積、結合など\n\n```rust\n// 積\nv.iter().fold(1, |acc, x| acc * x)\n\n// 文字列結合\nwords.iter().fold(String::new(), |acc, s| acc + s)\n```",
    "rust_lesson1_ex1_description": "Rustを使ってscreenに文字をdisplayしてみましょう。println! という特別なfunctionをuse。",
    "rust_lesson3_ex8_slide3_title": "Let's Try It!",
    "rust_lesson4_ex6_description": "一意なvalueのsetを管理しましょう。",
    "rust_lesson2_ex5_slide1_title": "impl ?",
    "rust_lesson1_ex8_title": "名前で引き出す「dictionary」",
    "rust_lesson2_ex7_description": "valueがあるかないかを表す「Option」を学びましょう。",
    "rust_lesson1_ex4_slide2_title": "Let's Try It!",
    "rust_lesson1_ex7_title": "たくさんのデータをまとめましょう「ベクタ」",
    "rust_lesson3_ex7_slide1_content": "# errorの早期リターン\n\n? は、Resultが Err の場合に早期リターンします。\n\n```rust\nfn read_file() -> Result<String, io::Error> {\n    let content = fs::read_to_string(\"file.txt\")?;\n    Ok(content)\n}\n```",
    "rust_lesson3_ex9_slide1_content": "# 末尾に追加\n\npush は、Vecの末尾にelementをadd。\n\n```rust\nlet mut v = vec![1, 2];\nv.push(3);\n// [1, 2, 3]\n```",
    "rust_lesson4_ex8_slide3_content": "トレイトを返す関数を簡潔に書きましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex1_title": "screenにメッセージを出しましょう",
    "rust_lesson2_ex8_slide2_title": "Result  Usage",
    "rust_lesson3_ex2_slide1_title": "closure?",
    "rust_lesson3_ex8_title": "unwrap_or でデフォルトvalue",
    "rust_lesson4_ex10_slide1_content": "# 番号とelementを一緒にもらう\n\nenumerate は、「何番目か」と「そのelement」をsetで取り出せるmethodです。\n\nFor example：\n- 0番目: りんご\n- 1番目: バナナ\n- 2番目: みかん\n\ncodeExample：\n```rust\nfor (i, x) in vec![\"a\", \"b\", \"c\"].iter().enumerate() {\n    println!(\"{}: {}\", i, x);\n}\n// 0: a\n// 1: b\n// 2: c\n```",
    "rust_lesson1_ex7_slide1_content": "# データを並べてまとめる「長い箱」\n\nベクタ（Vec） は、たくさんのデータを順番に並べて入れられる「長い箱」です。\n\nFor example：\n- 買い物listの商品を全部まとめる\n- testの点数を全部まとめる\n- 友だちの名前を全部まとめる\n\n100個でも1000個でも、1つのvariableでまとめて管理できます！\n\n作り方：\n```rust\nlet fruits = vec![\"りんご\", \"バナナ\", \"みかん\"];\n// vec! で ベクタを作る\n```",
    "rust_lesson4_ex8_slide3_title": "Let's Try It!",
    "rust_lesson4_ex7_description": "パターンマッチに条件を追加しましょう。",
    "rust_lesson1_ex4_comment2": "+= で 20 を足す",
    "rust_lesson1_ex2_comment2": "y に 5 を入れる",
    "rust_lesson2_ex3_slide3_title": "Let's Try It!",
    "rust_lesson3_ex4_slide1_title": "map（map）?",
    "rust_lesson1_ex2_slide3_content": "データに名前をつけて保存できる「変数（へんすう）」を使ってみましょう。letで変数を作ります。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex8_slide2_content": "# match で成功と失敗を分ける\n\n`match` で「成功したら」「失敗したら」の処理を書き分けます。\n\ncodeExample：\n```rust\nfn divide(a: i32, b: i32) -> Result<i32, String> {\n    if b == 0 {\n        return Err(\"0で割れません\".to_string());\n    }\n    Ok(a / b)  // 成功なら答えを返す\n}\n\nmatch divide(10, 2) {\n    Ok(v) => println!(\"答えは{}\", v),\n    Err(e) => println!(\"エラー: {}\", e),\n}\n```\n\nPoint：\n- `Ok(値)` で成功をreturn\n- `Err(エラー)` で失敗をreturn",
    "rust_lesson4_ex3_comment1": "Box::new でheapに格納",
    "rust_lesson4_ex8_description": "トレイトをreturnfunctionを簡潔に書きましょう。",
    "rust_lesson2_ex10_description": "typeを後から決められる「ジェネリクス」を学びましょう。",
    "rust_lesson2_ex3_slide1_title": "可変reference（かへんさんしょう）?",
    "rust_lesson2_ex2_description": "所有権を移さずにvalueを借りる「reference」を学びましょう。",
    "rust_lesson3_ex5_slide2_title": "** にNote！",
    "rust_lesson2_ex2_slide3_title": "Let's Try It!",
    "rust_lesson4_ex3_slide3_content": "ヒープにデータを格納するBoxを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex4_title": "累算assignmentoperator（+=、-=）",
    "rust_lesson3_ex3_slide2_content": "# 借りるか、もらうか\n\n3種類の iter があり、所有権の扱いが違います。\n\n3つの違い：\n```rust\nv.iter()       // 参照で借りる（&T）\nv.iter_mut()   // 変更可能で借りる（&mut T）\nv.into_iter()  // 所有権をもらう（T）\n```\n\n使い分け：\n- `iter()` → 見るだけ（元のベクタも使える）\n- `iter_mut()` → 中身を変更したい\n- `into_iter()` → ベクタごともらう（元は使えない）\n\n普通は `iter()` をuseことが多いです。",
    "rust_lesson2_ex1_slide1_title": "所有権（しょゆうけん）?",
    "rust_lesson4_ex6_slide3_content": "一意な値の集合を管理しましょう。\n\n（When you're ready, select \"Start Lesson\".）"
  },
  "it": {
    "rust_lesson1_course_title": "Introduction to Rust",
    "rust_lesson1_course_description": "Learn the basics of Rust programming.",
    "rust_lesson2_course_title": "Rust II - Intermediate",
    "rust_lesson2_course_description": "Learn intermediate Rust concepts.",
    "rust_lesson3_course_title": "Rust III - Advanced",
    "rust_lesson3_course_description": "Master advanced Rust techniques.",
    "rust_lesson4_course_title": "Rust IV - Expert Level",
    "rust_lesson4_course_description": "Expert-level Rust programming.",
    "rust_lesson1_ex5_slide2_content": "条件によって動きを変える if文を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex9_title": "collect で変換",
    "rust_lesson2_ex7_slide1_content": "# 「あるかもしれない、ないかもしれない」\n\nOption<T> は、valueが「あるかもしれないし、ないかもしれない」ことを表すtypeです。\n\nFor example：\n- dictionaryで単語を探す → 見つかるかもしれないし、ないかもしれない\n- ゲームでアイテムを拾う → 落ちてるかもしれないし、ないかもしれない\n\n2つの状態：\n- `Some(値)` → valueがある！\n- `None` → valueがない...\n\n他の言語では `null` をuseが、Rustでは `Option` で安全に扱います。",
    "rust_lesson1_ex2_slide1_title": "variable（へんすう）?",
    "rust_lesson1_ex7_description": "「ベクタ（Vec）」をuseと、たくさんのデータを一つの「長い はこ」にまとめて入れられます。",
    "rust_lesson2_ex9_slide2_content": "# 約束を作って、守る\n\n1. `trait` で「約束」をdefinition\n2. `impl トレイト for 型` で「約束を守る」implementationをdo\n\ncodeExample：\n```rust\n// 1. トレイト（約束）を定義\ntrait Speak {\n    fn speak(&self);  // 鳴くメソッドを持つ約束\n}\n\n// 2. Dog構造体がトレイトを実装\nstruct Dog;\nimpl Speak for Dog {\n    fn speak(&self) {\n        println!(\"woof\");\n    }\n}\n```\n\n「DogはSpeakができる」ということになります。",
    "rust_lesson4_ex4_description": "referenceカウントでデータを共有しましょう。",
    "rust_lesson4_ex5_slide1_content": "# 名前で引ける「dictionary」\n\nHashMap は、「key（名前）」と「value（データ）」をsetで保存dodictionaryです。\n\nFor example：\n- 「青チーム」→ 10点\n- 「赤チーム」→ 15点\n\ncodeExample：\n```rust\nuse std::collections::HashMap;\n\nlet mut scores = HashMap::new();\nscores.insert(\"Blue\", 10);   // 追加\nscores.insert(\"Red\", 15);    // 追加\n```\n\n`use` で機能を読み込んでからuse。",
    "rust_lesson3_ex4_title": "map でiterator変換",
    "rust_lesson4_ex1_slide3_content": "共通の振る舞いを定義するトレイトを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex4_description": "variableのvalueを手軽に増やしたり減らしたりdo「+=」「-=」を学びましょう。",
    "rust_lesson1_ex2_description": "データに名前をつけて保存できる「variable（へんすう）」を使ってみましょう。letでvariableをcreate。",
    "rust_lesson4_ex4_slide2_title": "referenceカウントの仕組み",
    "rust_lesson3_ex8_slide2_title": "unwrap_or_else",
    "rust_lesson4_ex10_comment1": "1番目の i にindex、2番目の item にelementが入る",
    "rust_lesson3_ex6_slide1_content": "# 累積処理\n\nfold は、初期valueとfunctionでelementを1つずつ畳み込みます。\n\n```rust\nlet v = vec![1, 2, 3];\nlet sum = v.iter().fold(0, |acc, x| acc + x);\n// 6\n```",
    "rust_lesson4_ex2_slide2_title": "よくuse derive トレイト",
    "rust_lesson3_ex10_slide3_content": "文字列型の違いを理解しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex4_slide2_content": "変数の値を手軽に増やしたり減らしたりする「+=」「-=」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex4_slide3_title": "Let's Try It!",
    "rust_lesson3_ex5_slide1_title": "filter（filterー）?",
    "rust_lesson4_ex5_description": "keyとvalueのpairを格納しましょう。",
    "rust_lesson3_ex5_description": "条件に合うelementだけを取り出しましょう。",
    "rust_lesson2_ex2_slide2_content": "# functionに借りてもらう\n\nfunctionにデータを渡すとき、`&` をつけると「借りる」形になります。元のvariableはそのまま使い続けられます。\n\ncodeExample：\n```rust\nfn calc_len(s: &String) -> usize {\n    s.len()  // 長さを返す\n}\n\nfn main() {\n    let text = String::from(\"hello\");\n    let len = calc_len(&text);  // textを貸す\n    // text はまだ使える！\n    println!(\"{}の長さは{}\", text, len);\n}\n```\n\n`&String` は「Stringを借りる」という意味です。",
    "rust_lesson4_ex7_slide3_content": "パターンマッチに条件を追加しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex8_slide2_content": "# 遅延評価\n\n```rust\n// クロージャで計算\nlet value = x.unwrap_or_else(|| expensive_computation());\n```",
    "rust_lesson4_ex7_title": "match ガード",
    "rust_lesson3_ex7_title": "? operatorでerror伝播",
    "rust_lesson4_ex1_description": "共通の振る舞いをdefineトレイトを学びましょう。",
    "rust_lesson2_ex1_slide2_content": "# 所有権は「移動」do\n\nvariableを別のvariableにassignmentdoと、所有権が 移動（ムーブ） します。元のvariableは使えなくなります。\n\ncodeExample：\n```rust\nlet s1 = String::from(\"hello\");  // s1 が持ち主\nlet s2 = s1;  // 所有権が s2 に移動！\n// ↓ s1 はもう使えない（エラーになる）\n// println!(\"{}\", s1);  // ダメ！\nprintln!(\"{}\", s2);  // OK！\n```\n\nイメージ：\nおもちゃを友だちにあげたら、自分はもう使えない。これがムーブです。",
    "rust_lesson1_ex8_slide1_title": "dictionary（HashMap）?",
    "rust_lesson4_ex3_slide2_content": "# サイズが決まらないとき\n\nBoxは、コンパイル時にサイズがわからないtypeにuse。\n\nFor examplerecursion的なtype：\n```rust\n// リストは「値 + 次のリスト」の繰り返し\nenum List {\n    Cons(i32, Box<List>),  // Boxで次を指す\n    Nil,                   // 終わり\n}\n```\n\nなぜBoxが必要？\n- `List` の中に `List` がある → 無限に大きくなる？\n- `Box` をuseと、サイズが固定（pointerのサイズ）になる\n\n「中身」ではなく「中身への矢印」を持つイメージです。",
    "rust_lesson2_ex10_title": "ジェネリクスを使おう",
    "rust_lesson2_ex8_slide3_title": "Let's Try It!",
    "rust_lesson3_ex9_slide2_content": "# 可変reference\n\n```rust\n// mut が必要\nlet mut v = Vec::new();\nv.push(1);\nv.push(2);\n```",
    "rust_lesson4_ex4_title": "Rc<T>",
    "rust_lesson2_ex3_comment1": "mut で可変variableにdo",
    "rust_lesson4_ex5_slide3_title": "Let's Try It!",
    "rust_lesson2_ex6_slide2_content": "# バリアントを列挙\n\n`enum 名前 { バリアント1, バリアント2, ... }` でdefine。\n\ncodeExample：\n```rust\nenum Color {\n    Red,\n    Green,\n    Blue,\n}\nlet c = Color::Red;\n```",
    "rust_lesson1_ex1_comment1": "Hello, Rust! とdisplay",
    "rust_lesson1_ex1_slide1_content": "# 安全で速い！最新のプログラミング言語\n\nRust（ラスト）は、「間違いを事前に防ぐ」ことがとても得意なプログラミング言語です。\n\nRustのすごいところ：\n- programのミスをexecute前に見つけてくれる\n- とても速く動く\n- 世界中のプログラマーが「一番好き！」と選ぶ人気の言語\n\nたとえるなら：\n厳しいけど優しい先生のような言語です。「ここ間違ってるよ」と教えてくれるので、安心してprogramが書けます！",
    "rust_lesson3_ex8_slide1_content": "# None/Err の場合のデフォルト\n\nunwrap_or は、None や Err の場合にデフォルトvalueをreturn。\n\n```rust\nlet x: Option<i32> = None;\nlet value = x.unwrap_or(0);  // 0\n```",
    "rust_lesson2_ex7_slide3_title": "Let's Try It!",
    "rust_lesson2_ex6_title": "enum で状態を表す",
    "rust_lesson2_ex8_slide1_content": "# 「成功」か「失敗」かを表す\n\nResult<T, E> は、処理が「成功したか失敗したか」を表すtypeです。\n\nFor example：\n- fileをopen → 成功（内容）か失敗（error）\n- 0で割り算 → 成功（答え）か失敗（0で割れない！）\n\n2つの状態：\n- `Ok(値)` → 成功！valueが入っている\n- `Err(エラー)` → 失敗...error情報が入っている\n\n`Option` は「あるか・ないか」、`Result` は「成功か・失敗か」という違いです。",
    "rust_lesson2_ex8_slide3_content": "成功と失敗を表す「Result」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex6_slide1_title": "HashSet ?",
    "rust_lesson3_ex9_comment1": "push でelementを追加",
    "rust_lesson2_ex7_slide2_title": "Option  Usage",
    "rust_lesson3_ex2_title": "closureのBasic",
    "rust_lesson3_ex7_slide1_title": "? operator?",
    "rust_lesson4_ex6_comment1": "HashSet をimport",
    "rust_lesson2_ex10_slide1_content": "# どんなtypeでも使える「万能」の仕組み\n\nジェネリクス は、typeを後から決められる仕組みです。\n\nなぜ便利？\n同じようなfunctionを何度も書かなくてすみます。\n\nFor example：\n- 数字のarrayの最初のelementを取るfunction\n- stringのarrayの最初のelementを取るfunction\n\n両方とも「最初のelementを取る」のは同じなのに、typeが違うだけで別のfunctionをwriteのは大変！\n\nジェネリクスなら、`<T>` で「typeは後で決める」とwriteだけで、どんなtypeでも使えるfunctionが作れます。",
    "rust_lesson1_ex3_slide1_content": "# 剰余operator（じょうよえんざんし）「%」\n\n`%`（パーセント）は、割り算の 「あまり」 をcalculate特別な記号です。\n\nわかりやすいExample：\n- 10このアメを3人で分けると？\n- 1人3こずつで、1こあまる\n- これを `10 % 3` とwriteと、答えは `1`\n\ncodeExample：\n```rust\nprintln!(\"{}\", 10 % 3);  // 1（あまり1）\nprintln!(\"{}\", 8 % 4);   // 0（あまりなし＝割り切れる）\n```\n\n使いどころ：\n- 偶数か奇数か調べる（`n % 2` が0なら偶数）\n- 時計の計算（24を超えたら0に戻る、など）",
    "rust_lesson3_ex7_description": "errorを簡潔に伝播させましょう。",
    "rust_lesson3_ex8_comment1": "unwrap_or でデフォルトvalueを設定",
    "rust_lesson2_ex8_title": "Result<T, E> でerror処理",
    "rust_lesson2_ex10_comment1": "T をtypeパラメータとしてuse",
    "rust_lesson2_ex6_comment1": "enum で列挙typeをdefinition",
    "rust_lesson3_ex3_slide3_content": "要素を順番に処理するイテレータを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex2_comment1": "derive でトレイトを自動implementation",
    "rust_lesson1_ex8_slide1_content": "# 名前でsearchできる「dictionary」\n\nHashMap（ハッシュmap）は、「名前」と「データ」をsetにして保存できる仕組みです。本物のdictionaryのように使えます。\n\nFor example果物の色dictionary：\n- 「りんご」→「あか」\n- 「バナナ」→「きいろ」\n- 「みかん」→「オレンジ」\n\nuse準備：\n```rust\nuse std::collections::HashMap;  // 機能を読み込む\nlet mut fruits = HashMap::new();  // 空の辞書を作る\nfruits.insert(\"りんご\", \"あか\");  // データを追加\n```\n\n`use` は「この機能をuseよ」というdeclarationです。",
    "rust_lesson3_ex9_slide1_title": "push ?",
    "rust_lesson4_ex1_title": "トレイトのdefinition",
    "rust_lesson4_ex3_description": "heapにデータを格納doBoxを学びましょう。",
    "rust_lesson1_ex2_title": "便利な「はこ」variable（へんすう）",
    "rust_lesson1_ex8_comment2": "中身を出す",
    "rust_lesson3_ex9_slide3_title": "Let's Try It!",
    "rust_lesson1_ex4_comment3": "-= で 50 を引く",
    "rust_lesson1_ex6_comment1": "&& で両方の条件をチェック",
    "rust_lesson4_ex1_slide2_title": "トレイトのimplementation",
    "rust_lesson4_ex7_slide3_title": "Let's Try It!",
    "rust_lesson4_title": "Rust IV - トレイトとスマートpointer",
    "rust_lesson4_ex1_comment1": "trait でトレイトをdefinition",
    "rust_lesson4_ex4_slide1_content": "# 複数の「持ち主」を許可do仕組み\n\nRc<T> は「Reference Counted（referenceカウント）」の略で、複数の所有者でデータを共有できます。\n\n普通の所有権：\n1人だけが持ち主。渡したら元の人は使えない。\n\nRc をuseと：\n複数人が同じデータの「持ち主」になれる！\n\ncodeExample：\n```rust\nuse std::rc::Rc;\n\nlet a = Rc::new(5);       // Rcでラップ\nlet b = Rc::clone(&a);    // bも持ち主になる\n// a も b も使える！\n```",
    "rust_lesson3_ex5_slide1_content": "# 条件に合うものだけ残す\n\nfilter は、条件を満たすelementだけを残し、他を捨てます。\n\nFor example：\n- 80点以上の人だけ残す\n- 偶数だけ残す\n- 「あ」から始まる名前だけ残す\n\ncodeExample：\n```rust\nlet v = vec![1, 2, 3, 4, 5];\nlet evens: Vec<_> = v.iter()\n    .filter(|x| **x % 2 == 0)  // 偶数だけ\n    .collect();\n// [2, 4]\n```\n\n条件が `true` のelementだけが残ります。",
    "rust_lesson3_ex7_slide3_title": "Let's Try It!",
    "rust_lesson1_ex7_comment2": "2番目のデータ（1番）を出す",
    "rust_lesson4_ex8_title": "impl Trait",
    "rust_lesson1_ex5_description": "条件によって動きを変える if文を学びましょう。",
    "rust_lesson3_ex4_slide2_title": "遅延評価（ちえんひょうか）",
    "rust_lesson3_ex1_slide1_content": "# referenceの「寿命」を示す印\n\nライフタイム は、referenceがいつまで使えるかを示す印です。`'a`（アポストロフィ・エー）のようにwrite。\n\nなぜ必要？\nreferenceは「借りている」状態。借りた元のデータが消えたら、referenceも使えなくなります。\n\nFor example：\n- 図書館で借りた本 → 図書館が閉まったら読めない\n- referenceで借りたデータ → 元のデータが消えたら使えない\n\nライフタイムは「このreferenceはこの範囲で有効だよ」とコンパイラに伝える仕組みです。",
    "rust_lesson1_ex1_slide1_title": "Rust（ラスト）?",
    "rust_lesson1_ex2_slide2_title": "計算の記号（operator）",
    "rust_lesson4_ex5_slide2_content": "# get で安全に取り出す\n\n`get()` methodでvalueを取り出せます。見つからない可能性があるので、`Option` が返ってきます。\n\ncodeExample：\n```rust\n// getはOption<&V>を返す\nif let Some(score) = scores.get(\"Blue\") {\n    println!(\"青チームは{}点\", score);\n}\n```\n\nPoint：\n- keyがあれば `Some(値)` が返る\n- keyがなければ `None` が返る\n- `if let` で安全に取り出せる\n\n存在しないkeyでアクセスしてもprogramが落ちない！",
    "rust_lesson4_ex7_slide1_title": "match ガード?",
    "rust_lesson3_title": "Rust III - ライフタイムとiterator",
    "rust_lesson4_ex3_title": "Box<T>",
    "rust_lesson1_ex4_slide1_title": "累算assignmentoperator（るいさんだいにゅう）?",
    "rust_lesson2_ex9_comment1": "trait でトレイトをdefinition",
    "rust_lesson2_ex1_description": "Rust独自の概念「所有権」を学びましょう。",
    "rust_lesson2_ex3_slide3_content": "参照先の値を変更できる「可変参照」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex1_slide3_title": "Let's Try It!",
    "rust_lesson3_ex6_slide2_title": "様々な畳み込み",
    "rust_lesson4_ex9_slide3_title": "Let's Try It!",
    "rust_lesson2_ex5_title": "impl でmethodを追加",
    "rust_lesson2_ex6_slide1_content": "# 複数の選択肢\n\nenum は、valueがいくつかの種類のうちの一つであることを表します。各バリアントにデータを持たせることもできます。",
    "rust_lesson2_ex4_comment1": "struct で構造体をdefinition",
    "rust_lesson1_ex3_title": "剰余operator（%）",
    "rust_lesson1_ex7_comment1": "colors というベクタをcreate（'あか', 'あお'の順）",
    "rust_lesson1_ex4_slide1_content": "# valueをかんたんに増やす・減らす\n\n`+=`（プラスイコール）と `-=`（マイナスイコール）は、variableの中身を増やしたり減らしたりdo便利な記号です。\n\nRustのImportantなルール：`mut`が必要！\nRustでは、variableをchangeには `let mut`（レット ミュート）とwrite必要があります。`mut` は「mutable（変更できる）」の略です。\n\ncodeExample：\n```rust\nlet mut score = 100;  // mut をつけて変更可能に\nscore += 10;          // 10を足す → 110に\nscore -= 50;          // 50を引く → 60に\n```\n\n`mut` がないと「このvariableは変えちゃダメ！」とRustが怒ります。",
    "rust_lesson2_ex1_slide2_title": "ムーブ（移動）",
    "rust_lesson3_ex4_comment1": "map で各elementを変換",
    "rust_lesson3_ex8_slide1_title": "unwrap_or ?",
    "rust_lesson2_ex5_slide1_content": "# implementationブロック\n\nimpl ブロックで、構造体にmethodを追加できます。`self` で自分自身をreferenceします。",
    "rust_lesson2_ex10_slide1_title": "ジェネリクス?",
    "rust_lesson1_ex8_slide2_content": "# 名前（key）で取り出す\n\ndictionaryに入れたデータは、名前（key）を指定して取り出せます。\n\ncodeExample：\n```rust\nuse std::collections::HashMap;\nfn main() {\n    let mut fruits = HashMap::new();\n    fruits.insert(\"りんご\", \"あか\");  // 追加\n    fruits.insert(\"バナナ\", \"きいろ\");  // 追加\n    \n    println!(\"{}\", fruits[\"りんご\"]);  // あか と表示\n}\n```\n\nPoint：\n- `insert(名前, データ)` で追加\n- `辞書[名前]` で取り出し\n- 番号ではなく「名前」で探せるのが便利！",
    "rust_lesson4_ex9_slide1_content": "# iteratorをコレクションに\n\ncollect は、iteratorをVecやHashMapなどに変換します。\n\n```rust\nlet v: Vec<_> = (0..5).collect();\nlet s: String = vec!['a', 'b'].into_iter().collect();\n```",
    "rust_lesson2_ex2_slide3_content": "所有権を移さずに値を借りる「参照」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex2_slide3_content": "周囲の変数を使える無名関数「クロージャ」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex4_slide2_content": "# struct keyワードでdefinition\n\n`struct 名前 { フィールド }` で構造体をdefine。フィールドには名前とtypeをwrite。\n\ncodeExample：\n```rust\n// Point 構造体を定義\nstruct Point {\n    x: i32,  // xフィールド（整数）\n    y: i32,  // yフィールド（整数）\n}\n\n// 使い方\nlet p = Point { x: 10, y: 20 };\nprintln!(\"x={}, y={}\", p.x, p.y);\n```\n\nPoint：\n- `struct 名前` で構造体をcreate\n- `{ フィールド名: 型 }` でどんなデータを持つか決める\n- `.フィールド名` でアクセス",
    "rust_lesson2_ex10_slide3_content": "型を後から決められる「ジェネリクス」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex6_slide3_title": "Let's Try It!",
    "rust_lesson4_ex6_slide1_content": "# 一意なvalueのset\n\nHashSet は、重複のないvalueのsetです。\n\n```rust\nuse std::collections::HashSet;\n\nlet mut set = HashSet::new();\nset.insert(1);\nset.insert(2);\nset.insert(1); // 重複は無視\n```",
    "rust_lesson4_ex2_title": "derive 属性",
    "rust_lesson4_ex2_slide1_content": "# トレイトを「自動で」implementation\n\n#[derive(...)] をuseと、よくuseトレイトを自分で書かなくても自動でimplementationしてくれます。\n\nFor example：\n構造体を `println!` でdisplayしたいとき、普通は Display トレイトをimplementationdo必要がありますが、`#[derive(Debug)]` をwriteだけでOK！\n\ncodeExample：\n```rust\n#[derive(Debug)]  // Debug トレイトを自動実装\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nlet p = Point { x: 1, y: 2 };\nprintln!(\"{:?}\", p);  // Point { x: 1, y: 2 }\n```",
    "rust_lesson1_ex6_slide2_title": "Let's Try It!",
    "rust_lesson3_ex3_slide2_title": "3つの iter method",
    "rust_lesson4_ex7_slide2_content": "# 複雑なconditional\n\n```rust\nmatch Some(5) {\n    Some(x) if x % 2 == 0 => println!(\"even\"),\n    Some(x) => println!(\"odd: {}\", x),\n    None => println!(\"none\"),\n}\n```",
    "rust_lesson3_ex3_slide1_content": "# elementを1つずつ取り出す仕組み\n\niterator は、ベクタなどのデータを「1つずつ順番に」取り出す仕組みです。\n\nFor example：\n- 行列に並んでいる人を1人ずつ呼ぶ\n- 引き出しの中身を1つずつ出す\n\ncodeExample：\n```rust\nlet v = vec![1, 2, 3];\nfor x in v.iter() {\n    println!(\"{}\", x);  // 1, 2, 3 と順番に表示\n}\n```\n\n`iter()` で「順番に取り出す準備」をして、`for` で1つずつ処理します。",
    "rust_lesson3_ex3_slide1_title": "iterator?",
    "rust_lesson4_ex2_description": "トレイトを自動implementationdoderiveを学びましょう。",
    "rust_lesson3_ex4_slide1_content": "# 全部を同じように変換do\n\n**map** は、iteratorの各elementを「同じ方法で」変換します。\n\nFor example：\n- 全員の身長を2倍にdo\n- 全員の名前を大文字にdo\n- 全部の数を2乗do\n\ncodeExample：\n```rust\nlet v = vec![1, 2, 3];\nlet doubled: Vec<_> = v.iter()\n    .map(|x| x * 2)  // 各要素を2倍に\n    .collect();      // ベクタに戻す\n// [2, 4, 6]\n```\n\n`|x| x * 2` は「xを受け取って、x*2をreturn」closureです。",
    "rust_lesson1_ex3_slide1_title": "あまりを求める",
    "rust_lesson3_ex10_slide1_content": "# 所有権の違い\n\nString は所有権を持つheap上のstring、&str はreferenceです。\n\n```rust\nlet s1: String = String::from(\"hello\");\nlet s2: &str = \"hello\";\n```",
    "rust_lesson4_ex2_slide1_title": "derive（デライブ）?",
    "rust_lesson2_ex2_comment1": "& でreferenceを渡す",
    "rust_lesson4_ex5_slide1_title": "HashMap（ハッシュmap）?",
    "rust_lesson2_ex3_slide2_title": "&mut  Usage",
    "rust_lesson3_ex5_title": "filter で絞り込み",
    "rust_lesson4_ex3_slide2_title": "いつuse？",
    "rust_lesson2_ex2_title": "referenceと借用",
    "rust_lesson2_ex7_title": "Option<T> で null を安全に",
    "rust_lesson4_ex10_slide3_title": "Let's Try It!",
    "rust_lesson3_ex5_slide3_title": "Let's Try It!",
    "rust_lesson4_ex10_title": "enumerate でindex付き",
    "rust_lesson2_ex2_slide1_content": "# 所有権を渡さずに「借りる」\n\nreference をuseと、所有権を移さずにデータを「見せてもらう」ことができます。\n\nたとえるなら：\n- ムーブ = おもちゃをあげる（自分は使えない）\n- reference = おもちゃを見せる（自分も使える）\n\n作り方：\n`&`（アンパサンド）をつけるとreferenceを作れます。\n\n```rust\nlet s = String::from(\"hello\");\nlet r = &s;  // sを借りる（見せてもらう）\n// s も r も使える！\n```",
    "rust_lesson2_ex5_slide2_content": "# &self をuse\n\nmethodの最初のargumentは `&self` です。\n\ncodeExample：\n```rust\nimpl Rect {\n    fn area(&self) -> i32 {\n        self.width * self.height\n    }\n}\n```",
    "rust_lesson1_ex5_slide2_title": "Let's Try It!",
    "rust_lesson2_ex4_slide3_title": "Let's Try It!",
    "rust_lesson4_ex3_slide3_title": "Let's Try It!",
    "rust_lesson2_ex9_slide3_content": "共通の振る舞いを定義する「トレイト」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex1_slide2_content": "# impl で約束を守る\n\n構造体にトレイトをimplementationdoと、その構造体は「約束を守る」ことになります。\n\ncodeExample：\n```rust\nstruct Person { name: String }\n\nimpl Greet for Person {\n    fn greet(&self) -> String {\n        format!(\"Hello, {}\", self.name)\n    }\n}\n```\n\n読み方：\n- `impl Greet for Person` → 「PersonはGreetをimplementationdo」\n- これでPersonは「あいさつできる」ようになった！",
    "rust_lesson4_ex4_comment1": "clone でreferenceカウントを増やす",
    "rust_lesson3_ex4_slide2_content": "# map だけではexecuteされない！\n\nRustのiteratorは 遅延評価 といって、「本当に必要になるまで処理しない」仕組みです。\n\nなぜ？\n無駄な計算を省けるから。100万件あっても、最初の10件だけ欲しいなら10件だけ処理すればいい。\n\ncollect() でexecute：\n```rust\n// これだけでは何も起きない\nv.iter().map(|x| x * 2);\n\n// collect() で実行してベクタに変換\nlet result: Vec<_> = v.iter().map(|x| x * 2).collect();\n```\n\n`collect()` は「今すぐ全部処理してResultをちょうだい」という意味です。",
    "rust_lesson2_ex4_slide2_title": "struct のdefinitionのしかた",
    "rust_lesson2_ex3_slide1_content": "# 「書き換えできる」借り方\n\n普通のreference `&` は「見るだけ」ですが、可変reference `&mut` は「変更もできる」借り方です。\n\nたとえるなら：\n- `&` = 本を見せてもらう（readだけ）\n- `&mut` = ノートを借りる（writeOK）\n\nImportantなルール：\n- 可変referenceは同時に1つだけ！\n- 「みんなで見る」か「1人でwrite」かのどちらか\n\nこのルールで、データが同時に書き換えられるバグを防いでいます。",
    "rust_lesson2_ex10_slide3_title": "Let's Try It!",
    "rust_lesson2_ex4_title": "構造体をdefinitionしよう",
    "rust_lesson3_ex10_slide2_content": "# 相互変換\n\n```rust\n// &str -> String\nlet s = \"hello\".to_string();\n\n// String -> &str\nlet slice: &str = &s;\n```",
    "rust_lesson4_ex10_slide3_content": "イテレータにインデックスを付けましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex4_slide2_content": "# 「何人が持っているか」を数える\n\nRcは「今何人がこのデータを持っているか」を数えています。\n\ncodeExample：\n```rust\nlet a = Rc::new(5);\nprintln!(\"{}\", Rc::strong_count(&a));  // 1\n\nlet b = Rc::clone(&a);\nprintln!(\"{}\", Rc::strong_count(&a));  // 2\n```\n\nいつデータが消える？\n- カウントが0になったとき（誰も持っていないとき）\n- 最後の持ち主がいなくなると自動で片付けられる\n\n`Rc::clone` は「持ち主を1人増やす」操作です。",
    "rust_lesson1_ex8_slide2_title": "dictionary Usage",
    "rust_lesson4_ex3_slide1_content": "# データを「heap」に置く箱\n\nBox<T> は、データを「heap」という特別な場所に置くための箱です。\n\nmemoryの2つの場所：\n- stack：小さくて速い。サイズが決まっているデータ向け\n- heap：大きくて柔軟。サイズが大きいor変わるデータ向け\n\ncodeExample：\n```rust\nlet b = Box::new(5);  // 5をヒープに置く\nprintln!(\"{}\", *b);   // *で中身を取り出す → 5\n```\n\n`*` は「箱を開けて中身を見る」操作です。",
    "rust_lesson3_ex2_slide2_title": "closure Syntax",
    "rust_lesson4_ex4_slide1_title": "Rc（アールシー）?",
    "rust_lesson4_ex7_slide1_content": "# 追加条件\n\n**if** でパターンに追加条件をつけられます。\n\n```rust\nmatch x {\n    n if n < 0 => println!(\"negative\"),\n    n if n > 0 => println!(\"positive\"),\n    _ => println!(\"zero\"),\n}\n```",
    "rust_lesson2_ex3_title": "可変reference",
    "rust_lesson3_ex10_comment1": "to_string で String に変換",
    "rust_lesson3_ex10_slide2_title": "変換",
    "rust_lesson3_ex1_description": "referenceの有効期間を表すライフタイムを学びましょう。",
    "rust_lesson3_ex2_slide1_content": "# 名前のない「即席」function\n\nclosure は、名前をつけずにその場でcreatefunctionです。そして特別な能力があります：周りのvariableを使えるのです！\n\nFor example：\n```rust\nlet x = 5;  // 外側の変数\nlet add_x = |n| n + x;  // xを使えるクロージャ\nprintln!(\"{}\", add_x(10));  // 15\n```\n\n普通のfunctionとの違い：\n- 普通のfunction：argumentしか使えない\n- closure：argument + 周りのvariableも使える\n\n「その場の空気を読める」functionというイメージです！",
    "rust_lesson1_ex2_comment1": "x に 10 を入れる",
    "rust_lesson1_ex7_slide3_title": "Let's Try It!",
    "rust_lesson1_ex5_title": "「もし〜なら」で分けましょう",
    "rust_lesson3_ex2_slide3_title": "Let's Try It!",
    "rust_lesson3_ex7_slide2_content": "# 簡潔なerror処理\n\n```rust\n// ? を使わない場合\nmatch result {\n    Ok(v) => v,\n    Err(e) => return Err(e),\n}\n\n// ? を使う\nresult?\n```",
    "rust_lesson3_ex6_slide3_title": "Let's Try It!",
    "rust_lesson4_ex9_slide3_content": "イテレータをコレクションに変換しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex6_description": "elementを1つのvalueにまとめるfoldを学びましょう。",
    "rust_lesson2_ex9_description": "共通の振る舞いをdefine「トレイト」を学びましょう。",
    "rust_lesson2_ex8_comment1": "Ok で成功をreturn",
    "rust_lesson3_ex5_slide2_content": "# filter はreferenceのreferenceを受け取る\n\n`filter` のclosureは、referenceのreference（`&&T`）を受け取ります。そのため、valueをuseには `**x` と2回referenceを外す必要があります。\n\nなぜ？\n- `iter()` はreference（`&T`）をreturn\n- `filter` はそれをFurthermorereferenceで渡す（`&&T`）\n\nSyntax：\n```rust\n// **x で値を取り出す\n.filter(|x| **x > 2)\n\n// または * を引数につける\n.filter(|&x| *x > 2)\n```\n\n最初は混乱しますが、慣れれば大丈夫！",
    "rust_lesson1_ex5_comment1": "> でcompare",
    "rust_lesson2_ex4_description": "関連doデータをまとめる「構造体」を学びましょう。",
    "rust_lesson3_ex5_slide3_content": "条件に合う要素だけを取り出しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex7_slide3_content": "「ベクタ（Vec）」を使うと、たくさんのデータを一つの「長い はこ」にまとめて入れられます。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex5_slide2_title": "valueの取得",
    "rust_lesson3_ex1_slide1_title": "ライフタイム?",
    "rust_lesson1_ex3_comment1": "10 を 3 で割ったあまりをoutput",
    "rust_lesson3_ex1_comment1": "'a でライフタイムをdefinition",
    "rust_lesson3_ex10_slide1_title": "String vs &str",
    "rust_lesson2_title": "Rust II - 所有権とトレイト",
    "rust_lesson2_ex5_slide2_title": "methodのdefinition",
    "rust_lesson4_ex5_comment1": "insert でkeyとvalueを追加",
    "rust_lesson2_ex9_slide1_content": "# 「できること」の約束\n\nトレイト は、「このtypeはこういうことができる」という約束をdefine。\n\nFor example「鳴ける」という約束：\n- 犬は「ワン」と鳴く\n- 猫は「ニャー」と鳴く\n- 両方とも「鳴ける」能力がある\n\nトレイトは「鳴ける動物は、鳴き声を出すmethodを持つ」という約束です。\n\n他の言語とのcomparison：\n- Java: interface\n- TypeScript: interface\n\nに似た概念です。",
    "rust_lesson1_ex2_slide3_title": "Let's Try It!",
    "rust_lesson4_ex8_slide1_content": "# return valueのtypeをabstract化\n\nimpl Trait で、トレイトをimplementationdotypeを返せます。\n\n```rust\nfn make_iter() -> impl Iterator<Item = i32> {\n    vec![1, 2, 3].into_iter()\n}\n```",
    "rust_lesson1_ex2_slide2_content": "# 四則演算（しそくえんざん）\n\nRustでも算数と同じ記号で計算ができます。\n\n4つのBasic記号：\n- +（プラス）: たし算\n- -（マイナス）: ひき算\n- \\*（アスタリスク）: かけ算（×の代わり）\n- /（スラッシュ）: わり算（÷の代わり）\n\ncodeExample：\n```rust\nlet a = 10;\nlet b = 5;\nprintln!(\"{}\", a + b);  // 15 と表示される\n```\n\n`println!` の `{}` は「ここにvalueを入れてね」という目印です。",
    "rust_lesson4_ex9_slide2_content": "# 変換先を指定\n\n```rust\n// ターボフィッシュ構文\nlet v = (0..5).collect::<Vec<_>>();\n\n// 変数の型注釈\nlet v: Vec<i32> = (0..5).collect();\n```",
    "rust_lesson1_ex8_description": "「dictionary（HashMap）」をuseと、名前をつけてデータを保存し、その名前で取り出せます。",
    "rust_lesson4_ex9_slide2_title": "typeHint",
    "rust_lesson3_ex1_title": "ライフタイムのBasic",
    "rust_lesson2_ex5_description": "構造体にmethodをadd「impl」を学びましょう。",
    "rust_lesson4_ex8_comment1": "impl でトレイトをimplementationdotypeをreturn",
    "rust_lesson4_ex8_slide2_title": "argumentにも使える",
    "rust_lesson4_ex7_comment1": "if でマッチガードを追加",
    "rust_lesson2_ex9_slide2_title": "trait のdefinitionとimplementation",
    "rust_lesson4_ex10_slide2_title": "いつuse？",
    "rust_lesson3_ex7_slide2_title": "match の省略形",
    "rust_lesson1_ex6_title": "logicaloperator（&&、||）",
    "rust_lesson3_ex6_comment1": "fold で畳み込み",
    "rust_lesson2_ex6_description": "複数の状態を表す「列挙type（enum）」を学びましょう。",
    "rust_lesson4_ex10_slide1_title": "enumerate（イニュメレート）?",
    "rust_lesson1_ex7_slide1_title": "ベクタ（Vec）?",
    "rust_lesson2_ex6_slide3_content": "複数の状態を表す「列挙型（enum）」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex3_slide3_title": "Let's Try It!",
    "rust_lesson3_ex4_description": "各elementを変換domapを学びましょう。",
    "rust_lesson4_ex1_slide3_title": "Let's Try It!",
    "rust_lesson3_ex9_slide2_title": "mut が必要",
    "rust_lesson1_ex6_slide1_content": "# logicaloperator（ろんりえんざんし）\n\n2つ以上の条件を組み合わせたいときにuse記号です。\n\n2つの記号：\n- `&&`（アンドアンド）：「かつ」＝ 両方とも 正しいとき\n- `||`（オアオア）：「Alsoは」＝ どちらか 正しいとき\n\n身近なExample：\n- 遊園地：「18歳以上 かつ チケットあり」なら乗れる\n- おやつ：「宿題終わった Alsoは お手伝いした」ならOK\n\ncodeExample：\n```rust\nif score >= 70 && bonus > 0 {\n    // 70点以上 かつ ボーナスあり → 合格！\n    println!(\"合格！\");\n}\n```",
    "rust_lesson4_ex4_slide3_content": "参照カウントでデータを共有しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex6_slide3_title": "Let's Try It!",
    "rust_lesson2_ex5_slide3_content": "構造体にメソッドを追加する「impl」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex1_slide3_title": "Let's Try It!",
    "rust_lesson1_ex5_slide1_content": "# programに「判断」させよう\n\nconditional は、「もし〜なら、〇〇do」という判断をprogramにさせる仕組みです。\n\n身近なExample：\n- もし80点以上なら → 「合格！」とdisplay\n- もし雨なら → 傘を持っていく\n- もしHPが0なら → ゲームオーバー\n\nRustで Syntax：\n```rust\nif score > 80 {\n    println!(\"合格！\");\n}\n```\n\n読み方：\n- `if` →「もし」\n- `score > 80` →「スコアが80より大きいなら」\n- `{ }` の中 →「これをやる」",
    "rust_lesson4_ex5_title": "HashMap",
    "rust_lesson1_ex2_slide1_content": "# データを保存do「はこ」\n\nvariable（へんすう） は、数字や文字を入れておける「はこ」のことです。名前をつけて、あとでuseことができます。\n\nFor example：\n- 「りんごの数」というラベルの箱に「5」を入れる\n- あとで「りんごの数」と呼べば「5」が出てくる\n\nRustで Syntax：\n```rust\nlet x = 10;  // xという箱に10を入れる\nprintln!(\"{}\", x);  // xの中身（10）を表示\n```\n\n`let` は「この名前で箱をcreateよ」という意味です。",
    "rust_lesson2_ex4_slide3_content": "関連するデータをまとめる「構造体」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex6_slide1_title": "enum ?",
    "rust_lesson2_ex9_title": "トレイトをdefinitionしよう",
    "rust_lesson2_ex4_slide1_title": "構造体（こうぞうたい）?",
    "rust_lesson4_ex2_slide2_content": "# 覚えておくと便利な5つ\n\nよくusederiveトレイト：\n```rust\nDebug     // {:?} でデバッグ表示できる\nClone     // .clone() でコピーを作れる\nCopy      // 代入時に自動でコピー（小さい型向け）\nPartialEq // == で比較できる\nDefault   // 初期値を自動で作れる\n```\n\n複数指定もOK：\n```rust\n#[derive(Debug, Clone, PartialEq)]\nstruct User {\n    name: String,\n    age: u32,\n}\n```\n\n`Debug` は特によくuse。debug時に構造体の中身を見れて便利！",
    "rust_lesson2_ex1_slide1_content": "# データの「持ち主」を決めるルール\n\n所有権 は、Rust最大のFeatureです。「このデータの持ち主は誰か」をはっきりさせる仕組みです。\n\nルール：\n- データには必ず1人だけ「持ち主」がいる\n- 持ち主がいなくなると、データは自dynamicに片付けられる\n\nたとえるなら：\n- おもちゃは1人しか持てない\n- 持ち主が部屋を出たら、おもちゃは片付けられる\n\nこのルールのおかげで、Rustは「memoryリーク」（データが片付けられないバグ）を防げます！",
    "rust_lesson1_ex3_slide2_title": "Let's Try It!",
    "rust_lesson3_ex1_slide2_title": "なぜ必要？",
    "rust_lesson3_ex1_slide2_content": "# 危険なバグを防ぐ\n\nダングリングreference という危険なバグがあります。これは「もう存在しないデータ」を指し続けているreferenceのことです。\n\nExample：\n```rust\nfn longest<'a>(x: &'a str, y: &'a str) -> &'a str {\n    if x.len() > y.len() { x } else { y }\n}\n```\n\n`'a` の意味：\n- argument `x` と `y` は同じライフタイム `'a` を持つ\n- return valueも同じライフタイム `'a` を持つ\n- In other words「xとyが両方有効な間、return valueも有効」という約束\n\nRustはこれを自動でチェックしてくれます！",
    "rust_lesson4_ex6_slide2_title": "set演算",
    "rust_lesson3_ex7_comment1": "? でerrorを伝播",
    "rust_lesson3_ex2_slide2_content": "# | | でargumentを囲む\n\nclosureは `|引数| 処理` という形でwrite。`||` は「パイプ」と呼ばれます。\n\nいろいろなSyntax：\n```rust\n// 引数なし\n|| println!(\"Hello\")\n\n// 引数あり\n|x, y| x + y\n\n// 複数行のブロック\n|x| {\n    let y = x * 2;\n    y + 1\n}\n```\n\nPoint：\n- argumentを `| |` で囲む（functionの `()` の代わり）\n- typeは省略できることが多い（Rustが推測してくれる）",
    "rust_lesson2_ex7_comment1": "Some でvalueがあることを示す",
    "rust_lesson3_ex4_slide3_content": "各要素を変換するmapを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_title": "Rust (ラスト) に挑戦！",
    "rust_lesson2_ex8_description": "成功と失敗を表す「Result」を学びましょう。",
    "rust_lesson3_ex8_description": "Option/Resultのデフォルトvalueを設定しましょう。",
    "rust_lesson4_ex2_slide3_title": "Let's Try It!",
    "rust_lesson2_ex5_slide3_title": "Let's Try It!",
    "rust_lesson4_ex9_description": "iteratorをコレクションに変換しましょう。",
    "rust_lesson1_ex1_slide2_content": "# println! でscreenにdisplay\n\nRustで文字をscreenにdisplayには、`println!`（プリントラインびっくり）をuse。\n\nPoint：\n- `!` がつくのがRustのFeature（マクロと呼ばれます）\n- programは `fn main() { }` の中にwrite\n- `fn` は「function（function）」の略\n\ncodeExample：\n```rust\nfn main() {\n    println!(\"ヤッホー！\");\n}\n// 「ヤッホー！」と画面に表示される\n```\n\n`println!` の `!` は「マクロ」という特別な機能の印です。今は「おまじない」と思っておけばOK！",
    "rust_lesson3_ex6_slide1_title": "fold ?",
    "rust_lesson4_ex8_slide1_title": "impl Trait ?",
    "rust_lesson1_ex1_slide2_title": "Rustの「おまじない」",
    "rust_lesson3_ex10_description": "stringtypeの違いを理解しましょう。",
    "rust_lesson3_ex7_slide3_content": "エラーを簡潔に伝播させましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex1_comment1": "s1 の所有権を移動",
    "rust_lesson2_ex9_slide1_title": "トレイト?",
    "rust_lesson4_ex6_slide2_content": "# 和set、積setなど\n\n```rust\nset1.union(&set2)\nset1.intersection(&set2)\nset1.difference(&set2)\n```",
    "rust_lesson4_ex5_slide3_content": "キーと値のペアを格納しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex8_slide1_title": "Result（リザルト）?",
    "rust_lesson4_ex1_slide1_content": "# 「できること」の約束\n\nトレイト は、typeが持つべきmethodをdefine仕組みです。\n\nFor example：\n- 「あいさつできる」トレイト → greet() methodを持つ\n- 「displayできる」トレイト → display() methodを持つ\n\ncodeExample：\n```rust\ntrait Greet {\n    fn greet(&self) -> String;  // メソッドの「約束」\n}\n```\n\nこれは「Greetできるtypeは、greet()methodを持つ」という約束です。",
    "rust_lesson4_ex2_slide3_content": "トレイトを自動実装するderiveを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex6_title": "fold で畳み込み",
    "rust_lesson3_ex9_slide3_content": "Vecに要素を追加しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex4_slide1_content": "# 関係あるデータをまとめる「設計図」\n\n構造体（struct） は、いくつかのデータをひとまとめにdo仕組みです。\n\nFor example「点（座標）」のデータ：\n- x座標\n- y座標\n\nこの2つは関係があるので、「Point（点）」としてまとめると便利です。\n\nFor example「人」のデータ：\n- 名前\n- 年齢\n\nこれも「Person（人）」としてまとめられます。\n\n構造体は「こういうデータを持つ」という設計図です。",
    "rust_lesson4_ex1_slide1_title": "トレイト?（復習）",
    "rust_lesson2_ex3_description": "reference先のvalueを変更できる「可変reference」を学びましょう。",
    "rust_lesson2_ex7_slide2_content": "# match で安全に取り出す\n\n`match` を使って「ある場合」と「ない場合」で処理を分けます。\n\ncodeExample：\n```rust\nlet x: Option<i32> = Some(5);  // 値あり\n\nmatch x {\n    Some(n) => println!(\"値は{}です\", n),  // 5\n    None => println!(\"値がありません\"),\n}\n```\n\nなぜ安全？\n- `null` のように「あるつもりでアクセスしたら無かった」errorが起きない\n- 「ない場合」の処理を書かないとコンパイルerrorになる\n- 強制的に両方のケースを考えることになる！",
    "rust_lesson4_ex9_comment1": "collect で Vec に変換",
    "rust_lesson3_ex10_title": "String と &str",
    "rust_lesson2_ex7_slide1_title": "Option（オプション）?",
    "rust_lesson3_ex9_description": "Vecにelementを追加しましょう。",
    "rust_lesson2_ex5_comment1": "impl でmethodをimplementation",
    "rust_lesson3_ex1_slide3_content": "参照の有効期間を表すライフタイムを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex6_slide2_content": "複数の条件を組み合わせる「&&（かつ）」と「||（または）」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex5_comment1": "filter で条件に合うelementを絞り込む",
    "rust_lesson2_ex7_slide3_content": "値があるかないかを表す「Option」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex10_slide3_title": "Let's Try It!",
    "rust_lesson4_ex4_slide3_title": "Let's Try It!",
    "rust_lesson3_ex3_comment1": "iter でiteratorを取得",
    "rust_lesson3_ex6_slide3_content": "要素を1つの値にまとめるfoldを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex7_slide2_title": "ベクタの番号は「0」から！",
    "rust_lesson1_ex5_slide1_title": "conditional（じょうけんぶんき）?",
    "rust_lesson1_ex3_description": "割り算の「あまり」を求める「%」（パーセント）operatorを学びましょう。",
    "rust_lesson1_ex1_slide3_content": "Rustを使って画面に文字を表示してみましょう。println! という特別な関数を使います。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex10_slide2_content": "# <T> でtypeを「あとで決める」\n\nfunction名の後に `<T>` をつけて、`T` を「type」としてuse。\n\ncodeExample：\n```rust\n// Tはどんな型でもOK\nfn first<T>(arr: &[T]) -> &T {\n    &arr[0]  // 最初の要素を返す\n}\n\n// 使い方\nfirst(&[1, 2, 3]);         // Tはi32\nfirst(&[\"a\", \"b\", \"c\"]);   // Tは&str\n```\n\n読み方：\n- `<T>` → 「Tという名前のtypeをuseよ」\n- `T` は慣習で「Type（type）」の頭文字\n- 複数のtypeが必要なら `<T, U>` のようにwrite",
    "rust_lesson3_ex2_comment1": "|x| でclosureのargumentをdefinition",
    "rust_lesson3_ex3_description": "elementを順番に処理doiteratorを学びましょう。",
    "rust_lesson1_ex1_slide3_title": "Let's Try It!",
    "rust_lesson2_ex6_slide2_title": "enum のdefinition",
    "rust_lesson2_ex1_title": "所有権のBasic",
    "rust_lesson4_ex3_slide1_title": "Box（ボックス）?",
    "rust_lesson2_ex1_slide3_content": "Rust独自の概念「所有権」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex8_slide3_content": "Option/Resultのデフォルト値を設定しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex7_slide2_title": "使用Example",
    "rust_lesson4_ex10_description": "iteratorにindexを付けましょう。",
    "rust_lesson4_ex9_slide1_title": "collect ?",
    "rust_lesson4_ex10_slide2_content": "# 「何番目か」が必要なとき\n\n番号（index）とelementの両方が必要なときに便利です。\n\ncodeExample：\n```rust\nlet v = vec![10, 20, 30];\nfor (idx, val) in v.iter().enumerate() {\n    println!(\"{}番目の値は{}\", idx, val);\n}\n// 0番目の値は10\n// 1番目の値は20\n// 2番目の値は30\n```\n\nPoint：\n- `(i, x)` でtuple（2つのset）を受け取る\n- `i` にindex、`x` にelementが入る\n- indexは0から始まる",
    "rust_lesson3_ex2_description": "周囲のvariableを使えるanonymous function「closure」を学びましょう。",
    "rust_lesson1_ex4_comment1": "mut で変更可能にdo",
    "rust_lesson1_ex8_slide3_title": "Let's Try It!",
    "rust_lesson1_ex3_slide2_content": "割り算の「あまり」を求める「%」（パーセント）演算子を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex9_slide3_title": "Let's Try It!",
    "rust_lesson3_ex3_title": "iteratorのBasic",
    "rust_lesson3_ex9_title": "Vec のmethod push",
    "rust_lesson1_ex8_comment1": "dictionaryをcreate（keyは'みかん'、valueは'オレンジ'）",
    "rust_lesson1_ex2_comment3": "+ でたし算do",
    "rust_lesson4_ex8_slide2_content": "# ジェネリクスの代わり\n\n```rust\nfn print_all(iter: impl Iterator<Item = i32>) {\n    for x in iter {\n        println!(\"{}\", x);\n    }\n}\n```",
    "rust_lesson2_ex2_slide2_title": "reference Usage",
    "rust_lesson1_ex8_slide3_content": "「辞書（HashMap）」を使うと、名前をつけてデータを保存し、その名前で取り出せます。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex7_slide2_content": "# [ ]で番号を指定して取り出す\n\n`[番号]` で何番目のデータか指定して取り出せます。\n\nImportantなルール：番号は「0」から！\n- 1番目 → `[0]`\n- 2番目 → `[1]`\n- 3番目 → `[2]`\n\ncodeExample：\n```rust\nlet fruits = vec![\"りんご\", \"バナナ\", \"みかん\"];\n//                  ↑0番    ↑1番     ↑2番\nprintln!(\"{}\", fruits[0]);  // りんご\nprintln!(\"{}\", fruits[1]);  // バナナ\n```\n\nプログラミングでは「0から数える」のが世界共通のルールです！",
    "rust_lesson1_ex6_slide1_title": "条件を組み合わせる",
    "rust_lesson2_ex10_slide2_title": "ジェネリックfunction Syntax",
    "rust_lesson1_ex6_description": "複数の条件を組み合わせる「&&（かつ）」と「||（Alsoは）」を学びましょう。",
    "rust_lesson4_ex6_title": "HashSet",
    "rust_lesson2_ex3_slide2_content": "# mut が2か所に必要\n\n変更できるようにdoには、variableとreferenceの両方に `mut` が必要です。\n\ncodeExample：\n```rust\n// 1. 変数を mut で作る\nlet mut s = String::from(\"hello\");\n\n// 2. &mut で可変参照を渡す\nchange(&mut s);\n\nfn change(s: &mut String) {\n    s.push_str(\" world\");  // 変更できる！\n}\n```\n\nPoint：\n- `let mut 変数` でvariableを変更可能に\n- `&mut 変数` で可変referenceをcreate\n- 両方ないと変更できない！",
    "rust_lesson2_ex2_slide1_title": "reference（さんしょう）?",
    "rust_lesson3_ex6_slide2_content": "# 合計、積、結合など\n\n```rust\n// 積\nv.iter().fold(1, |acc, x| acc * x)\n\n// 文字列結合\nwords.iter().fold(String::new(), |acc, s| acc + s)\n```",
    "rust_lesson1_ex1_description": "Rustを使ってscreenに文字をdisplayしてみましょう。println! という特別なfunctionをuse。",
    "rust_lesson3_ex8_slide3_title": "Let's Try It!",
    "rust_lesson4_ex6_description": "一意なvalueのsetを管理しましょう。",
    "rust_lesson2_ex5_slide1_title": "impl ?",
    "rust_lesson1_ex8_title": "名前で引き出す「dictionary」",
    "rust_lesson2_ex7_description": "valueがあるかないかを表す「Option」を学びましょう。",
    "rust_lesson1_ex4_slide2_title": "Let's Try It!",
    "rust_lesson1_ex7_title": "たくさんのデータをまとめましょう「ベクタ」",
    "rust_lesson3_ex7_slide1_content": "# errorの早期リターン\n\n? は、Resultが Err の場合に早期リターンします。\n\n```rust\nfn read_file() -> Result<String, io::Error> {\n    let content = fs::read_to_string(\"file.txt\")?;\n    Ok(content)\n}\n```",
    "rust_lesson3_ex9_slide1_content": "# 末尾に追加\n\npush は、Vecの末尾にelementをadd。\n\n```rust\nlet mut v = vec![1, 2];\nv.push(3);\n// [1, 2, 3]\n```",
    "rust_lesson4_ex8_slide3_content": "トレイトを返す関数を簡潔に書きましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex1_title": "screenにメッセージを出しましょう",
    "rust_lesson2_ex8_slide2_title": "Result  Usage",
    "rust_lesson3_ex2_slide1_title": "closure?",
    "rust_lesson3_ex8_title": "unwrap_or でデフォルトvalue",
    "rust_lesson4_ex10_slide1_content": "# 番号とelementを一緒にもらう\n\nenumerate は、「何番目か」と「そのelement」をsetで取り出せるmethodです。\n\nFor example：\n- 0番目: りんご\n- 1番目: バナナ\n- 2番目: みかん\n\ncodeExample：\n```rust\nfor (i, x) in vec![\"a\", \"b\", \"c\"].iter().enumerate() {\n    println!(\"{}: {}\", i, x);\n}\n// 0: a\n// 1: b\n// 2: c\n```",
    "rust_lesson1_ex7_slide1_content": "# データを並べてまとめる「長い箱」\n\nベクタ（Vec） は、たくさんのデータを順番に並べて入れられる「長い箱」です。\n\nFor example：\n- 買い物listの商品を全部まとめる\n- testの点数を全部まとめる\n- 友だちの名前を全部まとめる\n\n100個でも1000個でも、1つのvariableでまとめて管理できます！\n\n作り方：\n```rust\nlet fruits = vec![\"りんご\", \"バナナ\", \"みかん\"];\n// vec! で ベクタを作る\n```",
    "rust_lesson4_ex8_slide3_title": "Let's Try It!",
    "rust_lesson4_ex7_description": "パターンマッチに条件を追加しましょう。",
    "rust_lesson1_ex4_comment2": "+= で 20 を足す",
    "rust_lesson1_ex2_comment2": "y に 5 を入れる",
    "rust_lesson2_ex3_slide3_title": "Let's Try It!",
    "rust_lesson3_ex4_slide1_title": "map（map）?",
    "rust_lesson1_ex2_slide3_content": "データに名前をつけて保存できる「変数（へんすう）」を使ってみましょう。letで変数を作ります。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex8_slide2_content": "# match で成功と失敗を分ける\n\n`match` で「成功したら」「失敗したら」の処理を書き分けます。\n\ncodeExample：\n```rust\nfn divide(a: i32, b: i32) -> Result<i32, String> {\n    if b == 0 {\n        return Err(\"0で割れません\".to_string());\n    }\n    Ok(a / b)  // 成功なら答えを返す\n}\n\nmatch divide(10, 2) {\n    Ok(v) => println!(\"答えは{}\", v),\n    Err(e) => println!(\"エラー: {}\", e),\n}\n```\n\nPoint：\n- `Ok(値)` で成功をreturn\n- `Err(エラー)` で失敗をreturn",
    "rust_lesson4_ex3_comment1": "Box::new でheapに格納",
    "rust_lesson4_ex8_description": "トレイトをreturnfunctionを簡潔に書きましょう。",
    "rust_lesson2_ex10_description": "typeを後から決められる「ジェネリクス」を学びましょう。",
    "rust_lesson2_ex3_slide1_title": "可変reference（かへんさんしょう）?",
    "rust_lesson2_ex2_description": "所有権を移さずにvalueを借りる「reference」を学びましょう。",
    "rust_lesson3_ex5_slide2_title": "** にNote！",
    "rust_lesson2_ex2_slide3_title": "Let's Try It!",
    "rust_lesson4_ex3_slide3_content": "ヒープにデータを格納するBoxを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex4_title": "累算assignmentoperator（+=、-=）",
    "rust_lesson3_ex3_slide2_content": "# 借りるか、もらうか\n\n3種類の iter があり、所有権の扱いが違います。\n\n3つの違い：\n```rust\nv.iter()       // 参照で借りる（&T）\nv.iter_mut()   // 変更可能で借りる（&mut T）\nv.into_iter()  // 所有権をもらう（T）\n```\n\n使い分け：\n- `iter()` → 見るだけ（元のベクタも使える）\n- `iter_mut()` → 中身を変更したい\n- `into_iter()` → ベクタごともらう（元は使えない）\n\n普通は `iter()` をuseことが多いです。",
    "rust_lesson2_ex1_slide1_title": "所有権（しょゆうけん）?",
    "rust_lesson4_ex6_slide3_content": "一意な値の集合を管理しましょう。\n\n（When you're ready, select \"Start Lesson\".）"
  },
  "ko": {
    "rust_lesson1_course_title": "Introduction to Rust",
    "rust_lesson1_course_description": "Learn the basics of Rust programming.",
    "rust_lesson2_course_title": "Rust II - Intermediate",
    "rust_lesson2_course_description": "Learn intermediate Rust concepts.",
    "rust_lesson3_course_title": "Rust III - Advanced",
    "rust_lesson3_course_description": "Master advanced Rust techniques.",
    "rust_lesson4_course_title": "Rust IV - Expert Level",
    "rust_lesson4_course_description": "Expert-level Rust programming.",
    "rust_lesson1_ex5_slide2_content": "条件によって動きを変える if文を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex9_title": "collect で変換",
    "rust_lesson2_ex7_slide1_content": "# 「あるかもしれない、ないかもしれない」\n\nOption<T> は、valueが「あるかもしれないし、ないかもしれない」ことを表すtypeです。\n\nFor example：\n- dictionaryで単語を探す → 見つかるかもしれないし、ないかもしれない\n- ゲームでアイテムを拾う → 落ちてるかもしれないし、ないかもしれない\n\n2つの状態：\n- `Some(値)` → valueがある！\n- `None` → valueがない...\n\n他の言語では `null` をuseが、Rustでは `Option` で安全に扱います。",
    "rust_lesson1_ex2_slide1_title": "variable（へんすう）?",
    "rust_lesson1_ex7_description": "「ベクタ（Vec）」をuseと、たくさんのデータを一つの「長い はこ」にまとめて入れられます。",
    "rust_lesson2_ex9_slide2_content": "# 約束を作って、守る\n\n1. `trait` で「約束」をdefinition\n2. `impl トレイト for 型` で「約束を守る」implementationをdo\n\ncodeExample：\n```rust\n// 1. トレイト（約束）を定義\ntrait Speak {\n    fn speak(&self);  // 鳴くメソッドを持つ約束\n}\n\n// 2. Dog構造体がトレイトを実装\nstruct Dog;\nimpl Speak for Dog {\n    fn speak(&self) {\n        println!(\"woof\");\n    }\n}\n```\n\n「DogはSpeakができる」ということになります。",
    "rust_lesson4_ex4_description": "referenceカウントでデータを共有しましょう。",
    "rust_lesson4_ex5_slide1_content": "# 名前で引ける「dictionary」\n\nHashMap は、「key（名前）」と「value（データ）」をsetで保存dodictionaryです。\n\nFor example：\n- 「青チーム」→ 10点\n- 「赤チーム」→ 15点\n\ncodeExample：\n```rust\nuse std::collections::HashMap;\n\nlet mut scores = HashMap::new();\nscores.insert(\"Blue\", 10);   // 追加\nscores.insert(\"Red\", 15);    // 追加\n```\n\n`use` で機能を読み込んでからuse。",
    "rust_lesson3_ex4_title": "map でiterator変換",
    "rust_lesson4_ex1_slide3_content": "共通の振る舞いを定義するトレイトを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex4_description": "variableのvalueを手軽に増やしたり減らしたりdo「+=」「-=」を学びましょう。",
    "rust_lesson1_ex2_description": "データに名前をつけて保存できる「variable（へんすう）」を使ってみましょう。letでvariableをcreate。",
    "rust_lesson4_ex4_slide2_title": "referenceカウントの仕組み",
    "rust_lesson3_ex8_slide2_title": "unwrap_or_else",
    "rust_lesson4_ex10_comment1": "1番目の i にindex、2番目の item にelementが入る",
    "rust_lesson3_ex6_slide1_content": "# 累積処理\n\nfold は、初期valueとfunctionでelementを1つずつ畳み込みます。\n\n```rust\nlet v = vec![1, 2, 3];\nlet sum = v.iter().fold(0, |acc, x| acc + x);\n// 6\n```",
    "rust_lesson4_ex2_slide2_title": "よくuse derive トレイト",
    "rust_lesson3_ex10_slide3_content": "文字列型の違いを理解しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex4_slide2_content": "変数の値を手軽に増やしたり減らしたりする「+=」「-=」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex4_slide3_title": "Let's Try It!",
    "rust_lesson3_ex5_slide1_title": "filter（filterー）?",
    "rust_lesson4_ex5_description": "keyとvalueのpairを格納しましょう。",
    "rust_lesson3_ex5_description": "条件に合うelementだけを取り出しましょう。",
    "rust_lesson2_ex2_slide2_content": "# functionに借りてもらう\n\nfunctionにデータを渡すとき、`&` をつけると「借りる」形になります。元のvariableはそのまま使い続けられます。\n\ncodeExample：\n```rust\nfn calc_len(s: &String) -> usize {\n    s.len()  // 長さを返す\n}\n\nfn main() {\n    let text = String::from(\"hello\");\n    let len = calc_len(&text);  // textを貸す\n    // text はまだ使える！\n    println!(\"{}の長さは{}\", text, len);\n}\n```\n\n`&String` は「Stringを借りる」という意味です。",
    "rust_lesson4_ex7_slide3_content": "パターンマッチに条件を追加しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex8_slide2_content": "# 遅延評価\n\n```rust\n// クロージャで計算\nlet value = x.unwrap_or_else(|| expensive_computation());\n```",
    "rust_lesson4_ex7_title": "match ガード",
    "rust_lesson3_ex7_title": "? operatorでerror伝播",
    "rust_lesson4_ex1_description": "共通の振る舞いをdefineトレイトを学びましょう。",
    "rust_lesson2_ex1_slide2_content": "# 所有権は「移動」do\n\nvariableを別のvariableにassignmentdoと、所有権が 移動（ムーブ） します。元のvariableは使えなくなります。\n\ncodeExample：\n```rust\nlet s1 = String::from(\"hello\");  // s1 が持ち主\nlet s2 = s1;  // 所有権が s2 に移動！\n// ↓ s1 はもう使えない（エラーになる）\n// println!(\"{}\", s1);  // ダメ！\nprintln!(\"{}\", s2);  // OK！\n```\n\nイメージ：\nおもちゃを友だちにあげたら、自分はもう使えない。これがムーブです。",
    "rust_lesson1_ex8_slide1_title": "dictionary（HashMap）?",
    "rust_lesson4_ex3_slide2_content": "# サイズが決まらないとき\n\nBoxは、コンパイル時にサイズがわからないtypeにuse。\n\nFor examplerecursion的なtype：\n```rust\n// リストは「値 + 次のリスト」の繰り返し\nenum List {\n    Cons(i32, Box<List>),  // Boxで次を指す\n    Nil,                   // 終わり\n}\n```\n\nなぜBoxが必要？\n- `List` の中に `List` がある → 無限に大きくなる？\n- `Box` をuseと、サイズが固定（pointerのサイズ）になる\n\n「中身」ではなく「中身への矢印」を持つイメージです。",
    "rust_lesson2_ex10_title": "ジェネリクスを使おう",
    "rust_lesson2_ex8_slide3_title": "Let's Try It!",
    "rust_lesson3_ex9_slide2_content": "# 可変reference\n\n```rust\n// mut が必要\nlet mut v = Vec::new();\nv.push(1);\nv.push(2);\n```",
    "rust_lesson4_ex4_title": "Rc<T>",
    "rust_lesson2_ex3_comment1": "mut で可変variableにdo",
    "rust_lesson4_ex5_slide3_title": "Let's Try It!",
    "rust_lesson2_ex6_slide2_content": "# バリアントを列挙\n\n`enum 名前 { バリアント1, バリアント2, ... }` でdefine。\n\ncodeExample：\n```rust\nenum Color {\n    Red,\n    Green,\n    Blue,\n}\nlet c = Color::Red;\n```",
    "rust_lesson1_ex1_comment1": "Hello, Rust! とdisplay",
    "rust_lesson1_ex1_slide1_content": "# 安全で速い！最新のプログラミング言語\n\nRust（ラスト）は、「間違いを事前に防ぐ」ことがとても得意なプログラミング言語です。\n\nRustのすごいところ：\n- programのミスをexecute前に見つけてくれる\n- とても速く動く\n- 世界中のプログラマーが「一番好き！」と選ぶ人気の言語\n\nたとえるなら：\n厳しいけど優しい先生のような言語です。「ここ間違ってるよ」と教えてくれるので、安心してprogramが書けます！",
    "rust_lesson3_ex8_slide1_content": "# None/Err の場合のデフォルト\n\nunwrap_or は、None や Err の場合にデフォルトvalueをreturn。\n\n```rust\nlet x: Option<i32> = None;\nlet value = x.unwrap_or(0);  // 0\n```",
    "rust_lesson2_ex7_slide3_title": "Let's Try It!",
    "rust_lesson2_ex6_title": "enum で状態を表す",
    "rust_lesson2_ex8_slide1_content": "# 「成功」か「失敗」かを表す\n\nResult<T, E> は、処理が「成功したか失敗したか」を表すtypeです。\n\nFor example：\n- fileをopen → 成功（内容）か失敗（error）\n- 0で割り算 → 成功（答え）か失敗（0で割れない！）\n\n2つの状態：\n- `Ok(値)` → 成功！valueが入っている\n- `Err(エラー)` → 失敗...error情報が入っている\n\n`Option` は「あるか・ないか」、`Result` は「成功か・失敗か」という違いです。",
    "rust_lesson2_ex8_slide3_content": "成功と失敗を表す「Result」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex6_slide1_title": "HashSet ?",
    "rust_lesson3_ex9_comment1": "push でelementを追加",
    "rust_lesson2_ex7_slide2_title": "Option  Usage",
    "rust_lesson3_ex2_title": "closureのBasic",
    "rust_lesson3_ex7_slide1_title": "? operator?",
    "rust_lesson4_ex6_comment1": "HashSet をimport",
    "rust_lesson2_ex10_slide1_content": "# どんなtypeでも使える「万能」の仕組み\n\nジェネリクス は、typeを後から決められる仕組みです。\n\nなぜ便利？\n同じようなfunctionを何度も書かなくてすみます。\n\nFor example：\n- 数字のarrayの最初のelementを取るfunction\n- stringのarrayの最初のelementを取るfunction\n\n両方とも「最初のelementを取る」のは同じなのに、typeが違うだけで別のfunctionをwriteのは大変！\n\nジェネリクスなら、`<T>` で「typeは後で決める」とwriteだけで、どんなtypeでも使えるfunctionが作れます。",
    "rust_lesson1_ex3_slide1_content": "# 剰余operator（じょうよえんざんし）「%」\n\n`%`（パーセント）は、割り算の 「あまり」 をcalculate特別な記号です。\n\nわかりやすいExample：\n- 10このアメを3人で分けると？\n- 1人3こずつで、1こあまる\n- これを `10 % 3` とwriteと、答えは `1`\n\ncodeExample：\n```rust\nprintln!(\"{}\", 10 % 3);  // 1（あまり1）\nprintln!(\"{}\", 8 % 4);   // 0（あまりなし＝割り切れる）\n```\n\n使いどころ：\n- 偶数か奇数か調べる（`n % 2` が0なら偶数）\n- 時計の計算（24を超えたら0に戻る、など）",
    "rust_lesson3_ex7_description": "errorを簡潔に伝播させましょう。",
    "rust_lesson3_ex8_comment1": "unwrap_or でデフォルトvalueを設定",
    "rust_lesson2_ex8_title": "Result<T, E> でerror処理",
    "rust_lesson2_ex10_comment1": "T をtypeパラメータとしてuse",
    "rust_lesson2_ex6_comment1": "enum で列挙typeをdefinition",
    "rust_lesson3_ex3_slide3_content": "要素を順番に処理するイテレータを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex2_comment1": "derive でトレイトを自動implementation",
    "rust_lesson1_ex8_slide1_content": "# 名前でsearchできる「dictionary」\n\nHashMap（ハッシュmap）は、「名前」と「データ」をsetにして保存できる仕組みです。本物のdictionaryのように使えます。\n\nFor example果物の色dictionary：\n- 「りんご」→「あか」\n- 「バナナ」→「きいろ」\n- 「みかん」→「オレンジ」\n\nuse準備：\n```rust\nuse std::collections::HashMap;  // 機能を読み込む\nlet mut fruits = HashMap::new();  // 空の辞書を作る\nfruits.insert(\"りんご\", \"あか\");  // データを追加\n```\n\n`use` は「この機能をuseよ」というdeclarationです。",
    "rust_lesson3_ex9_slide1_title": "push ?",
    "rust_lesson4_ex1_title": "トレイトのdefinition",
    "rust_lesson4_ex3_description": "heapにデータを格納doBoxを学びましょう。",
    "rust_lesson1_ex2_title": "便利な「はこ」variable（へんすう）",
    "rust_lesson1_ex8_comment2": "中身を出す",
    "rust_lesson3_ex9_slide3_title": "Let's Try It!",
    "rust_lesson1_ex4_comment3": "-= で 50 を引く",
    "rust_lesson1_ex6_comment1": "&& で両方の条件をチェック",
    "rust_lesson4_ex1_slide2_title": "トレイトのimplementation",
    "rust_lesson4_ex7_slide3_title": "Let's Try It!",
    "rust_lesson4_title": "Rust IV - トレイトとスマートpointer",
    "rust_lesson4_ex1_comment1": "trait でトレイトをdefinition",
    "rust_lesson4_ex4_slide1_content": "# 複数の「持ち主」を許可do仕組み\n\nRc<T> は「Reference Counted（referenceカウント）」の略で、複数の所有者でデータを共有できます。\n\n普通の所有権：\n1人だけが持ち主。渡したら元の人は使えない。\n\nRc をuseと：\n複数人が同じデータの「持ち主」になれる！\n\ncodeExample：\n```rust\nuse std::rc::Rc;\n\nlet a = Rc::new(5);       // Rcでラップ\nlet b = Rc::clone(&a);    // bも持ち主になる\n// a も b も使える！\n```",
    "rust_lesson3_ex5_slide1_content": "# 条件に合うものだけ残す\n\nfilter は、条件を満たすelementだけを残し、他を捨てます。\n\nFor example：\n- 80点以上の人だけ残す\n- 偶数だけ残す\n- 「あ」から始まる名前だけ残す\n\ncodeExample：\n```rust\nlet v = vec![1, 2, 3, 4, 5];\nlet evens: Vec<_> = v.iter()\n    .filter(|x| **x % 2 == 0)  // 偶数だけ\n    .collect();\n// [2, 4]\n```\n\n条件が `true` のelementだけが残ります。",
    "rust_lesson3_ex7_slide3_title": "Let's Try It!",
    "rust_lesson1_ex7_comment2": "2番目のデータ（1番）を出す",
    "rust_lesson4_ex8_title": "impl Trait",
    "rust_lesson1_ex5_description": "条件によって動きを変える if文を学びましょう。",
    "rust_lesson3_ex4_slide2_title": "遅延評価（ちえんひょうか）",
    "rust_lesson3_ex1_slide1_content": "# referenceの「寿命」を示す印\n\nライフタイム は、referenceがいつまで使えるかを示す印です。`'a`（アポストロフィ・エー）のようにwrite。\n\nなぜ必要？\nreferenceは「借りている」状態。借りた元のデータが消えたら、referenceも使えなくなります。\n\nFor example：\n- 図書館で借りた本 → 図書館が閉まったら読めない\n- referenceで借りたデータ → 元のデータが消えたら使えない\n\nライフタイムは「このreferenceはこの範囲で有効だよ」とコンパイラに伝える仕組みです。",
    "rust_lesson1_ex1_slide1_title": "Rust（ラスト）?",
    "rust_lesson1_ex2_slide2_title": "計算の記号（operator）",
    "rust_lesson4_ex5_slide2_content": "# get で安全に取り出す\n\n`get()` methodでvalueを取り出せます。見つからない可能性があるので、`Option` が返ってきます。\n\ncodeExample：\n```rust\n// getはOption<&V>を返す\nif let Some(score) = scores.get(\"Blue\") {\n    println!(\"青チームは{}点\", score);\n}\n```\n\nPoint：\n- keyがあれば `Some(値)` が返る\n- keyがなければ `None` が返る\n- `if let` で安全に取り出せる\n\n存在しないkeyでアクセスしてもprogramが落ちない！",
    "rust_lesson4_ex7_slide1_title": "match ガード?",
    "rust_lesson3_title": "Rust III - ライフタイムとiterator",
    "rust_lesson4_ex3_title": "Box<T>",
    "rust_lesson1_ex4_slide1_title": "累算assignmentoperator（るいさんだいにゅう）?",
    "rust_lesson2_ex9_comment1": "trait でトレイトをdefinition",
    "rust_lesson2_ex1_description": "Rust独自の概念「所有権」を学びましょう。",
    "rust_lesson2_ex3_slide3_content": "参照先の値を変更できる「可変参照」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex1_slide3_title": "Let's Try It!",
    "rust_lesson3_ex6_slide2_title": "様々な畳み込み",
    "rust_lesson4_ex9_slide3_title": "Let's Try It!",
    "rust_lesson2_ex5_title": "impl でmethodを追加",
    "rust_lesson2_ex6_slide1_content": "# 複数の選択肢\n\nenum は、valueがいくつかの種類のうちの一つであることを表します。各バリアントにデータを持たせることもできます。",
    "rust_lesson2_ex4_comment1": "struct で構造体をdefinition",
    "rust_lesson1_ex3_title": "剰余operator（%）",
    "rust_lesson1_ex7_comment1": "colors というベクタをcreate（'あか', 'あお'の順）",
    "rust_lesson1_ex4_slide1_content": "# valueをかんたんに増やす・減らす\n\n`+=`（プラスイコール）と `-=`（マイナスイコール）は、variableの中身を増やしたり減らしたりdo便利な記号です。\n\nRustのImportantなルール：`mut`が必要！\nRustでは、variableをchangeには `let mut`（レット ミュート）とwrite必要があります。`mut` は「mutable（変更できる）」の略です。\n\ncodeExample：\n```rust\nlet mut score = 100;  // mut をつけて変更可能に\nscore += 10;          // 10を足す → 110に\nscore -= 50;          // 50を引く → 60に\n```\n\n`mut` がないと「このvariableは変えちゃダメ！」とRustが怒ります。",
    "rust_lesson2_ex1_slide2_title": "ムーブ（移動）",
    "rust_lesson3_ex4_comment1": "map で各elementを変換",
    "rust_lesson3_ex8_slide1_title": "unwrap_or ?",
    "rust_lesson2_ex5_slide1_content": "# implementationブロック\n\nimpl ブロックで、構造体にmethodを追加できます。`self` で自分自身をreferenceします。",
    "rust_lesson2_ex10_slide1_title": "ジェネリクス?",
    "rust_lesson1_ex8_slide2_content": "# 名前（key）で取り出す\n\ndictionaryに入れたデータは、名前（key）を指定して取り出せます。\n\ncodeExample：\n```rust\nuse std::collections::HashMap;\nfn main() {\n    let mut fruits = HashMap::new();\n    fruits.insert(\"りんご\", \"あか\");  // 追加\n    fruits.insert(\"バナナ\", \"きいろ\");  // 追加\n    \n    println!(\"{}\", fruits[\"りんご\"]);  // あか と表示\n}\n```\n\nPoint：\n- `insert(名前, データ)` で追加\n- `辞書[名前]` で取り出し\n- 番号ではなく「名前」で探せるのが便利！",
    "rust_lesson4_ex9_slide1_content": "# iteratorをコレクションに\n\ncollect は、iteratorをVecやHashMapなどに変換します。\n\n```rust\nlet v: Vec<_> = (0..5).collect();\nlet s: String = vec!['a', 'b'].into_iter().collect();\n```",
    "rust_lesson2_ex2_slide3_content": "所有権を移さずに値を借りる「参照」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex2_slide3_content": "周囲の変数を使える無名関数「クロージャ」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex4_slide2_content": "# struct keyワードでdefinition\n\n`struct 名前 { フィールド }` で構造体をdefine。フィールドには名前とtypeをwrite。\n\ncodeExample：\n```rust\n// Point 構造体を定義\nstruct Point {\n    x: i32,  // xフィールド（整数）\n    y: i32,  // yフィールド（整数）\n}\n\n// 使い方\nlet p = Point { x: 10, y: 20 };\nprintln!(\"x={}, y={}\", p.x, p.y);\n```\n\nPoint：\n- `struct 名前` で構造体をcreate\n- `{ フィールド名: 型 }` でどんなデータを持つか決める\n- `.フィールド名` でアクセス",
    "rust_lesson2_ex10_slide3_content": "型を後から決められる「ジェネリクス」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex6_slide3_title": "Let's Try It!",
    "rust_lesson4_ex6_slide1_content": "# 一意なvalueのset\n\nHashSet は、重複のないvalueのsetです。\n\n```rust\nuse std::collections::HashSet;\n\nlet mut set = HashSet::new();\nset.insert(1);\nset.insert(2);\nset.insert(1); // 重複は無視\n```",
    "rust_lesson4_ex2_title": "derive 属性",
    "rust_lesson4_ex2_slide1_content": "# トレイトを「自動で」implementation\n\n#[derive(...)] をuseと、よくuseトレイトを自分で書かなくても自動でimplementationしてくれます。\n\nFor example：\n構造体を `println!` でdisplayしたいとき、普通は Display トレイトをimplementationdo必要がありますが、`#[derive(Debug)]` をwriteだけでOK！\n\ncodeExample：\n```rust\n#[derive(Debug)]  // Debug トレイトを自動実装\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nlet p = Point { x: 1, y: 2 };\nprintln!(\"{:?}\", p);  // Point { x: 1, y: 2 }\n```",
    "rust_lesson1_ex6_slide2_title": "Let's Try It!",
    "rust_lesson3_ex3_slide2_title": "3つの iter method",
    "rust_lesson4_ex7_slide2_content": "# 複雑なconditional\n\n```rust\nmatch Some(5) {\n    Some(x) if x % 2 == 0 => println!(\"even\"),\n    Some(x) => println!(\"odd: {}\", x),\n    None => println!(\"none\"),\n}\n```",
    "rust_lesson3_ex3_slide1_content": "# elementを1つずつ取り出す仕組み\n\niterator は、ベクタなどのデータを「1つずつ順番に」取り出す仕組みです。\n\nFor example：\n- 行列に並んでいる人を1人ずつ呼ぶ\n- 引き出しの中身を1つずつ出す\n\ncodeExample：\n```rust\nlet v = vec![1, 2, 3];\nfor x in v.iter() {\n    println!(\"{}\", x);  // 1, 2, 3 と順番に表示\n}\n```\n\n`iter()` で「順番に取り出す準備」をして、`for` で1つずつ処理します。",
    "rust_lesson3_ex3_slide1_title": "iterator?",
    "rust_lesson4_ex2_description": "トレイトを自動implementationdoderiveを学びましょう。",
    "rust_lesson3_ex4_slide1_content": "# 全部を同じように変換do\n\n**map** は、iteratorの各elementを「同じ方法で」変換します。\n\nFor example：\n- 全員の身長を2倍にdo\n- 全員の名前を大文字にdo\n- 全部の数を2乗do\n\ncodeExample：\n```rust\nlet v = vec![1, 2, 3];\nlet doubled: Vec<_> = v.iter()\n    .map(|x| x * 2)  // 各要素を2倍に\n    .collect();      // ベクタに戻す\n// [2, 4, 6]\n```\n\n`|x| x * 2` は「xを受け取って、x*2をreturn」closureです。",
    "rust_lesson1_ex3_slide1_title": "あまりを求める",
    "rust_lesson3_ex10_slide1_content": "# 所有権の違い\n\nString は所有権を持つheap上のstring、&str はreferenceです。\n\n```rust\nlet s1: String = String::from(\"hello\");\nlet s2: &str = \"hello\";\n```",
    "rust_lesson4_ex2_slide1_title": "derive（デライブ）?",
    "rust_lesson2_ex2_comment1": "& でreferenceを渡す",
    "rust_lesson4_ex5_slide1_title": "HashMap（ハッシュmap）?",
    "rust_lesson2_ex3_slide2_title": "&mut  Usage",
    "rust_lesson3_ex5_title": "filter で絞り込み",
    "rust_lesson4_ex3_slide2_title": "いつuse？",
    "rust_lesson2_ex2_title": "referenceと借用",
    "rust_lesson2_ex7_title": "Option<T> で null を安全に",
    "rust_lesson4_ex10_slide3_title": "Let's Try It!",
    "rust_lesson3_ex5_slide3_title": "Let's Try It!",
    "rust_lesson4_ex10_title": "enumerate でindex付き",
    "rust_lesson2_ex2_slide1_content": "# 所有権を渡さずに「借りる」\n\nreference をuseと、所有権を移さずにデータを「見せてもらう」ことができます。\n\nたとえるなら：\n- ムーブ = おもちゃをあげる（自分は使えない）\n- reference = おもちゃを見せる（自分も使える）\n\n作り方：\n`&`（アンパサンド）をつけるとreferenceを作れます。\n\n```rust\nlet s = String::from(\"hello\");\nlet r = &s;  // sを借りる（見せてもらう）\n// s も r も使える！\n```",
    "rust_lesson2_ex5_slide2_content": "# &self をuse\n\nmethodの最初のargumentは `&self` です。\n\ncodeExample：\n```rust\nimpl Rect {\n    fn area(&self) -> i32 {\n        self.width * self.height\n    }\n}\n```",
    "rust_lesson1_ex5_slide2_title": "Let's Try It!",
    "rust_lesson2_ex4_slide3_title": "Let's Try It!",
    "rust_lesson4_ex3_slide3_title": "Let's Try It!",
    "rust_lesson2_ex9_slide3_content": "共通の振る舞いを定義する「トレイト」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex1_slide2_content": "# impl で約束を守る\n\n構造体にトレイトをimplementationdoと、その構造体は「約束を守る」ことになります。\n\ncodeExample：\n```rust\nstruct Person { name: String }\n\nimpl Greet for Person {\n    fn greet(&self) -> String {\n        format!(\"Hello, {}\", self.name)\n    }\n}\n```\n\n読み方：\n- `impl Greet for Person` → 「PersonはGreetをimplementationdo」\n- これでPersonは「あいさつできる」ようになった！",
    "rust_lesson4_ex4_comment1": "clone でreferenceカウントを増やす",
    "rust_lesson3_ex4_slide2_content": "# map だけではexecuteされない！\n\nRustのiteratorは 遅延評価 といって、「本当に必要になるまで処理しない」仕組みです。\n\nなぜ？\n無駄な計算を省けるから。100万件あっても、最初の10件だけ欲しいなら10件だけ処理すればいい。\n\ncollect() でexecute：\n```rust\n// これだけでは何も起きない\nv.iter().map(|x| x * 2);\n\n// collect() で実行してベクタに変換\nlet result: Vec<_> = v.iter().map(|x| x * 2).collect();\n```\n\n`collect()` は「今すぐ全部処理してResultをちょうだい」という意味です。",
    "rust_lesson2_ex4_slide2_title": "struct のdefinitionのしかた",
    "rust_lesson2_ex3_slide1_content": "# 「書き換えできる」借り方\n\n普通のreference `&` は「見るだけ」ですが、可変reference `&mut` は「変更もできる」借り方です。\n\nたとえるなら：\n- `&` = 本を見せてもらう（readだけ）\n- `&mut` = ノートを借りる（writeOK）\n\nImportantなルール：\n- 可変referenceは同時に1つだけ！\n- 「みんなで見る」か「1人でwrite」かのどちらか\n\nこのルールで、データが同時に書き換えられるバグを防いでいます。",
    "rust_lesson2_ex10_slide3_title": "Let's Try It!",
    "rust_lesson2_ex4_title": "構造体をdefinitionしよう",
    "rust_lesson3_ex10_slide2_content": "# 相互変換\n\n```rust\n// &str -> String\nlet s = \"hello\".to_string();\n\n// String -> &str\nlet slice: &str = &s;\n```",
    "rust_lesson4_ex10_slide3_content": "イテレータにインデックスを付けましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex4_slide2_content": "# 「何人が持っているか」を数える\n\nRcは「今何人がこのデータを持っているか」を数えています。\n\ncodeExample：\n```rust\nlet a = Rc::new(5);\nprintln!(\"{}\", Rc::strong_count(&a));  // 1\n\nlet b = Rc::clone(&a);\nprintln!(\"{}\", Rc::strong_count(&a));  // 2\n```\n\nいつデータが消える？\n- カウントが0になったとき（誰も持っていないとき）\n- 最後の持ち主がいなくなると自動で片付けられる\n\n`Rc::clone` は「持ち主を1人増やす」操作です。",
    "rust_lesson1_ex8_slide2_title": "dictionary Usage",
    "rust_lesson4_ex3_slide1_content": "# データを「heap」に置く箱\n\nBox<T> は、データを「heap」という特別な場所に置くための箱です。\n\nmemoryの2つの場所：\n- stack：小さくて速い。サイズが決まっているデータ向け\n- heap：大きくて柔軟。サイズが大きいor変わるデータ向け\n\ncodeExample：\n```rust\nlet b = Box::new(5);  // 5をヒープに置く\nprintln!(\"{}\", *b);   // *で中身を取り出す → 5\n```\n\n`*` は「箱を開けて中身を見る」操作です。",
    "rust_lesson3_ex2_slide2_title": "closure Syntax",
    "rust_lesson4_ex4_slide1_title": "Rc（アールシー）?",
    "rust_lesson4_ex7_slide1_content": "# 追加条件\n\n**if** でパターンに追加条件をつけられます。\n\n```rust\nmatch x {\n    n if n < 0 => println!(\"negative\"),\n    n if n > 0 => println!(\"positive\"),\n    _ => println!(\"zero\"),\n}\n```",
    "rust_lesson2_ex3_title": "可変reference",
    "rust_lesson3_ex10_comment1": "to_string で String に変換",
    "rust_lesson3_ex10_slide2_title": "変換",
    "rust_lesson3_ex1_description": "referenceの有効期間を表すライフタイムを学びましょう。",
    "rust_lesson3_ex2_slide1_content": "# 名前のない「即席」function\n\nclosure は、名前をつけずにその場でcreatefunctionです。そして特別な能力があります：周りのvariableを使えるのです！\n\nFor example：\n```rust\nlet x = 5;  // 外側の変数\nlet add_x = |n| n + x;  // xを使えるクロージャ\nprintln!(\"{}\", add_x(10));  // 15\n```\n\n普通のfunctionとの違い：\n- 普通のfunction：argumentしか使えない\n- closure：argument + 周りのvariableも使える\n\n「その場の空気を読める」functionというイメージです！",
    "rust_lesson1_ex2_comment1": "x に 10 を入れる",
    "rust_lesson1_ex7_slide3_title": "Let's Try It!",
    "rust_lesson1_ex5_title": "「もし〜なら」で分けましょう",
    "rust_lesson3_ex2_slide3_title": "Let's Try It!",
    "rust_lesson3_ex7_slide2_content": "# 簡潔なerror処理\n\n```rust\n// ? を使わない場合\nmatch result {\n    Ok(v) => v,\n    Err(e) => return Err(e),\n}\n\n// ? を使う\nresult?\n```",
    "rust_lesson3_ex6_slide3_title": "Let's Try It!",
    "rust_lesson4_ex9_slide3_content": "イテレータをコレクションに変換しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex6_description": "elementを1つのvalueにまとめるfoldを学びましょう。",
    "rust_lesson2_ex9_description": "共通の振る舞いをdefine「トレイト」を学びましょう。",
    "rust_lesson2_ex8_comment1": "Ok で成功をreturn",
    "rust_lesson3_ex5_slide2_content": "# filter はreferenceのreferenceを受け取る\n\n`filter` のclosureは、referenceのreference（`&&T`）を受け取ります。そのため、valueをuseには `**x` と2回referenceを外す必要があります。\n\nなぜ？\n- `iter()` はreference（`&T`）をreturn\n- `filter` はそれをFurthermorereferenceで渡す（`&&T`）\n\nSyntax：\n```rust\n// **x で値を取り出す\n.filter(|x| **x > 2)\n\n// または * を引数につける\n.filter(|&x| *x > 2)\n```\n\n最初は混乱しますが、慣れれば大丈夫！",
    "rust_lesson1_ex5_comment1": "> でcompare",
    "rust_lesson2_ex4_description": "関連doデータをまとめる「構造体」を学びましょう。",
    "rust_lesson3_ex5_slide3_content": "条件に合う要素だけを取り出しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex7_slide3_content": "「ベクタ（Vec）」を使うと、たくさんのデータを一つの「長い はこ」にまとめて入れられます。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex5_slide2_title": "valueの取得",
    "rust_lesson3_ex1_slide1_title": "ライフタイム?",
    "rust_lesson1_ex3_comment1": "10 を 3 で割ったあまりをoutput",
    "rust_lesson3_ex1_comment1": "'a でライフタイムをdefinition",
    "rust_lesson3_ex10_slide1_title": "String vs &str",
    "rust_lesson2_title": "Rust II - 所有権とトレイト",
    "rust_lesson2_ex5_slide2_title": "methodのdefinition",
    "rust_lesson4_ex5_comment1": "insert でkeyとvalueを追加",
    "rust_lesson2_ex9_slide1_content": "# 「できること」の約束\n\nトレイト は、「このtypeはこういうことができる」という約束をdefine。\n\nFor example「鳴ける」という約束：\n- 犬は「ワン」と鳴く\n- 猫は「ニャー」と鳴く\n- 両方とも「鳴ける」能力がある\n\nトレイトは「鳴ける動物は、鳴き声を出すmethodを持つ」という約束です。\n\n他の言語とのcomparison：\n- Java: interface\n- TypeScript: interface\n\nに似た概念です。",
    "rust_lesson1_ex2_slide3_title": "Let's Try It!",
    "rust_lesson4_ex8_slide1_content": "# return valueのtypeをabstract化\n\nimpl Trait で、トレイトをimplementationdotypeを返せます。\n\n```rust\nfn make_iter() -> impl Iterator<Item = i32> {\n    vec![1, 2, 3].into_iter()\n}\n```",
    "rust_lesson1_ex2_slide2_content": "# 四則演算（しそくえんざん）\n\nRustでも算数と同じ記号で計算ができます。\n\n4つのBasic記号：\n- +（プラス）: たし算\n- -（マイナス）: ひき算\n- \\*（アスタリスク）: かけ算（×の代わり）\n- /（スラッシュ）: わり算（÷の代わり）\n\ncodeExample：\n```rust\nlet a = 10;\nlet b = 5;\nprintln!(\"{}\", a + b);  // 15 と表示される\n```\n\n`println!` の `{}` は「ここにvalueを入れてね」という目印です。",
    "rust_lesson4_ex9_slide2_content": "# 変換先を指定\n\n```rust\n// ターボフィッシュ構文\nlet v = (0..5).collect::<Vec<_>>();\n\n// 変数の型注釈\nlet v: Vec<i32> = (0..5).collect();\n```",
    "rust_lesson1_ex8_description": "「dictionary（HashMap）」をuseと、名前をつけてデータを保存し、その名前で取り出せます。",
    "rust_lesson4_ex9_slide2_title": "typeHint",
    "rust_lesson3_ex1_title": "ライフタイムのBasic",
    "rust_lesson2_ex5_description": "構造体にmethodをadd「impl」を学びましょう。",
    "rust_lesson4_ex8_comment1": "impl でトレイトをimplementationdotypeをreturn",
    "rust_lesson4_ex8_slide2_title": "argumentにも使える",
    "rust_lesson4_ex7_comment1": "if でマッチガードを追加",
    "rust_lesson2_ex9_slide2_title": "trait のdefinitionとimplementation",
    "rust_lesson4_ex10_slide2_title": "いつuse？",
    "rust_lesson3_ex7_slide2_title": "match の省略形",
    "rust_lesson1_ex6_title": "logicaloperator（&&、||）",
    "rust_lesson3_ex6_comment1": "fold で畳み込み",
    "rust_lesson2_ex6_description": "複数の状態を表す「列挙type（enum）」を学びましょう。",
    "rust_lesson4_ex10_slide1_title": "enumerate（イニュメレート）?",
    "rust_lesson1_ex7_slide1_title": "ベクタ（Vec）?",
    "rust_lesson2_ex6_slide3_content": "複数の状態を表す「列挙型（enum）」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex3_slide3_title": "Let's Try It!",
    "rust_lesson3_ex4_description": "各elementを変換domapを学びましょう。",
    "rust_lesson4_ex1_slide3_title": "Let's Try It!",
    "rust_lesson3_ex9_slide2_title": "mut が必要",
    "rust_lesson1_ex6_slide1_content": "# logicaloperator（ろんりえんざんし）\n\n2つ以上の条件を組み合わせたいときにuse記号です。\n\n2つの記号：\n- `&&`（アンドアンド）：「かつ」＝ 両方とも 正しいとき\n- `||`（オアオア）：「Alsoは」＝ どちらか 正しいとき\n\n身近なExample：\n- 遊園地：「18歳以上 かつ チケットあり」なら乗れる\n- おやつ：「宿題終わった Alsoは お手伝いした」ならOK\n\ncodeExample：\n```rust\nif score >= 70 && bonus > 0 {\n    // 70点以上 かつ ボーナスあり → 合格！\n    println!(\"合格！\");\n}\n```",
    "rust_lesson4_ex4_slide3_content": "参照カウントでデータを共有しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex6_slide3_title": "Let's Try It!",
    "rust_lesson2_ex5_slide3_content": "構造体にメソッドを追加する「impl」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex1_slide3_title": "Let's Try It!",
    "rust_lesson1_ex5_slide1_content": "# programに「判断」させよう\n\nconditional は、「もし〜なら、〇〇do」という判断をprogramにさせる仕組みです。\n\n身近なExample：\n- もし80点以上なら → 「合格！」とdisplay\n- もし雨なら → 傘を持っていく\n- もしHPが0なら → ゲームオーバー\n\nRustで Syntax：\n```rust\nif score > 80 {\n    println!(\"合格！\");\n}\n```\n\n読み方：\n- `if` →「もし」\n- `score > 80` →「スコアが80より大きいなら」\n- `{ }` の中 →「これをやる」",
    "rust_lesson4_ex5_title": "HashMap",
    "rust_lesson1_ex2_slide1_content": "# データを保存do「はこ」\n\nvariable（へんすう） は、数字や文字を入れておける「はこ」のことです。名前をつけて、あとでuseことができます。\n\nFor example：\n- 「りんごの数」というラベルの箱に「5」を入れる\n- あとで「りんごの数」と呼べば「5」が出てくる\n\nRustで Syntax：\n```rust\nlet x = 10;  // xという箱に10を入れる\nprintln!(\"{}\", x);  // xの中身（10）を表示\n```\n\n`let` は「この名前で箱をcreateよ」という意味です。",
    "rust_lesson2_ex4_slide3_content": "関連するデータをまとめる「構造体」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex6_slide1_title": "enum ?",
    "rust_lesson2_ex9_title": "トレイトをdefinitionしよう",
    "rust_lesson2_ex4_slide1_title": "構造体（こうぞうたい）?",
    "rust_lesson4_ex2_slide2_content": "# 覚えておくと便利な5つ\n\nよくusederiveトレイト：\n```rust\nDebug     // {:?} でデバッグ表示できる\nClone     // .clone() でコピーを作れる\nCopy      // 代入時に自動でコピー（小さい型向け）\nPartialEq // == で比較できる\nDefault   // 初期値を自動で作れる\n```\n\n複数指定もOK：\n```rust\n#[derive(Debug, Clone, PartialEq)]\nstruct User {\n    name: String,\n    age: u32,\n}\n```\n\n`Debug` は特によくuse。debug時に構造体の中身を見れて便利！",
    "rust_lesson2_ex1_slide1_content": "# データの「持ち主」を決めるルール\n\n所有権 は、Rust最大のFeatureです。「このデータの持ち主は誰か」をはっきりさせる仕組みです。\n\nルール：\n- データには必ず1人だけ「持ち主」がいる\n- 持ち主がいなくなると、データは自dynamicに片付けられる\n\nたとえるなら：\n- おもちゃは1人しか持てない\n- 持ち主が部屋を出たら、おもちゃは片付けられる\n\nこのルールのおかげで、Rustは「memoryリーク」（データが片付けられないバグ）を防げます！",
    "rust_lesson1_ex3_slide2_title": "Let's Try It!",
    "rust_lesson3_ex1_slide2_title": "なぜ必要？",
    "rust_lesson3_ex1_slide2_content": "# 危険なバグを防ぐ\n\nダングリングreference という危険なバグがあります。これは「もう存在しないデータ」を指し続けているreferenceのことです。\n\nExample：\n```rust\nfn longest<'a>(x: &'a str, y: &'a str) -> &'a str {\n    if x.len() > y.len() { x } else { y }\n}\n```\n\n`'a` の意味：\n- argument `x` と `y` は同じライフタイム `'a` を持つ\n- return valueも同じライフタイム `'a` を持つ\n- In other words「xとyが両方有効な間、return valueも有効」という約束\n\nRustはこれを自動でチェックしてくれます！",
    "rust_lesson4_ex6_slide2_title": "set演算",
    "rust_lesson3_ex7_comment1": "? でerrorを伝播",
    "rust_lesson3_ex2_slide2_content": "# | | でargumentを囲む\n\nclosureは `|引数| 処理` という形でwrite。`||` は「パイプ」と呼ばれます。\n\nいろいろなSyntax：\n```rust\n// 引数なし\n|| println!(\"Hello\")\n\n// 引数あり\n|x, y| x + y\n\n// 複数行のブロック\n|x| {\n    let y = x * 2;\n    y + 1\n}\n```\n\nPoint：\n- argumentを `| |` で囲む（functionの `()` の代わり）\n- typeは省略できることが多い（Rustが推測してくれる）",
    "rust_lesson2_ex7_comment1": "Some でvalueがあることを示す",
    "rust_lesson3_ex4_slide3_content": "各要素を変換するmapを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_title": "Rust (ラスト) に挑戦！",
    "rust_lesson2_ex8_description": "成功と失敗を表す「Result」を学びましょう。",
    "rust_lesson3_ex8_description": "Option/Resultのデフォルトvalueを設定しましょう。",
    "rust_lesson4_ex2_slide3_title": "Let's Try It!",
    "rust_lesson2_ex5_slide3_title": "Let's Try It!",
    "rust_lesson4_ex9_description": "iteratorをコレクションに変換しましょう。",
    "rust_lesson1_ex1_slide2_content": "# println! でscreenにdisplay\n\nRustで文字をscreenにdisplayには、`println!`（プリントラインびっくり）をuse。\n\nPoint：\n- `!` がつくのがRustのFeature（マクロと呼ばれます）\n- programは `fn main() { }` の中にwrite\n- `fn` は「function（function）」の略\n\ncodeExample：\n```rust\nfn main() {\n    println!(\"ヤッホー！\");\n}\n// 「ヤッホー！」と画面に表示される\n```\n\n`println!` の `!` は「マクロ」という特別な機能の印です。今は「おまじない」と思っておけばOK！",
    "rust_lesson3_ex6_slide1_title": "fold ?",
    "rust_lesson4_ex8_slide1_title": "impl Trait ?",
    "rust_lesson1_ex1_slide2_title": "Rustの「おまじない」",
    "rust_lesson3_ex10_description": "stringtypeの違いを理解しましょう。",
    "rust_lesson3_ex7_slide3_content": "エラーを簡潔に伝播させましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex1_comment1": "s1 の所有権を移動",
    "rust_lesson2_ex9_slide1_title": "トレイト?",
    "rust_lesson4_ex6_slide2_content": "# 和set、積setなど\n\n```rust\nset1.union(&set2)\nset1.intersection(&set2)\nset1.difference(&set2)\n```",
    "rust_lesson4_ex5_slide3_content": "キーと値のペアを格納しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex8_slide1_title": "Result（リザルト）?",
    "rust_lesson4_ex1_slide1_content": "# 「できること」の約束\n\nトレイト は、typeが持つべきmethodをdefine仕組みです。\n\nFor example：\n- 「あいさつできる」トレイト → greet() methodを持つ\n- 「displayできる」トレイト → display() methodを持つ\n\ncodeExample：\n```rust\ntrait Greet {\n    fn greet(&self) -> String;  // メソッドの「約束」\n}\n```\n\nこれは「Greetできるtypeは、greet()methodを持つ」という約束です。",
    "rust_lesson4_ex2_slide3_content": "トレイトを自動実装するderiveを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex6_title": "fold で畳み込み",
    "rust_lesson3_ex9_slide3_content": "Vecに要素を追加しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex4_slide1_content": "# 関係あるデータをまとめる「設計図」\n\n構造体（struct） は、いくつかのデータをひとまとめにdo仕組みです。\n\nFor example「点（座標）」のデータ：\n- x座標\n- y座標\n\nこの2つは関係があるので、「Point（点）」としてまとめると便利です。\n\nFor example「人」のデータ：\n- 名前\n- 年齢\n\nこれも「Person（人）」としてまとめられます。\n\n構造体は「こういうデータを持つ」という設計図です。",
    "rust_lesson4_ex1_slide1_title": "トレイト?（復習）",
    "rust_lesson2_ex3_description": "reference先のvalueを変更できる「可変reference」を学びましょう。",
    "rust_lesson2_ex7_slide2_content": "# match で安全に取り出す\n\n`match` を使って「ある場合」と「ない場合」で処理を分けます。\n\ncodeExample：\n```rust\nlet x: Option<i32> = Some(5);  // 値あり\n\nmatch x {\n    Some(n) => println!(\"値は{}です\", n),  // 5\n    None => println!(\"値がありません\"),\n}\n```\n\nなぜ安全？\n- `null` のように「あるつもりでアクセスしたら無かった」errorが起きない\n- 「ない場合」の処理を書かないとコンパイルerrorになる\n- 強制的に両方のケースを考えることになる！",
    "rust_lesson4_ex9_comment1": "collect で Vec に変換",
    "rust_lesson3_ex10_title": "String と &str",
    "rust_lesson2_ex7_slide1_title": "Option（オプション）?",
    "rust_lesson3_ex9_description": "Vecにelementを追加しましょう。",
    "rust_lesson2_ex5_comment1": "impl でmethodをimplementation",
    "rust_lesson3_ex1_slide3_content": "参照の有効期間を表すライフタイムを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex6_slide2_content": "複数の条件を組み合わせる「&&（かつ）」と「||（または）」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex5_comment1": "filter で条件に合うelementを絞り込む",
    "rust_lesson2_ex7_slide3_content": "値があるかないかを表す「Option」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex10_slide3_title": "Let's Try It!",
    "rust_lesson4_ex4_slide3_title": "Let's Try It!",
    "rust_lesson3_ex3_comment1": "iter でiteratorを取得",
    "rust_lesson3_ex6_slide3_content": "要素を1つの値にまとめるfoldを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex7_slide2_title": "ベクタの番号は「0」から！",
    "rust_lesson1_ex5_slide1_title": "conditional（じょうけんぶんき）?",
    "rust_lesson1_ex3_description": "割り算の「あまり」を求める「%」（パーセント）operatorを学びましょう。",
    "rust_lesson1_ex1_slide3_content": "Rustを使って画面に文字を表示してみましょう。println! という特別な関数を使います。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex10_slide2_content": "# <T> でtypeを「あとで決める」\n\nfunction名の後に `<T>` をつけて、`T` を「type」としてuse。\n\ncodeExample：\n```rust\n// Tはどんな型でもOK\nfn first<T>(arr: &[T]) -> &T {\n    &arr[0]  // 最初の要素を返す\n}\n\n// 使い方\nfirst(&[1, 2, 3]);         // Tはi32\nfirst(&[\"a\", \"b\", \"c\"]);   // Tは&str\n```\n\n読み方：\n- `<T>` → 「Tという名前のtypeをuseよ」\n- `T` は慣習で「Type（type）」の頭文字\n- 複数のtypeが必要なら `<T, U>` のようにwrite",
    "rust_lesson3_ex2_comment1": "|x| でclosureのargumentをdefinition",
    "rust_lesson3_ex3_description": "elementを順番に処理doiteratorを学びましょう。",
    "rust_lesson1_ex1_slide3_title": "Let's Try It!",
    "rust_lesson2_ex6_slide2_title": "enum のdefinition",
    "rust_lesson2_ex1_title": "所有権のBasic",
    "rust_lesson4_ex3_slide1_title": "Box（ボックス）?",
    "rust_lesson2_ex1_slide3_content": "Rust独自の概念「所有権」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex8_slide3_content": "Option/Resultのデフォルト値を設定しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex7_slide2_title": "使用Example",
    "rust_lesson4_ex10_description": "iteratorにindexを付けましょう。",
    "rust_lesson4_ex9_slide1_title": "collect ?",
    "rust_lesson4_ex10_slide2_content": "# 「何番目か」が必要なとき\n\n番号（index）とelementの両方が必要なときに便利です。\n\ncodeExample：\n```rust\nlet v = vec![10, 20, 30];\nfor (idx, val) in v.iter().enumerate() {\n    println!(\"{}番目の値は{}\", idx, val);\n}\n// 0番目の値は10\n// 1番目の値は20\n// 2番目の値は30\n```\n\nPoint：\n- `(i, x)` でtuple（2つのset）を受け取る\n- `i` にindex、`x` にelementが入る\n- indexは0から始まる",
    "rust_lesson3_ex2_description": "周囲のvariableを使えるanonymous function「closure」を学びましょう。",
    "rust_lesson1_ex4_comment1": "mut で変更可能にdo",
    "rust_lesson1_ex8_slide3_title": "Let's Try It!",
    "rust_lesson1_ex3_slide2_content": "割り算の「あまり」を求める「%」（パーセント）演算子を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex9_slide3_title": "Let's Try It!",
    "rust_lesson3_ex3_title": "iteratorのBasic",
    "rust_lesson3_ex9_title": "Vec のmethod push",
    "rust_lesson1_ex8_comment1": "dictionaryをcreate（keyは'みかん'、valueは'オレンジ'）",
    "rust_lesson1_ex2_comment3": "+ でたし算do",
    "rust_lesson4_ex8_slide2_content": "# ジェネリクスの代わり\n\n```rust\nfn print_all(iter: impl Iterator<Item = i32>) {\n    for x in iter {\n        println!(\"{}\", x);\n    }\n}\n```",
    "rust_lesson2_ex2_slide2_title": "reference Usage",
    "rust_lesson1_ex8_slide3_content": "「辞書（HashMap）」を使うと、名前をつけてデータを保存し、その名前で取り出せます。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex7_slide2_content": "# [ ]で番号を指定して取り出す\n\n`[番号]` で何番目のデータか指定して取り出せます。\n\nImportantなルール：番号は「0」から！\n- 1番目 → `[0]`\n- 2番目 → `[1]`\n- 3番目 → `[2]`\n\ncodeExample：\n```rust\nlet fruits = vec![\"りんご\", \"バナナ\", \"みかん\"];\n//                  ↑0番    ↑1番     ↑2番\nprintln!(\"{}\", fruits[0]);  // りんご\nprintln!(\"{}\", fruits[1]);  // バナナ\n```\n\nプログラミングでは「0から数える」のが世界共通のルールです！",
    "rust_lesson1_ex6_slide1_title": "条件を組み合わせる",
    "rust_lesson2_ex10_slide2_title": "ジェネリックfunction Syntax",
    "rust_lesson1_ex6_description": "複数の条件を組み合わせる「&&（かつ）」と「||（Alsoは）」を学びましょう。",
    "rust_lesson4_ex6_title": "HashSet",
    "rust_lesson2_ex3_slide2_content": "# mut が2か所に必要\n\n変更できるようにdoには、variableとreferenceの両方に `mut` が必要です。\n\ncodeExample：\n```rust\n// 1. 変数を mut で作る\nlet mut s = String::from(\"hello\");\n\n// 2. &mut で可変参照を渡す\nchange(&mut s);\n\nfn change(s: &mut String) {\n    s.push_str(\" world\");  // 変更できる！\n}\n```\n\nPoint：\n- `let mut 変数` でvariableを変更可能に\n- `&mut 変数` で可変referenceをcreate\n- 両方ないと変更できない！",
    "rust_lesson2_ex2_slide1_title": "reference（さんしょう）?",
    "rust_lesson3_ex6_slide2_content": "# 合計、積、結合など\n\n```rust\n// 積\nv.iter().fold(1, |acc, x| acc * x)\n\n// 文字列結合\nwords.iter().fold(String::new(), |acc, s| acc + s)\n```",
    "rust_lesson1_ex1_description": "Rustを使ってscreenに文字をdisplayしてみましょう。println! という特別なfunctionをuse。",
    "rust_lesson3_ex8_slide3_title": "Let's Try It!",
    "rust_lesson4_ex6_description": "一意なvalueのsetを管理しましょう。",
    "rust_lesson2_ex5_slide1_title": "impl ?",
    "rust_lesson1_ex8_title": "名前で引き出す「dictionary」",
    "rust_lesson2_ex7_description": "valueがあるかないかを表す「Option」を学びましょう。",
    "rust_lesson1_ex4_slide2_title": "Let's Try It!",
    "rust_lesson1_ex7_title": "たくさんのデータをまとめましょう「ベクタ」",
    "rust_lesson3_ex7_slide1_content": "# errorの早期リターン\n\n? は、Resultが Err の場合に早期リターンします。\n\n```rust\nfn read_file() -> Result<String, io::Error> {\n    let content = fs::read_to_string(\"file.txt\")?;\n    Ok(content)\n}\n```",
    "rust_lesson3_ex9_slide1_content": "# 末尾に追加\n\npush は、Vecの末尾にelementをadd。\n\n```rust\nlet mut v = vec![1, 2];\nv.push(3);\n// [1, 2, 3]\n```",
    "rust_lesson4_ex8_slide3_content": "トレイトを返す関数を簡潔に書きましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex1_title": "screenにメッセージを出しましょう",
    "rust_lesson2_ex8_slide2_title": "Result  Usage",
    "rust_lesson3_ex2_slide1_title": "closure?",
    "rust_lesson3_ex8_title": "unwrap_or でデフォルトvalue",
    "rust_lesson4_ex10_slide1_content": "# 番号とelementを一緒にもらう\n\nenumerate は、「何番目か」と「そのelement」をsetで取り出せるmethodです。\n\nFor example：\n- 0番目: りんご\n- 1番目: バナナ\n- 2番目: みかん\n\ncodeExample：\n```rust\nfor (i, x) in vec![\"a\", \"b\", \"c\"].iter().enumerate() {\n    println!(\"{}: {}\", i, x);\n}\n// 0: a\n// 1: b\n// 2: c\n```",
    "rust_lesson1_ex7_slide1_content": "# データを並べてまとめる「長い箱」\n\nベクタ（Vec） は、たくさんのデータを順番に並べて入れられる「長い箱」です。\n\nFor example：\n- 買い物listの商品を全部まとめる\n- testの点数を全部まとめる\n- 友だちの名前を全部まとめる\n\n100個でも1000個でも、1つのvariableでまとめて管理できます！\n\n作り方：\n```rust\nlet fruits = vec![\"りんご\", \"バナナ\", \"みかん\"];\n// vec! で ベクタを作る\n```",
    "rust_lesson4_ex8_slide3_title": "Let's Try It!",
    "rust_lesson4_ex7_description": "パターンマッチに条件を追加しましょう。",
    "rust_lesson1_ex4_comment2": "+= で 20 を足す",
    "rust_lesson1_ex2_comment2": "y に 5 を入れる",
    "rust_lesson2_ex3_slide3_title": "Let's Try It!",
    "rust_lesson3_ex4_slide1_title": "map（map）?",
    "rust_lesson1_ex2_slide3_content": "データに名前をつけて保存できる「変数（へんすう）」を使ってみましょう。letで変数を作ります。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex8_slide2_content": "# match で成功と失敗を分ける\n\n`match` で「成功したら」「失敗したら」の処理を書き分けます。\n\ncodeExample：\n```rust\nfn divide(a: i32, b: i32) -> Result<i32, String> {\n    if b == 0 {\n        return Err(\"0で割れません\".to_string());\n    }\n    Ok(a / b)  // 成功なら答えを返す\n}\n\nmatch divide(10, 2) {\n    Ok(v) => println!(\"答えは{}\", v),\n    Err(e) => println!(\"エラー: {}\", e),\n}\n```\n\nPoint：\n- `Ok(値)` で成功をreturn\n- `Err(エラー)` で失敗をreturn",
    "rust_lesson4_ex3_comment1": "Box::new でheapに格納",
    "rust_lesson4_ex8_description": "トレイトをreturnfunctionを簡潔に書きましょう。",
    "rust_lesson2_ex10_description": "typeを後から決められる「ジェネリクス」を学びましょう。",
    "rust_lesson2_ex3_slide1_title": "可変reference（かへんさんしょう）?",
    "rust_lesson2_ex2_description": "所有権を移さずにvalueを借りる「reference」を学びましょう。",
    "rust_lesson3_ex5_slide2_title": "** にNote！",
    "rust_lesson2_ex2_slide3_title": "Let's Try It!",
    "rust_lesson4_ex3_slide3_content": "ヒープにデータを格納するBoxを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex4_title": "累算assignmentoperator（+=、-=）",
    "rust_lesson3_ex3_slide2_content": "# 借りるか、もらうか\n\n3種類の iter があり、所有権の扱いが違います。\n\n3つの違い：\n```rust\nv.iter()       // 参照で借りる（&T）\nv.iter_mut()   // 変更可能で借りる（&mut T）\nv.into_iter()  // 所有権をもらう（T）\n```\n\n使い分け：\n- `iter()` → 見るだけ（元のベクタも使える）\n- `iter_mut()` → 中身を変更したい\n- `into_iter()` → ベクタごともらう（元は使えない）\n\n普通は `iter()` をuseことが多いです。",
    "rust_lesson2_ex1_slide1_title": "所有権（しょゆうけん）?",
    "rust_lesson4_ex6_slide3_content": "一意な値の集合を管理しましょう。\n\n（When you're ready, select \"Start Lesson\".）"
  },
  "no": {
    "rust_lesson1_course_title": "Introduction to Rust",
    "rust_lesson1_course_description": "Learn the basics of Rust programming.",
    "rust_lesson2_course_title": "Rust II - Intermediate",
    "rust_lesson2_course_description": "Learn intermediate Rust concepts.",
    "rust_lesson3_course_title": "Rust III - Advanced",
    "rust_lesson3_course_description": "Master advanced Rust techniques.",
    "rust_lesson4_course_title": "Rust IV - Expert Level",
    "rust_lesson4_course_description": "Expert-level Rust programming.",
    "rust_lesson1_ex5_slide2_content": "条件によって動きを変える if文を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex9_title": "collect で変換",
    "rust_lesson2_ex7_slide1_content": "# 「あるかもしれない、ないかもしれない」\n\nOption<T> は、valueが「あるかもしれないし、ないかもしれない」ことを表すtypeです。\n\nFor example：\n- dictionaryで単語を探す → 見つかるかもしれないし、ないかもしれない\n- ゲームでアイテムを拾う → 落ちてるかもしれないし、ないかもしれない\n\n2つの状態：\n- `Some(値)` → valueがある！\n- `None` → valueがない...\n\n他の言語では `null` をuseが、Rustでは `Option` で安全に扱います。",
    "rust_lesson1_ex2_slide1_title": "variable（へんすう）?",
    "rust_lesson1_ex7_description": "「ベクタ（Vec）」をuseと、たくさんのデータを一つの「長い はこ」にまとめて入れられます。",
    "rust_lesson2_ex9_slide2_content": "# 約束を作って、守る\n\n1. `trait` で「約束」をdefinition\n2. `impl トレイト for 型` で「約束を守る」implementationをdo\n\ncodeExample：\n```rust\n// 1. トレイト（約束）を定義\ntrait Speak {\n    fn speak(&self);  // 鳴くメソッドを持つ約束\n}\n\n// 2. Dog構造体がトレイトを実装\nstruct Dog;\nimpl Speak for Dog {\n    fn speak(&self) {\n        println!(\"woof\");\n    }\n}\n```\n\n「DogはSpeakができる」ということになります。",
    "rust_lesson4_ex4_description": "referenceカウントでデータを共有しましょう。",
    "rust_lesson4_ex5_slide1_content": "# 名前で引ける「dictionary」\n\nHashMap は、「key（名前）」と「value（データ）」をsetで保存dodictionaryです。\n\nFor example：\n- 「青チーム」→ 10点\n- 「赤チーム」→ 15点\n\ncodeExample：\n```rust\nuse std::collections::HashMap;\n\nlet mut scores = HashMap::new();\nscores.insert(\"Blue\", 10);   // 追加\nscores.insert(\"Red\", 15);    // 追加\n```\n\n`use` で機能を読み込んでからuse。",
    "rust_lesson3_ex4_title": "map でiterator変換",
    "rust_lesson4_ex1_slide3_content": "共通の振る舞いを定義するトレイトを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex4_description": "variableのvalueを手軽に増やしたり減らしたりdo「+=」「-=」を学びましょう。",
    "rust_lesson1_ex2_description": "データに名前をつけて保存できる「variable（へんすう）」を使ってみましょう。letでvariableをcreate。",
    "rust_lesson4_ex4_slide2_title": "referenceカウントの仕組み",
    "rust_lesson3_ex8_slide2_title": "unwrap_or_else",
    "rust_lesson4_ex10_comment1": "1番目の i にindex、2番目の item にelementが入る",
    "rust_lesson3_ex6_slide1_content": "# 累積処理\n\nfold は、初期valueとfunctionでelementを1つずつ畳み込みます。\n\n```rust\nlet v = vec![1, 2, 3];\nlet sum = v.iter().fold(0, |acc, x| acc + x);\n// 6\n```",
    "rust_lesson4_ex2_slide2_title": "よくuse derive トレイト",
    "rust_lesson3_ex10_slide3_content": "文字列型の違いを理解しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex4_slide2_content": "変数の値を手軽に増やしたり減らしたりする「+=」「-=」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex4_slide3_title": "Let's Try It!",
    "rust_lesson3_ex5_slide1_title": "filter（filterー）?",
    "rust_lesson4_ex5_description": "keyとvalueのpairを格納しましょう。",
    "rust_lesson3_ex5_description": "条件に合うelementだけを取り出しましょう。",
    "rust_lesson2_ex2_slide2_content": "# functionに借りてもらう\n\nfunctionにデータを渡すとき、`&` をつけると「借りる」形になります。元のvariableはそのまま使い続けられます。\n\ncodeExample：\n```rust\nfn calc_len(s: &String) -> usize {\n    s.len()  // 長さを返す\n}\n\nfn main() {\n    let text = String::from(\"hello\");\n    let len = calc_len(&text);  // textを貸す\n    // text はまだ使える！\n    println!(\"{}の長さは{}\", text, len);\n}\n```\n\n`&String` は「Stringを借りる」という意味です。",
    "rust_lesson4_ex7_slide3_content": "パターンマッチに条件を追加しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex8_slide2_content": "# 遅延評価\n\n```rust\n// クロージャで計算\nlet value = x.unwrap_or_else(|| expensive_computation());\n```",
    "rust_lesson4_ex7_title": "match ガード",
    "rust_lesson3_ex7_title": "? operatorでerror伝播",
    "rust_lesson4_ex1_description": "共通の振る舞いをdefineトレイトを学びましょう。",
    "rust_lesson2_ex1_slide2_content": "# 所有権は「移動」do\n\nvariableを別のvariableにassignmentdoと、所有権が 移動（ムーブ） します。元のvariableは使えなくなります。\n\ncodeExample：\n```rust\nlet s1 = String::from(\"hello\");  // s1 が持ち主\nlet s2 = s1;  // 所有権が s2 に移動！\n// ↓ s1 はもう使えない（エラーになる）\n// println!(\"{}\", s1);  // ダメ！\nprintln!(\"{}\", s2);  // OK！\n```\n\nイメージ：\nおもちゃを友だちにあげたら、自分はもう使えない。これがムーブです。",
    "rust_lesson1_ex8_slide1_title": "dictionary（HashMap）?",
    "rust_lesson4_ex3_slide2_content": "# サイズが決まらないとき\n\nBoxは、コンパイル時にサイズがわからないtypeにuse。\n\nFor examplerecursion的なtype：\n```rust\n// リストは「値 + 次のリスト」の繰り返し\nenum List {\n    Cons(i32, Box<List>),  // Boxで次を指す\n    Nil,                   // 終わり\n}\n```\n\nなぜBoxが必要？\n- `List` の中に `List` がある → 無限に大きくなる？\n- `Box` をuseと、サイズが固定（pointerのサイズ）になる\n\n「中身」ではなく「中身への矢印」を持つイメージです。",
    "rust_lesson2_ex10_title": "ジェネリクスを使おう",
    "rust_lesson2_ex8_slide3_title": "Let's Try It!",
    "rust_lesson3_ex9_slide2_content": "# 可変reference\n\n```rust\n// mut が必要\nlet mut v = Vec::new();\nv.push(1);\nv.push(2);\n```",
    "rust_lesson4_ex4_title": "Rc<T>",
    "rust_lesson2_ex3_comment1": "mut で可変variableにdo",
    "rust_lesson4_ex5_slide3_title": "Let's Try It!",
    "rust_lesson2_ex6_slide2_content": "# バリアントを列挙\n\n`enum 名前 { バリアント1, バリアント2, ... }` でdefine。\n\ncodeExample：\n```rust\nenum Color {\n    Red,\n    Green,\n    Blue,\n}\nlet c = Color::Red;\n```",
    "rust_lesson1_ex1_comment1": "Hello, Rust! とdisplay",
    "rust_lesson1_ex1_slide1_content": "# 安全で速い！最新のプログラミング言語\n\nRust（ラスト）は、「間違いを事前に防ぐ」ことがとても得意なプログラミング言語です。\n\nRustのすごいところ：\n- programのミスをexecute前に見つけてくれる\n- とても速く動く\n- 世界中のプログラマーが「一番好き！」と選ぶ人気の言語\n\nたとえるなら：\n厳しいけど優しい先生のような言語です。「ここ間違ってるよ」と教えてくれるので、安心してprogramが書けます！",
    "rust_lesson3_ex8_slide1_content": "# None/Err の場合のデフォルト\n\nunwrap_or は、None や Err の場合にデフォルトvalueをreturn。\n\n```rust\nlet x: Option<i32> = None;\nlet value = x.unwrap_or(0);  // 0\n```",
    "rust_lesson2_ex7_slide3_title": "Let's Try It!",
    "rust_lesson2_ex6_title": "enum で状態を表す",
    "rust_lesson2_ex8_slide1_content": "# 「成功」か「失敗」かを表す\n\nResult<T, E> は、処理が「成功したか失敗したか」を表すtypeです。\n\nFor example：\n- fileをopen → 成功（内容）か失敗（error）\n- 0で割り算 → 成功（答え）か失敗（0で割れない！）\n\n2つの状態：\n- `Ok(値)` → 成功！valueが入っている\n- `Err(エラー)` → 失敗...error情報が入っている\n\n`Option` は「あるか・ないか」、`Result` は「成功か・失敗か」という違いです。",
    "rust_lesson2_ex8_slide3_content": "成功と失敗を表す「Result」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex6_slide1_title": "HashSet ?",
    "rust_lesson3_ex9_comment1": "push でelementを追加",
    "rust_lesson2_ex7_slide2_title": "Option  Usage",
    "rust_lesson3_ex2_title": "closureのBasic",
    "rust_lesson3_ex7_slide1_title": "? operator?",
    "rust_lesson4_ex6_comment1": "HashSet をimport",
    "rust_lesson2_ex10_slide1_content": "# どんなtypeでも使える「万能」の仕組み\n\nジェネリクス は、typeを後から決められる仕組みです。\n\nなぜ便利？\n同じようなfunctionを何度も書かなくてすみます。\n\nFor example：\n- 数字のarrayの最初のelementを取るfunction\n- stringのarrayの最初のelementを取るfunction\n\n両方とも「最初のelementを取る」のは同じなのに、typeが違うだけで別のfunctionをwriteのは大変！\n\nジェネリクスなら、`<T>` で「typeは後で決める」とwriteだけで、どんなtypeでも使えるfunctionが作れます。",
    "rust_lesson1_ex3_slide1_content": "# 剰余operator（じょうよえんざんし）「%」\n\n`%`（パーセント）は、割り算の 「あまり」 をcalculate特別な記号です。\n\nわかりやすいExample：\n- 10このアメを3人で分けると？\n- 1人3こずつで、1こあまる\n- これを `10 % 3` とwriteと、答えは `1`\n\ncodeExample：\n```rust\nprintln!(\"{}\", 10 % 3);  // 1（あまり1）\nprintln!(\"{}\", 8 % 4);   // 0（あまりなし＝割り切れる）\n```\n\n使いどころ：\n- 偶数か奇数か調べる（`n % 2` が0なら偶数）\n- 時計の計算（24を超えたら0に戻る、など）",
    "rust_lesson3_ex7_description": "errorを簡潔に伝播させましょう。",
    "rust_lesson3_ex8_comment1": "unwrap_or でデフォルトvalueを設定",
    "rust_lesson2_ex8_title": "Result<T, E> でerror処理",
    "rust_lesson2_ex10_comment1": "T をtypeパラメータとしてuse",
    "rust_lesson2_ex6_comment1": "enum で列挙typeをdefinition",
    "rust_lesson3_ex3_slide3_content": "要素を順番に処理するイテレータを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex2_comment1": "derive でトレイトを自動implementation",
    "rust_lesson1_ex8_slide1_content": "# 名前でsearchできる「dictionary」\n\nHashMap（ハッシュmap）は、「名前」と「データ」をsetにして保存できる仕組みです。本物のdictionaryのように使えます。\n\nFor example果物の色dictionary：\n- 「りんご」→「あか」\n- 「バナナ」→「きいろ」\n- 「みかん」→「オレンジ」\n\nuse準備：\n```rust\nuse std::collections::HashMap;  // 機能を読み込む\nlet mut fruits = HashMap::new();  // 空の辞書を作る\nfruits.insert(\"りんご\", \"あか\");  // データを追加\n```\n\n`use` は「この機能をuseよ」というdeclarationです。",
    "rust_lesson3_ex9_slide1_title": "push ?",
    "rust_lesson4_ex1_title": "トレイトのdefinition",
    "rust_lesson4_ex3_description": "heapにデータを格納doBoxを学びましょう。",
    "rust_lesson1_ex2_title": "便利な「はこ」variable（へんすう）",
    "rust_lesson1_ex8_comment2": "中身を出す",
    "rust_lesson3_ex9_slide3_title": "Let's Try It!",
    "rust_lesson1_ex4_comment3": "-= で 50 を引く",
    "rust_lesson1_ex6_comment1": "&& で両方の条件をチェック",
    "rust_lesson4_ex1_slide2_title": "トレイトのimplementation",
    "rust_lesson4_ex7_slide3_title": "Let's Try It!",
    "rust_lesson4_title": "Rust IV - トレイトとスマートpointer",
    "rust_lesson4_ex1_comment1": "trait でトレイトをdefinition",
    "rust_lesson4_ex4_slide1_content": "# 複数の「持ち主」を許可do仕組み\n\nRc<T> は「Reference Counted（referenceカウント）」の略で、複数の所有者でデータを共有できます。\n\n普通の所有権：\n1人だけが持ち主。渡したら元の人は使えない。\n\nRc をuseと：\n複数人が同じデータの「持ち主」になれる！\n\ncodeExample：\n```rust\nuse std::rc::Rc;\n\nlet a = Rc::new(5);       // Rcでラップ\nlet b = Rc::clone(&a);    // bも持ち主になる\n// a も b も使える！\n```",
    "rust_lesson3_ex5_slide1_content": "# 条件に合うものだけ残す\n\nfilter は、条件を満たすelementだけを残し、他を捨てます。\n\nFor example：\n- 80点以上の人だけ残す\n- 偶数だけ残す\n- 「あ」から始まる名前だけ残す\n\ncodeExample：\n```rust\nlet v = vec![1, 2, 3, 4, 5];\nlet evens: Vec<_> = v.iter()\n    .filter(|x| **x % 2 == 0)  // 偶数だけ\n    .collect();\n// [2, 4]\n```\n\n条件が `true` のelementだけが残ります。",
    "rust_lesson3_ex7_slide3_title": "Let's Try It!",
    "rust_lesson1_ex7_comment2": "2番目のデータ（1番）を出す",
    "rust_lesson4_ex8_title": "impl Trait",
    "rust_lesson1_ex5_description": "条件によって動きを変える if文を学びましょう。",
    "rust_lesson3_ex4_slide2_title": "遅延評価（ちえんひょうか）",
    "rust_lesson3_ex1_slide1_content": "# referenceの「寿命」を示す印\n\nライフタイム は、referenceがいつまで使えるかを示す印です。`'a`（アポストロフィ・エー）のようにwrite。\n\nなぜ必要？\nreferenceは「借りている」状態。借りた元のデータが消えたら、referenceも使えなくなります。\n\nFor example：\n- 図書館で借りた本 → 図書館が閉まったら読めない\n- referenceで借りたデータ → 元のデータが消えたら使えない\n\nライフタイムは「このreferenceはこの範囲で有効だよ」とコンパイラに伝える仕組みです。",
    "rust_lesson1_ex1_slide1_title": "Rust（ラスト）?",
    "rust_lesson1_ex2_slide2_title": "計算の記号（operator）",
    "rust_lesson4_ex5_slide2_content": "# get で安全に取り出す\n\n`get()` methodでvalueを取り出せます。見つからない可能性があるので、`Option` が返ってきます。\n\ncodeExample：\n```rust\n// getはOption<&V>を返す\nif let Some(score) = scores.get(\"Blue\") {\n    println!(\"青チームは{}点\", score);\n}\n```\n\nPoint：\n- keyがあれば `Some(値)` が返る\n- keyがなければ `None` が返る\n- `if let` で安全に取り出せる\n\n存在しないkeyでアクセスしてもprogramが落ちない！",
    "rust_lesson4_ex7_slide1_title": "match ガード?",
    "rust_lesson3_title": "Rust III - ライフタイムとiterator",
    "rust_lesson4_ex3_title": "Box<T>",
    "rust_lesson1_ex4_slide1_title": "累算assignmentoperator（るいさんだいにゅう）?",
    "rust_lesson2_ex9_comment1": "trait でトレイトをdefinition",
    "rust_lesson2_ex1_description": "Rust独自の概念「所有権」を学びましょう。",
    "rust_lesson2_ex3_slide3_content": "参照先の値を変更できる「可変参照」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex1_slide3_title": "Let's Try It!",
    "rust_lesson3_ex6_slide2_title": "様々な畳み込み",
    "rust_lesson4_ex9_slide3_title": "Let's Try It!",
    "rust_lesson2_ex5_title": "impl でmethodを追加",
    "rust_lesson2_ex6_slide1_content": "# 複数の選択肢\n\nenum は、valueがいくつかの種類のうちの一つであることを表します。各バリアントにデータを持たせることもできます。",
    "rust_lesson2_ex4_comment1": "struct で構造体をdefinition",
    "rust_lesson1_ex3_title": "剰余operator（%）",
    "rust_lesson1_ex7_comment1": "colors というベクタをcreate（'あか', 'あお'の順）",
    "rust_lesson1_ex4_slide1_content": "# valueをかんたんに増やす・減らす\n\n`+=`（プラスイコール）と `-=`（マイナスイコール）は、variableの中身を増やしたり減らしたりdo便利な記号です。\n\nRustのImportantなルール：`mut`が必要！\nRustでは、variableをchangeには `let mut`（レット ミュート）とwrite必要があります。`mut` は「mutable（変更できる）」の略です。\n\ncodeExample：\n```rust\nlet mut score = 100;  // mut をつけて変更可能に\nscore += 10;          // 10を足す → 110に\nscore -= 50;          // 50を引く → 60に\n```\n\n`mut` がないと「このvariableは変えちゃダメ！」とRustが怒ります。",
    "rust_lesson2_ex1_slide2_title": "ムーブ（移動）",
    "rust_lesson3_ex4_comment1": "map で各elementを変換",
    "rust_lesson3_ex8_slide1_title": "unwrap_or ?",
    "rust_lesson2_ex5_slide1_content": "# implementationブロック\n\nimpl ブロックで、構造体にmethodを追加できます。`self` で自分自身をreferenceします。",
    "rust_lesson2_ex10_slide1_title": "ジェネリクス?",
    "rust_lesson1_ex8_slide2_content": "# 名前（key）で取り出す\n\ndictionaryに入れたデータは、名前（key）を指定して取り出せます。\n\ncodeExample：\n```rust\nuse std::collections::HashMap;\nfn main() {\n    let mut fruits = HashMap::new();\n    fruits.insert(\"りんご\", \"あか\");  // 追加\n    fruits.insert(\"バナナ\", \"きいろ\");  // 追加\n    \n    println!(\"{}\", fruits[\"りんご\"]);  // あか と表示\n}\n```\n\nPoint：\n- `insert(名前, データ)` で追加\n- `辞書[名前]` で取り出し\n- 番号ではなく「名前」で探せるのが便利！",
    "rust_lesson4_ex9_slide1_content": "# iteratorをコレクションに\n\ncollect は、iteratorをVecやHashMapなどに変換します。\n\n```rust\nlet v: Vec<_> = (0..5).collect();\nlet s: String = vec!['a', 'b'].into_iter().collect();\n```",
    "rust_lesson2_ex2_slide3_content": "所有権を移さずに値を借りる「参照」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex2_slide3_content": "周囲の変数を使える無名関数「クロージャ」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex4_slide2_content": "# struct keyワードでdefinition\n\n`struct 名前 { フィールド }` で構造体をdefine。フィールドには名前とtypeをwrite。\n\ncodeExample：\n```rust\n// Point 構造体を定義\nstruct Point {\n    x: i32,  // xフィールド（整数）\n    y: i32,  // yフィールド（整数）\n}\n\n// 使い方\nlet p = Point { x: 10, y: 20 };\nprintln!(\"x={}, y={}\", p.x, p.y);\n```\n\nPoint：\n- `struct 名前` で構造体をcreate\n- `{ フィールド名: 型 }` でどんなデータを持つか決める\n- `.フィールド名` でアクセス",
    "rust_lesson2_ex10_slide3_content": "型を後から決められる「ジェネリクス」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex6_slide3_title": "Let's Try It!",
    "rust_lesson4_ex6_slide1_content": "# 一意なvalueのset\n\nHashSet は、重複のないvalueのsetです。\n\n```rust\nuse std::collections::HashSet;\n\nlet mut set = HashSet::new();\nset.insert(1);\nset.insert(2);\nset.insert(1); // 重複は無視\n```",
    "rust_lesson4_ex2_title": "derive 属性",
    "rust_lesson4_ex2_slide1_content": "# トレイトを「自動で」implementation\n\n#[derive(...)] をuseと、よくuseトレイトを自分で書かなくても自動でimplementationしてくれます。\n\nFor example：\n構造体を `println!` でdisplayしたいとき、普通は Display トレイトをimplementationdo必要がありますが、`#[derive(Debug)]` をwriteだけでOK！\n\ncodeExample：\n```rust\n#[derive(Debug)]  // Debug トレイトを自動実装\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nlet p = Point { x: 1, y: 2 };\nprintln!(\"{:?}\", p);  // Point { x: 1, y: 2 }\n```",
    "rust_lesson1_ex6_slide2_title": "Let's Try It!",
    "rust_lesson3_ex3_slide2_title": "3つの iter method",
    "rust_lesson4_ex7_slide2_content": "# 複雑なconditional\n\n```rust\nmatch Some(5) {\n    Some(x) if x % 2 == 0 => println!(\"even\"),\n    Some(x) => println!(\"odd: {}\", x),\n    None => println!(\"none\"),\n}\n```",
    "rust_lesson3_ex3_slide1_content": "# elementを1つずつ取り出す仕組み\n\niterator は、ベクタなどのデータを「1つずつ順番に」取り出す仕組みです。\n\nFor example：\n- 行列に並んでいる人を1人ずつ呼ぶ\n- 引き出しの中身を1つずつ出す\n\ncodeExample：\n```rust\nlet v = vec![1, 2, 3];\nfor x in v.iter() {\n    println!(\"{}\", x);  // 1, 2, 3 と順番に表示\n}\n```\n\n`iter()` で「順番に取り出す準備」をして、`for` で1つずつ処理します。",
    "rust_lesson3_ex3_slide1_title": "iterator?",
    "rust_lesson4_ex2_description": "トレイトを自動implementationdoderiveを学びましょう。",
    "rust_lesson3_ex4_slide1_content": "# 全部を同じように変換do\n\n**map** は、iteratorの各elementを「同じ方法で」変換します。\n\nFor example：\n- 全員の身長を2倍にdo\n- 全員の名前を大文字にdo\n- 全部の数を2乗do\n\ncodeExample：\n```rust\nlet v = vec![1, 2, 3];\nlet doubled: Vec<_> = v.iter()\n    .map(|x| x * 2)  // 各要素を2倍に\n    .collect();      // ベクタに戻す\n// [2, 4, 6]\n```\n\n`|x| x * 2` は「xを受け取って、x*2をreturn」closureです。",
    "rust_lesson1_ex3_slide1_title": "あまりを求める",
    "rust_lesson3_ex10_slide1_content": "# 所有権の違い\n\nString は所有権を持つheap上のstring、&str はreferenceです。\n\n```rust\nlet s1: String = String::from(\"hello\");\nlet s2: &str = \"hello\";\n```",
    "rust_lesson4_ex2_slide1_title": "derive（デライブ）?",
    "rust_lesson2_ex2_comment1": "& でreferenceを渡す",
    "rust_lesson4_ex5_slide1_title": "HashMap（ハッシュmap）?",
    "rust_lesson2_ex3_slide2_title": "&mut  Usage",
    "rust_lesson3_ex5_title": "filter で絞り込み",
    "rust_lesson4_ex3_slide2_title": "いつuse？",
    "rust_lesson2_ex2_title": "referenceと借用",
    "rust_lesson2_ex7_title": "Option<T> で null を安全に",
    "rust_lesson4_ex10_slide3_title": "Let's Try It!",
    "rust_lesson3_ex5_slide3_title": "Let's Try It!",
    "rust_lesson4_ex10_title": "enumerate でindex付き",
    "rust_lesson2_ex2_slide1_content": "# 所有権を渡さずに「借りる」\n\nreference をuseと、所有権を移さずにデータを「見せてもらう」ことができます。\n\nたとえるなら：\n- ムーブ = おもちゃをあげる（自分は使えない）\n- reference = おもちゃを見せる（自分も使える）\n\n作り方：\n`&`（アンパサンド）をつけるとreferenceを作れます。\n\n```rust\nlet s = String::from(\"hello\");\nlet r = &s;  // sを借りる（見せてもらう）\n// s も r も使える！\n```",
    "rust_lesson2_ex5_slide2_content": "# &self をuse\n\nmethodの最初のargumentは `&self` です。\n\ncodeExample：\n```rust\nimpl Rect {\n    fn area(&self) -> i32 {\n        self.width * self.height\n    }\n}\n```",
    "rust_lesson1_ex5_slide2_title": "Let's Try It!",
    "rust_lesson2_ex4_slide3_title": "Let's Try It!",
    "rust_lesson4_ex3_slide3_title": "Let's Try It!",
    "rust_lesson2_ex9_slide3_content": "共通の振る舞いを定義する「トレイト」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex1_slide2_content": "# impl で約束を守る\n\n構造体にトレイトをimplementationdoと、その構造体は「約束を守る」ことになります。\n\ncodeExample：\n```rust\nstruct Person { name: String }\n\nimpl Greet for Person {\n    fn greet(&self) -> String {\n        format!(\"Hello, {}\", self.name)\n    }\n}\n```\n\n読み方：\n- `impl Greet for Person` → 「PersonはGreetをimplementationdo」\n- これでPersonは「あいさつできる」ようになった！",
    "rust_lesson4_ex4_comment1": "clone でreferenceカウントを増やす",
    "rust_lesson3_ex4_slide2_content": "# map だけではexecuteされない！\n\nRustのiteratorは 遅延評価 といって、「本当に必要になるまで処理しない」仕組みです。\n\nなぜ？\n無駄な計算を省けるから。100万件あっても、最初の10件だけ欲しいなら10件だけ処理すればいい。\n\ncollect() でexecute：\n```rust\n// これだけでは何も起きない\nv.iter().map(|x| x * 2);\n\n// collect() で実行してベクタに変換\nlet result: Vec<_> = v.iter().map(|x| x * 2).collect();\n```\n\n`collect()` は「今すぐ全部処理してResultをちょうだい」という意味です。",
    "rust_lesson2_ex4_slide2_title": "struct のdefinitionのしかた",
    "rust_lesson2_ex3_slide1_content": "# 「書き換えできる」借り方\n\n普通のreference `&` は「見るだけ」ですが、可変reference `&mut` は「変更もできる」借り方です。\n\nたとえるなら：\n- `&` = 本を見せてもらう（readだけ）\n- `&mut` = ノートを借りる（writeOK）\n\nImportantなルール：\n- 可変referenceは同時に1つだけ！\n- 「みんなで見る」か「1人でwrite」かのどちらか\n\nこのルールで、データが同時に書き換えられるバグを防いでいます。",
    "rust_lesson2_ex10_slide3_title": "Let's Try It!",
    "rust_lesson2_ex4_title": "構造体をdefinitionしよう",
    "rust_lesson3_ex10_slide2_content": "# 相互変換\n\n```rust\n// &str -> String\nlet s = \"hello\".to_string();\n\n// String -> &str\nlet slice: &str = &s;\n```",
    "rust_lesson4_ex10_slide3_content": "イテレータにインデックスを付けましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex4_slide2_content": "# 「何人が持っているか」を数える\n\nRcは「今何人がこのデータを持っているか」を数えています。\n\ncodeExample：\n```rust\nlet a = Rc::new(5);\nprintln!(\"{}\", Rc::strong_count(&a));  // 1\n\nlet b = Rc::clone(&a);\nprintln!(\"{}\", Rc::strong_count(&a));  // 2\n```\n\nいつデータが消える？\n- カウントが0になったとき（誰も持っていないとき）\n- 最後の持ち主がいなくなると自動で片付けられる\n\n`Rc::clone` は「持ち主を1人増やす」操作です。",
    "rust_lesson1_ex8_slide2_title": "dictionary Usage",
    "rust_lesson4_ex3_slide1_content": "# データを「heap」に置く箱\n\nBox<T> は、データを「heap」という特別な場所に置くための箱です。\n\nmemoryの2つの場所：\n- stack：小さくて速い。サイズが決まっているデータ向け\n- heap：大きくて柔軟。サイズが大きいor変わるデータ向け\n\ncodeExample：\n```rust\nlet b = Box::new(5);  // 5をヒープに置く\nprintln!(\"{}\", *b);   // *で中身を取り出す → 5\n```\n\n`*` は「箱を開けて中身を見る」操作です。",
    "rust_lesson3_ex2_slide2_title": "closure Syntax",
    "rust_lesson4_ex4_slide1_title": "Rc（アールシー）?",
    "rust_lesson4_ex7_slide1_content": "# 追加条件\n\n**if** でパターンに追加条件をつけられます。\n\n```rust\nmatch x {\n    n if n < 0 => println!(\"negative\"),\n    n if n > 0 => println!(\"positive\"),\n    _ => println!(\"zero\"),\n}\n```",
    "rust_lesson2_ex3_title": "可変reference",
    "rust_lesson3_ex10_comment1": "to_string で String に変換",
    "rust_lesson3_ex10_slide2_title": "変換",
    "rust_lesson3_ex1_description": "referenceの有効期間を表すライフタイムを学びましょう。",
    "rust_lesson3_ex2_slide1_content": "# 名前のない「即席」function\n\nclosure は、名前をつけずにその場でcreatefunctionです。そして特別な能力があります：周りのvariableを使えるのです！\n\nFor example：\n```rust\nlet x = 5;  // 外側の変数\nlet add_x = |n| n + x;  // xを使えるクロージャ\nprintln!(\"{}\", add_x(10));  // 15\n```\n\n普通のfunctionとの違い：\n- 普通のfunction：argumentしか使えない\n- closure：argument + 周りのvariableも使える\n\n「その場の空気を読める」functionというイメージです！",
    "rust_lesson1_ex2_comment1": "x に 10 を入れる",
    "rust_lesson1_ex7_slide3_title": "Let's Try It!",
    "rust_lesson1_ex5_title": "「もし〜なら」で分けましょう",
    "rust_lesson3_ex2_slide3_title": "Let's Try It!",
    "rust_lesson3_ex7_slide2_content": "# 簡潔なerror処理\n\n```rust\n// ? を使わない場合\nmatch result {\n    Ok(v) => v,\n    Err(e) => return Err(e),\n}\n\n// ? を使う\nresult?\n```",
    "rust_lesson3_ex6_slide3_title": "Let's Try It!",
    "rust_lesson4_ex9_slide3_content": "イテレータをコレクションに変換しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex6_description": "elementを1つのvalueにまとめるfoldを学びましょう。",
    "rust_lesson2_ex9_description": "共通の振る舞いをdefine「トレイト」を学びましょう。",
    "rust_lesson2_ex8_comment1": "Ok で成功をreturn",
    "rust_lesson3_ex5_slide2_content": "# filter はreferenceのreferenceを受け取る\n\n`filter` のclosureは、referenceのreference（`&&T`）を受け取ります。そのため、valueをuseには `**x` と2回referenceを外す必要があります。\n\nなぜ？\n- `iter()` はreference（`&T`）をreturn\n- `filter` はそれをFurthermorereferenceで渡す（`&&T`）\n\nSyntax：\n```rust\n// **x で値を取り出す\n.filter(|x| **x > 2)\n\n// または * を引数につける\n.filter(|&x| *x > 2)\n```\n\n最初は混乱しますが、慣れれば大丈夫！",
    "rust_lesson1_ex5_comment1": "> でcompare",
    "rust_lesson2_ex4_description": "関連doデータをまとめる「構造体」を学びましょう。",
    "rust_lesson3_ex5_slide3_content": "条件に合う要素だけを取り出しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex7_slide3_content": "「ベクタ（Vec）」を使うと、たくさんのデータを一つの「長い はこ」にまとめて入れられます。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex5_slide2_title": "valueの取得",
    "rust_lesson3_ex1_slide1_title": "ライフタイム?",
    "rust_lesson1_ex3_comment1": "10 を 3 で割ったあまりをoutput",
    "rust_lesson3_ex1_comment1": "'a でライフタイムをdefinition",
    "rust_lesson3_ex10_slide1_title": "String vs &str",
    "rust_lesson2_title": "Rust II - 所有権とトレイト",
    "rust_lesson2_ex5_slide2_title": "methodのdefinition",
    "rust_lesson4_ex5_comment1": "insert でkeyとvalueを追加",
    "rust_lesson2_ex9_slide1_content": "# 「できること」の約束\n\nトレイト は、「このtypeはこういうことができる」という約束をdefine。\n\nFor example「鳴ける」という約束：\n- 犬は「ワン」と鳴く\n- 猫は「ニャー」と鳴く\n- 両方とも「鳴ける」能力がある\n\nトレイトは「鳴ける動物は、鳴き声を出すmethodを持つ」という約束です。\n\n他の言語とのcomparison：\n- Java: interface\n- TypeScript: interface\n\nに似た概念です。",
    "rust_lesson1_ex2_slide3_title": "Let's Try It!",
    "rust_lesson4_ex8_slide1_content": "# return valueのtypeをabstract化\n\nimpl Trait で、トレイトをimplementationdotypeを返せます。\n\n```rust\nfn make_iter() -> impl Iterator<Item = i32> {\n    vec![1, 2, 3].into_iter()\n}\n```",
    "rust_lesson1_ex2_slide2_content": "# 四則演算（しそくえんざん）\n\nRustでも算数と同じ記号で計算ができます。\n\n4つのBasic記号：\n- +（プラス）: たし算\n- -（マイナス）: ひき算\n- \\*（アスタリスク）: かけ算（×の代わり）\n- /（スラッシュ）: わり算（÷の代わり）\n\ncodeExample：\n```rust\nlet a = 10;\nlet b = 5;\nprintln!(\"{}\", a + b);  // 15 と表示される\n```\n\n`println!` の `{}` は「ここにvalueを入れてね」という目印です。",
    "rust_lesson4_ex9_slide2_content": "# 変換先を指定\n\n```rust\n// ターボフィッシュ構文\nlet v = (0..5).collect::<Vec<_>>();\n\n// 変数の型注釈\nlet v: Vec<i32> = (0..5).collect();\n```",
    "rust_lesson1_ex8_description": "「dictionary（HashMap）」をuseと、名前をつけてデータを保存し、その名前で取り出せます。",
    "rust_lesson4_ex9_slide2_title": "typeHint",
    "rust_lesson3_ex1_title": "ライフタイムのBasic",
    "rust_lesson2_ex5_description": "構造体にmethodをadd「impl」を学びましょう。",
    "rust_lesson4_ex8_comment1": "impl でトレイトをimplementationdotypeをreturn",
    "rust_lesson4_ex8_slide2_title": "argumentにも使える",
    "rust_lesson4_ex7_comment1": "if でマッチガードを追加",
    "rust_lesson2_ex9_slide2_title": "trait のdefinitionとimplementation",
    "rust_lesson4_ex10_slide2_title": "いつuse？",
    "rust_lesson3_ex7_slide2_title": "match の省略形",
    "rust_lesson1_ex6_title": "logicaloperator（&&、||）",
    "rust_lesson3_ex6_comment1": "fold で畳み込み",
    "rust_lesson2_ex6_description": "複数の状態を表す「列挙type（enum）」を学びましょう。",
    "rust_lesson4_ex10_slide1_title": "enumerate（イニュメレート）?",
    "rust_lesson1_ex7_slide1_title": "ベクタ（Vec）?",
    "rust_lesson2_ex6_slide3_content": "複数の状態を表す「列挙型（enum）」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex3_slide3_title": "Let's Try It!",
    "rust_lesson3_ex4_description": "各elementを変換domapを学びましょう。",
    "rust_lesson4_ex1_slide3_title": "Let's Try It!",
    "rust_lesson3_ex9_slide2_title": "mut が必要",
    "rust_lesson1_ex6_slide1_content": "# logicaloperator（ろんりえんざんし）\n\n2つ以上の条件を組み合わせたいときにuse記号です。\n\n2つの記号：\n- `&&`（アンドアンド）：「かつ」＝ 両方とも 正しいとき\n- `||`（オアオア）：「Alsoは」＝ どちらか 正しいとき\n\n身近なExample：\n- 遊園地：「18歳以上 かつ チケットあり」なら乗れる\n- おやつ：「宿題終わった Alsoは お手伝いした」ならOK\n\ncodeExample：\n```rust\nif score >= 70 && bonus > 0 {\n    // 70点以上 かつ ボーナスあり → 合格！\n    println!(\"合格！\");\n}\n```",
    "rust_lesson4_ex4_slide3_content": "参照カウントでデータを共有しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex6_slide3_title": "Let's Try It!",
    "rust_lesson2_ex5_slide3_content": "構造体にメソッドを追加する「impl」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex1_slide3_title": "Let's Try It!",
    "rust_lesson1_ex5_slide1_content": "# programに「判断」させよう\n\nconditional は、「もし〜なら、〇〇do」という判断をprogramにさせる仕組みです。\n\n身近なExample：\n- もし80点以上なら → 「合格！」とdisplay\n- もし雨なら → 傘を持っていく\n- もしHPが0なら → ゲームオーバー\n\nRustで Syntax：\n```rust\nif score > 80 {\n    println!(\"合格！\");\n}\n```\n\n読み方：\n- `if` →「もし」\n- `score > 80` →「スコアが80より大きいなら」\n- `{ }` の中 →「これをやる」",
    "rust_lesson4_ex5_title": "HashMap",
    "rust_lesson1_ex2_slide1_content": "# データを保存do「はこ」\n\nvariable（へんすう） は、数字や文字を入れておける「はこ」のことです。名前をつけて、あとでuseことができます。\n\nFor example：\n- 「りんごの数」というラベルの箱に「5」を入れる\n- あとで「りんごの数」と呼べば「5」が出てくる\n\nRustで Syntax：\n```rust\nlet x = 10;  // xという箱に10を入れる\nprintln!(\"{}\", x);  // xの中身（10）を表示\n```\n\n`let` は「この名前で箱をcreateよ」という意味です。",
    "rust_lesson2_ex4_slide3_content": "関連するデータをまとめる「構造体」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex6_slide1_title": "enum ?",
    "rust_lesson2_ex9_title": "トレイトをdefinitionしよう",
    "rust_lesson2_ex4_slide1_title": "構造体（こうぞうたい）?",
    "rust_lesson4_ex2_slide2_content": "# 覚えておくと便利な5つ\n\nよくusederiveトレイト：\n```rust\nDebug     // {:?} でデバッグ表示できる\nClone     // .clone() でコピーを作れる\nCopy      // 代入時に自動でコピー（小さい型向け）\nPartialEq // == で比較できる\nDefault   // 初期値を自動で作れる\n```\n\n複数指定もOK：\n```rust\n#[derive(Debug, Clone, PartialEq)]\nstruct User {\n    name: String,\n    age: u32,\n}\n```\n\n`Debug` は特によくuse。debug時に構造体の中身を見れて便利！",
    "rust_lesson2_ex1_slide1_content": "# データの「持ち主」を決めるルール\n\n所有権 は、Rust最大のFeatureです。「このデータの持ち主は誰か」をはっきりさせる仕組みです。\n\nルール：\n- データには必ず1人だけ「持ち主」がいる\n- 持ち主がいなくなると、データは自dynamicに片付けられる\n\nたとえるなら：\n- おもちゃは1人しか持てない\n- 持ち主が部屋を出たら、おもちゃは片付けられる\n\nこのルールのおかげで、Rustは「memoryリーク」（データが片付けられないバグ）を防げます！",
    "rust_lesson1_ex3_slide2_title": "Let's Try It!",
    "rust_lesson3_ex1_slide2_title": "なぜ必要？",
    "rust_lesson3_ex1_slide2_content": "# 危険なバグを防ぐ\n\nダングリングreference という危険なバグがあります。これは「もう存在しないデータ」を指し続けているreferenceのことです。\n\nExample：\n```rust\nfn longest<'a>(x: &'a str, y: &'a str) -> &'a str {\n    if x.len() > y.len() { x } else { y }\n}\n```\n\n`'a` の意味：\n- argument `x` と `y` は同じライフタイム `'a` を持つ\n- return valueも同じライフタイム `'a` を持つ\n- In other words「xとyが両方有効な間、return valueも有効」という約束\n\nRustはこれを自動でチェックしてくれます！",
    "rust_lesson4_ex6_slide2_title": "set演算",
    "rust_lesson3_ex7_comment1": "? でerrorを伝播",
    "rust_lesson3_ex2_slide2_content": "# | | でargumentを囲む\n\nclosureは `|引数| 処理` という形でwrite。`||` は「パイプ」と呼ばれます。\n\nいろいろなSyntax：\n```rust\n// 引数なし\n|| println!(\"Hello\")\n\n// 引数あり\n|x, y| x + y\n\n// 複数行のブロック\n|x| {\n    let y = x * 2;\n    y + 1\n}\n```\n\nPoint：\n- argumentを `| |` で囲む（functionの `()` の代わり）\n- typeは省略できることが多い（Rustが推測してくれる）",
    "rust_lesson2_ex7_comment1": "Some でvalueがあることを示す",
    "rust_lesson3_ex4_slide3_content": "各要素を変換するmapを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_title": "Rust (ラスト) に挑戦！",
    "rust_lesson2_ex8_description": "成功と失敗を表す「Result」を学びましょう。",
    "rust_lesson3_ex8_description": "Option/Resultのデフォルトvalueを設定しましょう。",
    "rust_lesson4_ex2_slide3_title": "Let's Try It!",
    "rust_lesson2_ex5_slide3_title": "Let's Try It!",
    "rust_lesson4_ex9_description": "iteratorをコレクションに変換しましょう。",
    "rust_lesson1_ex1_slide2_content": "# println! でscreenにdisplay\n\nRustで文字をscreenにdisplayには、`println!`（プリントラインびっくり）をuse。\n\nPoint：\n- `!` がつくのがRustのFeature（マクロと呼ばれます）\n- programは `fn main() { }` の中にwrite\n- `fn` は「function（function）」の略\n\ncodeExample：\n```rust\nfn main() {\n    println!(\"ヤッホー！\");\n}\n// 「ヤッホー！」と画面に表示される\n```\n\n`println!` の `!` は「マクロ」という特別な機能の印です。今は「おまじない」と思っておけばOK！",
    "rust_lesson3_ex6_slide1_title": "fold ?",
    "rust_lesson4_ex8_slide1_title": "impl Trait ?",
    "rust_lesson1_ex1_slide2_title": "Rustの「おまじない」",
    "rust_lesson3_ex10_description": "stringtypeの違いを理解しましょう。",
    "rust_lesson3_ex7_slide3_content": "エラーを簡潔に伝播させましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex1_comment1": "s1 の所有権を移動",
    "rust_lesson2_ex9_slide1_title": "トレイト?",
    "rust_lesson4_ex6_slide2_content": "# 和set、積setなど\n\n```rust\nset1.union(&set2)\nset1.intersection(&set2)\nset1.difference(&set2)\n```",
    "rust_lesson4_ex5_slide3_content": "キーと値のペアを格納しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex8_slide1_title": "Result（リザルト）?",
    "rust_lesson4_ex1_slide1_content": "# 「できること」の約束\n\nトレイト は、typeが持つべきmethodをdefine仕組みです。\n\nFor example：\n- 「あいさつできる」トレイト → greet() methodを持つ\n- 「displayできる」トレイト → display() methodを持つ\n\ncodeExample：\n```rust\ntrait Greet {\n    fn greet(&self) -> String;  // メソッドの「約束」\n}\n```\n\nこれは「Greetできるtypeは、greet()methodを持つ」という約束です。",
    "rust_lesson4_ex2_slide3_content": "トレイトを自動実装するderiveを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex6_title": "fold で畳み込み",
    "rust_lesson3_ex9_slide3_content": "Vecに要素を追加しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex4_slide1_content": "# 関係あるデータをまとめる「設計図」\n\n構造体（struct） は、いくつかのデータをひとまとめにdo仕組みです。\n\nFor example「点（座標）」のデータ：\n- x座標\n- y座標\n\nこの2つは関係があるので、「Point（点）」としてまとめると便利です。\n\nFor example「人」のデータ：\n- 名前\n- 年齢\n\nこれも「Person（人）」としてまとめられます。\n\n構造体は「こういうデータを持つ」という設計図です。",
    "rust_lesson4_ex1_slide1_title": "トレイト?（復習）",
    "rust_lesson2_ex3_description": "reference先のvalueを変更できる「可変reference」を学びましょう。",
    "rust_lesson2_ex7_slide2_content": "# match で安全に取り出す\n\n`match` を使って「ある場合」と「ない場合」で処理を分けます。\n\ncodeExample：\n```rust\nlet x: Option<i32> = Some(5);  // 値あり\n\nmatch x {\n    Some(n) => println!(\"値は{}です\", n),  // 5\n    None => println!(\"値がありません\"),\n}\n```\n\nなぜ安全？\n- `null` のように「あるつもりでアクセスしたら無かった」errorが起きない\n- 「ない場合」の処理を書かないとコンパイルerrorになる\n- 強制的に両方のケースを考えることになる！",
    "rust_lesson4_ex9_comment1": "collect で Vec に変換",
    "rust_lesson3_ex10_title": "String と &str",
    "rust_lesson2_ex7_slide1_title": "Option（オプション）?",
    "rust_lesson3_ex9_description": "Vecにelementを追加しましょう。",
    "rust_lesson2_ex5_comment1": "impl でmethodをimplementation",
    "rust_lesson3_ex1_slide3_content": "参照の有効期間を表すライフタイムを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex6_slide2_content": "複数の条件を組み合わせる「&&（かつ）」と「||（または）」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex5_comment1": "filter で条件に合うelementを絞り込む",
    "rust_lesson2_ex7_slide3_content": "値があるかないかを表す「Option」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex10_slide3_title": "Let's Try It!",
    "rust_lesson4_ex4_slide3_title": "Let's Try It!",
    "rust_lesson3_ex3_comment1": "iter でiteratorを取得",
    "rust_lesson3_ex6_slide3_content": "要素を1つの値にまとめるfoldを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex7_slide2_title": "ベクタの番号は「0」から！",
    "rust_lesson1_ex5_slide1_title": "conditional（じょうけんぶんき）?",
    "rust_lesson1_ex3_description": "割り算の「あまり」を求める「%」（パーセント）operatorを学びましょう。",
    "rust_lesson1_ex1_slide3_content": "Rustを使って画面に文字を表示してみましょう。println! という特別な関数を使います。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex10_slide2_content": "# <T> でtypeを「あとで決める」\n\nfunction名の後に `<T>` をつけて、`T` を「type」としてuse。\n\ncodeExample：\n```rust\n// Tはどんな型でもOK\nfn first<T>(arr: &[T]) -> &T {\n    &arr[0]  // 最初の要素を返す\n}\n\n// 使い方\nfirst(&[1, 2, 3]);         // Tはi32\nfirst(&[\"a\", \"b\", \"c\"]);   // Tは&str\n```\n\n読み方：\n- `<T>` → 「Tという名前のtypeをuseよ」\n- `T` は慣習で「Type（type）」の頭文字\n- 複数のtypeが必要なら `<T, U>` のようにwrite",
    "rust_lesson3_ex2_comment1": "|x| でclosureのargumentをdefinition",
    "rust_lesson3_ex3_description": "elementを順番に処理doiteratorを学びましょう。",
    "rust_lesson1_ex1_slide3_title": "Let's Try It!",
    "rust_lesson2_ex6_slide2_title": "enum のdefinition",
    "rust_lesson2_ex1_title": "所有権のBasic",
    "rust_lesson4_ex3_slide1_title": "Box（ボックス）?",
    "rust_lesson2_ex1_slide3_content": "Rust独自の概念「所有権」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex8_slide3_content": "Option/Resultのデフォルト値を設定しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex7_slide2_title": "使用Example",
    "rust_lesson4_ex10_description": "iteratorにindexを付けましょう。",
    "rust_lesson4_ex9_slide1_title": "collect ?",
    "rust_lesson4_ex10_slide2_content": "# 「何番目か」が必要なとき\n\n番号（index）とelementの両方が必要なときに便利です。\n\ncodeExample：\n```rust\nlet v = vec![10, 20, 30];\nfor (idx, val) in v.iter().enumerate() {\n    println!(\"{}番目の値は{}\", idx, val);\n}\n// 0番目の値は10\n// 1番目の値は20\n// 2番目の値は30\n```\n\nPoint：\n- `(i, x)` でtuple（2つのset）を受け取る\n- `i` にindex、`x` にelementが入る\n- indexは0から始まる",
    "rust_lesson3_ex2_description": "周囲のvariableを使えるanonymous function「closure」を学びましょう。",
    "rust_lesson1_ex4_comment1": "mut で変更可能にdo",
    "rust_lesson1_ex8_slide3_title": "Let's Try It!",
    "rust_lesson1_ex3_slide2_content": "割り算の「あまり」を求める「%」（パーセント）演算子を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex9_slide3_title": "Let's Try It!",
    "rust_lesson3_ex3_title": "iteratorのBasic",
    "rust_lesson3_ex9_title": "Vec のmethod push",
    "rust_lesson1_ex8_comment1": "dictionaryをcreate（keyは'みかん'、valueは'オレンジ'）",
    "rust_lesson1_ex2_comment3": "+ でたし算do",
    "rust_lesson4_ex8_slide2_content": "# ジェネリクスの代わり\n\n```rust\nfn print_all(iter: impl Iterator<Item = i32>) {\n    for x in iter {\n        println!(\"{}\", x);\n    }\n}\n```",
    "rust_lesson2_ex2_slide2_title": "reference Usage",
    "rust_lesson1_ex8_slide3_content": "「辞書（HashMap）」を使うと、名前をつけてデータを保存し、その名前で取り出せます。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex7_slide2_content": "# [ ]で番号を指定して取り出す\n\n`[番号]` で何番目のデータか指定して取り出せます。\n\nImportantなルール：番号は「0」から！\n- 1番目 → `[0]`\n- 2番目 → `[1]`\n- 3番目 → `[2]`\n\ncodeExample：\n```rust\nlet fruits = vec![\"りんご\", \"バナナ\", \"みかん\"];\n//                  ↑0番    ↑1番     ↑2番\nprintln!(\"{}\", fruits[0]);  // りんご\nprintln!(\"{}\", fruits[1]);  // バナナ\n```\n\nプログラミングでは「0から数える」のが世界共通のルールです！",
    "rust_lesson1_ex6_slide1_title": "条件を組み合わせる",
    "rust_lesson2_ex10_slide2_title": "ジェネリックfunction Syntax",
    "rust_lesson1_ex6_description": "複数の条件を組み合わせる「&&（かつ）」と「||（Alsoは）」を学びましょう。",
    "rust_lesson4_ex6_title": "HashSet",
    "rust_lesson2_ex3_slide2_content": "# mut が2か所に必要\n\n変更できるようにdoには、variableとreferenceの両方に `mut` が必要です。\n\ncodeExample：\n```rust\n// 1. 変数を mut で作る\nlet mut s = String::from(\"hello\");\n\n// 2. &mut で可変参照を渡す\nchange(&mut s);\n\nfn change(s: &mut String) {\n    s.push_str(\" world\");  // 変更できる！\n}\n```\n\nPoint：\n- `let mut 変数` でvariableを変更可能に\n- `&mut 変数` で可変referenceをcreate\n- 両方ないと変更できない！",
    "rust_lesson2_ex2_slide1_title": "reference（さんしょう）?",
    "rust_lesson3_ex6_slide2_content": "# 合計、積、結合など\n\n```rust\n// 積\nv.iter().fold(1, |acc, x| acc * x)\n\n// 文字列結合\nwords.iter().fold(String::new(), |acc, s| acc + s)\n```",
    "rust_lesson1_ex1_description": "Rustを使ってscreenに文字をdisplayしてみましょう。println! という特別なfunctionをuse。",
    "rust_lesson3_ex8_slide3_title": "Let's Try It!",
    "rust_lesson4_ex6_description": "一意なvalueのsetを管理しましょう。",
    "rust_lesson2_ex5_slide1_title": "impl ?",
    "rust_lesson1_ex8_title": "名前で引き出す「dictionary」",
    "rust_lesson2_ex7_description": "valueがあるかないかを表す「Option」を学びましょう。",
    "rust_lesson1_ex4_slide2_title": "Let's Try It!",
    "rust_lesson1_ex7_title": "たくさんのデータをまとめましょう「ベクタ」",
    "rust_lesson3_ex7_slide1_content": "# errorの早期リターン\n\n? は、Resultが Err の場合に早期リターンします。\n\n```rust\nfn read_file() -> Result<String, io::Error> {\n    let content = fs::read_to_string(\"file.txt\")?;\n    Ok(content)\n}\n```",
    "rust_lesson3_ex9_slide1_content": "# 末尾に追加\n\npush は、Vecの末尾にelementをadd。\n\n```rust\nlet mut v = vec![1, 2];\nv.push(3);\n// [1, 2, 3]\n```",
    "rust_lesson4_ex8_slide3_content": "トレイトを返す関数を簡潔に書きましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex1_title": "screenにメッセージを出しましょう",
    "rust_lesson2_ex8_slide2_title": "Result  Usage",
    "rust_lesson3_ex2_slide1_title": "closure?",
    "rust_lesson3_ex8_title": "unwrap_or でデフォルトvalue",
    "rust_lesson4_ex10_slide1_content": "# 番号とelementを一緒にもらう\n\nenumerate は、「何番目か」と「そのelement」をsetで取り出せるmethodです。\n\nFor example：\n- 0番目: りんご\n- 1番目: バナナ\n- 2番目: みかん\n\ncodeExample：\n```rust\nfor (i, x) in vec![\"a\", \"b\", \"c\"].iter().enumerate() {\n    println!(\"{}: {}\", i, x);\n}\n// 0: a\n// 1: b\n// 2: c\n```",
    "rust_lesson1_ex7_slide1_content": "# データを並べてまとめる「長い箱」\n\nベクタ（Vec） は、たくさんのデータを順番に並べて入れられる「長い箱」です。\n\nFor example：\n- 買い物listの商品を全部まとめる\n- testの点数を全部まとめる\n- 友だちの名前を全部まとめる\n\n100個でも1000個でも、1つのvariableでまとめて管理できます！\n\n作り方：\n```rust\nlet fruits = vec![\"りんご\", \"バナナ\", \"みかん\"];\n// vec! で ベクタを作る\n```",
    "rust_lesson4_ex8_slide3_title": "Let's Try It!",
    "rust_lesson4_ex7_description": "パターンマッチに条件を追加しましょう。",
    "rust_lesson1_ex4_comment2": "+= で 20 を足す",
    "rust_lesson1_ex2_comment2": "y に 5 を入れる",
    "rust_lesson2_ex3_slide3_title": "Let's Try It!",
    "rust_lesson3_ex4_slide1_title": "map（map）?",
    "rust_lesson1_ex2_slide3_content": "データに名前をつけて保存できる「変数（へんすう）」を使ってみましょう。letで変数を作ります。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex8_slide2_content": "# match で成功と失敗を分ける\n\n`match` で「成功したら」「失敗したら」の処理を書き分けます。\n\ncodeExample：\n```rust\nfn divide(a: i32, b: i32) -> Result<i32, String> {\n    if b == 0 {\n        return Err(\"0で割れません\".to_string());\n    }\n    Ok(a / b)  // 成功なら答えを返す\n}\n\nmatch divide(10, 2) {\n    Ok(v) => println!(\"答えは{}\", v),\n    Err(e) => println!(\"エラー: {}\", e),\n}\n```\n\nPoint：\n- `Ok(値)` で成功をreturn\n- `Err(エラー)` で失敗をreturn",
    "rust_lesson4_ex3_comment1": "Box::new でheapに格納",
    "rust_lesson4_ex8_description": "トレイトをreturnfunctionを簡潔に書きましょう。",
    "rust_lesson2_ex10_description": "typeを後から決められる「ジェネリクス」を学びましょう。",
    "rust_lesson2_ex3_slide1_title": "可変reference（かへんさんしょう）?",
    "rust_lesson2_ex2_description": "所有権を移さずにvalueを借りる「reference」を学びましょう。",
    "rust_lesson3_ex5_slide2_title": "** にNote！",
    "rust_lesson2_ex2_slide3_title": "Let's Try It!",
    "rust_lesson4_ex3_slide3_content": "ヒープにデータを格納するBoxを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex4_title": "累算assignmentoperator（+=、-=）",
    "rust_lesson3_ex3_slide2_content": "# 借りるか、もらうか\n\n3種類の iter があり、所有権の扱いが違います。\n\n3つの違い：\n```rust\nv.iter()       // 参照で借りる（&T）\nv.iter_mut()   // 変更可能で借りる（&mut T）\nv.into_iter()  // 所有権をもらう（T）\n```\n\n使い分け：\n- `iter()` → 見るだけ（元のベクタも使える）\n- `iter_mut()` → 中身を変更したい\n- `into_iter()` → ベクタごともらう（元は使えない）\n\n普通は `iter()` をuseことが多いです。",
    "rust_lesson2_ex1_slide1_title": "所有権（しょゆうけん）?",
    "rust_lesson4_ex6_slide3_content": "一意な値の集合を管理しましょう。\n\n（When you're ready, select \"Start Lesson\".）"
  },
  "pl": {
    "rust_lesson1_course_title": "Introduction to Rust",
    "rust_lesson1_course_description": "Learn the basics of Rust programming.",
    "rust_lesson2_course_title": "Rust II - Intermediate",
    "rust_lesson2_course_description": "Learn intermediate Rust concepts.",
    "rust_lesson3_course_title": "Rust III - Advanced",
    "rust_lesson3_course_description": "Master advanced Rust techniques.",
    "rust_lesson4_course_title": "Rust IV - Expert Level",
    "rust_lesson4_course_description": "Expert-level Rust programming.",
    "rust_lesson1_ex5_slide2_content": "条件によって動きを変える if文を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex9_title": "collect で変換",
    "rust_lesson2_ex7_slide1_content": "# 「あるかもしれない、ないかもしれない」\n\nOption<T> は、valueが「あるかもしれないし、ないかもしれない」ことを表すtypeです。\n\nFor example：\n- dictionaryで単語を探す → 見つかるかもしれないし、ないかもしれない\n- ゲームでアイテムを拾う → 落ちてるかもしれないし、ないかもしれない\n\n2つの状態：\n- `Some(値)` → valueがある！\n- `None` → valueがない...\n\n他の言語では `null` をuseが、Rustでは `Option` で安全に扱います。",
    "rust_lesson1_ex2_slide1_title": "variable（へんすう）?",
    "rust_lesson1_ex7_description": "「ベクタ（Vec）」をuseと、たくさんのデータを一つの「長い はこ」にまとめて入れられます。",
    "rust_lesson2_ex9_slide2_content": "# 約束を作って、守る\n\n1. `trait` で「約束」をdefinition\n2. `impl トレイト for 型` で「約束を守る」implementationをdo\n\ncodeExample：\n```rust\n// 1. トレイト（約束）を定義\ntrait Speak {\n    fn speak(&self);  // 鳴くメソッドを持つ約束\n}\n\n// 2. Dog構造体がトレイトを実装\nstruct Dog;\nimpl Speak for Dog {\n    fn speak(&self) {\n        println!(\"woof\");\n    }\n}\n```\n\n「DogはSpeakができる」ということになります。",
    "rust_lesson4_ex4_description": "referenceカウントでデータを共有しましょう。",
    "rust_lesson4_ex5_slide1_content": "# 名前で引ける「dictionary」\n\nHashMap は、「key（名前）」と「value（データ）」をsetで保存dodictionaryです。\n\nFor example：\n- 「青チーム」→ 10点\n- 「赤チーム」→ 15点\n\ncodeExample：\n```rust\nuse std::collections::HashMap;\n\nlet mut scores = HashMap::new();\nscores.insert(\"Blue\", 10);   // 追加\nscores.insert(\"Red\", 15);    // 追加\n```\n\n`use` で機能を読み込んでからuse。",
    "rust_lesson3_ex4_title": "map でiterator変換",
    "rust_lesson4_ex1_slide3_content": "共通の振る舞いを定義するトレイトを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex4_description": "variableのvalueを手軽に増やしたり減らしたりdo「+=」「-=」を学びましょう。",
    "rust_lesson1_ex2_description": "データに名前をつけて保存できる「variable（へんすう）」を使ってみましょう。letでvariableをcreate。",
    "rust_lesson4_ex4_slide2_title": "referenceカウントの仕組み",
    "rust_lesson3_ex8_slide2_title": "unwrap_or_else",
    "rust_lesson4_ex10_comment1": "1番目の i にindex、2番目の item にelementが入る",
    "rust_lesson3_ex6_slide1_content": "# 累積処理\n\nfold は、初期valueとfunctionでelementを1つずつ畳み込みます。\n\n```rust\nlet v = vec![1, 2, 3];\nlet sum = v.iter().fold(0, |acc, x| acc + x);\n// 6\n```",
    "rust_lesson4_ex2_slide2_title": "よくuse derive トレイト",
    "rust_lesson3_ex10_slide3_content": "文字列型の違いを理解しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex4_slide2_content": "変数の値を手軽に増やしたり減らしたりする「+=」「-=」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex4_slide3_title": "Let's Try It!",
    "rust_lesson3_ex5_slide1_title": "filter（filterー）?",
    "rust_lesson4_ex5_description": "keyとvalueのpairを格納しましょう。",
    "rust_lesson3_ex5_description": "条件に合うelementだけを取り出しましょう。",
    "rust_lesson2_ex2_slide2_content": "# functionに借りてもらう\n\nfunctionにデータを渡すとき、`&` をつけると「借りる」形になります。元のvariableはそのまま使い続けられます。\n\ncodeExample：\n```rust\nfn calc_len(s: &String) -> usize {\n    s.len()  // 長さを返す\n}\n\nfn main() {\n    let text = String::from(\"hello\");\n    let len = calc_len(&text);  // textを貸す\n    // text はまだ使える！\n    println!(\"{}の長さは{}\", text, len);\n}\n```\n\n`&String` は「Stringを借りる」という意味です。",
    "rust_lesson4_ex7_slide3_content": "パターンマッチに条件を追加しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex8_slide2_content": "# 遅延評価\n\n```rust\n// クロージャで計算\nlet value = x.unwrap_or_else(|| expensive_computation());\n```",
    "rust_lesson4_ex7_title": "match ガード",
    "rust_lesson3_ex7_title": "? operatorでerror伝播",
    "rust_lesson4_ex1_description": "共通の振る舞いをdefineトレイトを学びましょう。",
    "rust_lesson2_ex1_slide2_content": "# 所有権は「移動」do\n\nvariableを別のvariableにassignmentdoと、所有権が 移動（ムーブ） します。元のvariableは使えなくなります。\n\ncodeExample：\n```rust\nlet s1 = String::from(\"hello\");  // s1 が持ち主\nlet s2 = s1;  // 所有権が s2 に移動！\n// ↓ s1 はもう使えない（エラーになる）\n// println!(\"{}\", s1);  // ダメ！\nprintln!(\"{}\", s2);  // OK！\n```\n\nイメージ：\nおもちゃを友だちにあげたら、自分はもう使えない。これがムーブです。",
    "rust_lesson1_ex8_slide1_title": "dictionary（HashMap）?",
    "rust_lesson4_ex3_slide2_content": "# サイズが決まらないとき\n\nBoxは、コンパイル時にサイズがわからないtypeにuse。\n\nFor examplerecursion的なtype：\n```rust\n// リストは「値 + 次のリスト」の繰り返し\nenum List {\n    Cons(i32, Box<List>),  // Boxで次を指す\n    Nil,                   // 終わり\n}\n```\n\nなぜBoxが必要？\n- `List` の中に `List` がある → 無限に大きくなる？\n- `Box` をuseと、サイズが固定（pointerのサイズ）になる\n\n「中身」ではなく「中身への矢印」を持つイメージです。",
    "rust_lesson2_ex10_title": "ジェネリクスを使おう",
    "rust_lesson2_ex8_slide3_title": "Let's Try It!",
    "rust_lesson3_ex9_slide2_content": "# 可変reference\n\n```rust\n// mut が必要\nlet mut v = Vec::new();\nv.push(1);\nv.push(2);\n```",
    "rust_lesson4_ex4_title": "Rc<T>",
    "rust_lesson2_ex3_comment1": "mut で可変variableにdo",
    "rust_lesson4_ex5_slide3_title": "Let's Try It!",
    "rust_lesson2_ex6_slide2_content": "# バリアントを列挙\n\n`enum 名前 { バリアント1, バリアント2, ... }` でdefine。\n\ncodeExample：\n```rust\nenum Color {\n    Red,\n    Green,\n    Blue,\n}\nlet c = Color::Red;\n```",
    "rust_lesson1_ex1_comment1": "Hello, Rust! とdisplay",
    "rust_lesson1_ex1_slide1_content": "# 安全で速い！最新のプログラミング言語\n\nRust（ラスト）は、「間違いを事前に防ぐ」ことがとても得意なプログラミング言語です。\n\nRustのすごいところ：\n- programのミスをexecute前に見つけてくれる\n- とても速く動く\n- 世界中のプログラマーが「一番好き！」と選ぶ人気の言語\n\nたとえるなら：\n厳しいけど優しい先生のような言語です。「ここ間違ってるよ」と教えてくれるので、安心してprogramが書けます！",
    "rust_lesson3_ex8_slide1_content": "# None/Err の場合のデフォルト\n\nunwrap_or は、None や Err の場合にデフォルトvalueをreturn。\n\n```rust\nlet x: Option<i32> = None;\nlet value = x.unwrap_or(0);  // 0\n```",
    "rust_lesson2_ex7_slide3_title": "Let's Try It!",
    "rust_lesson2_ex6_title": "enum で状態を表す",
    "rust_lesson2_ex8_slide1_content": "# 「成功」か「失敗」かを表す\n\nResult<T, E> は、処理が「成功したか失敗したか」を表すtypeです。\n\nFor example：\n- fileをopen → 成功（内容）か失敗（error）\n- 0で割り算 → 成功（答え）か失敗（0で割れない！）\n\n2つの状態：\n- `Ok(値)` → 成功！valueが入っている\n- `Err(エラー)` → 失敗...error情報が入っている\n\n`Option` は「あるか・ないか」、`Result` は「成功か・失敗か」という違いです。",
    "rust_lesson2_ex8_slide3_content": "成功と失敗を表す「Result」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex6_slide1_title": "HashSet ?",
    "rust_lesson3_ex9_comment1": "push でelementを追加",
    "rust_lesson2_ex7_slide2_title": "Option  Usage",
    "rust_lesson3_ex2_title": "closureのBasic",
    "rust_lesson3_ex7_slide1_title": "? operator?",
    "rust_lesson4_ex6_comment1": "HashSet をimport",
    "rust_lesson2_ex10_slide1_content": "# どんなtypeでも使える「万能」の仕組み\n\nジェネリクス は、typeを後から決められる仕組みです。\n\nなぜ便利？\n同じようなfunctionを何度も書かなくてすみます。\n\nFor example：\n- 数字のarrayの最初のelementを取るfunction\n- stringのarrayの最初のelementを取るfunction\n\n両方とも「最初のelementを取る」のは同じなのに、typeが違うだけで別のfunctionをwriteのは大変！\n\nジェネリクスなら、`<T>` で「typeは後で決める」とwriteだけで、どんなtypeでも使えるfunctionが作れます。",
    "rust_lesson1_ex3_slide1_content": "# 剰余operator（じょうよえんざんし）「%」\n\n`%`（パーセント）は、割り算の 「あまり」 をcalculate特別な記号です。\n\nわかりやすいExample：\n- 10このアメを3人で分けると？\n- 1人3こずつで、1こあまる\n- これを `10 % 3` とwriteと、答えは `1`\n\ncodeExample：\n```rust\nprintln!(\"{}\", 10 % 3);  // 1（あまり1）\nprintln!(\"{}\", 8 % 4);   // 0（あまりなし＝割り切れる）\n```\n\n使いどころ：\n- 偶数か奇数か調べる（`n % 2` が0なら偶数）\n- 時計の計算（24を超えたら0に戻る、など）",
    "rust_lesson3_ex7_description": "errorを簡潔に伝播させましょう。",
    "rust_lesson3_ex8_comment1": "unwrap_or でデフォルトvalueを設定",
    "rust_lesson2_ex8_title": "Result<T, E> でerror処理",
    "rust_lesson2_ex10_comment1": "T をtypeパラメータとしてuse",
    "rust_lesson2_ex6_comment1": "enum で列挙typeをdefinition",
    "rust_lesson3_ex3_slide3_content": "要素を順番に処理するイテレータを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex2_comment1": "derive でトレイトを自動implementation",
    "rust_lesson1_ex8_slide1_content": "# 名前でsearchできる「dictionary」\n\nHashMap（ハッシュmap）は、「名前」と「データ」をsetにして保存できる仕組みです。本物のdictionaryのように使えます。\n\nFor example果物の色dictionary：\n- 「りんご」→「あか」\n- 「バナナ」→「きいろ」\n- 「みかん」→「オレンジ」\n\nuse準備：\n```rust\nuse std::collections::HashMap;  // 機能を読み込む\nlet mut fruits = HashMap::new();  // 空の辞書を作る\nfruits.insert(\"りんご\", \"あか\");  // データを追加\n```\n\n`use` は「この機能をuseよ」というdeclarationです。",
    "rust_lesson3_ex9_slide1_title": "push ?",
    "rust_lesson4_ex1_title": "トレイトのdefinition",
    "rust_lesson4_ex3_description": "heapにデータを格納doBoxを学びましょう。",
    "rust_lesson1_ex2_title": "便利な「はこ」variable（へんすう）",
    "rust_lesson1_ex8_comment2": "中身を出す",
    "rust_lesson3_ex9_slide3_title": "Let's Try It!",
    "rust_lesson1_ex4_comment3": "-= で 50 を引く",
    "rust_lesson1_ex6_comment1": "&& で両方の条件をチェック",
    "rust_lesson4_ex1_slide2_title": "トレイトのimplementation",
    "rust_lesson4_ex7_slide3_title": "Let's Try It!",
    "rust_lesson4_title": "Rust IV - トレイトとスマートpointer",
    "rust_lesson4_ex1_comment1": "trait でトレイトをdefinition",
    "rust_lesson4_ex4_slide1_content": "# 複数の「持ち主」を許可do仕組み\n\nRc<T> は「Reference Counted（referenceカウント）」の略で、複数の所有者でデータを共有できます。\n\n普通の所有権：\n1人だけが持ち主。渡したら元の人は使えない。\n\nRc をuseと：\n複数人が同じデータの「持ち主」になれる！\n\ncodeExample：\n```rust\nuse std::rc::Rc;\n\nlet a = Rc::new(5);       // Rcでラップ\nlet b = Rc::clone(&a);    // bも持ち主になる\n// a も b も使える！\n```",
    "rust_lesson3_ex5_slide1_content": "# 条件に合うものだけ残す\n\nfilter は、条件を満たすelementだけを残し、他を捨てます。\n\nFor example：\n- 80点以上の人だけ残す\n- 偶数だけ残す\n- 「あ」から始まる名前だけ残す\n\ncodeExample：\n```rust\nlet v = vec![1, 2, 3, 4, 5];\nlet evens: Vec<_> = v.iter()\n    .filter(|x| **x % 2 == 0)  // 偶数だけ\n    .collect();\n// [2, 4]\n```\n\n条件が `true` のelementだけが残ります。",
    "rust_lesson3_ex7_slide3_title": "Let's Try It!",
    "rust_lesson1_ex7_comment2": "2番目のデータ（1番）を出す",
    "rust_lesson4_ex8_title": "impl Trait",
    "rust_lesson1_ex5_description": "条件によって動きを変える if文を学びましょう。",
    "rust_lesson3_ex4_slide2_title": "遅延評価（ちえんひょうか）",
    "rust_lesson3_ex1_slide1_content": "# referenceの「寿命」を示す印\n\nライフタイム は、referenceがいつまで使えるかを示す印です。`'a`（アポストロフィ・エー）のようにwrite。\n\nなぜ必要？\nreferenceは「借りている」状態。借りた元のデータが消えたら、referenceも使えなくなります。\n\nFor example：\n- 図書館で借りた本 → 図書館が閉まったら読めない\n- referenceで借りたデータ → 元のデータが消えたら使えない\n\nライフタイムは「このreferenceはこの範囲で有効だよ」とコンパイラに伝える仕組みです。",
    "rust_lesson1_ex1_slide1_title": "Rust（ラスト）?",
    "rust_lesson1_ex2_slide2_title": "計算の記号（operator）",
    "rust_lesson4_ex5_slide2_content": "# get で安全に取り出す\n\n`get()` methodでvalueを取り出せます。見つからない可能性があるので、`Option` が返ってきます。\n\ncodeExample：\n```rust\n// getはOption<&V>を返す\nif let Some(score) = scores.get(\"Blue\") {\n    println!(\"青チームは{}点\", score);\n}\n```\n\nPoint：\n- keyがあれば `Some(値)` が返る\n- keyがなければ `None` が返る\n- `if let` で安全に取り出せる\n\n存在しないkeyでアクセスしてもprogramが落ちない！",
    "rust_lesson4_ex7_slide1_title": "match ガード?",
    "rust_lesson3_title": "Rust III - ライフタイムとiterator",
    "rust_lesson4_ex3_title": "Box<T>",
    "rust_lesson1_ex4_slide1_title": "累算assignmentoperator（るいさんだいにゅう）?",
    "rust_lesson2_ex9_comment1": "trait でトレイトをdefinition",
    "rust_lesson2_ex1_description": "Rust独自の概念「所有権」を学びましょう。",
    "rust_lesson2_ex3_slide3_content": "参照先の値を変更できる「可変参照」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex1_slide3_title": "Let's Try It!",
    "rust_lesson3_ex6_slide2_title": "様々な畳み込み",
    "rust_lesson4_ex9_slide3_title": "Let's Try It!",
    "rust_lesson2_ex5_title": "impl でmethodを追加",
    "rust_lesson2_ex6_slide1_content": "# 複数の選択肢\n\nenum は、valueがいくつかの種類のうちの一つであることを表します。各バリアントにデータを持たせることもできます。",
    "rust_lesson2_ex4_comment1": "struct で構造体をdefinition",
    "rust_lesson1_ex3_title": "剰余operator（%）",
    "rust_lesson1_ex7_comment1": "colors というベクタをcreate（'あか', 'あお'の順）",
    "rust_lesson1_ex4_slide1_content": "# valueをかんたんに増やす・減らす\n\n`+=`（プラスイコール）と `-=`（マイナスイコール）は、variableの中身を増やしたり減らしたりdo便利な記号です。\n\nRustのImportantなルール：`mut`が必要！\nRustでは、variableをchangeには `let mut`（レット ミュート）とwrite必要があります。`mut` は「mutable（変更できる）」の略です。\n\ncodeExample：\n```rust\nlet mut score = 100;  // mut をつけて変更可能に\nscore += 10;          // 10を足す → 110に\nscore -= 50;          // 50を引く → 60に\n```\n\n`mut` がないと「このvariableは変えちゃダメ！」とRustが怒ります。",
    "rust_lesson2_ex1_slide2_title": "ムーブ（移動）",
    "rust_lesson3_ex4_comment1": "map で各elementを変換",
    "rust_lesson3_ex8_slide1_title": "unwrap_or ?",
    "rust_lesson2_ex5_slide1_content": "# implementationブロック\n\nimpl ブロックで、構造体にmethodを追加できます。`self` で自分自身をreferenceします。",
    "rust_lesson2_ex10_slide1_title": "ジェネリクス?",
    "rust_lesson1_ex8_slide2_content": "# 名前（key）で取り出す\n\ndictionaryに入れたデータは、名前（key）を指定して取り出せます。\n\ncodeExample：\n```rust\nuse std::collections::HashMap;\nfn main() {\n    let mut fruits = HashMap::new();\n    fruits.insert(\"りんご\", \"あか\");  // 追加\n    fruits.insert(\"バナナ\", \"きいろ\");  // 追加\n    \n    println!(\"{}\", fruits[\"りんご\"]);  // あか と表示\n}\n```\n\nPoint：\n- `insert(名前, データ)` で追加\n- `辞書[名前]` で取り出し\n- 番号ではなく「名前」で探せるのが便利！",
    "rust_lesson4_ex9_slide1_content": "# iteratorをコレクションに\n\ncollect は、iteratorをVecやHashMapなどに変換します。\n\n```rust\nlet v: Vec<_> = (0..5).collect();\nlet s: String = vec!['a', 'b'].into_iter().collect();\n```",
    "rust_lesson2_ex2_slide3_content": "所有権を移さずに値を借りる「参照」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex2_slide3_content": "周囲の変数を使える無名関数「クロージャ」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex4_slide2_content": "# struct keyワードでdefinition\n\n`struct 名前 { フィールド }` で構造体をdefine。フィールドには名前とtypeをwrite。\n\ncodeExample：\n```rust\n// Point 構造体を定義\nstruct Point {\n    x: i32,  // xフィールド（整数）\n    y: i32,  // yフィールド（整数）\n}\n\n// 使い方\nlet p = Point { x: 10, y: 20 };\nprintln!(\"x={}, y={}\", p.x, p.y);\n```\n\nPoint：\n- `struct 名前` で構造体をcreate\n- `{ フィールド名: 型 }` でどんなデータを持つか決める\n- `.フィールド名` でアクセス",
    "rust_lesson2_ex10_slide3_content": "型を後から決められる「ジェネリクス」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex6_slide3_title": "Let's Try It!",
    "rust_lesson4_ex6_slide1_content": "# 一意なvalueのset\n\nHashSet は、重複のないvalueのsetです。\n\n```rust\nuse std::collections::HashSet;\n\nlet mut set = HashSet::new();\nset.insert(1);\nset.insert(2);\nset.insert(1); // 重複は無視\n```",
    "rust_lesson4_ex2_title": "derive 属性",
    "rust_lesson4_ex2_slide1_content": "# トレイトを「自動で」implementation\n\n#[derive(...)] をuseと、よくuseトレイトを自分で書かなくても自動でimplementationしてくれます。\n\nFor example：\n構造体を `println!` でdisplayしたいとき、普通は Display トレイトをimplementationdo必要がありますが、`#[derive(Debug)]` をwriteだけでOK！\n\ncodeExample：\n```rust\n#[derive(Debug)]  // Debug トレイトを自動実装\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nlet p = Point { x: 1, y: 2 };\nprintln!(\"{:?}\", p);  // Point { x: 1, y: 2 }\n```",
    "rust_lesson1_ex6_slide2_title": "Let's Try It!",
    "rust_lesson3_ex3_slide2_title": "3つの iter method",
    "rust_lesson4_ex7_slide2_content": "# 複雑なconditional\n\n```rust\nmatch Some(5) {\n    Some(x) if x % 2 == 0 => println!(\"even\"),\n    Some(x) => println!(\"odd: {}\", x),\n    None => println!(\"none\"),\n}\n```",
    "rust_lesson3_ex3_slide1_content": "# elementを1つずつ取り出す仕組み\n\niterator は、ベクタなどのデータを「1つずつ順番に」取り出す仕組みです。\n\nFor example：\n- 行列に並んでいる人を1人ずつ呼ぶ\n- 引き出しの中身を1つずつ出す\n\ncodeExample：\n```rust\nlet v = vec![1, 2, 3];\nfor x in v.iter() {\n    println!(\"{}\", x);  // 1, 2, 3 と順番に表示\n}\n```\n\n`iter()` で「順番に取り出す準備」をして、`for` で1つずつ処理します。",
    "rust_lesson3_ex3_slide1_title": "iterator?",
    "rust_lesson4_ex2_description": "トレイトを自動implementationdoderiveを学びましょう。",
    "rust_lesson3_ex4_slide1_content": "# 全部を同じように変換do\n\n**map** は、iteratorの各elementを「同じ方法で」変換します。\n\nFor example：\n- 全員の身長を2倍にdo\n- 全員の名前を大文字にdo\n- 全部の数を2乗do\n\ncodeExample：\n```rust\nlet v = vec![1, 2, 3];\nlet doubled: Vec<_> = v.iter()\n    .map(|x| x * 2)  // 各要素を2倍に\n    .collect();      // ベクタに戻す\n// [2, 4, 6]\n```\n\n`|x| x * 2` は「xを受け取って、x*2をreturn」closureです。",
    "rust_lesson1_ex3_slide1_title": "あまりを求める",
    "rust_lesson3_ex10_slide1_content": "# 所有権の違い\n\nString は所有権を持つheap上のstring、&str はreferenceです。\n\n```rust\nlet s1: String = String::from(\"hello\");\nlet s2: &str = \"hello\";\n```",
    "rust_lesson4_ex2_slide1_title": "derive（デライブ）?",
    "rust_lesson2_ex2_comment1": "& でreferenceを渡す",
    "rust_lesson4_ex5_slide1_title": "HashMap（ハッシュmap）?",
    "rust_lesson2_ex3_slide2_title": "&mut  Usage",
    "rust_lesson3_ex5_title": "filter で絞り込み",
    "rust_lesson4_ex3_slide2_title": "いつuse？",
    "rust_lesson2_ex2_title": "referenceと借用",
    "rust_lesson2_ex7_title": "Option<T> で null を安全に",
    "rust_lesson4_ex10_slide3_title": "Let's Try It!",
    "rust_lesson3_ex5_slide3_title": "Let's Try It!",
    "rust_lesson4_ex10_title": "enumerate でindex付き",
    "rust_lesson2_ex2_slide1_content": "# 所有権を渡さずに「借りる」\n\nreference をuseと、所有権を移さずにデータを「見せてもらう」ことができます。\n\nたとえるなら：\n- ムーブ = おもちゃをあげる（自分は使えない）\n- reference = おもちゃを見せる（自分も使える）\n\n作り方：\n`&`（アンパサンド）をつけるとreferenceを作れます。\n\n```rust\nlet s = String::from(\"hello\");\nlet r = &s;  // sを借りる（見せてもらう）\n// s も r も使える！\n```",
    "rust_lesson2_ex5_slide2_content": "# &self をuse\n\nmethodの最初のargumentは `&self` です。\n\ncodeExample：\n```rust\nimpl Rect {\n    fn area(&self) -> i32 {\n        self.width * self.height\n    }\n}\n```",
    "rust_lesson1_ex5_slide2_title": "Let's Try It!",
    "rust_lesson2_ex4_slide3_title": "Let's Try It!",
    "rust_lesson4_ex3_slide3_title": "Let's Try It!",
    "rust_lesson2_ex9_slide3_content": "共通の振る舞いを定義する「トレイト」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex1_slide2_content": "# impl で約束を守る\n\n構造体にトレイトをimplementationdoと、その構造体は「約束を守る」ことになります。\n\ncodeExample：\n```rust\nstruct Person { name: String }\n\nimpl Greet for Person {\n    fn greet(&self) -> String {\n        format!(\"Hello, {}\", self.name)\n    }\n}\n```\n\n読み方：\n- `impl Greet for Person` → 「PersonはGreetをimplementationdo」\n- これでPersonは「あいさつできる」ようになった！",
    "rust_lesson4_ex4_comment1": "clone でreferenceカウントを増やす",
    "rust_lesson3_ex4_slide2_content": "# map だけではexecuteされない！\n\nRustのiteratorは 遅延評価 といって、「本当に必要になるまで処理しない」仕組みです。\n\nなぜ？\n無駄な計算を省けるから。100万件あっても、最初の10件だけ欲しいなら10件だけ処理すればいい。\n\ncollect() でexecute：\n```rust\n// これだけでは何も起きない\nv.iter().map(|x| x * 2);\n\n// collect() で実行してベクタに変換\nlet result: Vec<_> = v.iter().map(|x| x * 2).collect();\n```\n\n`collect()` は「今すぐ全部処理してResultをちょうだい」という意味です。",
    "rust_lesson2_ex4_slide2_title": "struct のdefinitionのしかた",
    "rust_lesson2_ex3_slide1_content": "# 「書き換えできる」借り方\n\n普通のreference `&` は「見るだけ」ですが、可変reference `&mut` は「変更もできる」借り方です。\n\nたとえるなら：\n- `&` = 本を見せてもらう（readだけ）\n- `&mut` = ノートを借りる（writeOK）\n\nImportantなルール：\n- 可変referenceは同時に1つだけ！\n- 「みんなで見る」か「1人でwrite」かのどちらか\n\nこのルールで、データが同時に書き換えられるバグを防いでいます。",
    "rust_lesson2_ex10_slide3_title": "Let's Try It!",
    "rust_lesson2_ex4_title": "構造体をdefinitionしよう",
    "rust_lesson3_ex10_slide2_content": "# 相互変換\n\n```rust\n// &str -> String\nlet s = \"hello\".to_string();\n\n// String -> &str\nlet slice: &str = &s;\n```",
    "rust_lesson4_ex10_slide3_content": "イテレータにインデックスを付けましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex4_slide2_content": "# 「何人が持っているか」を数える\n\nRcは「今何人がこのデータを持っているか」を数えています。\n\ncodeExample：\n```rust\nlet a = Rc::new(5);\nprintln!(\"{}\", Rc::strong_count(&a));  // 1\n\nlet b = Rc::clone(&a);\nprintln!(\"{}\", Rc::strong_count(&a));  // 2\n```\n\nいつデータが消える？\n- カウントが0になったとき（誰も持っていないとき）\n- 最後の持ち主がいなくなると自動で片付けられる\n\n`Rc::clone` は「持ち主を1人増やす」操作です。",
    "rust_lesson1_ex8_slide2_title": "dictionary Usage",
    "rust_lesson4_ex3_slide1_content": "# データを「heap」に置く箱\n\nBox<T> は、データを「heap」という特別な場所に置くための箱です。\n\nmemoryの2つの場所：\n- stack：小さくて速い。サイズが決まっているデータ向け\n- heap：大きくて柔軟。サイズが大きいor変わるデータ向け\n\ncodeExample：\n```rust\nlet b = Box::new(5);  // 5をヒープに置く\nprintln!(\"{}\", *b);   // *で中身を取り出す → 5\n```\n\n`*` は「箱を開けて中身を見る」操作です。",
    "rust_lesson3_ex2_slide2_title": "closure Syntax",
    "rust_lesson4_ex4_slide1_title": "Rc（アールシー）?",
    "rust_lesson4_ex7_slide1_content": "# 追加条件\n\n**if** でパターンに追加条件をつけられます。\n\n```rust\nmatch x {\n    n if n < 0 => println!(\"negative\"),\n    n if n > 0 => println!(\"positive\"),\n    _ => println!(\"zero\"),\n}\n```",
    "rust_lesson2_ex3_title": "可変reference",
    "rust_lesson3_ex10_comment1": "to_string で String に変換",
    "rust_lesson3_ex10_slide2_title": "変換",
    "rust_lesson3_ex1_description": "referenceの有効期間を表すライフタイムを学びましょう。",
    "rust_lesson3_ex2_slide1_content": "# 名前のない「即席」function\n\nclosure は、名前をつけずにその場でcreatefunctionです。そして特別な能力があります：周りのvariableを使えるのです！\n\nFor example：\n```rust\nlet x = 5;  // 外側の変数\nlet add_x = |n| n + x;  // xを使えるクロージャ\nprintln!(\"{}\", add_x(10));  // 15\n```\n\n普通のfunctionとの違い：\n- 普通のfunction：argumentしか使えない\n- closure：argument + 周りのvariableも使える\n\n「その場の空気を読める」functionというイメージです！",
    "rust_lesson1_ex2_comment1": "x に 10 を入れる",
    "rust_lesson1_ex7_slide3_title": "Let's Try It!",
    "rust_lesson1_ex5_title": "「もし〜なら」で分けましょう",
    "rust_lesson3_ex2_slide3_title": "Let's Try It!",
    "rust_lesson3_ex7_slide2_content": "# 簡潔なerror処理\n\n```rust\n// ? を使わない場合\nmatch result {\n    Ok(v) => v,\n    Err(e) => return Err(e),\n}\n\n// ? を使う\nresult?\n```",
    "rust_lesson3_ex6_slide3_title": "Let's Try It!",
    "rust_lesson4_ex9_slide3_content": "イテレータをコレクションに変換しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex6_description": "elementを1つのvalueにまとめるfoldを学びましょう。",
    "rust_lesson2_ex9_description": "共通の振る舞いをdefine「トレイト」を学びましょう。",
    "rust_lesson2_ex8_comment1": "Ok で成功をreturn",
    "rust_lesson3_ex5_slide2_content": "# filter はreferenceのreferenceを受け取る\n\n`filter` のclosureは、referenceのreference（`&&T`）を受け取ります。そのため、valueをuseには `**x` と2回referenceを外す必要があります。\n\nなぜ？\n- `iter()` はreference（`&T`）をreturn\n- `filter` はそれをFurthermorereferenceで渡す（`&&T`）\n\nSyntax：\n```rust\n// **x で値を取り出す\n.filter(|x| **x > 2)\n\n// または * を引数につける\n.filter(|&x| *x > 2)\n```\n\n最初は混乱しますが、慣れれば大丈夫！",
    "rust_lesson1_ex5_comment1": "> でcompare",
    "rust_lesson2_ex4_description": "関連doデータをまとめる「構造体」を学びましょう。",
    "rust_lesson3_ex5_slide3_content": "条件に合う要素だけを取り出しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex7_slide3_content": "「ベクタ（Vec）」を使うと、たくさんのデータを一つの「長い はこ」にまとめて入れられます。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex5_slide2_title": "valueの取得",
    "rust_lesson3_ex1_slide1_title": "ライフタイム?",
    "rust_lesson1_ex3_comment1": "10 を 3 で割ったあまりをoutput",
    "rust_lesson3_ex1_comment1": "'a でライフタイムをdefinition",
    "rust_lesson3_ex10_slide1_title": "String vs &str",
    "rust_lesson2_title": "Rust II - 所有権とトレイト",
    "rust_lesson2_ex5_slide2_title": "methodのdefinition",
    "rust_lesson4_ex5_comment1": "insert でkeyとvalueを追加",
    "rust_lesson2_ex9_slide1_content": "# 「できること」の約束\n\nトレイト は、「このtypeはこういうことができる」という約束をdefine。\n\nFor example「鳴ける」という約束：\n- 犬は「ワン」と鳴く\n- 猫は「ニャー」と鳴く\n- 両方とも「鳴ける」能力がある\n\nトレイトは「鳴ける動物は、鳴き声を出すmethodを持つ」という約束です。\n\n他の言語とのcomparison：\n- Java: interface\n- TypeScript: interface\n\nに似た概念です。",
    "rust_lesson1_ex2_slide3_title": "Let's Try It!",
    "rust_lesson4_ex8_slide1_content": "# return valueのtypeをabstract化\n\nimpl Trait で、トレイトをimplementationdotypeを返せます。\n\n```rust\nfn make_iter() -> impl Iterator<Item = i32> {\n    vec![1, 2, 3].into_iter()\n}\n```",
    "rust_lesson1_ex2_slide2_content": "# 四則演算（しそくえんざん）\n\nRustでも算数と同じ記号で計算ができます。\n\n4つのBasic記号：\n- +（プラス）: たし算\n- -（マイナス）: ひき算\n- \\*（アスタリスク）: かけ算（×の代わり）\n- /（スラッシュ）: わり算（÷の代わり）\n\ncodeExample：\n```rust\nlet a = 10;\nlet b = 5;\nprintln!(\"{}\", a + b);  // 15 と表示される\n```\n\n`println!` の `{}` は「ここにvalueを入れてね」という目印です。",
    "rust_lesson4_ex9_slide2_content": "# 変換先を指定\n\n```rust\n// ターボフィッシュ構文\nlet v = (0..5).collect::<Vec<_>>();\n\n// 変数の型注釈\nlet v: Vec<i32> = (0..5).collect();\n```",
    "rust_lesson1_ex8_description": "「dictionary（HashMap）」をuseと、名前をつけてデータを保存し、その名前で取り出せます。",
    "rust_lesson4_ex9_slide2_title": "typeHint",
    "rust_lesson3_ex1_title": "ライフタイムのBasic",
    "rust_lesson2_ex5_description": "構造体にmethodをadd「impl」を学びましょう。",
    "rust_lesson4_ex8_comment1": "impl でトレイトをimplementationdotypeをreturn",
    "rust_lesson4_ex8_slide2_title": "argumentにも使える",
    "rust_lesson4_ex7_comment1": "if でマッチガードを追加",
    "rust_lesson2_ex9_slide2_title": "trait のdefinitionとimplementation",
    "rust_lesson4_ex10_slide2_title": "いつuse？",
    "rust_lesson3_ex7_slide2_title": "match の省略形",
    "rust_lesson1_ex6_title": "logicaloperator（&&、||）",
    "rust_lesson3_ex6_comment1": "fold で畳み込み",
    "rust_lesson2_ex6_description": "複数の状態を表す「列挙type（enum）」を学びましょう。",
    "rust_lesson4_ex10_slide1_title": "enumerate（イニュメレート）?",
    "rust_lesson1_ex7_slide1_title": "ベクタ（Vec）?",
    "rust_lesson2_ex6_slide3_content": "複数の状態を表す「列挙型（enum）」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex3_slide3_title": "Let's Try It!",
    "rust_lesson3_ex4_description": "各elementを変換domapを学びましょう。",
    "rust_lesson4_ex1_slide3_title": "Let's Try It!",
    "rust_lesson3_ex9_slide2_title": "mut が必要",
    "rust_lesson1_ex6_slide1_content": "# logicaloperator（ろんりえんざんし）\n\n2つ以上の条件を組み合わせたいときにuse記号です。\n\n2つの記号：\n- `&&`（アンドアンド）：「かつ」＝ 両方とも 正しいとき\n- `||`（オアオア）：「Alsoは」＝ どちらか 正しいとき\n\n身近なExample：\n- 遊園地：「18歳以上 かつ チケットあり」なら乗れる\n- おやつ：「宿題終わった Alsoは お手伝いした」ならOK\n\ncodeExample：\n```rust\nif score >= 70 && bonus > 0 {\n    // 70点以上 かつ ボーナスあり → 合格！\n    println!(\"合格！\");\n}\n```",
    "rust_lesson4_ex4_slide3_content": "参照カウントでデータを共有しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex6_slide3_title": "Let's Try It!",
    "rust_lesson2_ex5_slide3_content": "構造体にメソッドを追加する「impl」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex1_slide3_title": "Let's Try It!",
    "rust_lesson1_ex5_slide1_content": "# programに「判断」させよう\n\nconditional は、「もし〜なら、〇〇do」という判断をprogramにさせる仕組みです。\n\n身近なExample：\n- もし80点以上なら → 「合格！」とdisplay\n- もし雨なら → 傘を持っていく\n- もしHPが0なら → ゲームオーバー\n\nRustで Syntax：\n```rust\nif score > 80 {\n    println!(\"合格！\");\n}\n```\n\n読み方：\n- `if` →「もし」\n- `score > 80` →「スコアが80より大きいなら」\n- `{ }` の中 →「これをやる」",
    "rust_lesson4_ex5_title": "HashMap",
    "rust_lesson1_ex2_slide1_content": "# データを保存do「はこ」\n\nvariable（へんすう） は、数字や文字を入れておける「はこ」のことです。名前をつけて、あとでuseことができます。\n\nFor example：\n- 「りんごの数」というラベルの箱に「5」を入れる\n- あとで「りんごの数」と呼べば「5」が出てくる\n\nRustで Syntax：\n```rust\nlet x = 10;  // xという箱に10を入れる\nprintln!(\"{}\", x);  // xの中身（10）を表示\n```\n\n`let` は「この名前で箱をcreateよ」という意味です。",
    "rust_lesson2_ex4_slide3_content": "関連するデータをまとめる「構造体」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex6_slide1_title": "enum ?",
    "rust_lesson2_ex9_title": "トレイトをdefinitionしよう",
    "rust_lesson2_ex4_slide1_title": "構造体（こうぞうたい）?",
    "rust_lesson4_ex2_slide2_content": "# 覚えておくと便利な5つ\n\nよくusederiveトレイト：\n```rust\nDebug     // {:?} でデバッグ表示できる\nClone     // .clone() でコピーを作れる\nCopy      // 代入時に自動でコピー（小さい型向け）\nPartialEq // == で比較できる\nDefault   // 初期値を自動で作れる\n```\n\n複数指定もOK：\n```rust\n#[derive(Debug, Clone, PartialEq)]\nstruct User {\n    name: String,\n    age: u32,\n}\n```\n\n`Debug` は特によくuse。debug時に構造体の中身を見れて便利！",
    "rust_lesson2_ex1_slide1_content": "# データの「持ち主」を決めるルール\n\n所有権 は、Rust最大のFeatureです。「このデータの持ち主は誰か」をはっきりさせる仕組みです。\n\nルール：\n- データには必ず1人だけ「持ち主」がいる\n- 持ち主がいなくなると、データは自dynamicに片付けられる\n\nたとえるなら：\n- おもちゃは1人しか持てない\n- 持ち主が部屋を出たら、おもちゃは片付けられる\n\nこのルールのおかげで、Rustは「memoryリーク」（データが片付けられないバグ）を防げます！",
    "rust_lesson1_ex3_slide2_title": "Let's Try It!",
    "rust_lesson3_ex1_slide2_title": "なぜ必要？",
    "rust_lesson3_ex1_slide2_content": "# 危険なバグを防ぐ\n\nダングリングreference という危険なバグがあります。これは「もう存在しないデータ」を指し続けているreferenceのことです。\n\nExample：\n```rust\nfn longest<'a>(x: &'a str, y: &'a str) -> &'a str {\n    if x.len() > y.len() { x } else { y }\n}\n```\n\n`'a` の意味：\n- argument `x` と `y` は同じライフタイム `'a` を持つ\n- return valueも同じライフタイム `'a` を持つ\n- In other words「xとyが両方有効な間、return valueも有効」という約束\n\nRustはこれを自動でチェックしてくれます！",
    "rust_lesson4_ex6_slide2_title": "set演算",
    "rust_lesson3_ex7_comment1": "? でerrorを伝播",
    "rust_lesson3_ex2_slide2_content": "# | | でargumentを囲む\n\nclosureは `|引数| 処理` という形でwrite。`||` は「パイプ」と呼ばれます。\n\nいろいろなSyntax：\n```rust\n// 引数なし\n|| println!(\"Hello\")\n\n// 引数あり\n|x, y| x + y\n\n// 複数行のブロック\n|x| {\n    let y = x * 2;\n    y + 1\n}\n```\n\nPoint：\n- argumentを `| |` で囲む（functionの `()` の代わり）\n- typeは省略できることが多い（Rustが推測してくれる）",
    "rust_lesson2_ex7_comment1": "Some でvalueがあることを示す",
    "rust_lesson3_ex4_slide3_content": "各要素を変換するmapを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_title": "Rust (ラスト) に挑戦！",
    "rust_lesson2_ex8_description": "成功と失敗を表す「Result」を学びましょう。",
    "rust_lesson3_ex8_description": "Option/Resultのデフォルトvalueを設定しましょう。",
    "rust_lesson4_ex2_slide3_title": "Let's Try It!",
    "rust_lesson2_ex5_slide3_title": "Let's Try It!",
    "rust_lesson4_ex9_description": "iteratorをコレクションに変換しましょう。",
    "rust_lesson1_ex1_slide2_content": "# println! でscreenにdisplay\n\nRustで文字をscreenにdisplayには、`println!`（プリントラインびっくり）をuse。\n\nPoint：\n- `!` がつくのがRustのFeature（マクロと呼ばれます）\n- programは `fn main() { }` の中にwrite\n- `fn` は「function（function）」の略\n\ncodeExample：\n```rust\nfn main() {\n    println!(\"ヤッホー！\");\n}\n// 「ヤッホー！」と画面に表示される\n```\n\n`println!` の `!` は「マクロ」という特別な機能の印です。今は「おまじない」と思っておけばOK！",
    "rust_lesson3_ex6_slide1_title": "fold ?",
    "rust_lesson4_ex8_slide1_title": "impl Trait ?",
    "rust_lesson1_ex1_slide2_title": "Rustの「おまじない」",
    "rust_lesson3_ex10_description": "stringtypeの違いを理解しましょう。",
    "rust_lesson3_ex7_slide3_content": "エラーを簡潔に伝播させましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex1_comment1": "s1 の所有権を移動",
    "rust_lesson2_ex9_slide1_title": "トレイト?",
    "rust_lesson4_ex6_slide2_content": "# 和set、積setなど\n\n```rust\nset1.union(&set2)\nset1.intersection(&set2)\nset1.difference(&set2)\n```",
    "rust_lesson4_ex5_slide3_content": "キーと値のペアを格納しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex8_slide1_title": "Result（リザルト）?",
    "rust_lesson4_ex1_slide1_content": "# 「できること」の約束\n\nトレイト は、typeが持つべきmethodをdefine仕組みです。\n\nFor example：\n- 「あいさつできる」トレイト → greet() methodを持つ\n- 「displayできる」トレイト → display() methodを持つ\n\ncodeExample：\n```rust\ntrait Greet {\n    fn greet(&self) -> String;  // メソッドの「約束」\n}\n```\n\nこれは「Greetできるtypeは、greet()methodを持つ」という約束です。",
    "rust_lesson4_ex2_slide3_content": "トレイトを自動実装するderiveを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex6_title": "fold で畳み込み",
    "rust_lesson3_ex9_slide3_content": "Vecに要素を追加しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex4_slide1_content": "# 関係あるデータをまとめる「設計図」\n\n構造体（struct） は、いくつかのデータをひとまとめにdo仕組みです。\n\nFor example「点（座標）」のデータ：\n- x座標\n- y座標\n\nこの2つは関係があるので、「Point（点）」としてまとめると便利です。\n\nFor example「人」のデータ：\n- 名前\n- 年齢\n\nこれも「Person（人）」としてまとめられます。\n\n構造体は「こういうデータを持つ」という設計図です。",
    "rust_lesson4_ex1_slide1_title": "トレイト?（復習）",
    "rust_lesson2_ex3_description": "reference先のvalueを変更できる「可変reference」を学びましょう。",
    "rust_lesson2_ex7_slide2_content": "# match で安全に取り出す\n\n`match` を使って「ある場合」と「ない場合」で処理を分けます。\n\ncodeExample：\n```rust\nlet x: Option<i32> = Some(5);  // 値あり\n\nmatch x {\n    Some(n) => println!(\"値は{}です\", n),  // 5\n    None => println!(\"値がありません\"),\n}\n```\n\nなぜ安全？\n- `null` のように「あるつもりでアクセスしたら無かった」errorが起きない\n- 「ない場合」の処理を書かないとコンパイルerrorになる\n- 強制的に両方のケースを考えることになる！",
    "rust_lesson4_ex9_comment1": "collect で Vec に変換",
    "rust_lesson3_ex10_title": "String と &str",
    "rust_lesson2_ex7_slide1_title": "Option（オプション）?",
    "rust_lesson3_ex9_description": "Vecにelementを追加しましょう。",
    "rust_lesson2_ex5_comment1": "impl でmethodをimplementation",
    "rust_lesson3_ex1_slide3_content": "参照の有効期間を表すライフタイムを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex6_slide2_content": "複数の条件を組み合わせる「&&（かつ）」と「||（または）」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex5_comment1": "filter で条件に合うelementを絞り込む",
    "rust_lesson2_ex7_slide3_content": "値があるかないかを表す「Option」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex10_slide3_title": "Let's Try It!",
    "rust_lesson4_ex4_slide3_title": "Let's Try It!",
    "rust_lesson3_ex3_comment1": "iter でiteratorを取得",
    "rust_lesson3_ex6_slide3_content": "要素を1つの値にまとめるfoldを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex7_slide2_title": "ベクタの番号は「0」から！",
    "rust_lesson1_ex5_slide1_title": "conditional（じょうけんぶんき）?",
    "rust_lesson1_ex3_description": "割り算の「あまり」を求める「%」（パーセント）operatorを学びましょう。",
    "rust_lesson1_ex1_slide3_content": "Rustを使って画面に文字を表示してみましょう。println! という特別な関数を使います。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex10_slide2_content": "# <T> でtypeを「あとで決める」\n\nfunction名の後に `<T>` をつけて、`T` を「type」としてuse。\n\ncodeExample：\n```rust\n// Tはどんな型でもOK\nfn first<T>(arr: &[T]) -> &T {\n    &arr[0]  // 最初の要素を返す\n}\n\n// 使い方\nfirst(&[1, 2, 3]);         // Tはi32\nfirst(&[\"a\", \"b\", \"c\"]);   // Tは&str\n```\n\n読み方：\n- `<T>` → 「Tという名前のtypeをuseよ」\n- `T` は慣習で「Type（type）」の頭文字\n- 複数のtypeが必要なら `<T, U>` のようにwrite",
    "rust_lesson3_ex2_comment1": "|x| でclosureのargumentをdefinition",
    "rust_lesson3_ex3_description": "elementを順番に処理doiteratorを学びましょう。",
    "rust_lesson1_ex1_slide3_title": "Let's Try It!",
    "rust_lesson2_ex6_slide2_title": "enum のdefinition",
    "rust_lesson2_ex1_title": "所有権のBasic",
    "rust_lesson4_ex3_slide1_title": "Box（ボックス）?",
    "rust_lesson2_ex1_slide3_content": "Rust独自の概念「所有権」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex8_slide3_content": "Option/Resultのデフォルト値を設定しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex7_slide2_title": "使用Example",
    "rust_lesson4_ex10_description": "iteratorにindexを付けましょう。",
    "rust_lesson4_ex9_slide1_title": "collect ?",
    "rust_lesson4_ex10_slide2_content": "# 「何番目か」が必要なとき\n\n番号（index）とelementの両方が必要なときに便利です。\n\ncodeExample：\n```rust\nlet v = vec![10, 20, 30];\nfor (idx, val) in v.iter().enumerate() {\n    println!(\"{}番目の値は{}\", idx, val);\n}\n// 0番目の値は10\n// 1番目の値は20\n// 2番目の値は30\n```\n\nPoint：\n- `(i, x)` でtuple（2つのset）を受け取る\n- `i` にindex、`x` にelementが入る\n- indexは0から始まる",
    "rust_lesson3_ex2_description": "周囲のvariableを使えるanonymous function「closure」を学びましょう。",
    "rust_lesson1_ex4_comment1": "mut で変更可能にdo",
    "rust_lesson1_ex8_slide3_title": "Let's Try It!",
    "rust_lesson1_ex3_slide2_content": "割り算の「あまり」を求める「%」（パーセント）演算子を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex9_slide3_title": "Let's Try It!",
    "rust_lesson3_ex3_title": "iteratorのBasic",
    "rust_lesson3_ex9_title": "Vec のmethod push",
    "rust_lesson1_ex8_comment1": "dictionaryをcreate（keyは'みかん'、valueは'オレンジ'）",
    "rust_lesson1_ex2_comment3": "+ でたし算do",
    "rust_lesson4_ex8_slide2_content": "# ジェネリクスの代わり\n\n```rust\nfn print_all(iter: impl Iterator<Item = i32>) {\n    for x in iter {\n        println!(\"{}\", x);\n    }\n}\n```",
    "rust_lesson2_ex2_slide2_title": "reference Usage",
    "rust_lesson1_ex8_slide3_content": "「辞書（HashMap）」を使うと、名前をつけてデータを保存し、その名前で取り出せます。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex7_slide2_content": "# [ ]で番号を指定して取り出す\n\n`[番号]` で何番目のデータか指定して取り出せます。\n\nImportantなルール：番号は「0」から！\n- 1番目 → `[0]`\n- 2番目 → `[1]`\n- 3番目 → `[2]`\n\ncodeExample：\n```rust\nlet fruits = vec![\"りんご\", \"バナナ\", \"みかん\"];\n//                  ↑0番    ↑1番     ↑2番\nprintln!(\"{}\", fruits[0]);  // りんご\nprintln!(\"{}\", fruits[1]);  // バナナ\n```\n\nプログラミングでは「0から数える」のが世界共通のルールです！",
    "rust_lesson1_ex6_slide1_title": "条件を組み合わせる",
    "rust_lesson2_ex10_slide2_title": "ジェネリックfunction Syntax",
    "rust_lesson1_ex6_description": "複数の条件を組み合わせる「&&（かつ）」と「||（Alsoは）」を学びましょう。",
    "rust_lesson4_ex6_title": "HashSet",
    "rust_lesson2_ex3_slide2_content": "# mut が2か所に必要\n\n変更できるようにdoには、variableとreferenceの両方に `mut` が必要です。\n\ncodeExample：\n```rust\n// 1. 変数を mut で作る\nlet mut s = String::from(\"hello\");\n\n// 2. &mut で可変参照を渡す\nchange(&mut s);\n\nfn change(s: &mut String) {\n    s.push_str(\" world\");  // 変更できる！\n}\n```\n\nPoint：\n- `let mut 変数` でvariableを変更可能に\n- `&mut 変数` で可変referenceをcreate\n- 両方ないと変更できない！",
    "rust_lesson2_ex2_slide1_title": "reference（さんしょう）?",
    "rust_lesson3_ex6_slide2_content": "# 合計、積、結合など\n\n```rust\n// 積\nv.iter().fold(1, |acc, x| acc * x)\n\n// 文字列結合\nwords.iter().fold(String::new(), |acc, s| acc + s)\n```",
    "rust_lesson1_ex1_description": "Rustを使ってscreenに文字をdisplayしてみましょう。println! という特別なfunctionをuse。",
    "rust_lesson3_ex8_slide3_title": "Let's Try It!",
    "rust_lesson4_ex6_description": "一意なvalueのsetを管理しましょう。",
    "rust_lesson2_ex5_slide1_title": "impl ?",
    "rust_lesson1_ex8_title": "名前で引き出す「dictionary」",
    "rust_lesson2_ex7_description": "valueがあるかないかを表す「Option」を学びましょう。",
    "rust_lesson1_ex4_slide2_title": "Let's Try It!",
    "rust_lesson1_ex7_title": "たくさんのデータをまとめましょう「ベクタ」",
    "rust_lesson3_ex7_slide1_content": "# errorの早期リターン\n\n? は、Resultが Err の場合に早期リターンします。\n\n```rust\nfn read_file() -> Result<String, io::Error> {\n    let content = fs::read_to_string(\"file.txt\")?;\n    Ok(content)\n}\n```",
    "rust_lesson3_ex9_slide1_content": "# 末尾に追加\n\npush は、Vecの末尾にelementをadd。\n\n```rust\nlet mut v = vec![1, 2];\nv.push(3);\n// [1, 2, 3]\n```",
    "rust_lesson4_ex8_slide3_content": "トレイトを返す関数を簡潔に書きましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex1_title": "screenにメッセージを出しましょう",
    "rust_lesson2_ex8_slide2_title": "Result  Usage",
    "rust_lesson3_ex2_slide1_title": "closure?",
    "rust_lesson3_ex8_title": "unwrap_or でデフォルトvalue",
    "rust_lesson4_ex10_slide1_content": "# 番号とelementを一緒にもらう\n\nenumerate は、「何番目か」と「そのelement」をsetで取り出せるmethodです。\n\nFor example：\n- 0番目: りんご\n- 1番目: バナナ\n- 2番目: みかん\n\ncodeExample：\n```rust\nfor (i, x) in vec![\"a\", \"b\", \"c\"].iter().enumerate() {\n    println!(\"{}: {}\", i, x);\n}\n// 0: a\n// 1: b\n// 2: c\n```",
    "rust_lesson1_ex7_slide1_content": "# データを並べてまとめる「長い箱」\n\nベクタ（Vec） は、たくさんのデータを順番に並べて入れられる「長い箱」です。\n\nFor example：\n- 買い物listの商品を全部まとめる\n- testの点数を全部まとめる\n- 友だちの名前を全部まとめる\n\n100個でも1000個でも、1つのvariableでまとめて管理できます！\n\n作り方：\n```rust\nlet fruits = vec![\"りんご\", \"バナナ\", \"みかん\"];\n// vec! で ベクタを作る\n```",
    "rust_lesson4_ex8_slide3_title": "Let's Try It!",
    "rust_lesson4_ex7_description": "パターンマッチに条件を追加しましょう。",
    "rust_lesson1_ex4_comment2": "+= で 20 を足す",
    "rust_lesson1_ex2_comment2": "y に 5 を入れる",
    "rust_lesson2_ex3_slide3_title": "Let's Try It!",
    "rust_lesson3_ex4_slide1_title": "map（map）?",
    "rust_lesson1_ex2_slide3_content": "データに名前をつけて保存できる「変数（へんすう）」を使ってみましょう。letで変数を作ります。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex8_slide2_content": "# match で成功と失敗を分ける\n\n`match` で「成功したら」「失敗したら」の処理を書き分けます。\n\ncodeExample：\n```rust\nfn divide(a: i32, b: i32) -> Result<i32, String> {\n    if b == 0 {\n        return Err(\"0で割れません\".to_string());\n    }\n    Ok(a / b)  // 成功なら答えを返す\n}\n\nmatch divide(10, 2) {\n    Ok(v) => println!(\"答えは{}\", v),\n    Err(e) => println!(\"エラー: {}\", e),\n}\n```\n\nPoint：\n- `Ok(値)` で成功をreturn\n- `Err(エラー)` で失敗をreturn",
    "rust_lesson4_ex3_comment1": "Box::new でheapに格納",
    "rust_lesson4_ex8_description": "トレイトをreturnfunctionを簡潔に書きましょう。",
    "rust_lesson2_ex10_description": "typeを後から決められる「ジェネリクス」を学びましょう。",
    "rust_lesson2_ex3_slide1_title": "可変reference（かへんさんしょう）?",
    "rust_lesson2_ex2_description": "所有権を移さずにvalueを借りる「reference」を学びましょう。",
    "rust_lesson3_ex5_slide2_title": "** にNote！",
    "rust_lesson2_ex2_slide3_title": "Let's Try It!",
    "rust_lesson4_ex3_slide3_content": "ヒープにデータを格納するBoxを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex4_title": "累算assignmentoperator（+=、-=）",
    "rust_lesson3_ex3_slide2_content": "# 借りるか、もらうか\n\n3種類の iter があり、所有権の扱いが違います。\n\n3つの違い：\n```rust\nv.iter()       // 参照で借りる（&T）\nv.iter_mut()   // 変更可能で借りる（&mut T）\nv.into_iter()  // 所有権をもらう（T）\n```\n\n使い分け：\n- `iter()` → 見るだけ（元のベクタも使える）\n- `iter_mut()` → 中身を変更したい\n- `into_iter()` → ベクタごともらう（元は使えない）\n\n普通は `iter()` をuseことが多いです。",
    "rust_lesson2_ex1_slide1_title": "所有権（しょゆうけん）?",
    "rust_lesson4_ex6_slide3_content": "一意な値の集合を管理しましょう。\n\n（When you're ready, select \"Start Lesson\".）"
  },
  "pt": {
    "rust_lesson1_course_title": "Introduction to Rust",
    "rust_lesson1_course_description": "Learn the basics of Rust programming.",
    "rust_lesson2_course_title": "Rust II - Intermediate",
    "rust_lesson2_course_description": "Learn intermediate Rust concepts.",
    "rust_lesson3_course_title": "Rust III - Advanced",
    "rust_lesson3_course_description": "Master advanced Rust techniques.",
    "rust_lesson4_course_title": "Rust IV - Expert Level",
    "rust_lesson4_course_description": "Expert-level Rust programming.",
    "rust_lesson1_ex5_slide2_content": "条件によって動きを変える if文を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex9_title": "collect で変換",
    "rust_lesson2_ex7_slide1_content": "# 「あるかもしれない、ないかもしれない」\n\nOption<T> は、valueが「あるかもしれないし、ないかもしれない」ことを表すtypeです。\n\nFor example：\n- dictionaryで単語を探す → 見つかるかもしれないし、ないかもしれない\n- ゲームでアイテムを拾う → 落ちてるかもしれないし、ないかもしれない\n\n2つの状態：\n- `Some(値)` → valueがある！\n- `None` → valueがない...\n\n他の言語では `null` をuseが、Rustでは `Option` で安全に扱います。",
    "rust_lesson1_ex2_slide1_title": "variable（へんすう）?",
    "rust_lesson1_ex7_description": "「ベクタ（Vec）」をuseと、たくさんのデータを一つの「長い はこ」にまとめて入れられます。",
    "rust_lesson2_ex9_slide2_content": "# 約束を作って、守る\n\n1. `trait` で「約束」をdefinition\n2. `impl トレイト for 型` で「約束を守る」implementationをdo\n\ncodeExample：\n```rust\n// 1. トレイト（約束）を定義\ntrait Speak {\n    fn speak(&self);  // 鳴くメソッドを持つ約束\n}\n\n// 2. Dog構造体がトレイトを実装\nstruct Dog;\nimpl Speak for Dog {\n    fn speak(&self) {\n        println!(\"woof\");\n    }\n}\n```\n\n「DogはSpeakができる」ということになります。",
    "rust_lesson4_ex4_description": "referenceカウントでデータを共有しましょう。",
    "rust_lesson4_ex5_slide1_content": "# 名前で引ける「dictionary」\n\nHashMap は、「key（名前）」と「value（データ）」をsetで保存dodictionaryです。\n\nFor example：\n- 「青チーム」→ 10点\n- 「赤チーム」→ 15点\n\ncodeExample：\n```rust\nuse std::collections::HashMap;\n\nlet mut scores = HashMap::new();\nscores.insert(\"Blue\", 10);   // 追加\nscores.insert(\"Red\", 15);    // 追加\n```\n\n`use` で機能を読み込んでからuse。",
    "rust_lesson3_ex4_title": "map でiterator変換",
    "rust_lesson4_ex1_slide3_content": "共通の振る舞いを定義するトレイトを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex4_description": "variableのvalueを手軽に増やしたり減らしたりdo「+=」「-=」を学びましょう。",
    "rust_lesson1_ex2_description": "データに名前をつけて保存できる「variable（へんすう）」を使ってみましょう。letでvariableをcreate。",
    "rust_lesson4_ex4_slide2_title": "referenceカウントの仕組み",
    "rust_lesson3_ex8_slide2_title": "unwrap_or_else",
    "rust_lesson4_ex10_comment1": "1番目の i にindex、2番目の item にelementが入る",
    "rust_lesson3_ex6_slide1_content": "# 累積処理\n\nfold は、初期valueとfunctionでelementを1つずつ畳み込みます。\n\n```rust\nlet v = vec![1, 2, 3];\nlet sum = v.iter().fold(0, |acc, x| acc + x);\n// 6\n```",
    "rust_lesson4_ex2_slide2_title": "よくuse derive トレイト",
    "rust_lesson3_ex10_slide3_content": "文字列型の違いを理解しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex4_slide2_content": "変数の値を手軽に増やしたり減らしたりする「+=」「-=」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex4_slide3_title": "Let's Try It!",
    "rust_lesson3_ex5_slide1_title": "filter（filterー）?",
    "rust_lesson4_ex5_description": "keyとvalueのpairを格納しましょう。",
    "rust_lesson3_ex5_description": "条件に合うelementだけを取り出しましょう。",
    "rust_lesson2_ex2_slide2_content": "# functionに借りてもらう\n\nfunctionにデータを渡すとき、`&` をつけると「借りる」形になります。元のvariableはそのまま使い続けられます。\n\ncodeExample：\n```rust\nfn calc_len(s: &String) -> usize {\n    s.len()  // 長さを返す\n}\n\nfn main() {\n    let text = String::from(\"hello\");\n    let len = calc_len(&text);  // textを貸す\n    // text はまだ使える！\n    println!(\"{}の長さは{}\", text, len);\n}\n```\n\n`&String` は「Stringを借りる」という意味です。",
    "rust_lesson4_ex7_slide3_content": "パターンマッチに条件を追加しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex8_slide2_content": "# 遅延評価\n\n```rust\n// クロージャで計算\nlet value = x.unwrap_or_else(|| expensive_computation());\n```",
    "rust_lesson4_ex7_title": "match ガード",
    "rust_lesson3_ex7_title": "? operatorでerror伝播",
    "rust_lesson4_ex1_description": "共通の振る舞いをdefineトレイトを学びましょう。",
    "rust_lesson2_ex1_slide2_content": "# 所有権は「移動」do\n\nvariableを別のvariableにassignmentdoと、所有権が 移動（ムーブ） します。元のvariableは使えなくなります。\n\ncodeExample：\n```rust\nlet s1 = String::from(\"hello\");  // s1 が持ち主\nlet s2 = s1;  // 所有権が s2 に移動！\n// ↓ s1 はもう使えない（エラーになる）\n// println!(\"{}\", s1);  // ダメ！\nprintln!(\"{}\", s2);  // OK！\n```\n\nイメージ：\nおもちゃを友だちにあげたら、自分はもう使えない。これがムーブです。",
    "rust_lesson1_ex8_slide1_title": "dictionary（HashMap）?",
    "rust_lesson4_ex3_slide2_content": "# サイズが決まらないとき\n\nBoxは、コンパイル時にサイズがわからないtypeにuse。\n\nFor examplerecursion的なtype：\n```rust\n// リストは「値 + 次のリスト」の繰り返し\nenum List {\n    Cons(i32, Box<List>),  // Boxで次を指す\n    Nil,                   // 終わり\n}\n```\n\nなぜBoxが必要？\n- `List` の中に `List` がある → 無限に大きくなる？\n- `Box` をuseと、サイズが固定（pointerのサイズ）になる\n\n「中身」ではなく「中身への矢印」を持つイメージです。",
    "rust_lesson2_ex10_title": "ジェネリクスを使おう",
    "rust_lesson2_ex8_slide3_title": "Let's Try It!",
    "rust_lesson3_ex9_slide2_content": "# 可変reference\n\n```rust\n// mut が必要\nlet mut v = Vec::new();\nv.push(1);\nv.push(2);\n```",
    "rust_lesson4_ex4_title": "Rc<T>",
    "rust_lesson2_ex3_comment1": "mut で可変variableにdo",
    "rust_lesson4_ex5_slide3_title": "Let's Try It!",
    "rust_lesson2_ex6_slide2_content": "# バリアントを列挙\n\n`enum 名前 { バリアント1, バリアント2, ... }` でdefine。\n\ncodeExample：\n```rust\nenum Color {\n    Red,\n    Green,\n    Blue,\n}\nlet c = Color::Red;\n```",
    "rust_lesson1_ex1_comment1": "Hello, Rust! とdisplay",
    "rust_lesson1_ex1_slide1_content": "# 安全で速い！最新のプログラミング言語\n\nRust（ラスト）は、「間違いを事前に防ぐ」ことがとても得意なプログラミング言語です。\n\nRustのすごいところ：\n- programのミスをexecute前に見つけてくれる\n- とても速く動く\n- 世界中のプログラマーが「一番好き！」と選ぶ人気の言語\n\nたとえるなら：\n厳しいけど優しい先生のような言語です。「ここ間違ってるよ」と教えてくれるので、安心してprogramが書けます！",
    "rust_lesson3_ex8_slide1_content": "# None/Err の場合のデフォルト\n\nunwrap_or は、None や Err の場合にデフォルトvalueをreturn。\n\n```rust\nlet x: Option<i32> = None;\nlet value = x.unwrap_or(0);  // 0\n```",
    "rust_lesson2_ex7_slide3_title": "Let's Try It!",
    "rust_lesson2_ex6_title": "enum で状態を表す",
    "rust_lesson2_ex8_slide1_content": "# 「成功」か「失敗」かを表す\n\nResult<T, E> は、処理が「成功したか失敗したか」を表すtypeです。\n\nFor example：\n- fileをopen → 成功（内容）か失敗（error）\n- 0で割り算 → 成功（答え）か失敗（0で割れない！）\n\n2つの状態：\n- `Ok(値)` → 成功！valueが入っている\n- `Err(エラー)` → 失敗...error情報が入っている\n\n`Option` は「あるか・ないか」、`Result` は「成功か・失敗か」という違いです。",
    "rust_lesson2_ex8_slide3_content": "成功と失敗を表す「Result」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex6_slide1_title": "HashSet ?",
    "rust_lesson3_ex9_comment1": "push でelementを追加",
    "rust_lesson2_ex7_slide2_title": "Option  Usage",
    "rust_lesson3_ex2_title": "closureのBasic",
    "rust_lesson3_ex7_slide1_title": "? operator?",
    "rust_lesson4_ex6_comment1": "HashSet をimport",
    "rust_lesson2_ex10_slide1_content": "# どんなtypeでも使える「万能」の仕組み\n\nジェネリクス は、typeを後から決められる仕組みです。\n\nなぜ便利？\n同じようなfunctionを何度も書かなくてすみます。\n\nFor example：\n- 数字のarrayの最初のelementを取るfunction\n- stringのarrayの最初のelementを取るfunction\n\n両方とも「最初のelementを取る」のは同じなのに、typeが違うだけで別のfunctionをwriteのは大変！\n\nジェネリクスなら、`<T>` で「typeは後で決める」とwriteだけで、どんなtypeでも使えるfunctionが作れます。",
    "rust_lesson1_ex3_slide1_content": "# 剰余operator（じょうよえんざんし）「%」\n\n`%`（パーセント）は、割り算の 「あまり」 をcalculate特別な記号です。\n\nわかりやすいExample：\n- 10このアメを3人で分けると？\n- 1人3こずつで、1こあまる\n- これを `10 % 3` とwriteと、答えは `1`\n\ncodeExample：\n```rust\nprintln!(\"{}\", 10 % 3);  // 1（あまり1）\nprintln!(\"{}\", 8 % 4);   // 0（あまりなし＝割り切れる）\n```\n\n使いどころ：\n- 偶数か奇数か調べる（`n % 2` が0なら偶数）\n- 時計の計算（24を超えたら0に戻る、など）",
    "rust_lesson3_ex7_description": "errorを簡潔に伝播させましょう。",
    "rust_lesson3_ex8_comment1": "unwrap_or でデフォルトvalueを設定",
    "rust_lesson2_ex8_title": "Result<T, E> でerror処理",
    "rust_lesson2_ex10_comment1": "T をtypeパラメータとしてuse",
    "rust_lesson2_ex6_comment1": "enum で列挙typeをdefinition",
    "rust_lesson3_ex3_slide3_content": "要素を順番に処理するイテレータを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex2_comment1": "derive でトレイトを自動implementation",
    "rust_lesson1_ex8_slide1_content": "# 名前でsearchできる「dictionary」\n\nHashMap（ハッシュmap）は、「名前」と「データ」をsetにして保存できる仕組みです。本物のdictionaryのように使えます。\n\nFor example果物の色dictionary：\n- 「りんご」→「あか」\n- 「バナナ」→「きいろ」\n- 「みかん」→「オレンジ」\n\nuse準備：\n```rust\nuse std::collections::HashMap;  // 機能を読み込む\nlet mut fruits = HashMap::new();  // 空の辞書を作る\nfruits.insert(\"りんご\", \"あか\");  // データを追加\n```\n\n`use` は「この機能をuseよ」というdeclarationです。",
    "rust_lesson3_ex9_slide1_title": "push ?",
    "rust_lesson4_ex1_title": "トレイトのdefinition",
    "rust_lesson4_ex3_description": "heapにデータを格納doBoxを学びましょう。",
    "rust_lesson1_ex2_title": "便利な「はこ」variable（へんすう）",
    "rust_lesson1_ex8_comment2": "中身を出す",
    "rust_lesson3_ex9_slide3_title": "Let's Try It!",
    "rust_lesson1_ex4_comment3": "-= で 50 を引く",
    "rust_lesson1_ex6_comment1": "&& で両方の条件をチェック",
    "rust_lesson4_ex1_slide2_title": "トレイトのimplementation",
    "rust_lesson4_ex7_slide3_title": "Let's Try It!",
    "rust_lesson4_title": "Rust IV - トレイトとスマートpointer",
    "rust_lesson4_ex1_comment1": "trait でトレイトをdefinition",
    "rust_lesson4_ex4_slide1_content": "# 複数の「持ち主」を許可do仕組み\n\nRc<T> は「Reference Counted（referenceカウント）」の略で、複数の所有者でデータを共有できます。\n\n普通の所有権：\n1人だけが持ち主。渡したら元の人は使えない。\n\nRc をuseと：\n複数人が同じデータの「持ち主」になれる！\n\ncodeExample：\n```rust\nuse std::rc::Rc;\n\nlet a = Rc::new(5);       // Rcでラップ\nlet b = Rc::clone(&a);    // bも持ち主になる\n// a も b も使える！\n```",
    "rust_lesson3_ex5_slide1_content": "# 条件に合うものだけ残す\n\nfilter は、条件を満たすelementだけを残し、他を捨てます。\n\nFor example：\n- 80点以上の人だけ残す\n- 偶数だけ残す\n- 「あ」から始まる名前だけ残す\n\ncodeExample：\n```rust\nlet v = vec![1, 2, 3, 4, 5];\nlet evens: Vec<_> = v.iter()\n    .filter(|x| **x % 2 == 0)  // 偶数だけ\n    .collect();\n// [2, 4]\n```\n\n条件が `true` のelementだけが残ります。",
    "rust_lesson3_ex7_slide3_title": "Let's Try It!",
    "rust_lesson1_ex7_comment2": "2番目のデータ（1番）を出す",
    "rust_lesson4_ex8_title": "impl Trait",
    "rust_lesson1_ex5_description": "条件によって動きを変える if文を学びましょう。",
    "rust_lesson3_ex4_slide2_title": "遅延評価（ちえんひょうか）",
    "rust_lesson3_ex1_slide1_content": "# referenceの「寿命」を示す印\n\nライフタイム は、referenceがいつまで使えるかを示す印です。`'a`（アポストロフィ・エー）のようにwrite。\n\nなぜ必要？\nreferenceは「借りている」状態。借りた元のデータが消えたら、referenceも使えなくなります。\n\nFor example：\n- 図書館で借りた本 → 図書館が閉まったら読めない\n- referenceで借りたデータ → 元のデータが消えたら使えない\n\nライフタイムは「このreferenceはこの範囲で有効だよ」とコンパイラに伝える仕組みです。",
    "rust_lesson1_ex1_slide1_title": "Rust（ラスト）?",
    "rust_lesson1_ex2_slide2_title": "計算の記号（operator）",
    "rust_lesson4_ex5_slide2_content": "# get で安全に取り出す\n\n`get()` methodでvalueを取り出せます。見つからない可能性があるので、`Option` が返ってきます。\n\ncodeExample：\n```rust\n// getはOption<&V>を返す\nif let Some(score) = scores.get(\"Blue\") {\n    println!(\"青チームは{}点\", score);\n}\n```\n\nPoint：\n- keyがあれば `Some(値)` が返る\n- keyがなければ `None` が返る\n- `if let` で安全に取り出せる\n\n存在しないkeyでアクセスしてもprogramが落ちない！",
    "rust_lesson4_ex7_slide1_title": "match ガード?",
    "rust_lesson3_title": "Rust III - ライフタイムとiterator",
    "rust_lesson4_ex3_title": "Box<T>",
    "rust_lesson1_ex4_slide1_title": "累算assignmentoperator（るいさんだいにゅう）?",
    "rust_lesson2_ex9_comment1": "trait でトレイトをdefinition",
    "rust_lesson2_ex1_description": "Rust独自の概念「所有権」を学びましょう。",
    "rust_lesson2_ex3_slide3_content": "参照先の値を変更できる「可変参照」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex1_slide3_title": "Let's Try It!",
    "rust_lesson3_ex6_slide2_title": "様々な畳み込み",
    "rust_lesson4_ex9_slide3_title": "Let's Try It!",
    "rust_lesson2_ex5_title": "impl でmethodを追加",
    "rust_lesson2_ex6_slide1_content": "# 複数の選択肢\n\nenum は、valueがいくつかの種類のうちの一つであることを表します。各バリアントにデータを持たせることもできます。",
    "rust_lesson2_ex4_comment1": "struct で構造体をdefinition",
    "rust_lesson1_ex3_title": "剰余operator（%）",
    "rust_lesson1_ex7_comment1": "colors というベクタをcreate（'あか', 'あお'の順）",
    "rust_lesson1_ex4_slide1_content": "# valueをかんたんに増やす・減らす\n\n`+=`（プラスイコール）と `-=`（マイナスイコール）は、variableの中身を増やしたり減らしたりdo便利な記号です。\n\nRustのImportantなルール：`mut`が必要！\nRustでは、variableをchangeには `let mut`（レット ミュート）とwrite必要があります。`mut` は「mutable（変更できる）」の略です。\n\ncodeExample：\n```rust\nlet mut score = 100;  // mut をつけて変更可能に\nscore += 10;          // 10を足す → 110に\nscore -= 50;          // 50を引く → 60に\n```\n\n`mut` がないと「このvariableは変えちゃダメ！」とRustが怒ります。",
    "rust_lesson2_ex1_slide2_title": "ムーブ（移動）",
    "rust_lesson3_ex4_comment1": "map で各elementを変換",
    "rust_lesson3_ex8_slide1_title": "unwrap_or ?",
    "rust_lesson2_ex5_slide1_content": "# implementationブロック\n\nimpl ブロックで、構造体にmethodを追加できます。`self` で自分自身をreferenceします。",
    "rust_lesson2_ex10_slide1_title": "ジェネリクス?",
    "rust_lesson1_ex8_slide2_content": "# 名前（key）で取り出す\n\ndictionaryに入れたデータは、名前（key）を指定して取り出せます。\n\ncodeExample：\n```rust\nuse std::collections::HashMap;\nfn main() {\n    let mut fruits = HashMap::new();\n    fruits.insert(\"りんご\", \"あか\");  // 追加\n    fruits.insert(\"バナナ\", \"きいろ\");  // 追加\n    \n    println!(\"{}\", fruits[\"りんご\"]);  // あか と表示\n}\n```\n\nPoint：\n- `insert(名前, データ)` で追加\n- `辞書[名前]` で取り出し\n- 番号ではなく「名前」で探せるのが便利！",
    "rust_lesson4_ex9_slide1_content": "# iteratorをコレクションに\n\ncollect は、iteratorをVecやHashMapなどに変換します。\n\n```rust\nlet v: Vec<_> = (0..5).collect();\nlet s: String = vec!['a', 'b'].into_iter().collect();\n```",
    "rust_lesson2_ex2_slide3_content": "所有権を移さずに値を借りる「参照」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex2_slide3_content": "周囲の変数を使える無名関数「クロージャ」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex4_slide2_content": "# struct keyワードでdefinition\n\n`struct 名前 { フィールド }` で構造体をdefine。フィールドには名前とtypeをwrite。\n\ncodeExample：\n```rust\n// Point 構造体を定義\nstruct Point {\n    x: i32,  // xフィールド（整数）\n    y: i32,  // yフィールド（整数）\n}\n\n// 使い方\nlet p = Point { x: 10, y: 20 };\nprintln!(\"x={}, y={}\", p.x, p.y);\n```\n\nPoint：\n- `struct 名前` で構造体をcreate\n- `{ フィールド名: 型 }` でどんなデータを持つか決める\n- `.フィールド名` でアクセス",
    "rust_lesson2_ex10_slide3_content": "型を後から決められる「ジェネリクス」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex6_slide3_title": "Let's Try It!",
    "rust_lesson4_ex6_slide1_content": "# 一意なvalueのset\n\nHashSet は、重複のないvalueのsetです。\n\n```rust\nuse std::collections::HashSet;\n\nlet mut set = HashSet::new();\nset.insert(1);\nset.insert(2);\nset.insert(1); // 重複は無視\n```",
    "rust_lesson4_ex2_title": "derive 属性",
    "rust_lesson4_ex2_slide1_content": "# トレイトを「自動で」implementation\n\n#[derive(...)] をuseと、よくuseトレイトを自分で書かなくても自動でimplementationしてくれます。\n\nFor example：\n構造体を `println!` でdisplayしたいとき、普通は Display トレイトをimplementationdo必要がありますが、`#[derive(Debug)]` をwriteだけでOK！\n\ncodeExample：\n```rust\n#[derive(Debug)]  // Debug トレイトを自動実装\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nlet p = Point { x: 1, y: 2 };\nprintln!(\"{:?}\", p);  // Point { x: 1, y: 2 }\n```",
    "rust_lesson1_ex6_slide2_title": "Let's Try It!",
    "rust_lesson3_ex3_slide2_title": "3つの iter method",
    "rust_lesson4_ex7_slide2_content": "# 複雑なconditional\n\n```rust\nmatch Some(5) {\n    Some(x) if x % 2 == 0 => println!(\"even\"),\n    Some(x) => println!(\"odd: {}\", x),\n    None => println!(\"none\"),\n}\n```",
    "rust_lesson3_ex3_slide1_content": "# elementを1つずつ取り出す仕組み\n\niterator は、ベクタなどのデータを「1つずつ順番に」取り出す仕組みです。\n\nFor example：\n- 行列に並んでいる人を1人ずつ呼ぶ\n- 引き出しの中身を1つずつ出す\n\ncodeExample：\n```rust\nlet v = vec![1, 2, 3];\nfor x in v.iter() {\n    println!(\"{}\", x);  // 1, 2, 3 と順番に表示\n}\n```\n\n`iter()` で「順番に取り出す準備」をして、`for` で1つずつ処理します。",
    "rust_lesson3_ex3_slide1_title": "iterator?",
    "rust_lesson4_ex2_description": "トレイトを自動implementationdoderiveを学びましょう。",
    "rust_lesson3_ex4_slide1_content": "# 全部を同じように変換do\n\n**map** は、iteratorの各elementを「同じ方法で」変換します。\n\nFor example：\n- 全員の身長を2倍にdo\n- 全員の名前を大文字にdo\n- 全部の数を2乗do\n\ncodeExample：\n```rust\nlet v = vec![1, 2, 3];\nlet doubled: Vec<_> = v.iter()\n    .map(|x| x * 2)  // 各要素を2倍に\n    .collect();      // ベクタに戻す\n// [2, 4, 6]\n```\n\n`|x| x * 2` は「xを受け取って、x*2をreturn」closureです。",
    "rust_lesson1_ex3_slide1_title": "あまりを求める",
    "rust_lesson3_ex10_slide1_content": "# 所有権の違い\n\nString は所有権を持つheap上のstring、&str はreferenceです。\n\n```rust\nlet s1: String = String::from(\"hello\");\nlet s2: &str = \"hello\";\n```",
    "rust_lesson4_ex2_slide1_title": "derive（デライブ）?",
    "rust_lesson2_ex2_comment1": "& でreferenceを渡す",
    "rust_lesson4_ex5_slide1_title": "HashMap（ハッシュmap）?",
    "rust_lesson2_ex3_slide2_title": "&mut  Usage",
    "rust_lesson3_ex5_title": "filter で絞り込み",
    "rust_lesson4_ex3_slide2_title": "いつuse？",
    "rust_lesson2_ex2_title": "referenceと借用",
    "rust_lesson2_ex7_title": "Option<T> で null を安全に",
    "rust_lesson4_ex10_slide3_title": "Let's Try It!",
    "rust_lesson3_ex5_slide3_title": "Let's Try It!",
    "rust_lesson4_ex10_title": "enumerate でindex付き",
    "rust_lesson2_ex2_slide1_content": "# 所有権を渡さずに「借りる」\n\nreference をuseと、所有権を移さずにデータを「見せてもらう」ことができます。\n\nたとえるなら：\n- ムーブ = おもちゃをあげる（自分は使えない）\n- reference = おもちゃを見せる（自分も使える）\n\n作り方：\n`&`（アンパサンド）をつけるとreferenceを作れます。\n\n```rust\nlet s = String::from(\"hello\");\nlet r = &s;  // sを借りる（見せてもらう）\n// s も r も使える！\n```",
    "rust_lesson2_ex5_slide2_content": "# &self をuse\n\nmethodの最初のargumentは `&self` です。\n\ncodeExample：\n```rust\nimpl Rect {\n    fn area(&self) -> i32 {\n        self.width * self.height\n    }\n}\n```",
    "rust_lesson1_ex5_slide2_title": "Let's Try It!",
    "rust_lesson2_ex4_slide3_title": "Let's Try It!",
    "rust_lesson4_ex3_slide3_title": "Let's Try It!",
    "rust_lesson2_ex9_slide3_content": "共通の振る舞いを定義する「トレイト」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex1_slide2_content": "# impl で約束を守る\n\n構造体にトレイトをimplementationdoと、その構造体は「約束を守る」ことになります。\n\ncodeExample：\n```rust\nstruct Person { name: String }\n\nimpl Greet for Person {\n    fn greet(&self) -> String {\n        format!(\"Hello, {}\", self.name)\n    }\n}\n```\n\n読み方：\n- `impl Greet for Person` → 「PersonはGreetをimplementationdo」\n- これでPersonは「あいさつできる」ようになった！",
    "rust_lesson4_ex4_comment1": "clone でreferenceカウントを増やす",
    "rust_lesson3_ex4_slide2_content": "# map だけではexecuteされない！\n\nRustのiteratorは 遅延評価 といって、「本当に必要になるまで処理しない」仕組みです。\n\nなぜ？\n無駄な計算を省けるから。100万件あっても、最初の10件だけ欲しいなら10件だけ処理すればいい。\n\ncollect() でexecute：\n```rust\n// これだけでは何も起きない\nv.iter().map(|x| x * 2);\n\n// collect() で実行してベクタに変換\nlet result: Vec<_> = v.iter().map(|x| x * 2).collect();\n```\n\n`collect()` は「今すぐ全部処理してResultをちょうだい」という意味です。",
    "rust_lesson2_ex4_slide2_title": "struct のdefinitionのしかた",
    "rust_lesson2_ex3_slide1_content": "# 「書き換えできる」借り方\n\n普通のreference `&` は「見るだけ」ですが、可変reference `&mut` は「変更もできる」借り方です。\n\nたとえるなら：\n- `&` = 本を見せてもらう（readだけ）\n- `&mut` = ノートを借りる（writeOK）\n\nImportantなルール：\n- 可変referenceは同時に1つだけ！\n- 「みんなで見る」か「1人でwrite」かのどちらか\n\nこのルールで、データが同時に書き換えられるバグを防いでいます。",
    "rust_lesson2_ex10_slide3_title": "Let's Try It!",
    "rust_lesson2_ex4_title": "構造体をdefinitionしよう",
    "rust_lesson3_ex10_slide2_content": "# 相互変換\n\n```rust\n// &str -> String\nlet s = \"hello\".to_string();\n\n// String -> &str\nlet slice: &str = &s;\n```",
    "rust_lesson4_ex10_slide3_content": "イテレータにインデックスを付けましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex4_slide2_content": "# 「何人が持っているか」を数える\n\nRcは「今何人がこのデータを持っているか」を数えています。\n\ncodeExample：\n```rust\nlet a = Rc::new(5);\nprintln!(\"{}\", Rc::strong_count(&a));  // 1\n\nlet b = Rc::clone(&a);\nprintln!(\"{}\", Rc::strong_count(&a));  // 2\n```\n\nいつデータが消える？\n- カウントが0になったとき（誰も持っていないとき）\n- 最後の持ち主がいなくなると自動で片付けられる\n\n`Rc::clone` は「持ち主を1人増やす」操作です。",
    "rust_lesson1_ex8_slide2_title": "dictionary Usage",
    "rust_lesson4_ex3_slide1_content": "# データを「heap」に置く箱\n\nBox<T> は、データを「heap」という特別な場所に置くための箱です。\n\nmemoryの2つの場所：\n- stack：小さくて速い。サイズが決まっているデータ向け\n- heap：大きくて柔軟。サイズが大きいor変わるデータ向け\n\ncodeExample：\n```rust\nlet b = Box::new(5);  // 5をヒープに置く\nprintln!(\"{}\", *b);   // *で中身を取り出す → 5\n```\n\n`*` は「箱を開けて中身を見る」操作です。",
    "rust_lesson3_ex2_slide2_title": "closure Syntax",
    "rust_lesson4_ex4_slide1_title": "Rc（アールシー）?",
    "rust_lesson4_ex7_slide1_content": "# 追加条件\n\n**if** でパターンに追加条件をつけられます。\n\n```rust\nmatch x {\n    n if n < 0 => println!(\"negative\"),\n    n if n > 0 => println!(\"positive\"),\n    _ => println!(\"zero\"),\n}\n```",
    "rust_lesson2_ex3_title": "可変reference",
    "rust_lesson3_ex10_comment1": "to_string で String に変換",
    "rust_lesson3_ex10_slide2_title": "変換",
    "rust_lesson3_ex1_description": "referenceの有効期間を表すライフタイムを学びましょう。",
    "rust_lesson3_ex2_slide1_content": "# 名前のない「即席」function\n\nclosure は、名前をつけずにその場でcreatefunctionです。そして特別な能力があります：周りのvariableを使えるのです！\n\nFor example：\n```rust\nlet x = 5;  // 外側の変数\nlet add_x = |n| n + x;  // xを使えるクロージャ\nprintln!(\"{}\", add_x(10));  // 15\n```\n\n普通のfunctionとの違い：\n- 普通のfunction：argumentしか使えない\n- closure：argument + 周りのvariableも使える\n\n「その場の空気を読める」functionというイメージです！",
    "rust_lesson1_ex2_comment1": "x に 10 を入れる",
    "rust_lesson1_ex7_slide3_title": "Let's Try It!",
    "rust_lesson1_ex5_title": "「もし〜なら」で分けましょう",
    "rust_lesson3_ex2_slide3_title": "Let's Try It!",
    "rust_lesson3_ex7_slide2_content": "# 簡潔なerror処理\n\n```rust\n// ? を使わない場合\nmatch result {\n    Ok(v) => v,\n    Err(e) => return Err(e),\n}\n\n// ? を使う\nresult?\n```",
    "rust_lesson3_ex6_slide3_title": "Let's Try It!",
    "rust_lesson4_ex9_slide3_content": "イテレータをコレクションに変換しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex6_description": "elementを1つのvalueにまとめるfoldを学びましょう。",
    "rust_lesson2_ex9_description": "共通の振る舞いをdefine「トレイト」を学びましょう。",
    "rust_lesson2_ex8_comment1": "Ok で成功をreturn",
    "rust_lesson3_ex5_slide2_content": "# filter はreferenceのreferenceを受け取る\n\n`filter` のclosureは、referenceのreference（`&&T`）を受け取ります。そのため、valueをuseには `**x` と2回referenceを外す必要があります。\n\nなぜ？\n- `iter()` はreference（`&T`）をreturn\n- `filter` はそれをFurthermorereferenceで渡す（`&&T`）\n\nSyntax：\n```rust\n// **x で値を取り出す\n.filter(|x| **x > 2)\n\n// または * を引数につける\n.filter(|&x| *x > 2)\n```\n\n最初は混乱しますが、慣れれば大丈夫！",
    "rust_lesson1_ex5_comment1": "> でcompare",
    "rust_lesson2_ex4_description": "関連doデータをまとめる「構造体」を学びましょう。",
    "rust_lesson3_ex5_slide3_content": "条件に合う要素だけを取り出しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex7_slide3_content": "「ベクタ（Vec）」を使うと、たくさんのデータを一つの「長い はこ」にまとめて入れられます。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex5_slide2_title": "valueの取得",
    "rust_lesson3_ex1_slide1_title": "ライフタイム?",
    "rust_lesson1_ex3_comment1": "10 を 3 で割ったあまりをoutput",
    "rust_lesson3_ex1_comment1": "'a でライフタイムをdefinition",
    "rust_lesson3_ex10_slide1_title": "String vs &str",
    "rust_lesson2_title": "Rust II - 所有権とトレイト",
    "rust_lesson2_ex5_slide2_title": "methodのdefinition",
    "rust_lesson4_ex5_comment1": "insert でkeyとvalueを追加",
    "rust_lesson2_ex9_slide1_content": "# 「できること」の約束\n\nトレイト は、「このtypeはこういうことができる」という約束をdefine。\n\nFor example「鳴ける」という約束：\n- 犬は「ワン」と鳴く\n- 猫は「ニャー」と鳴く\n- 両方とも「鳴ける」能力がある\n\nトレイトは「鳴ける動物は、鳴き声を出すmethodを持つ」という約束です。\n\n他の言語とのcomparison：\n- Java: interface\n- TypeScript: interface\n\nに似た概念です。",
    "rust_lesson1_ex2_slide3_title": "Let's Try It!",
    "rust_lesson4_ex8_slide1_content": "# return valueのtypeをabstract化\n\nimpl Trait で、トレイトをimplementationdotypeを返せます。\n\n```rust\nfn make_iter() -> impl Iterator<Item = i32> {\n    vec![1, 2, 3].into_iter()\n}\n```",
    "rust_lesson1_ex2_slide2_content": "# 四則演算（しそくえんざん）\n\nRustでも算数と同じ記号で計算ができます。\n\n4つのBasic記号：\n- +（プラス）: たし算\n- -（マイナス）: ひき算\n- \\*（アスタリスク）: かけ算（×の代わり）\n- /（スラッシュ）: わり算（÷の代わり）\n\ncodeExample：\n```rust\nlet a = 10;\nlet b = 5;\nprintln!(\"{}\", a + b);  // 15 と表示される\n```\n\n`println!` の `{}` は「ここにvalueを入れてね」という目印です。",
    "rust_lesson4_ex9_slide2_content": "# 変換先を指定\n\n```rust\n// ターボフィッシュ構文\nlet v = (0..5).collect::<Vec<_>>();\n\n// 変数の型注釈\nlet v: Vec<i32> = (0..5).collect();\n```",
    "rust_lesson1_ex8_description": "「dictionary（HashMap）」をuseと、名前をつけてデータを保存し、その名前で取り出せます。",
    "rust_lesson4_ex9_slide2_title": "typeHint",
    "rust_lesson3_ex1_title": "ライフタイムのBasic",
    "rust_lesson2_ex5_description": "構造体にmethodをadd「impl」を学びましょう。",
    "rust_lesson4_ex8_comment1": "impl でトレイトをimplementationdotypeをreturn",
    "rust_lesson4_ex8_slide2_title": "argumentにも使える",
    "rust_lesson4_ex7_comment1": "if でマッチガードを追加",
    "rust_lesson2_ex9_slide2_title": "trait のdefinitionとimplementation",
    "rust_lesson4_ex10_slide2_title": "いつuse？",
    "rust_lesson3_ex7_slide2_title": "match の省略形",
    "rust_lesson1_ex6_title": "logicaloperator（&&、||）",
    "rust_lesson3_ex6_comment1": "fold で畳み込み",
    "rust_lesson2_ex6_description": "複数の状態を表す「列挙type（enum）」を学びましょう。",
    "rust_lesson4_ex10_slide1_title": "enumerate（イニュメレート）?",
    "rust_lesson1_ex7_slide1_title": "ベクタ（Vec）?",
    "rust_lesson2_ex6_slide3_content": "複数の状態を表す「列挙型（enum）」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex3_slide3_title": "Let's Try It!",
    "rust_lesson3_ex4_description": "各elementを変換domapを学びましょう。",
    "rust_lesson4_ex1_slide3_title": "Let's Try It!",
    "rust_lesson3_ex9_slide2_title": "mut が必要",
    "rust_lesson1_ex6_slide1_content": "# logicaloperator（ろんりえんざんし）\n\n2つ以上の条件を組み合わせたいときにuse記号です。\n\n2つの記号：\n- `&&`（アンドアンド）：「かつ」＝ 両方とも 正しいとき\n- `||`（オアオア）：「Alsoは」＝ どちらか 正しいとき\n\n身近なExample：\n- 遊園地：「18歳以上 かつ チケットあり」なら乗れる\n- おやつ：「宿題終わった Alsoは お手伝いした」ならOK\n\ncodeExample：\n```rust\nif score >= 70 && bonus > 0 {\n    // 70点以上 かつ ボーナスあり → 合格！\n    println!(\"合格！\");\n}\n```",
    "rust_lesson4_ex4_slide3_content": "参照カウントでデータを共有しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex6_slide3_title": "Let's Try It!",
    "rust_lesson2_ex5_slide3_content": "構造体にメソッドを追加する「impl」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex1_slide3_title": "Let's Try It!",
    "rust_lesson1_ex5_slide1_content": "# programに「判断」させよう\n\nconditional は、「もし〜なら、〇〇do」という判断をprogramにさせる仕組みです。\n\n身近なExample：\n- もし80点以上なら → 「合格！」とdisplay\n- もし雨なら → 傘を持っていく\n- もしHPが0なら → ゲームオーバー\n\nRustで Syntax：\n```rust\nif score > 80 {\n    println!(\"合格！\");\n}\n```\n\n読み方：\n- `if` →「もし」\n- `score > 80` →「スコアが80より大きいなら」\n- `{ }` の中 →「これをやる」",
    "rust_lesson4_ex5_title": "HashMap",
    "rust_lesson1_ex2_slide1_content": "# データを保存do「はこ」\n\nvariable（へんすう） は、数字や文字を入れておける「はこ」のことです。名前をつけて、あとでuseことができます。\n\nFor example：\n- 「りんごの数」というラベルの箱に「5」を入れる\n- あとで「りんごの数」と呼べば「5」が出てくる\n\nRustで Syntax：\n```rust\nlet x = 10;  // xという箱に10を入れる\nprintln!(\"{}\", x);  // xの中身（10）を表示\n```\n\n`let` は「この名前で箱をcreateよ」という意味です。",
    "rust_lesson2_ex4_slide3_content": "関連するデータをまとめる「構造体」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex6_slide1_title": "enum ?",
    "rust_lesson2_ex9_title": "トレイトをdefinitionしよう",
    "rust_lesson2_ex4_slide1_title": "構造体（こうぞうたい）?",
    "rust_lesson4_ex2_slide2_content": "# 覚えておくと便利な5つ\n\nよくusederiveトレイト：\n```rust\nDebug     // {:?} でデバッグ表示できる\nClone     // .clone() でコピーを作れる\nCopy      // 代入時に自動でコピー（小さい型向け）\nPartialEq // == で比較できる\nDefault   // 初期値を自動で作れる\n```\n\n複数指定もOK：\n```rust\n#[derive(Debug, Clone, PartialEq)]\nstruct User {\n    name: String,\n    age: u32,\n}\n```\n\n`Debug` は特によくuse。debug時に構造体の中身を見れて便利！",
    "rust_lesson2_ex1_slide1_content": "# データの「持ち主」を決めるルール\n\n所有権 は、Rust最大のFeatureです。「このデータの持ち主は誰か」をはっきりさせる仕組みです。\n\nルール：\n- データには必ず1人だけ「持ち主」がいる\n- 持ち主がいなくなると、データは自dynamicに片付けられる\n\nたとえるなら：\n- おもちゃは1人しか持てない\n- 持ち主が部屋を出たら、おもちゃは片付けられる\n\nこのルールのおかげで、Rustは「memoryリーク」（データが片付けられないバグ）を防げます！",
    "rust_lesson1_ex3_slide2_title": "Let's Try It!",
    "rust_lesson3_ex1_slide2_title": "なぜ必要？",
    "rust_lesson3_ex1_slide2_content": "# 危険なバグを防ぐ\n\nダングリングreference という危険なバグがあります。これは「もう存在しないデータ」を指し続けているreferenceのことです。\n\nExample：\n```rust\nfn longest<'a>(x: &'a str, y: &'a str) -> &'a str {\n    if x.len() > y.len() { x } else { y }\n}\n```\n\n`'a` の意味：\n- argument `x` と `y` は同じライフタイム `'a` を持つ\n- return valueも同じライフタイム `'a` を持つ\n- In other words「xとyが両方有効な間、return valueも有効」という約束\n\nRustはこれを自動でチェックしてくれます！",
    "rust_lesson4_ex6_slide2_title": "set演算",
    "rust_lesson3_ex7_comment1": "? でerrorを伝播",
    "rust_lesson3_ex2_slide2_content": "# | | でargumentを囲む\n\nclosureは `|引数| 処理` という形でwrite。`||` は「パイプ」と呼ばれます。\n\nいろいろなSyntax：\n```rust\n// 引数なし\n|| println!(\"Hello\")\n\n// 引数あり\n|x, y| x + y\n\n// 複数行のブロック\n|x| {\n    let y = x * 2;\n    y + 1\n}\n```\n\nPoint：\n- argumentを `| |` で囲む（functionの `()` の代わり）\n- typeは省略できることが多い（Rustが推測してくれる）",
    "rust_lesson2_ex7_comment1": "Some でvalueがあることを示す",
    "rust_lesson3_ex4_slide3_content": "各要素を変換するmapを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_title": "Rust (ラスト) に挑戦！",
    "rust_lesson2_ex8_description": "成功と失敗を表す「Result」を学びましょう。",
    "rust_lesson3_ex8_description": "Option/Resultのデフォルトvalueを設定しましょう。",
    "rust_lesson4_ex2_slide3_title": "Let's Try It!",
    "rust_lesson2_ex5_slide3_title": "Let's Try It!",
    "rust_lesson4_ex9_description": "iteratorをコレクションに変換しましょう。",
    "rust_lesson1_ex1_slide2_content": "# println! でscreenにdisplay\n\nRustで文字をscreenにdisplayには、`println!`（プリントラインびっくり）をuse。\n\nPoint：\n- `!` がつくのがRustのFeature（マクロと呼ばれます）\n- programは `fn main() { }` の中にwrite\n- `fn` は「function（function）」の略\n\ncodeExample：\n```rust\nfn main() {\n    println!(\"ヤッホー！\");\n}\n// 「ヤッホー！」と画面に表示される\n```\n\n`println!` の `!` は「マクロ」という特別な機能の印です。今は「おまじない」と思っておけばOK！",
    "rust_lesson3_ex6_slide1_title": "fold ?",
    "rust_lesson4_ex8_slide1_title": "impl Trait ?",
    "rust_lesson1_ex1_slide2_title": "Rustの「おまじない」",
    "rust_lesson3_ex10_description": "stringtypeの違いを理解しましょう。",
    "rust_lesson3_ex7_slide3_content": "エラーを簡潔に伝播させましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex1_comment1": "s1 の所有権を移動",
    "rust_lesson2_ex9_slide1_title": "トレイト?",
    "rust_lesson4_ex6_slide2_content": "# 和set、積setなど\n\n```rust\nset1.union(&set2)\nset1.intersection(&set2)\nset1.difference(&set2)\n```",
    "rust_lesson4_ex5_slide3_content": "キーと値のペアを格納しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex8_slide1_title": "Result（リザルト）?",
    "rust_lesson4_ex1_slide1_content": "# 「できること」の約束\n\nトレイト は、typeが持つべきmethodをdefine仕組みです。\n\nFor example：\n- 「あいさつできる」トレイト → greet() methodを持つ\n- 「displayできる」トレイト → display() methodを持つ\n\ncodeExample：\n```rust\ntrait Greet {\n    fn greet(&self) -> String;  // メソッドの「約束」\n}\n```\n\nこれは「Greetできるtypeは、greet()methodを持つ」という約束です。",
    "rust_lesson4_ex2_slide3_content": "トレイトを自動実装するderiveを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex6_title": "fold で畳み込み",
    "rust_lesson3_ex9_slide3_content": "Vecに要素を追加しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex4_slide1_content": "# 関係あるデータをまとめる「設計図」\n\n構造体（struct） は、いくつかのデータをひとまとめにdo仕組みです。\n\nFor example「点（座標）」のデータ：\n- x座標\n- y座標\n\nこの2つは関係があるので、「Point（点）」としてまとめると便利です。\n\nFor example「人」のデータ：\n- 名前\n- 年齢\n\nこれも「Person（人）」としてまとめられます。\n\n構造体は「こういうデータを持つ」という設計図です。",
    "rust_lesson4_ex1_slide1_title": "トレイト?（復習）",
    "rust_lesson2_ex3_description": "reference先のvalueを変更できる「可変reference」を学びましょう。",
    "rust_lesson2_ex7_slide2_content": "# match で安全に取り出す\n\n`match` を使って「ある場合」と「ない場合」で処理を分けます。\n\ncodeExample：\n```rust\nlet x: Option<i32> = Some(5);  // 値あり\n\nmatch x {\n    Some(n) => println!(\"値は{}です\", n),  // 5\n    None => println!(\"値がありません\"),\n}\n```\n\nなぜ安全？\n- `null` のように「あるつもりでアクセスしたら無かった」errorが起きない\n- 「ない場合」の処理を書かないとコンパイルerrorになる\n- 強制的に両方のケースを考えることになる！",
    "rust_lesson4_ex9_comment1": "collect で Vec に変換",
    "rust_lesson3_ex10_title": "String と &str",
    "rust_lesson2_ex7_slide1_title": "Option（オプション）?",
    "rust_lesson3_ex9_description": "Vecにelementを追加しましょう。",
    "rust_lesson2_ex5_comment1": "impl でmethodをimplementation",
    "rust_lesson3_ex1_slide3_content": "参照の有効期間を表すライフタイムを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex6_slide2_content": "複数の条件を組み合わせる「&&（かつ）」と「||（または）」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex5_comment1": "filter で条件に合うelementを絞り込む",
    "rust_lesson2_ex7_slide3_content": "値があるかないかを表す「Option」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex10_slide3_title": "Let's Try It!",
    "rust_lesson4_ex4_slide3_title": "Let's Try It!",
    "rust_lesson3_ex3_comment1": "iter でiteratorを取得",
    "rust_lesson3_ex6_slide3_content": "要素を1つの値にまとめるfoldを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex7_slide2_title": "ベクタの番号は「0」から！",
    "rust_lesson1_ex5_slide1_title": "conditional（じょうけんぶんき）?",
    "rust_lesson1_ex3_description": "割り算の「あまり」を求める「%」（パーセント）operatorを学びましょう。",
    "rust_lesson1_ex1_slide3_content": "Rustを使って画面に文字を表示してみましょう。println! という特別な関数を使います。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex10_slide2_content": "# <T> でtypeを「あとで決める」\n\nfunction名の後に `<T>` をつけて、`T` を「type」としてuse。\n\ncodeExample：\n```rust\n// Tはどんな型でもOK\nfn first<T>(arr: &[T]) -> &T {\n    &arr[0]  // 最初の要素を返す\n}\n\n// 使い方\nfirst(&[1, 2, 3]);         // Tはi32\nfirst(&[\"a\", \"b\", \"c\"]);   // Tは&str\n```\n\n読み方：\n- `<T>` → 「Tという名前のtypeをuseよ」\n- `T` は慣習で「Type（type）」の頭文字\n- 複数のtypeが必要なら `<T, U>` のようにwrite",
    "rust_lesson3_ex2_comment1": "|x| でclosureのargumentをdefinition",
    "rust_lesson3_ex3_description": "elementを順番に処理doiteratorを学びましょう。",
    "rust_lesson1_ex1_slide3_title": "Let's Try It!",
    "rust_lesson2_ex6_slide2_title": "enum のdefinition",
    "rust_lesson2_ex1_title": "所有権のBasic",
    "rust_lesson4_ex3_slide1_title": "Box（ボックス）?",
    "rust_lesson2_ex1_slide3_content": "Rust独自の概念「所有権」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex8_slide3_content": "Option/Resultのデフォルト値を設定しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex7_slide2_title": "使用Example",
    "rust_lesson4_ex10_description": "iteratorにindexを付けましょう。",
    "rust_lesson4_ex9_slide1_title": "collect ?",
    "rust_lesson4_ex10_slide2_content": "# 「何番目か」が必要なとき\n\n番号（index）とelementの両方が必要なときに便利です。\n\ncodeExample：\n```rust\nlet v = vec![10, 20, 30];\nfor (idx, val) in v.iter().enumerate() {\n    println!(\"{}番目の値は{}\", idx, val);\n}\n// 0番目の値は10\n// 1番目の値は20\n// 2番目の値は30\n```\n\nPoint：\n- `(i, x)` でtuple（2つのset）を受け取る\n- `i` にindex、`x` にelementが入る\n- indexは0から始まる",
    "rust_lesson3_ex2_description": "周囲のvariableを使えるanonymous function「closure」を学びましょう。",
    "rust_lesson1_ex4_comment1": "mut で変更可能にdo",
    "rust_lesson1_ex8_slide3_title": "Let's Try It!",
    "rust_lesson1_ex3_slide2_content": "割り算の「あまり」を求める「%」（パーセント）演算子を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex9_slide3_title": "Let's Try It!",
    "rust_lesson3_ex3_title": "iteratorのBasic",
    "rust_lesson3_ex9_title": "Vec のmethod push",
    "rust_lesson1_ex8_comment1": "dictionaryをcreate（keyは'みかん'、valueは'オレンジ'）",
    "rust_lesson1_ex2_comment3": "+ でたし算do",
    "rust_lesson4_ex8_slide2_content": "# ジェネリクスの代わり\n\n```rust\nfn print_all(iter: impl Iterator<Item = i32>) {\n    for x in iter {\n        println!(\"{}\", x);\n    }\n}\n```",
    "rust_lesson2_ex2_slide2_title": "reference Usage",
    "rust_lesson1_ex8_slide3_content": "「辞書（HashMap）」を使うと、名前をつけてデータを保存し、その名前で取り出せます。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex7_slide2_content": "# [ ]で番号を指定して取り出す\n\n`[番号]` で何番目のデータか指定して取り出せます。\n\nImportantなルール：番号は「0」から！\n- 1番目 → `[0]`\n- 2番目 → `[1]`\n- 3番目 → `[2]`\n\ncodeExample：\n```rust\nlet fruits = vec![\"りんご\", \"バナナ\", \"みかん\"];\n//                  ↑0番    ↑1番     ↑2番\nprintln!(\"{}\", fruits[0]);  // りんご\nprintln!(\"{}\", fruits[1]);  // バナナ\n```\n\nプログラミングでは「0から数える」のが世界共通のルールです！",
    "rust_lesson1_ex6_slide1_title": "条件を組み合わせる",
    "rust_lesson2_ex10_slide2_title": "ジェネリックfunction Syntax",
    "rust_lesson1_ex6_description": "複数の条件を組み合わせる「&&（かつ）」と「||（Alsoは）」を学びましょう。",
    "rust_lesson4_ex6_title": "HashSet",
    "rust_lesson2_ex3_slide2_content": "# mut が2か所に必要\n\n変更できるようにdoには、variableとreferenceの両方に `mut` が必要です。\n\ncodeExample：\n```rust\n// 1. 変数を mut で作る\nlet mut s = String::from(\"hello\");\n\n// 2. &mut で可変参照を渡す\nchange(&mut s);\n\nfn change(s: &mut String) {\n    s.push_str(\" world\");  // 変更できる！\n}\n```\n\nPoint：\n- `let mut 変数` でvariableを変更可能に\n- `&mut 変数` で可変referenceをcreate\n- 両方ないと変更できない！",
    "rust_lesson2_ex2_slide1_title": "reference（さんしょう）?",
    "rust_lesson3_ex6_slide2_content": "# 合計、積、結合など\n\n```rust\n// 積\nv.iter().fold(1, |acc, x| acc * x)\n\n// 文字列結合\nwords.iter().fold(String::new(), |acc, s| acc + s)\n```",
    "rust_lesson1_ex1_description": "Rustを使ってscreenに文字をdisplayしてみましょう。println! という特別なfunctionをuse。",
    "rust_lesson3_ex8_slide3_title": "Let's Try It!",
    "rust_lesson4_ex6_description": "一意なvalueのsetを管理しましょう。",
    "rust_lesson2_ex5_slide1_title": "impl ?",
    "rust_lesson1_ex8_title": "名前で引き出す「dictionary」",
    "rust_lesson2_ex7_description": "valueがあるかないかを表す「Option」を学びましょう。",
    "rust_lesson1_ex4_slide2_title": "Let's Try It!",
    "rust_lesson1_ex7_title": "たくさんのデータをまとめましょう「ベクタ」",
    "rust_lesson3_ex7_slide1_content": "# errorの早期リターン\n\n? は、Resultが Err の場合に早期リターンします。\n\n```rust\nfn read_file() -> Result<String, io::Error> {\n    let content = fs::read_to_string(\"file.txt\")?;\n    Ok(content)\n}\n```",
    "rust_lesson3_ex9_slide1_content": "# 末尾に追加\n\npush は、Vecの末尾にelementをadd。\n\n```rust\nlet mut v = vec![1, 2];\nv.push(3);\n// [1, 2, 3]\n```",
    "rust_lesson4_ex8_slide3_content": "トレイトを返す関数を簡潔に書きましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex1_title": "screenにメッセージを出しましょう",
    "rust_lesson2_ex8_slide2_title": "Result  Usage",
    "rust_lesson3_ex2_slide1_title": "closure?",
    "rust_lesson3_ex8_title": "unwrap_or でデフォルトvalue",
    "rust_lesson4_ex10_slide1_content": "# 番号とelementを一緒にもらう\n\nenumerate は、「何番目か」と「そのelement」をsetで取り出せるmethodです。\n\nFor example：\n- 0番目: りんご\n- 1番目: バナナ\n- 2番目: みかん\n\ncodeExample：\n```rust\nfor (i, x) in vec![\"a\", \"b\", \"c\"].iter().enumerate() {\n    println!(\"{}: {}\", i, x);\n}\n// 0: a\n// 1: b\n// 2: c\n```",
    "rust_lesson1_ex7_slide1_content": "# データを並べてまとめる「長い箱」\n\nベクタ（Vec） は、たくさんのデータを順番に並べて入れられる「長い箱」です。\n\nFor example：\n- 買い物listの商品を全部まとめる\n- testの点数を全部まとめる\n- 友だちの名前を全部まとめる\n\n100個でも1000個でも、1つのvariableでまとめて管理できます！\n\n作り方：\n```rust\nlet fruits = vec![\"りんご\", \"バナナ\", \"みかん\"];\n// vec! で ベクタを作る\n```",
    "rust_lesson4_ex8_slide3_title": "Let's Try It!",
    "rust_lesson4_ex7_description": "パターンマッチに条件を追加しましょう。",
    "rust_lesson1_ex4_comment2": "+= で 20 を足す",
    "rust_lesson1_ex2_comment2": "y に 5 を入れる",
    "rust_lesson2_ex3_slide3_title": "Let's Try It!",
    "rust_lesson3_ex4_slide1_title": "map（map）?",
    "rust_lesson1_ex2_slide3_content": "データに名前をつけて保存できる「変数（へんすう）」を使ってみましょう。letで変数を作ります。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex8_slide2_content": "# match で成功と失敗を分ける\n\n`match` で「成功したら」「失敗したら」の処理を書き分けます。\n\ncodeExample：\n```rust\nfn divide(a: i32, b: i32) -> Result<i32, String> {\n    if b == 0 {\n        return Err(\"0で割れません\".to_string());\n    }\n    Ok(a / b)  // 成功なら答えを返す\n}\n\nmatch divide(10, 2) {\n    Ok(v) => println!(\"答えは{}\", v),\n    Err(e) => println!(\"エラー: {}\", e),\n}\n```\n\nPoint：\n- `Ok(値)` で成功をreturn\n- `Err(エラー)` で失敗をreturn",
    "rust_lesson4_ex3_comment1": "Box::new でheapに格納",
    "rust_lesson4_ex8_description": "トレイトをreturnfunctionを簡潔に書きましょう。",
    "rust_lesson2_ex10_description": "typeを後から決められる「ジェネリクス」を学びましょう。",
    "rust_lesson2_ex3_slide1_title": "可変reference（かへんさんしょう）?",
    "rust_lesson2_ex2_description": "所有権を移さずにvalueを借りる「reference」を学びましょう。",
    "rust_lesson3_ex5_slide2_title": "** にNote！",
    "rust_lesson2_ex2_slide3_title": "Let's Try It!",
    "rust_lesson4_ex3_slide3_content": "ヒープにデータを格納するBoxを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex4_title": "累算assignmentoperator（+=、-=）",
    "rust_lesson3_ex3_slide2_content": "# 借りるか、もらうか\n\n3種類の iter があり、所有権の扱いが違います。\n\n3つの違い：\n```rust\nv.iter()       // 参照で借りる（&T）\nv.iter_mut()   // 変更可能で借りる（&mut T）\nv.into_iter()  // 所有権をもらう（T）\n```\n\n使い分け：\n- `iter()` → 見るだけ（元のベクタも使える）\n- `iter_mut()` → 中身を変更したい\n- `into_iter()` → ベクタごともらう（元は使えない）\n\n普通は `iter()` をuseことが多いです。",
    "rust_lesson2_ex1_slide1_title": "所有権（しょゆうけん）?",
    "rust_lesson4_ex6_slide3_content": "一意な値の集合を管理しましょう。\n\n（When you're ready, select \"Start Lesson\".）"
  },
  "ro": {
    "rust_lesson1_course_title": "Introduction to Rust",
    "rust_lesson1_course_description": "Learn the basics of Rust programming.",
    "rust_lesson2_course_title": "Rust II - Intermediate",
    "rust_lesson2_course_description": "Learn intermediate Rust concepts.",
    "rust_lesson3_course_title": "Rust III - Advanced",
    "rust_lesson3_course_description": "Master advanced Rust techniques.",
    "rust_lesson4_course_title": "Rust IV - Expert Level",
    "rust_lesson4_course_description": "Expert-level Rust programming.",
    "rust_lesson1_ex5_slide2_content": "条件によって動きを変える if文を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex9_title": "collect で変換",
    "rust_lesson2_ex7_slide1_content": "# 「あるかもしれない、ないかもしれない」\n\nOption<T> は、valueが「あるかもしれないし、ないかもしれない」ことを表すtypeです。\n\nFor example：\n- dictionaryで単語を探す → 見つかるかもしれないし、ないかもしれない\n- ゲームでアイテムを拾う → 落ちてるかもしれないし、ないかもしれない\n\n2つの状態：\n- `Some(値)` → valueがある！\n- `None` → valueがない...\n\n他の言語では `null` をuseが、Rustでは `Option` で安全に扱います。",
    "rust_lesson1_ex2_slide1_title": "variable（へんすう）?",
    "rust_lesson1_ex7_description": "「ベクタ（Vec）」をuseと、たくさんのデータを一つの「長い はこ」にまとめて入れられます。",
    "rust_lesson2_ex9_slide2_content": "# 約束を作って、守る\n\n1. `trait` で「約束」をdefinition\n2. `impl トレイト for 型` で「約束を守る」implementationをdo\n\ncodeExample：\n```rust\n// 1. トレイト（約束）を定義\ntrait Speak {\n    fn speak(&self);  // 鳴くメソッドを持つ約束\n}\n\n// 2. Dog構造体がトレイトを実装\nstruct Dog;\nimpl Speak for Dog {\n    fn speak(&self) {\n        println!(\"woof\");\n    }\n}\n```\n\n「DogはSpeakができる」ということになります。",
    "rust_lesson4_ex4_description": "referenceカウントでデータを共有しましょう。",
    "rust_lesson4_ex5_slide1_content": "# 名前で引ける「dictionary」\n\nHashMap は、「key（名前）」と「value（データ）」をsetで保存dodictionaryです。\n\nFor example：\n- 「青チーム」→ 10点\n- 「赤チーム」→ 15点\n\ncodeExample：\n```rust\nuse std::collections::HashMap;\n\nlet mut scores = HashMap::new();\nscores.insert(\"Blue\", 10);   // 追加\nscores.insert(\"Red\", 15);    // 追加\n```\n\n`use` で機能を読み込んでからuse。",
    "rust_lesson3_ex4_title": "map でiterator変換",
    "rust_lesson4_ex1_slide3_content": "共通の振る舞いを定義するトレイトを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex4_description": "variableのvalueを手軽に増やしたり減らしたりdo「+=」「-=」を学びましょう。",
    "rust_lesson1_ex2_description": "データに名前をつけて保存できる「variable（へんすう）」を使ってみましょう。letでvariableをcreate。",
    "rust_lesson4_ex4_slide2_title": "referenceカウントの仕組み",
    "rust_lesson3_ex8_slide2_title": "unwrap_or_else",
    "rust_lesson4_ex10_comment1": "1番目の i にindex、2番目の item にelementが入る",
    "rust_lesson3_ex6_slide1_content": "# 累積処理\n\nfold は、初期valueとfunctionでelementを1つずつ畳み込みます。\n\n```rust\nlet v = vec![1, 2, 3];\nlet sum = v.iter().fold(0, |acc, x| acc + x);\n// 6\n```",
    "rust_lesson4_ex2_slide2_title": "よくuse derive トレイト",
    "rust_lesson3_ex10_slide3_content": "文字列型の違いを理解しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex4_slide2_content": "変数の値を手軽に増やしたり減らしたりする「+=」「-=」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex4_slide3_title": "Let's Try It!",
    "rust_lesson3_ex5_slide1_title": "filter（filterー）?",
    "rust_lesson4_ex5_description": "keyとvalueのpairを格納しましょう。",
    "rust_lesson3_ex5_description": "条件に合うelementだけを取り出しましょう。",
    "rust_lesson2_ex2_slide2_content": "# functionに借りてもらう\n\nfunctionにデータを渡すとき、`&` をつけると「借りる」形になります。元のvariableはそのまま使い続けられます。\n\ncodeExample：\n```rust\nfn calc_len(s: &String) -> usize {\n    s.len()  // 長さを返す\n}\n\nfn main() {\n    let text = String::from(\"hello\");\n    let len = calc_len(&text);  // textを貸す\n    // text はまだ使える！\n    println!(\"{}の長さは{}\", text, len);\n}\n```\n\n`&String` は「Stringを借りる」という意味です。",
    "rust_lesson4_ex7_slide3_content": "パターンマッチに条件を追加しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex8_slide2_content": "# 遅延評価\n\n```rust\n// クロージャで計算\nlet value = x.unwrap_or_else(|| expensive_computation());\n```",
    "rust_lesson4_ex7_title": "match ガード",
    "rust_lesson3_ex7_title": "? operatorでerror伝播",
    "rust_lesson4_ex1_description": "共通の振る舞いをdefineトレイトを学びましょう。",
    "rust_lesson2_ex1_slide2_content": "# 所有権は「移動」do\n\nvariableを別のvariableにassignmentdoと、所有権が 移動（ムーブ） します。元のvariableは使えなくなります。\n\ncodeExample：\n```rust\nlet s1 = String::from(\"hello\");  // s1 が持ち主\nlet s2 = s1;  // 所有権が s2 に移動！\n// ↓ s1 はもう使えない（エラーになる）\n// println!(\"{}\", s1);  // ダメ！\nprintln!(\"{}\", s2);  // OK！\n```\n\nイメージ：\nおもちゃを友だちにあげたら、自分はもう使えない。これがムーブです。",
    "rust_lesson1_ex8_slide1_title": "dictionary（HashMap）?",
    "rust_lesson4_ex3_slide2_content": "# サイズが決まらないとき\n\nBoxは、コンパイル時にサイズがわからないtypeにuse。\n\nFor examplerecursion的なtype：\n```rust\n// リストは「値 + 次のリスト」の繰り返し\nenum List {\n    Cons(i32, Box<List>),  // Boxで次を指す\n    Nil,                   // 終わり\n}\n```\n\nなぜBoxが必要？\n- `List` の中に `List` がある → 無限に大きくなる？\n- `Box` をuseと、サイズが固定（pointerのサイズ）になる\n\n「中身」ではなく「中身への矢印」を持つイメージです。",
    "rust_lesson2_ex10_title": "ジェネリクスを使おう",
    "rust_lesson2_ex8_slide3_title": "Let's Try It!",
    "rust_lesson3_ex9_slide2_content": "# 可変reference\n\n```rust\n// mut が必要\nlet mut v = Vec::new();\nv.push(1);\nv.push(2);\n```",
    "rust_lesson4_ex4_title": "Rc<T>",
    "rust_lesson2_ex3_comment1": "mut で可変variableにdo",
    "rust_lesson4_ex5_slide3_title": "Let's Try It!",
    "rust_lesson2_ex6_slide2_content": "# バリアントを列挙\n\n`enum 名前 { バリアント1, バリアント2, ... }` でdefine。\n\ncodeExample：\n```rust\nenum Color {\n    Red,\n    Green,\n    Blue,\n}\nlet c = Color::Red;\n```",
    "rust_lesson1_ex1_comment1": "Hello, Rust! とdisplay",
    "rust_lesson1_ex1_slide1_content": "# 安全で速い！最新のプログラミング言語\n\nRust（ラスト）は、「間違いを事前に防ぐ」ことがとても得意なプログラミング言語です。\n\nRustのすごいところ：\n- programのミスをexecute前に見つけてくれる\n- とても速く動く\n- 世界中のプログラマーが「一番好き！」と選ぶ人気の言語\n\nたとえるなら：\n厳しいけど優しい先生のような言語です。「ここ間違ってるよ」と教えてくれるので、安心してprogramが書けます！",
    "rust_lesson3_ex8_slide1_content": "# None/Err の場合のデフォルト\n\nunwrap_or は、None や Err の場合にデフォルトvalueをreturn。\n\n```rust\nlet x: Option<i32> = None;\nlet value = x.unwrap_or(0);  // 0\n```",
    "rust_lesson2_ex7_slide3_title": "Let's Try It!",
    "rust_lesson2_ex6_title": "enum で状態を表す",
    "rust_lesson2_ex8_slide1_content": "# 「成功」か「失敗」かを表す\n\nResult<T, E> は、処理が「成功したか失敗したか」を表すtypeです。\n\nFor example：\n- fileをopen → 成功（内容）か失敗（error）\n- 0で割り算 → 成功（答え）か失敗（0で割れない！）\n\n2つの状態：\n- `Ok(値)` → 成功！valueが入っている\n- `Err(エラー)` → 失敗...error情報が入っている\n\n`Option` は「あるか・ないか」、`Result` は「成功か・失敗か」という違いです。",
    "rust_lesson2_ex8_slide3_content": "成功と失敗を表す「Result」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex6_slide1_title": "HashSet ?",
    "rust_lesson3_ex9_comment1": "push でelementを追加",
    "rust_lesson2_ex7_slide2_title": "Option  Usage",
    "rust_lesson3_ex2_title": "closureのBasic",
    "rust_lesson3_ex7_slide1_title": "? operator?",
    "rust_lesson4_ex6_comment1": "HashSet をimport",
    "rust_lesson2_ex10_slide1_content": "# どんなtypeでも使える「万能」の仕組み\n\nジェネリクス は、typeを後から決められる仕組みです。\n\nなぜ便利？\n同じようなfunctionを何度も書かなくてすみます。\n\nFor example：\n- 数字のarrayの最初のelementを取るfunction\n- stringのarrayの最初のelementを取るfunction\n\n両方とも「最初のelementを取る」のは同じなのに、typeが違うだけで別のfunctionをwriteのは大変！\n\nジェネリクスなら、`<T>` で「typeは後で決める」とwriteだけで、どんなtypeでも使えるfunctionが作れます。",
    "rust_lesson1_ex3_slide1_content": "# 剰余operator（じょうよえんざんし）「%」\n\n`%`（パーセント）は、割り算の 「あまり」 をcalculate特別な記号です。\n\nわかりやすいExample：\n- 10このアメを3人で分けると？\n- 1人3こずつで、1こあまる\n- これを `10 % 3` とwriteと、答えは `1`\n\ncodeExample：\n```rust\nprintln!(\"{}\", 10 % 3);  // 1（あまり1）\nprintln!(\"{}\", 8 % 4);   // 0（あまりなし＝割り切れる）\n```\n\n使いどころ：\n- 偶数か奇数か調べる（`n % 2` が0なら偶数）\n- 時計の計算（24を超えたら0に戻る、など）",
    "rust_lesson3_ex7_description": "errorを簡潔に伝播させましょう。",
    "rust_lesson3_ex8_comment1": "unwrap_or でデフォルトvalueを設定",
    "rust_lesson2_ex8_title": "Result<T, E> でerror処理",
    "rust_lesson2_ex10_comment1": "T をtypeパラメータとしてuse",
    "rust_lesson2_ex6_comment1": "enum で列挙typeをdefinition",
    "rust_lesson3_ex3_slide3_content": "要素を順番に処理するイテレータを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex2_comment1": "derive でトレイトを自動implementation",
    "rust_lesson1_ex8_slide1_content": "# 名前でsearchできる「dictionary」\n\nHashMap（ハッシュmap）は、「名前」と「データ」をsetにして保存できる仕組みです。本物のdictionaryのように使えます。\n\nFor example果物の色dictionary：\n- 「りんご」→「あか」\n- 「バナナ」→「きいろ」\n- 「みかん」→「オレンジ」\n\nuse準備：\n```rust\nuse std::collections::HashMap;  // 機能を読み込む\nlet mut fruits = HashMap::new();  // 空の辞書を作る\nfruits.insert(\"りんご\", \"あか\");  // データを追加\n```\n\n`use` は「この機能をuseよ」というdeclarationです。",
    "rust_lesson3_ex9_slide1_title": "push ?",
    "rust_lesson4_ex1_title": "トレイトのdefinition",
    "rust_lesson4_ex3_description": "heapにデータを格納doBoxを学びましょう。",
    "rust_lesson1_ex2_title": "便利な「はこ」variable（へんすう）",
    "rust_lesson1_ex8_comment2": "中身を出す",
    "rust_lesson3_ex9_slide3_title": "Let's Try It!",
    "rust_lesson1_ex4_comment3": "-= で 50 を引く",
    "rust_lesson1_ex6_comment1": "&& で両方の条件をチェック",
    "rust_lesson4_ex1_slide2_title": "トレイトのimplementation",
    "rust_lesson4_ex7_slide3_title": "Let's Try It!",
    "rust_lesson4_title": "Rust IV - トレイトとスマートpointer",
    "rust_lesson4_ex1_comment1": "trait でトレイトをdefinition",
    "rust_lesson4_ex4_slide1_content": "# 複数の「持ち主」を許可do仕組み\n\nRc<T> は「Reference Counted（referenceカウント）」の略で、複数の所有者でデータを共有できます。\n\n普通の所有権：\n1人だけが持ち主。渡したら元の人は使えない。\n\nRc をuseと：\n複数人が同じデータの「持ち主」になれる！\n\ncodeExample：\n```rust\nuse std::rc::Rc;\n\nlet a = Rc::new(5);       // Rcでラップ\nlet b = Rc::clone(&a);    // bも持ち主になる\n// a も b も使える！\n```",
    "rust_lesson3_ex5_slide1_content": "# 条件に合うものだけ残す\n\nfilter は、条件を満たすelementだけを残し、他を捨てます。\n\nFor example：\n- 80点以上の人だけ残す\n- 偶数だけ残す\n- 「あ」から始まる名前だけ残す\n\ncodeExample：\n```rust\nlet v = vec![1, 2, 3, 4, 5];\nlet evens: Vec<_> = v.iter()\n    .filter(|x| **x % 2 == 0)  // 偶数だけ\n    .collect();\n// [2, 4]\n```\n\n条件が `true` のelementだけが残ります。",
    "rust_lesson3_ex7_slide3_title": "Let's Try It!",
    "rust_lesson1_ex7_comment2": "2番目のデータ（1番）を出す",
    "rust_lesson4_ex8_title": "impl Trait",
    "rust_lesson1_ex5_description": "条件によって動きを変える if文を学びましょう。",
    "rust_lesson3_ex4_slide2_title": "遅延評価（ちえんひょうか）",
    "rust_lesson3_ex1_slide1_content": "# referenceの「寿命」を示す印\n\nライフタイム は、referenceがいつまで使えるかを示す印です。`'a`（アポストロフィ・エー）のようにwrite。\n\nなぜ必要？\nreferenceは「借りている」状態。借りた元のデータが消えたら、referenceも使えなくなります。\n\nFor example：\n- 図書館で借りた本 → 図書館が閉まったら読めない\n- referenceで借りたデータ → 元のデータが消えたら使えない\n\nライフタイムは「このreferenceはこの範囲で有効だよ」とコンパイラに伝える仕組みです。",
    "rust_lesson1_ex1_slide1_title": "Rust（ラスト）?",
    "rust_lesson1_ex2_slide2_title": "計算の記号（operator）",
    "rust_lesson4_ex5_slide2_content": "# get で安全に取り出す\n\n`get()` methodでvalueを取り出せます。見つからない可能性があるので、`Option` が返ってきます。\n\ncodeExample：\n```rust\n// getはOption<&V>を返す\nif let Some(score) = scores.get(\"Blue\") {\n    println!(\"青チームは{}点\", score);\n}\n```\n\nPoint：\n- keyがあれば `Some(値)` が返る\n- keyがなければ `None` が返る\n- `if let` で安全に取り出せる\n\n存在しないkeyでアクセスしてもprogramが落ちない！",
    "rust_lesson4_ex7_slide1_title": "match ガード?",
    "rust_lesson3_title": "Rust III - ライフタイムとiterator",
    "rust_lesson4_ex3_title": "Box<T>",
    "rust_lesson1_ex4_slide1_title": "累算assignmentoperator（るいさんだいにゅう）?",
    "rust_lesson2_ex9_comment1": "trait でトレイトをdefinition",
    "rust_lesson2_ex1_description": "Rust独自の概念「所有権」を学びましょう。",
    "rust_lesson2_ex3_slide3_content": "参照先の値を変更できる「可変参照」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex1_slide3_title": "Let's Try It!",
    "rust_lesson3_ex6_slide2_title": "様々な畳み込み",
    "rust_lesson4_ex9_slide3_title": "Let's Try It!",
    "rust_lesson2_ex5_title": "impl でmethodを追加",
    "rust_lesson2_ex6_slide1_content": "# 複数の選択肢\n\nenum は、valueがいくつかの種類のうちの一つであることを表します。各バリアントにデータを持たせることもできます。",
    "rust_lesson2_ex4_comment1": "struct で構造体をdefinition",
    "rust_lesson1_ex3_title": "剰余operator（%）",
    "rust_lesson1_ex7_comment1": "colors というベクタをcreate（'あか', 'あお'の順）",
    "rust_lesson1_ex4_slide1_content": "# valueをかんたんに増やす・減らす\n\n`+=`（プラスイコール）と `-=`（マイナスイコール）は、variableの中身を増やしたり減らしたりdo便利な記号です。\n\nRustのImportantなルール：`mut`が必要！\nRustでは、variableをchangeには `let mut`（レット ミュート）とwrite必要があります。`mut` は「mutable（変更できる）」の略です。\n\ncodeExample：\n```rust\nlet mut score = 100;  // mut をつけて変更可能に\nscore += 10;          // 10を足す → 110に\nscore -= 50;          // 50を引く → 60に\n```\n\n`mut` がないと「このvariableは変えちゃダメ！」とRustが怒ります。",
    "rust_lesson2_ex1_slide2_title": "ムーブ（移動）",
    "rust_lesson3_ex4_comment1": "map で各elementを変換",
    "rust_lesson3_ex8_slide1_title": "unwrap_or ?",
    "rust_lesson2_ex5_slide1_content": "# implementationブロック\n\nimpl ブロックで、構造体にmethodを追加できます。`self` で自分自身をreferenceします。",
    "rust_lesson2_ex10_slide1_title": "ジェネリクス?",
    "rust_lesson1_ex8_slide2_content": "# 名前（key）で取り出す\n\ndictionaryに入れたデータは、名前（key）を指定して取り出せます。\n\ncodeExample：\n```rust\nuse std::collections::HashMap;\nfn main() {\n    let mut fruits = HashMap::new();\n    fruits.insert(\"りんご\", \"あか\");  // 追加\n    fruits.insert(\"バナナ\", \"きいろ\");  // 追加\n    \n    println!(\"{}\", fruits[\"りんご\"]);  // あか と表示\n}\n```\n\nPoint：\n- `insert(名前, データ)` で追加\n- `辞書[名前]` で取り出し\n- 番号ではなく「名前」で探せるのが便利！",
    "rust_lesson4_ex9_slide1_content": "# iteratorをコレクションに\n\ncollect は、iteratorをVecやHashMapなどに変換します。\n\n```rust\nlet v: Vec<_> = (0..5).collect();\nlet s: String = vec!['a', 'b'].into_iter().collect();\n```",
    "rust_lesson2_ex2_slide3_content": "所有権を移さずに値を借りる「参照」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex2_slide3_content": "周囲の変数を使える無名関数「クロージャ」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex4_slide2_content": "# struct keyワードでdefinition\n\n`struct 名前 { フィールド }` で構造体をdefine。フィールドには名前とtypeをwrite。\n\ncodeExample：\n```rust\n// Point 構造体を定義\nstruct Point {\n    x: i32,  // xフィールド（整数）\n    y: i32,  // yフィールド（整数）\n}\n\n// 使い方\nlet p = Point { x: 10, y: 20 };\nprintln!(\"x={}, y={}\", p.x, p.y);\n```\n\nPoint：\n- `struct 名前` で構造体をcreate\n- `{ フィールド名: 型 }` でどんなデータを持つか決める\n- `.フィールド名` でアクセス",
    "rust_lesson2_ex10_slide3_content": "型を後から決められる「ジェネリクス」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex6_slide3_title": "Let's Try It!",
    "rust_lesson4_ex6_slide1_content": "# 一意なvalueのset\n\nHashSet は、重複のないvalueのsetです。\n\n```rust\nuse std::collections::HashSet;\n\nlet mut set = HashSet::new();\nset.insert(1);\nset.insert(2);\nset.insert(1); // 重複は無視\n```",
    "rust_lesson4_ex2_title": "derive 属性",
    "rust_lesson4_ex2_slide1_content": "# トレイトを「自動で」implementation\n\n#[derive(...)] をuseと、よくuseトレイトを自分で書かなくても自動でimplementationしてくれます。\n\nFor example：\n構造体を `println!` でdisplayしたいとき、普通は Display トレイトをimplementationdo必要がありますが、`#[derive(Debug)]` をwriteだけでOK！\n\ncodeExample：\n```rust\n#[derive(Debug)]  // Debug トレイトを自動実装\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nlet p = Point { x: 1, y: 2 };\nprintln!(\"{:?}\", p);  // Point { x: 1, y: 2 }\n```",
    "rust_lesson1_ex6_slide2_title": "Let's Try It!",
    "rust_lesson3_ex3_slide2_title": "3つの iter method",
    "rust_lesson4_ex7_slide2_content": "# 複雑なconditional\n\n```rust\nmatch Some(5) {\n    Some(x) if x % 2 == 0 => println!(\"even\"),\n    Some(x) => println!(\"odd: {}\", x),\n    None => println!(\"none\"),\n}\n```",
    "rust_lesson3_ex3_slide1_content": "# elementを1つずつ取り出す仕組み\n\niterator は、ベクタなどのデータを「1つずつ順番に」取り出す仕組みです。\n\nFor example：\n- 行列に並んでいる人を1人ずつ呼ぶ\n- 引き出しの中身を1つずつ出す\n\ncodeExample：\n```rust\nlet v = vec![1, 2, 3];\nfor x in v.iter() {\n    println!(\"{}\", x);  // 1, 2, 3 と順番に表示\n}\n```\n\n`iter()` で「順番に取り出す準備」をして、`for` で1つずつ処理します。",
    "rust_lesson3_ex3_slide1_title": "iterator?",
    "rust_lesson4_ex2_description": "トレイトを自動implementationdoderiveを学びましょう。",
    "rust_lesson3_ex4_slide1_content": "# 全部を同じように変換do\n\n**map** は、iteratorの各elementを「同じ方法で」変換します。\n\nFor example：\n- 全員の身長を2倍にdo\n- 全員の名前を大文字にdo\n- 全部の数を2乗do\n\ncodeExample：\n```rust\nlet v = vec![1, 2, 3];\nlet doubled: Vec<_> = v.iter()\n    .map(|x| x * 2)  // 各要素を2倍に\n    .collect();      // ベクタに戻す\n// [2, 4, 6]\n```\n\n`|x| x * 2` は「xを受け取って、x*2をreturn」closureです。",
    "rust_lesson1_ex3_slide1_title": "あまりを求める",
    "rust_lesson3_ex10_slide1_content": "# 所有権の違い\n\nString は所有権を持つheap上のstring、&str はreferenceです。\n\n```rust\nlet s1: String = String::from(\"hello\");\nlet s2: &str = \"hello\";\n```",
    "rust_lesson4_ex2_slide1_title": "derive（デライブ）?",
    "rust_lesson2_ex2_comment1": "& でreferenceを渡す",
    "rust_lesson4_ex5_slide1_title": "HashMap（ハッシュmap）?",
    "rust_lesson2_ex3_slide2_title": "&mut  Usage",
    "rust_lesson3_ex5_title": "filter で絞り込み",
    "rust_lesson4_ex3_slide2_title": "いつuse？",
    "rust_lesson2_ex2_title": "referenceと借用",
    "rust_lesson2_ex7_title": "Option<T> で null を安全に",
    "rust_lesson4_ex10_slide3_title": "Let's Try It!",
    "rust_lesson3_ex5_slide3_title": "Let's Try It!",
    "rust_lesson4_ex10_title": "enumerate でindex付き",
    "rust_lesson2_ex2_slide1_content": "# 所有権を渡さずに「借りる」\n\nreference をuseと、所有権を移さずにデータを「見せてもらう」ことができます。\n\nたとえるなら：\n- ムーブ = おもちゃをあげる（自分は使えない）\n- reference = おもちゃを見せる（自分も使える）\n\n作り方：\n`&`（アンパサンド）をつけるとreferenceを作れます。\n\n```rust\nlet s = String::from(\"hello\");\nlet r = &s;  // sを借りる（見せてもらう）\n// s も r も使える！\n```",
    "rust_lesson2_ex5_slide2_content": "# &self をuse\n\nmethodの最初のargumentは `&self` です。\n\ncodeExample：\n```rust\nimpl Rect {\n    fn area(&self) -> i32 {\n        self.width * self.height\n    }\n}\n```",
    "rust_lesson1_ex5_slide2_title": "Let's Try It!",
    "rust_lesson2_ex4_slide3_title": "Let's Try It!",
    "rust_lesson4_ex3_slide3_title": "Let's Try It!",
    "rust_lesson2_ex9_slide3_content": "共通の振る舞いを定義する「トレイト」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex1_slide2_content": "# impl で約束を守る\n\n構造体にトレイトをimplementationdoと、その構造体は「約束を守る」ことになります。\n\ncodeExample：\n```rust\nstruct Person { name: String }\n\nimpl Greet for Person {\n    fn greet(&self) -> String {\n        format!(\"Hello, {}\", self.name)\n    }\n}\n```\n\n読み方：\n- `impl Greet for Person` → 「PersonはGreetをimplementationdo」\n- これでPersonは「あいさつできる」ようになった！",
    "rust_lesson4_ex4_comment1": "clone でreferenceカウントを増やす",
    "rust_lesson3_ex4_slide2_content": "# map だけではexecuteされない！\n\nRustのiteratorは 遅延評価 といって、「本当に必要になるまで処理しない」仕組みです。\n\nなぜ？\n無駄な計算を省けるから。100万件あっても、最初の10件だけ欲しいなら10件だけ処理すればいい。\n\ncollect() でexecute：\n```rust\n// これだけでは何も起きない\nv.iter().map(|x| x * 2);\n\n// collect() で実行してベクタに変換\nlet result: Vec<_> = v.iter().map(|x| x * 2).collect();\n```\n\n`collect()` は「今すぐ全部処理してResultをちょうだい」という意味です。",
    "rust_lesson2_ex4_slide2_title": "struct のdefinitionのしかた",
    "rust_lesson2_ex3_slide1_content": "# 「書き換えできる」借り方\n\n普通のreference `&` は「見るだけ」ですが、可変reference `&mut` は「変更もできる」借り方です。\n\nたとえるなら：\n- `&` = 本を見せてもらう（readだけ）\n- `&mut` = ノートを借りる（writeOK）\n\nImportantなルール：\n- 可変referenceは同時に1つだけ！\n- 「みんなで見る」か「1人でwrite」かのどちらか\n\nこのルールで、データが同時に書き換えられるバグを防いでいます。",
    "rust_lesson2_ex10_slide3_title": "Let's Try It!",
    "rust_lesson2_ex4_title": "構造体をdefinitionしよう",
    "rust_lesson3_ex10_slide2_content": "# 相互変換\n\n```rust\n// &str -> String\nlet s = \"hello\".to_string();\n\n// String -> &str\nlet slice: &str = &s;\n```",
    "rust_lesson4_ex10_slide3_content": "イテレータにインデックスを付けましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex4_slide2_content": "# 「何人が持っているか」を数える\n\nRcは「今何人がこのデータを持っているか」を数えています。\n\ncodeExample：\n```rust\nlet a = Rc::new(5);\nprintln!(\"{}\", Rc::strong_count(&a));  // 1\n\nlet b = Rc::clone(&a);\nprintln!(\"{}\", Rc::strong_count(&a));  // 2\n```\n\nいつデータが消える？\n- カウントが0になったとき（誰も持っていないとき）\n- 最後の持ち主がいなくなると自動で片付けられる\n\n`Rc::clone` は「持ち主を1人増やす」操作です。",
    "rust_lesson1_ex8_slide2_title": "dictionary Usage",
    "rust_lesson4_ex3_slide1_content": "# データを「heap」に置く箱\n\nBox<T> は、データを「heap」という特別な場所に置くための箱です。\n\nmemoryの2つの場所：\n- stack：小さくて速い。サイズが決まっているデータ向け\n- heap：大きくて柔軟。サイズが大きいor変わるデータ向け\n\ncodeExample：\n```rust\nlet b = Box::new(5);  // 5をヒープに置く\nprintln!(\"{}\", *b);   // *で中身を取り出す → 5\n```\n\n`*` は「箱を開けて中身を見る」操作です。",
    "rust_lesson3_ex2_slide2_title": "closure Syntax",
    "rust_lesson4_ex4_slide1_title": "Rc（アールシー）?",
    "rust_lesson4_ex7_slide1_content": "# 追加条件\n\n**if** でパターンに追加条件をつけられます。\n\n```rust\nmatch x {\n    n if n < 0 => println!(\"negative\"),\n    n if n > 0 => println!(\"positive\"),\n    _ => println!(\"zero\"),\n}\n```",
    "rust_lesson2_ex3_title": "可変reference",
    "rust_lesson3_ex10_comment1": "to_string で String に変換",
    "rust_lesson3_ex10_slide2_title": "変換",
    "rust_lesson3_ex1_description": "referenceの有効期間を表すライフタイムを学びましょう。",
    "rust_lesson3_ex2_slide1_content": "# 名前のない「即席」function\n\nclosure は、名前をつけずにその場でcreatefunctionです。そして特別な能力があります：周りのvariableを使えるのです！\n\nFor example：\n```rust\nlet x = 5;  // 外側の変数\nlet add_x = |n| n + x;  // xを使えるクロージャ\nprintln!(\"{}\", add_x(10));  // 15\n```\n\n普通のfunctionとの違い：\n- 普通のfunction：argumentしか使えない\n- closure：argument + 周りのvariableも使える\n\n「その場の空気を読める」functionというイメージです！",
    "rust_lesson1_ex2_comment1": "x に 10 を入れる",
    "rust_lesson1_ex7_slide3_title": "Let's Try It!",
    "rust_lesson1_ex5_title": "「もし〜なら」で分けましょう",
    "rust_lesson3_ex2_slide3_title": "Let's Try It!",
    "rust_lesson3_ex7_slide2_content": "# 簡潔なerror処理\n\n```rust\n// ? を使わない場合\nmatch result {\n    Ok(v) => v,\n    Err(e) => return Err(e),\n}\n\n// ? を使う\nresult?\n```",
    "rust_lesson3_ex6_slide3_title": "Let's Try It!",
    "rust_lesson4_ex9_slide3_content": "イテレータをコレクションに変換しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex6_description": "elementを1つのvalueにまとめるfoldを学びましょう。",
    "rust_lesson2_ex9_description": "共通の振る舞いをdefine「トレイト」を学びましょう。",
    "rust_lesson2_ex8_comment1": "Ok で成功をreturn",
    "rust_lesson3_ex5_slide2_content": "# filter はreferenceのreferenceを受け取る\n\n`filter` のclosureは、referenceのreference（`&&T`）を受け取ります。そのため、valueをuseには `**x` と2回referenceを外す必要があります。\n\nなぜ？\n- `iter()` はreference（`&T`）をreturn\n- `filter` はそれをFurthermorereferenceで渡す（`&&T`）\n\nSyntax：\n```rust\n// **x で値を取り出す\n.filter(|x| **x > 2)\n\n// または * を引数につける\n.filter(|&x| *x > 2)\n```\n\n最初は混乱しますが、慣れれば大丈夫！",
    "rust_lesson1_ex5_comment1": "> でcompare",
    "rust_lesson2_ex4_description": "関連doデータをまとめる「構造体」を学びましょう。",
    "rust_lesson3_ex5_slide3_content": "条件に合う要素だけを取り出しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex7_slide3_content": "「ベクタ（Vec）」を使うと、たくさんのデータを一つの「長い はこ」にまとめて入れられます。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex5_slide2_title": "valueの取得",
    "rust_lesson3_ex1_slide1_title": "ライフタイム?",
    "rust_lesson1_ex3_comment1": "10 を 3 で割ったあまりをoutput",
    "rust_lesson3_ex1_comment1": "'a でライフタイムをdefinition",
    "rust_lesson3_ex10_slide1_title": "String vs &str",
    "rust_lesson2_title": "Rust II - 所有権とトレイト",
    "rust_lesson2_ex5_slide2_title": "methodのdefinition",
    "rust_lesson4_ex5_comment1": "insert でkeyとvalueを追加",
    "rust_lesson2_ex9_slide1_content": "# 「できること」の約束\n\nトレイト は、「このtypeはこういうことができる」という約束をdefine。\n\nFor example「鳴ける」という約束：\n- 犬は「ワン」と鳴く\n- 猫は「ニャー」と鳴く\n- 両方とも「鳴ける」能力がある\n\nトレイトは「鳴ける動物は、鳴き声を出すmethodを持つ」という約束です。\n\n他の言語とのcomparison：\n- Java: interface\n- TypeScript: interface\n\nに似た概念です。",
    "rust_lesson1_ex2_slide3_title": "Let's Try It!",
    "rust_lesson4_ex8_slide1_content": "# return valueのtypeをabstract化\n\nimpl Trait で、トレイトをimplementationdotypeを返せます。\n\n```rust\nfn make_iter() -> impl Iterator<Item = i32> {\n    vec![1, 2, 3].into_iter()\n}\n```",
    "rust_lesson1_ex2_slide2_content": "# 四則演算（しそくえんざん）\n\nRustでも算数と同じ記号で計算ができます。\n\n4つのBasic記号：\n- +（プラス）: たし算\n- -（マイナス）: ひき算\n- \\*（アスタリスク）: かけ算（×の代わり）\n- /（スラッシュ）: わり算（÷の代わり）\n\ncodeExample：\n```rust\nlet a = 10;\nlet b = 5;\nprintln!(\"{}\", a + b);  // 15 と表示される\n```\n\n`println!` の `{}` は「ここにvalueを入れてね」という目印です。",
    "rust_lesson4_ex9_slide2_content": "# 変換先を指定\n\n```rust\n// ターボフィッシュ構文\nlet v = (0..5).collect::<Vec<_>>();\n\n// 変数の型注釈\nlet v: Vec<i32> = (0..5).collect();\n```",
    "rust_lesson1_ex8_description": "「dictionary（HashMap）」をuseと、名前をつけてデータを保存し、その名前で取り出せます。",
    "rust_lesson4_ex9_slide2_title": "typeHint",
    "rust_lesson3_ex1_title": "ライフタイムのBasic",
    "rust_lesson2_ex5_description": "構造体にmethodをadd「impl」を学びましょう。",
    "rust_lesson4_ex8_comment1": "impl でトレイトをimplementationdotypeをreturn",
    "rust_lesson4_ex8_slide2_title": "argumentにも使える",
    "rust_lesson4_ex7_comment1": "if でマッチガードを追加",
    "rust_lesson2_ex9_slide2_title": "trait のdefinitionとimplementation",
    "rust_lesson4_ex10_slide2_title": "いつuse？",
    "rust_lesson3_ex7_slide2_title": "match の省略形",
    "rust_lesson1_ex6_title": "logicaloperator（&&、||）",
    "rust_lesson3_ex6_comment1": "fold で畳み込み",
    "rust_lesson2_ex6_description": "複数の状態を表す「列挙type（enum）」を学びましょう。",
    "rust_lesson4_ex10_slide1_title": "enumerate（イニュメレート）?",
    "rust_lesson1_ex7_slide1_title": "ベクタ（Vec）?",
    "rust_lesson2_ex6_slide3_content": "複数の状態を表す「列挙型（enum）」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex3_slide3_title": "Let's Try It!",
    "rust_lesson3_ex4_description": "各elementを変換domapを学びましょう。",
    "rust_lesson4_ex1_slide3_title": "Let's Try It!",
    "rust_lesson3_ex9_slide2_title": "mut が必要",
    "rust_lesson1_ex6_slide1_content": "# logicaloperator（ろんりえんざんし）\n\n2つ以上の条件を組み合わせたいときにuse記号です。\n\n2つの記号：\n- `&&`（アンドアンド）：「かつ」＝ 両方とも 正しいとき\n- `||`（オアオア）：「Alsoは」＝ どちらか 正しいとき\n\n身近なExample：\n- 遊園地：「18歳以上 かつ チケットあり」なら乗れる\n- おやつ：「宿題終わった Alsoは お手伝いした」ならOK\n\ncodeExample：\n```rust\nif score >= 70 && bonus > 0 {\n    // 70点以上 かつ ボーナスあり → 合格！\n    println!(\"合格！\");\n}\n```",
    "rust_lesson4_ex4_slide3_content": "参照カウントでデータを共有しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex6_slide3_title": "Let's Try It!",
    "rust_lesson2_ex5_slide3_content": "構造体にメソッドを追加する「impl」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex1_slide3_title": "Let's Try It!",
    "rust_lesson1_ex5_slide1_content": "# programに「判断」させよう\n\nconditional は、「もし〜なら、〇〇do」という判断をprogramにさせる仕組みです。\n\n身近なExample：\n- もし80点以上なら → 「合格！」とdisplay\n- もし雨なら → 傘を持っていく\n- もしHPが0なら → ゲームオーバー\n\nRustで Syntax：\n```rust\nif score > 80 {\n    println!(\"合格！\");\n}\n```\n\n読み方：\n- `if` →「もし」\n- `score > 80` →「スコアが80より大きいなら」\n- `{ }` の中 →「これをやる」",
    "rust_lesson4_ex5_title": "HashMap",
    "rust_lesson1_ex2_slide1_content": "# データを保存do「はこ」\n\nvariable（へんすう） は、数字や文字を入れておける「はこ」のことです。名前をつけて、あとでuseことができます。\n\nFor example：\n- 「りんごの数」というラベルの箱に「5」を入れる\n- あとで「りんごの数」と呼べば「5」が出てくる\n\nRustで Syntax：\n```rust\nlet x = 10;  // xという箱に10を入れる\nprintln!(\"{}\", x);  // xの中身（10）を表示\n```\n\n`let` は「この名前で箱をcreateよ」という意味です。",
    "rust_lesson2_ex4_slide3_content": "関連するデータをまとめる「構造体」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex6_slide1_title": "enum ?",
    "rust_lesson2_ex9_title": "トレイトをdefinitionしよう",
    "rust_lesson2_ex4_slide1_title": "構造体（こうぞうたい）?",
    "rust_lesson4_ex2_slide2_content": "# 覚えておくと便利な5つ\n\nよくusederiveトレイト：\n```rust\nDebug     // {:?} でデバッグ表示できる\nClone     // .clone() でコピーを作れる\nCopy      // 代入時に自動でコピー（小さい型向け）\nPartialEq // == で比較できる\nDefault   // 初期値を自動で作れる\n```\n\n複数指定もOK：\n```rust\n#[derive(Debug, Clone, PartialEq)]\nstruct User {\n    name: String,\n    age: u32,\n}\n```\n\n`Debug` は特によくuse。debug時に構造体の中身を見れて便利！",
    "rust_lesson2_ex1_slide1_content": "# データの「持ち主」を決めるルール\n\n所有権 は、Rust最大のFeatureです。「このデータの持ち主は誰か」をはっきりさせる仕組みです。\n\nルール：\n- データには必ず1人だけ「持ち主」がいる\n- 持ち主がいなくなると、データは自dynamicに片付けられる\n\nたとえるなら：\n- おもちゃは1人しか持てない\n- 持ち主が部屋を出たら、おもちゃは片付けられる\n\nこのルールのおかげで、Rustは「memoryリーク」（データが片付けられないバグ）を防げます！",
    "rust_lesson1_ex3_slide2_title": "Let's Try It!",
    "rust_lesson3_ex1_slide2_title": "なぜ必要？",
    "rust_lesson3_ex1_slide2_content": "# 危険なバグを防ぐ\n\nダングリングreference という危険なバグがあります。これは「もう存在しないデータ」を指し続けているreferenceのことです。\n\nExample：\n```rust\nfn longest<'a>(x: &'a str, y: &'a str) -> &'a str {\n    if x.len() > y.len() { x } else { y }\n}\n```\n\n`'a` の意味：\n- argument `x` と `y` は同じライフタイム `'a` を持つ\n- return valueも同じライフタイム `'a` を持つ\n- In other words「xとyが両方有効な間、return valueも有効」という約束\n\nRustはこれを自動でチェックしてくれます！",
    "rust_lesson4_ex6_slide2_title": "set演算",
    "rust_lesson3_ex7_comment1": "? でerrorを伝播",
    "rust_lesson3_ex2_slide2_content": "# | | でargumentを囲む\n\nclosureは `|引数| 処理` という形でwrite。`||` は「パイプ」と呼ばれます。\n\nいろいろなSyntax：\n```rust\n// 引数なし\n|| println!(\"Hello\")\n\n// 引数あり\n|x, y| x + y\n\n// 複数行のブロック\n|x| {\n    let y = x * 2;\n    y + 1\n}\n```\n\nPoint：\n- argumentを `| |` で囲む（functionの `()` の代わり）\n- typeは省略できることが多い（Rustが推測してくれる）",
    "rust_lesson2_ex7_comment1": "Some でvalueがあることを示す",
    "rust_lesson3_ex4_slide3_content": "各要素を変換するmapを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_title": "Rust (ラスト) に挑戦！",
    "rust_lesson2_ex8_description": "成功と失敗を表す「Result」を学びましょう。",
    "rust_lesson3_ex8_description": "Option/Resultのデフォルトvalueを設定しましょう。",
    "rust_lesson4_ex2_slide3_title": "Let's Try It!",
    "rust_lesson2_ex5_slide3_title": "Let's Try It!",
    "rust_lesson4_ex9_description": "iteratorをコレクションに変換しましょう。",
    "rust_lesson1_ex1_slide2_content": "# println! でscreenにdisplay\n\nRustで文字をscreenにdisplayには、`println!`（プリントラインびっくり）をuse。\n\nPoint：\n- `!` がつくのがRustのFeature（マクロと呼ばれます）\n- programは `fn main() { }` の中にwrite\n- `fn` は「function（function）」の略\n\ncodeExample：\n```rust\nfn main() {\n    println!(\"ヤッホー！\");\n}\n// 「ヤッホー！」と画面に表示される\n```\n\n`println!` の `!` は「マクロ」という特別な機能の印です。今は「おまじない」と思っておけばOK！",
    "rust_lesson3_ex6_slide1_title": "fold ?",
    "rust_lesson4_ex8_slide1_title": "impl Trait ?",
    "rust_lesson1_ex1_slide2_title": "Rustの「おまじない」",
    "rust_lesson3_ex10_description": "stringtypeの違いを理解しましょう。",
    "rust_lesson3_ex7_slide3_content": "エラーを簡潔に伝播させましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex1_comment1": "s1 の所有権を移動",
    "rust_lesson2_ex9_slide1_title": "トレイト?",
    "rust_lesson4_ex6_slide2_content": "# 和set、積setなど\n\n```rust\nset1.union(&set2)\nset1.intersection(&set2)\nset1.difference(&set2)\n```",
    "rust_lesson4_ex5_slide3_content": "キーと値のペアを格納しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex8_slide1_title": "Result（リザルト）?",
    "rust_lesson4_ex1_slide1_content": "# 「できること」の約束\n\nトレイト は、typeが持つべきmethodをdefine仕組みです。\n\nFor example：\n- 「あいさつできる」トレイト → greet() methodを持つ\n- 「displayできる」トレイト → display() methodを持つ\n\ncodeExample：\n```rust\ntrait Greet {\n    fn greet(&self) -> String;  // メソッドの「約束」\n}\n```\n\nこれは「Greetできるtypeは、greet()methodを持つ」という約束です。",
    "rust_lesson4_ex2_slide3_content": "トレイトを自動実装するderiveを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex6_title": "fold で畳み込み",
    "rust_lesson3_ex9_slide3_content": "Vecに要素を追加しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex4_slide1_content": "# 関係あるデータをまとめる「設計図」\n\n構造体（struct） は、いくつかのデータをひとまとめにdo仕組みです。\n\nFor example「点（座標）」のデータ：\n- x座標\n- y座標\n\nこの2つは関係があるので、「Point（点）」としてまとめると便利です。\n\nFor example「人」のデータ：\n- 名前\n- 年齢\n\nこれも「Person（人）」としてまとめられます。\n\n構造体は「こういうデータを持つ」という設計図です。",
    "rust_lesson4_ex1_slide1_title": "トレイト?（復習）",
    "rust_lesson2_ex3_description": "reference先のvalueを変更できる「可変reference」を学びましょう。",
    "rust_lesson2_ex7_slide2_content": "# match で安全に取り出す\n\n`match` を使って「ある場合」と「ない場合」で処理を分けます。\n\ncodeExample：\n```rust\nlet x: Option<i32> = Some(5);  // 値あり\n\nmatch x {\n    Some(n) => println!(\"値は{}です\", n),  // 5\n    None => println!(\"値がありません\"),\n}\n```\n\nなぜ安全？\n- `null` のように「あるつもりでアクセスしたら無かった」errorが起きない\n- 「ない場合」の処理を書かないとコンパイルerrorになる\n- 強制的に両方のケースを考えることになる！",
    "rust_lesson4_ex9_comment1": "collect で Vec に変換",
    "rust_lesson3_ex10_title": "String と &str",
    "rust_lesson2_ex7_slide1_title": "Option（オプション）?",
    "rust_lesson3_ex9_description": "Vecにelementを追加しましょう。",
    "rust_lesson2_ex5_comment1": "impl でmethodをimplementation",
    "rust_lesson3_ex1_slide3_content": "参照の有効期間を表すライフタイムを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex6_slide2_content": "複数の条件を組み合わせる「&&（かつ）」と「||（または）」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex5_comment1": "filter で条件に合うelementを絞り込む",
    "rust_lesson2_ex7_slide3_content": "値があるかないかを表す「Option」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex10_slide3_title": "Let's Try It!",
    "rust_lesson4_ex4_slide3_title": "Let's Try It!",
    "rust_lesson3_ex3_comment1": "iter でiteratorを取得",
    "rust_lesson3_ex6_slide3_content": "要素を1つの値にまとめるfoldを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex7_slide2_title": "ベクタの番号は「0」から！",
    "rust_lesson1_ex5_slide1_title": "conditional（じょうけんぶんき）?",
    "rust_lesson1_ex3_description": "割り算の「あまり」を求める「%」（パーセント）operatorを学びましょう。",
    "rust_lesson1_ex1_slide3_content": "Rustを使って画面に文字を表示してみましょう。println! という特別な関数を使います。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex10_slide2_content": "# <T> でtypeを「あとで決める」\n\nfunction名の後に `<T>` をつけて、`T` を「type」としてuse。\n\ncodeExample：\n```rust\n// Tはどんな型でもOK\nfn first<T>(arr: &[T]) -> &T {\n    &arr[0]  // 最初の要素を返す\n}\n\n// 使い方\nfirst(&[1, 2, 3]);         // Tはi32\nfirst(&[\"a\", \"b\", \"c\"]);   // Tは&str\n```\n\n読み方：\n- `<T>` → 「Tという名前のtypeをuseよ」\n- `T` は慣習で「Type（type）」の頭文字\n- 複数のtypeが必要なら `<T, U>` のようにwrite",
    "rust_lesson3_ex2_comment1": "|x| でclosureのargumentをdefinition",
    "rust_lesson3_ex3_description": "elementを順番に処理doiteratorを学びましょう。",
    "rust_lesson1_ex1_slide3_title": "Let's Try It!",
    "rust_lesson2_ex6_slide2_title": "enum のdefinition",
    "rust_lesson2_ex1_title": "所有権のBasic",
    "rust_lesson4_ex3_slide1_title": "Box（ボックス）?",
    "rust_lesson2_ex1_slide3_content": "Rust独自の概念「所有権」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex8_slide3_content": "Option/Resultのデフォルト値を設定しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex7_slide2_title": "使用Example",
    "rust_lesson4_ex10_description": "iteratorにindexを付けましょう。",
    "rust_lesson4_ex9_slide1_title": "collect ?",
    "rust_lesson4_ex10_slide2_content": "# 「何番目か」が必要なとき\n\n番号（index）とelementの両方が必要なときに便利です。\n\ncodeExample：\n```rust\nlet v = vec![10, 20, 30];\nfor (idx, val) in v.iter().enumerate() {\n    println!(\"{}番目の値は{}\", idx, val);\n}\n// 0番目の値は10\n// 1番目の値は20\n// 2番目の値は30\n```\n\nPoint：\n- `(i, x)` でtuple（2つのset）を受け取る\n- `i` にindex、`x` にelementが入る\n- indexは0から始まる",
    "rust_lesson3_ex2_description": "周囲のvariableを使えるanonymous function「closure」を学びましょう。",
    "rust_lesson1_ex4_comment1": "mut で変更可能にdo",
    "rust_lesson1_ex8_slide3_title": "Let's Try It!",
    "rust_lesson1_ex3_slide2_content": "割り算の「あまり」を求める「%」（パーセント）演算子を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex9_slide3_title": "Let's Try It!",
    "rust_lesson3_ex3_title": "iteratorのBasic",
    "rust_lesson3_ex9_title": "Vec のmethod push",
    "rust_lesson1_ex8_comment1": "dictionaryをcreate（keyは'みかん'、valueは'オレンジ'）",
    "rust_lesson1_ex2_comment3": "+ でたし算do",
    "rust_lesson4_ex8_slide2_content": "# ジェネリクスの代わり\n\n```rust\nfn print_all(iter: impl Iterator<Item = i32>) {\n    for x in iter {\n        println!(\"{}\", x);\n    }\n}\n```",
    "rust_lesson2_ex2_slide2_title": "reference Usage",
    "rust_lesson1_ex8_slide3_content": "「辞書（HashMap）」を使うと、名前をつけてデータを保存し、その名前で取り出せます。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex7_slide2_content": "# [ ]で番号を指定して取り出す\n\n`[番号]` で何番目のデータか指定して取り出せます。\n\nImportantなルール：番号は「0」から！\n- 1番目 → `[0]`\n- 2番目 → `[1]`\n- 3番目 → `[2]`\n\ncodeExample：\n```rust\nlet fruits = vec![\"りんご\", \"バナナ\", \"みかん\"];\n//                  ↑0番    ↑1番     ↑2番\nprintln!(\"{}\", fruits[0]);  // りんご\nprintln!(\"{}\", fruits[1]);  // バナナ\n```\n\nプログラミングでは「0から数える」のが世界共通のルールです！",
    "rust_lesson1_ex6_slide1_title": "条件を組み合わせる",
    "rust_lesson2_ex10_slide2_title": "ジェネリックfunction Syntax",
    "rust_lesson1_ex6_description": "複数の条件を組み合わせる「&&（かつ）」と「||（Alsoは）」を学びましょう。",
    "rust_lesson4_ex6_title": "HashSet",
    "rust_lesson2_ex3_slide2_content": "# mut が2か所に必要\n\n変更できるようにdoには、variableとreferenceの両方に `mut` が必要です。\n\ncodeExample：\n```rust\n// 1. 変数を mut で作る\nlet mut s = String::from(\"hello\");\n\n// 2. &mut で可変参照を渡す\nchange(&mut s);\n\nfn change(s: &mut String) {\n    s.push_str(\" world\");  // 変更できる！\n}\n```\n\nPoint：\n- `let mut 変数` でvariableを変更可能に\n- `&mut 変数` で可変referenceをcreate\n- 両方ないと変更できない！",
    "rust_lesson2_ex2_slide1_title": "reference（さんしょう）?",
    "rust_lesson3_ex6_slide2_content": "# 合計、積、結合など\n\n```rust\n// 積\nv.iter().fold(1, |acc, x| acc * x)\n\n// 文字列結合\nwords.iter().fold(String::new(), |acc, s| acc + s)\n```",
    "rust_lesson1_ex1_description": "Rustを使ってscreenに文字をdisplayしてみましょう。println! という特別なfunctionをuse。",
    "rust_lesson3_ex8_slide3_title": "Let's Try It!",
    "rust_lesson4_ex6_description": "一意なvalueのsetを管理しましょう。",
    "rust_lesson2_ex5_slide1_title": "impl ?",
    "rust_lesson1_ex8_title": "名前で引き出す「dictionary」",
    "rust_lesson2_ex7_description": "valueがあるかないかを表す「Option」を学びましょう。",
    "rust_lesson1_ex4_slide2_title": "Let's Try It!",
    "rust_lesson1_ex7_title": "たくさんのデータをまとめましょう「ベクタ」",
    "rust_lesson3_ex7_slide1_content": "# errorの早期リターン\n\n? は、Resultが Err の場合に早期リターンします。\n\n```rust\nfn read_file() -> Result<String, io::Error> {\n    let content = fs::read_to_string(\"file.txt\")?;\n    Ok(content)\n}\n```",
    "rust_lesson3_ex9_slide1_content": "# 末尾に追加\n\npush は、Vecの末尾にelementをadd。\n\n```rust\nlet mut v = vec![1, 2];\nv.push(3);\n// [1, 2, 3]\n```",
    "rust_lesson4_ex8_slide3_content": "トレイトを返す関数を簡潔に書きましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex1_title": "screenにメッセージを出しましょう",
    "rust_lesson2_ex8_slide2_title": "Result  Usage",
    "rust_lesson3_ex2_slide1_title": "closure?",
    "rust_lesson3_ex8_title": "unwrap_or でデフォルトvalue",
    "rust_lesson4_ex10_slide1_content": "# 番号とelementを一緒にもらう\n\nenumerate は、「何番目か」と「そのelement」をsetで取り出せるmethodです。\n\nFor example：\n- 0番目: りんご\n- 1番目: バナナ\n- 2番目: みかん\n\ncodeExample：\n```rust\nfor (i, x) in vec![\"a\", \"b\", \"c\"].iter().enumerate() {\n    println!(\"{}: {}\", i, x);\n}\n// 0: a\n// 1: b\n// 2: c\n```",
    "rust_lesson1_ex7_slide1_content": "# データを並べてまとめる「長い箱」\n\nベクタ（Vec） は、たくさんのデータを順番に並べて入れられる「長い箱」です。\n\nFor example：\n- 買い物listの商品を全部まとめる\n- testの点数を全部まとめる\n- 友だちの名前を全部まとめる\n\n100個でも1000個でも、1つのvariableでまとめて管理できます！\n\n作り方：\n```rust\nlet fruits = vec![\"りんご\", \"バナナ\", \"みかん\"];\n// vec! で ベクタを作る\n```",
    "rust_lesson4_ex8_slide3_title": "Let's Try It!",
    "rust_lesson4_ex7_description": "パターンマッチに条件を追加しましょう。",
    "rust_lesson1_ex4_comment2": "+= で 20 を足す",
    "rust_lesson1_ex2_comment2": "y に 5 を入れる",
    "rust_lesson2_ex3_slide3_title": "Let's Try It!",
    "rust_lesson3_ex4_slide1_title": "map（map）?",
    "rust_lesson1_ex2_slide3_content": "データに名前をつけて保存できる「変数（へんすう）」を使ってみましょう。letで変数を作ります。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex8_slide2_content": "# match で成功と失敗を分ける\n\n`match` で「成功したら」「失敗したら」の処理を書き分けます。\n\ncodeExample：\n```rust\nfn divide(a: i32, b: i32) -> Result<i32, String> {\n    if b == 0 {\n        return Err(\"0で割れません\".to_string());\n    }\n    Ok(a / b)  // 成功なら答えを返す\n}\n\nmatch divide(10, 2) {\n    Ok(v) => println!(\"答えは{}\", v),\n    Err(e) => println!(\"エラー: {}\", e),\n}\n```\n\nPoint：\n- `Ok(値)` で成功をreturn\n- `Err(エラー)` で失敗をreturn",
    "rust_lesson4_ex3_comment1": "Box::new でheapに格納",
    "rust_lesson4_ex8_description": "トレイトをreturnfunctionを簡潔に書きましょう。",
    "rust_lesson2_ex10_description": "typeを後から決められる「ジェネリクス」を学びましょう。",
    "rust_lesson2_ex3_slide1_title": "可変reference（かへんさんしょう）?",
    "rust_lesson2_ex2_description": "所有権を移さずにvalueを借りる「reference」を学びましょう。",
    "rust_lesson3_ex5_slide2_title": "** にNote！",
    "rust_lesson2_ex2_slide3_title": "Let's Try It!",
    "rust_lesson4_ex3_slide3_content": "ヒープにデータを格納するBoxを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex4_title": "累算assignmentoperator（+=、-=）",
    "rust_lesson3_ex3_slide2_content": "# 借りるか、もらうか\n\n3種類の iter があり、所有権の扱いが違います。\n\n3つの違い：\n```rust\nv.iter()       // 参照で借りる（&T）\nv.iter_mut()   // 変更可能で借りる（&mut T）\nv.into_iter()  // 所有権をもらう（T）\n```\n\n使い分け：\n- `iter()` → 見るだけ（元のベクタも使える）\n- `iter_mut()` → 中身を変更したい\n- `into_iter()` → ベクタごともらう（元は使えない）\n\n普通は `iter()` をuseことが多いです。",
    "rust_lesson2_ex1_slide1_title": "所有権（しょゆうけん）?",
    "rust_lesson4_ex6_slide3_content": "一意な値の集合を管理しましょう。\n\n（When you're ready, select \"Start Lesson\".）"
  },
  "ru": {
    "rust_lesson1_course_title": "Introduction to Rust",
    "rust_lesson1_course_description": "Learn the basics of Rust programming.",
    "rust_lesson2_course_title": "Rust II - Intermediate",
    "rust_lesson2_course_description": "Learn intermediate Rust concepts.",
    "rust_lesson3_course_title": "Rust III - Advanced",
    "rust_lesson3_course_description": "Master advanced Rust techniques.",
    "rust_lesson4_course_title": "Rust IV - Expert Level",
    "rust_lesson4_course_description": "Expert-level Rust programming.",
    "rust_lesson1_ex5_slide2_content": "条件によって動きを変える if文を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex9_title": "collect で変換",
    "rust_lesson2_ex7_slide1_content": "# 「あるかもしれない、ないかもしれない」\n\nOption<T> は、valueが「あるかもしれないし、ないかもしれない」ことを表すtypeです。\n\nFor example：\n- dictionaryで単語を探す → 見つかるかもしれないし、ないかもしれない\n- ゲームでアイテムを拾う → 落ちてるかもしれないし、ないかもしれない\n\n2つの状態：\n- `Some(値)` → valueがある！\n- `None` → valueがない...\n\n他の言語では `null` をuseが、Rustでは `Option` で安全に扱います。",
    "rust_lesson1_ex2_slide1_title": "variable（へんすう）?",
    "rust_lesson1_ex7_description": "「ベクタ（Vec）」をuseと、たくさんのデータを一つの「長い はこ」にまとめて入れられます。",
    "rust_lesson2_ex9_slide2_content": "# 約束を作って、守る\n\n1. `trait` で「約束」をdefinition\n2. `impl トレイト for 型` で「約束を守る」implementationをdo\n\ncodeExample：\n```rust\n// 1. トレイト（約束）を定義\ntrait Speak {\n    fn speak(&self);  // 鳴くメソッドを持つ約束\n}\n\n// 2. Dog構造体がトレイトを実装\nstruct Dog;\nimpl Speak for Dog {\n    fn speak(&self) {\n        println!(\"woof\");\n    }\n}\n```\n\n「DogはSpeakができる」ということになります。",
    "rust_lesson4_ex4_description": "referenceカウントでデータを共有しましょう。",
    "rust_lesson4_ex5_slide1_content": "# 名前で引ける「dictionary」\n\nHashMap は、「key（名前）」と「value（データ）」をsetで保存dodictionaryです。\n\nFor example：\n- 「青チーム」→ 10点\n- 「赤チーム」→ 15点\n\ncodeExample：\n```rust\nuse std::collections::HashMap;\n\nlet mut scores = HashMap::new();\nscores.insert(\"Blue\", 10);   // 追加\nscores.insert(\"Red\", 15);    // 追加\n```\n\n`use` で機能を読み込んでからuse。",
    "rust_lesson3_ex4_title": "map でiterator変換",
    "rust_lesson4_ex1_slide3_content": "共通の振る舞いを定義するトレイトを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex4_description": "variableのvalueを手軽に増やしたり減らしたりdo「+=」「-=」を学びましょう。",
    "rust_lesson1_ex2_description": "データに名前をつけて保存できる「variable（へんすう）」を使ってみましょう。letでvariableをcreate。",
    "rust_lesson4_ex4_slide2_title": "referenceカウントの仕組み",
    "rust_lesson3_ex8_slide2_title": "unwrap_or_else",
    "rust_lesson4_ex10_comment1": "1番目の i にindex、2番目の item にelementが入る",
    "rust_lesson3_ex6_slide1_content": "# 累積処理\n\nfold は、初期valueとfunctionでelementを1つずつ畳み込みます。\n\n```rust\nlet v = vec![1, 2, 3];\nlet sum = v.iter().fold(0, |acc, x| acc + x);\n// 6\n```",
    "rust_lesson4_ex2_slide2_title": "よくuse derive トレイト",
    "rust_lesson3_ex10_slide3_content": "文字列型の違いを理解しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex4_slide2_content": "変数の値を手軽に増やしたり減らしたりする「+=」「-=」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex4_slide3_title": "Let's Try It!",
    "rust_lesson3_ex5_slide1_title": "filter（filterー）?",
    "rust_lesson4_ex5_description": "keyとvalueのpairを格納しましょう。",
    "rust_lesson3_ex5_description": "条件に合うelementだけを取り出しましょう。",
    "rust_lesson2_ex2_slide2_content": "# functionに借りてもらう\n\nfunctionにデータを渡すとき、`&` をつけると「借りる」形になります。元のvariableはそのまま使い続けられます。\n\ncodeExample：\n```rust\nfn calc_len(s: &String) -> usize {\n    s.len()  // 長さを返す\n}\n\nfn main() {\n    let text = String::from(\"hello\");\n    let len = calc_len(&text);  // textを貸す\n    // text はまだ使える！\n    println!(\"{}の長さは{}\", text, len);\n}\n```\n\n`&String` は「Stringを借りる」という意味です。",
    "rust_lesson4_ex7_slide3_content": "パターンマッチに条件を追加しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex8_slide2_content": "# 遅延評価\n\n```rust\n// クロージャで計算\nlet value = x.unwrap_or_else(|| expensive_computation());\n```",
    "rust_lesson4_ex7_title": "match ガード",
    "rust_lesson3_ex7_title": "? operatorでerror伝播",
    "rust_lesson4_ex1_description": "共通の振る舞いをdefineトレイトを学びましょう。",
    "rust_lesson2_ex1_slide2_content": "# 所有権は「移動」do\n\nvariableを別のvariableにassignmentdoと、所有権が 移動（ムーブ） します。元のvariableは使えなくなります。\n\ncodeExample：\n```rust\nlet s1 = String::from(\"hello\");  // s1 が持ち主\nlet s2 = s1;  // 所有権が s2 に移動！\n// ↓ s1 はもう使えない（エラーになる）\n// println!(\"{}\", s1);  // ダメ！\nprintln!(\"{}\", s2);  // OK！\n```\n\nイメージ：\nおもちゃを友だちにあげたら、自分はもう使えない。これがムーブです。",
    "rust_lesson1_ex8_slide1_title": "dictionary（HashMap）?",
    "rust_lesson4_ex3_slide2_content": "# サイズが決まらないとき\n\nBoxは、コンパイル時にサイズがわからないtypeにuse。\n\nFor examplerecursion的なtype：\n```rust\n// リストは「値 + 次のリスト」の繰り返し\nenum List {\n    Cons(i32, Box<List>),  // Boxで次を指す\n    Nil,                   // 終わり\n}\n```\n\nなぜBoxが必要？\n- `List` の中に `List` がある → 無限に大きくなる？\n- `Box` をuseと、サイズが固定（pointerのサイズ）になる\n\n「中身」ではなく「中身への矢印」を持つイメージです。",
    "rust_lesson2_ex10_title": "ジェネリクスを使おう",
    "rust_lesson2_ex8_slide3_title": "Let's Try It!",
    "rust_lesson3_ex9_slide2_content": "# 可変reference\n\n```rust\n// mut が必要\nlet mut v = Vec::new();\nv.push(1);\nv.push(2);\n```",
    "rust_lesson4_ex4_title": "Rc<T>",
    "rust_lesson2_ex3_comment1": "mut で可変variableにdo",
    "rust_lesson4_ex5_slide3_title": "Let's Try It!",
    "rust_lesson2_ex6_slide2_content": "# バリアントを列挙\n\n`enum 名前 { バリアント1, バリアント2, ... }` でdefine。\n\ncodeExample：\n```rust\nenum Color {\n    Red,\n    Green,\n    Blue,\n}\nlet c = Color::Red;\n```",
    "rust_lesson1_ex1_comment1": "Hello, Rust! とdisplay",
    "rust_lesson1_ex1_slide1_content": "# 安全で速い！最新のプログラミング言語\n\nRust（ラスト）は、「間違いを事前に防ぐ」ことがとても得意なプログラミング言語です。\n\nRustのすごいところ：\n- programのミスをexecute前に見つけてくれる\n- とても速く動く\n- 世界中のプログラマーが「一番好き！」と選ぶ人気の言語\n\nたとえるなら：\n厳しいけど優しい先生のような言語です。「ここ間違ってるよ」と教えてくれるので、安心してprogramが書けます！",
    "rust_lesson3_ex8_slide1_content": "# None/Err の場合のデフォルト\n\nunwrap_or は、None や Err の場合にデフォルトvalueをreturn。\n\n```rust\nlet x: Option<i32> = None;\nlet value = x.unwrap_or(0);  // 0\n```",
    "rust_lesson2_ex7_slide3_title": "Let's Try It!",
    "rust_lesson2_ex6_title": "enum で状態を表す",
    "rust_lesson2_ex8_slide1_content": "# 「成功」か「失敗」かを表す\n\nResult<T, E> は、処理が「成功したか失敗したか」を表すtypeです。\n\nFor example：\n- fileをopen → 成功（内容）か失敗（error）\n- 0で割り算 → 成功（答え）か失敗（0で割れない！）\n\n2つの状態：\n- `Ok(値)` → 成功！valueが入っている\n- `Err(エラー)` → 失敗...error情報が入っている\n\n`Option` は「あるか・ないか」、`Result` は「成功か・失敗か」という違いです。",
    "rust_lesson2_ex8_slide3_content": "成功と失敗を表す「Result」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex6_slide1_title": "HashSet ?",
    "rust_lesson3_ex9_comment1": "push でelementを追加",
    "rust_lesson2_ex7_slide2_title": "Option  Usage",
    "rust_lesson3_ex2_title": "closureのBasic",
    "rust_lesson3_ex7_slide1_title": "? operator?",
    "rust_lesson4_ex6_comment1": "HashSet をimport",
    "rust_lesson2_ex10_slide1_content": "# どんなtypeでも使える「万能」の仕組み\n\nジェネリクス は、typeを後から決められる仕組みです。\n\nなぜ便利？\n同じようなfunctionを何度も書かなくてすみます。\n\nFor example：\n- 数字のarrayの最初のelementを取るfunction\n- stringのarrayの最初のelementを取るfunction\n\n両方とも「最初のelementを取る」のは同じなのに、typeが違うだけで別のfunctionをwriteのは大変！\n\nジェネリクスなら、`<T>` で「typeは後で決める」とwriteだけで、どんなtypeでも使えるfunctionが作れます。",
    "rust_lesson1_ex3_slide1_content": "# 剰余operator（じょうよえんざんし）「%」\n\n`%`（パーセント）は、割り算の 「あまり」 をcalculate特別な記号です。\n\nわかりやすいExample：\n- 10このアメを3人で分けると？\n- 1人3こずつで、1こあまる\n- これを `10 % 3` とwriteと、答えは `1`\n\ncodeExample：\n```rust\nprintln!(\"{}\", 10 % 3);  // 1（あまり1）\nprintln!(\"{}\", 8 % 4);   // 0（あまりなし＝割り切れる）\n```\n\n使いどころ：\n- 偶数か奇数か調べる（`n % 2` が0なら偶数）\n- 時計の計算（24を超えたら0に戻る、など）",
    "rust_lesson3_ex7_description": "errorを簡潔に伝播させましょう。",
    "rust_lesson3_ex8_comment1": "unwrap_or でデフォルトvalueを設定",
    "rust_lesson2_ex8_title": "Result<T, E> でerror処理",
    "rust_lesson2_ex10_comment1": "T をtypeパラメータとしてuse",
    "rust_lesson2_ex6_comment1": "enum で列挙typeをdefinition",
    "rust_lesson3_ex3_slide3_content": "要素を順番に処理するイテレータを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex2_comment1": "derive でトレイトを自動implementation",
    "rust_lesson1_ex8_slide1_content": "# 名前でsearchできる「dictionary」\n\nHashMap（ハッシュmap）は、「名前」と「データ」をsetにして保存できる仕組みです。本物のdictionaryのように使えます。\n\nFor example果物の色dictionary：\n- 「りんご」→「あか」\n- 「バナナ」→「きいろ」\n- 「みかん」→「オレンジ」\n\nuse準備：\n```rust\nuse std::collections::HashMap;  // 機能を読み込む\nlet mut fruits = HashMap::new();  // 空の辞書を作る\nfruits.insert(\"りんご\", \"あか\");  // データを追加\n```\n\n`use` は「この機能をuseよ」というdeclarationです。",
    "rust_lesson3_ex9_slide1_title": "push ?",
    "rust_lesson4_ex1_title": "トレイトのdefinition",
    "rust_lesson4_ex3_description": "heapにデータを格納doBoxを学びましょう。",
    "rust_lesson1_ex2_title": "便利な「はこ」variable（へんすう）",
    "rust_lesson1_ex8_comment2": "中身を出す",
    "rust_lesson3_ex9_slide3_title": "Let's Try It!",
    "rust_lesson1_ex4_comment3": "-= で 50 を引く",
    "rust_lesson1_ex6_comment1": "&& で両方の条件をチェック",
    "rust_lesson4_ex1_slide2_title": "トレイトのimplementation",
    "rust_lesson4_ex7_slide3_title": "Let's Try It!",
    "rust_lesson4_title": "Rust IV - トレイトとスマートpointer",
    "rust_lesson4_ex1_comment1": "trait でトレイトをdefinition",
    "rust_lesson4_ex4_slide1_content": "# 複数の「持ち主」を許可do仕組み\n\nRc<T> は「Reference Counted（referenceカウント）」の略で、複数の所有者でデータを共有できます。\n\n普通の所有権：\n1人だけが持ち主。渡したら元の人は使えない。\n\nRc をuseと：\n複数人が同じデータの「持ち主」になれる！\n\ncodeExample：\n```rust\nuse std::rc::Rc;\n\nlet a = Rc::new(5);       // Rcでラップ\nlet b = Rc::clone(&a);    // bも持ち主になる\n// a も b も使える！\n```",
    "rust_lesson3_ex5_slide1_content": "# 条件に合うものだけ残す\n\nfilter は、条件を満たすelementだけを残し、他を捨てます。\n\nFor example：\n- 80点以上の人だけ残す\n- 偶数だけ残す\n- 「あ」から始まる名前だけ残す\n\ncodeExample：\n```rust\nlet v = vec![1, 2, 3, 4, 5];\nlet evens: Vec<_> = v.iter()\n    .filter(|x| **x % 2 == 0)  // 偶数だけ\n    .collect();\n// [2, 4]\n```\n\n条件が `true` のelementだけが残ります。",
    "rust_lesson3_ex7_slide3_title": "Let's Try It!",
    "rust_lesson1_ex7_comment2": "2番目のデータ（1番）を出す",
    "rust_lesson4_ex8_title": "impl Trait",
    "rust_lesson1_ex5_description": "条件によって動きを変える if文を学びましょう。",
    "rust_lesson3_ex4_slide2_title": "遅延評価（ちえんひょうか）",
    "rust_lesson3_ex1_slide1_content": "# referenceの「寿命」を示す印\n\nライフタイム は、referenceがいつまで使えるかを示す印です。`'a`（アポストロフィ・エー）のようにwrite。\n\nなぜ必要？\nreferenceは「借りている」状態。借りた元のデータが消えたら、referenceも使えなくなります。\n\nFor example：\n- 図書館で借りた本 → 図書館が閉まったら読めない\n- referenceで借りたデータ → 元のデータが消えたら使えない\n\nライフタイムは「このreferenceはこの範囲で有効だよ」とコンパイラに伝える仕組みです。",
    "rust_lesson1_ex1_slide1_title": "Rust（ラスト）?",
    "rust_lesson1_ex2_slide2_title": "計算の記号（operator）",
    "rust_lesson4_ex5_slide2_content": "# get で安全に取り出す\n\n`get()` methodでvalueを取り出せます。見つからない可能性があるので、`Option` が返ってきます。\n\ncodeExample：\n```rust\n// getはOption<&V>を返す\nif let Some(score) = scores.get(\"Blue\") {\n    println!(\"青チームは{}点\", score);\n}\n```\n\nPoint：\n- keyがあれば `Some(値)` が返る\n- keyがなければ `None` が返る\n- `if let` で安全に取り出せる\n\n存在しないkeyでアクセスしてもprogramが落ちない！",
    "rust_lesson4_ex7_slide1_title": "match ガード?",
    "rust_lesson3_title": "Rust III - ライフタイムとiterator",
    "rust_lesson4_ex3_title": "Box<T>",
    "rust_lesson1_ex4_slide1_title": "累算assignmentoperator（るいさんだいにゅう）?",
    "rust_lesson2_ex9_comment1": "trait でトレイトをdefinition",
    "rust_lesson2_ex1_description": "Rust独自の概念「所有権」を学びましょう。",
    "rust_lesson2_ex3_slide3_content": "参照先の値を変更できる「可変参照」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex1_slide3_title": "Let's Try It!",
    "rust_lesson3_ex6_slide2_title": "様々な畳み込み",
    "rust_lesson4_ex9_slide3_title": "Let's Try It!",
    "rust_lesson2_ex5_title": "impl でmethodを追加",
    "rust_lesson2_ex6_slide1_content": "# 複数の選択肢\n\nenum は、valueがいくつかの種類のうちの一つであることを表します。各バリアントにデータを持たせることもできます。",
    "rust_lesson2_ex4_comment1": "struct で構造体をdefinition",
    "rust_lesson1_ex3_title": "剰余operator（%）",
    "rust_lesson1_ex7_comment1": "colors というベクタをcreate（'あか', 'あお'の順）",
    "rust_lesson1_ex4_slide1_content": "# valueをかんたんに増やす・減らす\n\n`+=`（プラスイコール）と `-=`（マイナスイコール）は、variableの中身を増やしたり減らしたりdo便利な記号です。\n\nRustのImportantなルール：`mut`が必要！\nRustでは、variableをchangeには `let mut`（レット ミュート）とwrite必要があります。`mut` は「mutable（変更できる）」の略です。\n\ncodeExample：\n```rust\nlet mut score = 100;  // mut をつけて変更可能に\nscore += 10;          // 10を足す → 110に\nscore -= 50;          // 50を引く → 60に\n```\n\n`mut` がないと「このvariableは変えちゃダメ！」とRustが怒ります。",
    "rust_lesson2_ex1_slide2_title": "ムーブ（移動）",
    "rust_lesson3_ex4_comment1": "map で各elementを変換",
    "rust_lesson3_ex8_slide1_title": "unwrap_or ?",
    "rust_lesson2_ex5_slide1_content": "# implementationブロック\n\nimpl ブロックで、構造体にmethodを追加できます。`self` で自分自身をreferenceします。",
    "rust_lesson2_ex10_slide1_title": "ジェネリクス?",
    "rust_lesson1_ex8_slide2_content": "# 名前（key）で取り出す\n\ndictionaryに入れたデータは、名前（key）を指定して取り出せます。\n\ncodeExample：\n```rust\nuse std::collections::HashMap;\nfn main() {\n    let mut fruits = HashMap::new();\n    fruits.insert(\"りんご\", \"あか\");  // 追加\n    fruits.insert(\"バナナ\", \"きいろ\");  // 追加\n    \n    println!(\"{}\", fruits[\"りんご\"]);  // あか と表示\n}\n```\n\nPoint：\n- `insert(名前, データ)` で追加\n- `辞書[名前]` で取り出し\n- 番号ではなく「名前」で探せるのが便利！",
    "rust_lesson4_ex9_slide1_content": "# iteratorをコレクションに\n\ncollect は、iteratorをVecやHashMapなどに変換します。\n\n```rust\nlet v: Vec<_> = (0..5).collect();\nlet s: String = vec!['a', 'b'].into_iter().collect();\n```",
    "rust_lesson2_ex2_slide3_content": "所有権を移さずに値を借りる「参照」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex2_slide3_content": "周囲の変数を使える無名関数「クロージャ」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex4_slide2_content": "# struct keyワードでdefinition\n\n`struct 名前 { フィールド }` で構造体をdefine。フィールドには名前とtypeをwrite。\n\ncodeExample：\n```rust\n// Point 構造体を定義\nstruct Point {\n    x: i32,  // xフィールド（整数）\n    y: i32,  // yフィールド（整数）\n}\n\n// 使い方\nlet p = Point { x: 10, y: 20 };\nprintln!(\"x={}, y={}\", p.x, p.y);\n```\n\nPoint：\n- `struct 名前` で構造体をcreate\n- `{ フィールド名: 型 }` でどんなデータを持つか決める\n- `.フィールド名` でアクセス",
    "rust_lesson2_ex10_slide3_content": "型を後から決められる「ジェネリクス」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex6_slide3_title": "Let's Try It!",
    "rust_lesson4_ex6_slide1_content": "# 一意なvalueのset\n\nHashSet は、重複のないvalueのsetです。\n\n```rust\nuse std::collections::HashSet;\n\nlet mut set = HashSet::new();\nset.insert(1);\nset.insert(2);\nset.insert(1); // 重複は無視\n```",
    "rust_lesson4_ex2_title": "derive 属性",
    "rust_lesson4_ex2_slide1_content": "# トレイトを「自動で」implementation\n\n#[derive(...)] をuseと、よくuseトレイトを自分で書かなくても自動でimplementationしてくれます。\n\nFor example：\n構造体を `println!` でdisplayしたいとき、普通は Display トレイトをimplementationdo必要がありますが、`#[derive(Debug)]` をwriteだけでOK！\n\ncodeExample：\n```rust\n#[derive(Debug)]  // Debug トレイトを自動実装\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nlet p = Point { x: 1, y: 2 };\nprintln!(\"{:?}\", p);  // Point { x: 1, y: 2 }\n```",
    "rust_lesson1_ex6_slide2_title": "Let's Try It!",
    "rust_lesson3_ex3_slide2_title": "3つの iter method",
    "rust_lesson4_ex7_slide2_content": "# 複雑なconditional\n\n```rust\nmatch Some(5) {\n    Some(x) if x % 2 == 0 => println!(\"even\"),\n    Some(x) => println!(\"odd: {}\", x),\n    None => println!(\"none\"),\n}\n```",
    "rust_lesson3_ex3_slide1_content": "# elementを1つずつ取り出す仕組み\n\niterator は、ベクタなどのデータを「1つずつ順番に」取り出す仕組みです。\n\nFor example：\n- 行列に並んでいる人を1人ずつ呼ぶ\n- 引き出しの中身を1つずつ出す\n\ncodeExample：\n```rust\nlet v = vec![1, 2, 3];\nfor x in v.iter() {\n    println!(\"{}\", x);  // 1, 2, 3 と順番に表示\n}\n```\n\n`iter()` で「順番に取り出す準備」をして、`for` で1つずつ処理します。",
    "rust_lesson3_ex3_slide1_title": "iterator?",
    "rust_lesson4_ex2_description": "トレイトを自動implementationdoderiveを学びましょう。",
    "rust_lesson3_ex4_slide1_content": "# 全部を同じように変換do\n\n**map** は、iteratorの各elementを「同じ方法で」変換します。\n\nFor example：\n- 全員の身長を2倍にdo\n- 全員の名前を大文字にdo\n- 全部の数を2乗do\n\ncodeExample：\n```rust\nlet v = vec![1, 2, 3];\nlet doubled: Vec<_> = v.iter()\n    .map(|x| x * 2)  // 各要素を2倍に\n    .collect();      // ベクタに戻す\n// [2, 4, 6]\n```\n\n`|x| x * 2` は「xを受け取って、x*2をreturn」closureです。",
    "rust_lesson1_ex3_slide1_title": "あまりを求める",
    "rust_lesson3_ex10_slide1_content": "# 所有権の違い\n\nString は所有権を持つheap上のstring、&str はreferenceです。\n\n```rust\nlet s1: String = String::from(\"hello\");\nlet s2: &str = \"hello\";\n```",
    "rust_lesson4_ex2_slide1_title": "derive（デライブ）?",
    "rust_lesson2_ex2_comment1": "& でreferenceを渡す",
    "rust_lesson4_ex5_slide1_title": "HashMap（ハッシュmap）?",
    "rust_lesson2_ex3_slide2_title": "&mut  Usage",
    "rust_lesson3_ex5_title": "filter で絞り込み",
    "rust_lesson4_ex3_slide2_title": "いつuse？",
    "rust_lesson2_ex2_title": "referenceと借用",
    "rust_lesson2_ex7_title": "Option<T> で null を安全に",
    "rust_lesson4_ex10_slide3_title": "Let's Try It!",
    "rust_lesson3_ex5_slide3_title": "Let's Try It!",
    "rust_lesson4_ex10_title": "enumerate でindex付き",
    "rust_lesson2_ex2_slide1_content": "# 所有権を渡さずに「借りる」\n\nreference をuseと、所有権を移さずにデータを「見せてもらう」ことができます。\n\nたとえるなら：\n- ムーブ = おもちゃをあげる（自分は使えない）\n- reference = おもちゃを見せる（自分も使える）\n\n作り方：\n`&`（アンパサンド）をつけるとreferenceを作れます。\n\n```rust\nlet s = String::from(\"hello\");\nlet r = &s;  // sを借りる（見せてもらう）\n// s も r も使える！\n```",
    "rust_lesson2_ex5_slide2_content": "# &self をuse\n\nmethodの最初のargumentは `&self` です。\n\ncodeExample：\n```rust\nimpl Rect {\n    fn area(&self) -> i32 {\n        self.width * self.height\n    }\n}\n```",
    "rust_lesson1_ex5_slide2_title": "Let's Try It!",
    "rust_lesson2_ex4_slide3_title": "Let's Try It!",
    "rust_lesson4_ex3_slide3_title": "Let's Try It!",
    "rust_lesson2_ex9_slide3_content": "共通の振る舞いを定義する「トレイト」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex1_slide2_content": "# impl で約束を守る\n\n構造体にトレイトをimplementationdoと、その構造体は「約束を守る」ことになります。\n\ncodeExample：\n```rust\nstruct Person { name: String }\n\nimpl Greet for Person {\n    fn greet(&self) -> String {\n        format!(\"Hello, {}\", self.name)\n    }\n}\n```\n\n読み方：\n- `impl Greet for Person` → 「PersonはGreetをimplementationdo」\n- これでPersonは「あいさつできる」ようになった！",
    "rust_lesson4_ex4_comment1": "clone でreferenceカウントを増やす",
    "rust_lesson3_ex4_slide2_content": "# map だけではexecuteされない！\n\nRustのiteratorは 遅延評価 といって、「本当に必要になるまで処理しない」仕組みです。\n\nなぜ？\n無駄な計算を省けるから。100万件あっても、最初の10件だけ欲しいなら10件だけ処理すればいい。\n\ncollect() でexecute：\n```rust\n// これだけでは何も起きない\nv.iter().map(|x| x * 2);\n\n// collect() で実行してベクタに変換\nlet result: Vec<_> = v.iter().map(|x| x * 2).collect();\n```\n\n`collect()` は「今すぐ全部処理してResultをちょうだい」という意味です。",
    "rust_lesson2_ex4_slide2_title": "struct のdefinitionのしかた",
    "rust_lesson2_ex3_slide1_content": "# 「書き換えできる」借り方\n\n普通のreference `&` は「見るだけ」ですが、可変reference `&mut` は「変更もできる」借り方です。\n\nたとえるなら：\n- `&` = 本を見せてもらう（readだけ）\n- `&mut` = ノートを借りる（writeOK）\n\nImportantなルール：\n- 可変referenceは同時に1つだけ！\n- 「みんなで見る」か「1人でwrite」かのどちらか\n\nこのルールで、データが同時に書き換えられるバグを防いでいます。",
    "rust_lesson2_ex10_slide3_title": "Let's Try It!",
    "rust_lesson2_ex4_title": "構造体をdefinitionしよう",
    "rust_lesson3_ex10_slide2_content": "# 相互変換\n\n```rust\n// &str -> String\nlet s = \"hello\".to_string();\n\n// String -> &str\nlet slice: &str = &s;\n```",
    "rust_lesson4_ex10_slide3_content": "イテレータにインデックスを付けましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex4_slide2_content": "# 「何人が持っているか」を数える\n\nRcは「今何人がこのデータを持っているか」を数えています。\n\ncodeExample：\n```rust\nlet a = Rc::new(5);\nprintln!(\"{}\", Rc::strong_count(&a));  // 1\n\nlet b = Rc::clone(&a);\nprintln!(\"{}\", Rc::strong_count(&a));  // 2\n```\n\nいつデータが消える？\n- カウントが0になったとき（誰も持っていないとき）\n- 最後の持ち主がいなくなると自動で片付けられる\n\n`Rc::clone` は「持ち主を1人増やす」操作です。",
    "rust_lesson1_ex8_slide2_title": "dictionary Usage",
    "rust_lesson4_ex3_slide1_content": "# データを「heap」に置く箱\n\nBox<T> は、データを「heap」という特別な場所に置くための箱です。\n\nmemoryの2つの場所：\n- stack：小さくて速い。サイズが決まっているデータ向け\n- heap：大きくて柔軟。サイズが大きいor変わるデータ向け\n\ncodeExample：\n```rust\nlet b = Box::new(5);  // 5をヒープに置く\nprintln!(\"{}\", *b);   // *で中身を取り出す → 5\n```\n\n`*` は「箱を開けて中身を見る」操作です。",
    "rust_lesson3_ex2_slide2_title": "closure Syntax",
    "rust_lesson4_ex4_slide1_title": "Rc（アールシー）?",
    "rust_lesson4_ex7_slide1_content": "# 追加条件\n\n**if** でパターンに追加条件をつけられます。\n\n```rust\nmatch x {\n    n if n < 0 => println!(\"negative\"),\n    n if n > 0 => println!(\"positive\"),\n    _ => println!(\"zero\"),\n}\n```",
    "rust_lesson2_ex3_title": "可変reference",
    "rust_lesson3_ex10_comment1": "to_string で String に変換",
    "rust_lesson3_ex10_slide2_title": "変換",
    "rust_lesson3_ex1_description": "referenceの有効期間を表すライフタイムを学びましょう。",
    "rust_lesson3_ex2_slide1_content": "# 名前のない「即席」function\n\nclosure は、名前をつけずにその場でcreatefunctionです。そして特別な能力があります：周りのvariableを使えるのです！\n\nFor example：\n```rust\nlet x = 5;  // 外側の変数\nlet add_x = |n| n + x;  // xを使えるクロージャ\nprintln!(\"{}\", add_x(10));  // 15\n```\n\n普通のfunctionとの違い：\n- 普通のfunction：argumentしか使えない\n- closure：argument + 周りのvariableも使える\n\n「その場の空気を読める」functionというイメージです！",
    "rust_lesson1_ex2_comment1": "x に 10 を入れる",
    "rust_lesson1_ex7_slide3_title": "Let's Try It!",
    "rust_lesson1_ex5_title": "「もし〜なら」で分けましょう",
    "rust_lesson3_ex2_slide3_title": "Let's Try It!",
    "rust_lesson3_ex7_slide2_content": "# 簡潔なerror処理\n\n```rust\n// ? を使わない場合\nmatch result {\n    Ok(v) => v,\n    Err(e) => return Err(e),\n}\n\n// ? を使う\nresult?\n```",
    "rust_lesson3_ex6_slide3_title": "Let's Try It!",
    "rust_lesson4_ex9_slide3_content": "イテレータをコレクションに変換しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex6_description": "elementを1つのvalueにまとめるfoldを学びましょう。",
    "rust_lesson2_ex9_description": "共通の振る舞いをdefine「トレイト」を学びましょう。",
    "rust_lesson2_ex8_comment1": "Ok で成功をreturn",
    "rust_lesson3_ex5_slide2_content": "# filter はreferenceのreferenceを受け取る\n\n`filter` のclosureは、referenceのreference（`&&T`）を受け取ります。そのため、valueをuseには `**x` と2回referenceを外す必要があります。\n\nなぜ？\n- `iter()` はreference（`&T`）をreturn\n- `filter` はそれをFurthermorereferenceで渡す（`&&T`）\n\nSyntax：\n```rust\n// **x で値を取り出す\n.filter(|x| **x > 2)\n\n// または * を引数につける\n.filter(|&x| *x > 2)\n```\n\n最初は混乱しますが、慣れれば大丈夫！",
    "rust_lesson1_ex5_comment1": "> でcompare",
    "rust_lesson2_ex4_description": "関連doデータをまとめる「構造体」を学びましょう。",
    "rust_lesson3_ex5_slide3_content": "条件に合う要素だけを取り出しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex7_slide3_content": "「ベクタ（Vec）」を使うと、たくさんのデータを一つの「長い はこ」にまとめて入れられます。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex5_slide2_title": "valueの取得",
    "rust_lesson3_ex1_slide1_title": "ライフタイム?",
    "rust_lesson1_ex3_comment1": "10 を 3 で割ったあまりをoutput",
    "rust_lesson3_ex1_comment1": "'a でライフタイムをdefinition",
    "rust_lesson3_ex10_slide1_title": "String vs &str",
    "rust_lesson2_title": "Rust II - 所有権とトレイト",
    "rust_lesson2_ex5_slide2_title": "methodのdefinition",
    "rust_lesson4_ex5_comment1": "insert でkeyとvalueを追加",
    "rust_lesson2_ex9_slide1_content": "# 「できること」の約束\n\nトレイト は、「このtypeはこういうことができる」という約束をdefine。\n\nFor example「鳴ける」という約束：\n- 犬は「ワン」と鳴く\n- 猫は「ニャー」と鳴く\n- 両方とも「鳴ける」能力がある\n\nトレイトは「鳴ける動物は、鳴き声を出すmethodを持つ」という約束です。\n\n他の言語とのcomparison：\n- Java: interface\n- TypeScript: interface\n\nに似た概念です。",
    "rust_lesson1_ex2_slide3_title": "Let's Try It!",
    "rust_lesson4_ex8_slide1_content": "# return valueのtypeをabstract化\n\nimpl Trait で、トレイトをimplementationdotypeを返せます。\n\n```rust\nfn make_iter() -> impl Iterator<Item = i32> {\n    vec![1, 2, 3].into_iter()\n}\n```",
    "rust_lesson1_ex2_slide2_content": "# 四則演算（しそくえんざん）\n\nRustでも算数と同じ記号で計算ができます。\n\n4つのBasic記号：\n- +（プラス）: たし算\n- -（マイナス）: ひき算\n- \\*（アスタリスク）: かけ算（×の代わり）\n- /（スラッシュ）: わり算（÷の代わり）\n\ncodeExample：\n```rust\nlet a = 10;\nlet b = 5;\nprintln!(\"{}\", a + b);  // 15 と表示される\n```\n\n`println!` の `{}` は「ここにvalueを入れてね」という目印です。",
    "rust_lesson4_ex9_slide2_content": "# 変換先を指定\n\n```rust\n// ターボフィッシュ構文\nlet v = (0..5).collect::<Vec<_>>();\n\n// 変数の型注釈\nlet v: Vec<i32> = (0..5).collect();\n```",
    "rust_lesson1_ex8_description": "「dictionary（HashMap）」をuseと、名前をつけてデータを保存し、その名前で取り出せます。",
    "rust_lesson4_ex9_slide2_title": "typeHint",
    "rust_lesson3_ex1_title": "ライフタイムのBasic",
    "rust_lesson2_ex5_description": "構造体にmethodをadd「impl」を学びましょう。",
    "rust_lesson4_ex8_comment1": "impl でトレイトをimplementationdotypeをreturn",
    "rust_lesson4_ex8_slide2_title": "argumentにも使える",
    "rust_lesson4_ex7_comment1": "if でマッチガードを追加",
    "rust_lesson2_ex9_slide2_title": "trait のdefinitionとimplementation",
    "rust_lesson4_ex10_slide2_title": "いつuse？",
    "rust_lesson3_ex7_slide2_title": "match の省略形",
    "rust_lesson1_ex6_title": "logicaloperator（&&、||）",
    "rust_lesson3_ex6_comment1": "fold で畳み込み",
    "rust_lesson2_ex6_description": "複数の状態を表す「列挙type（enum）」を学びましょう。",
    "rust_lesson4_ex10_slide1_title": "enumerate（イニュメレート）?",
    "rust_lesson1_ex7_slide1_title": "ベクタ（Vec）?",
    "rust_lesson2_ex6_slide3_content": "複数の状態を表す「列挙型（enum）」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex3_slide3_title": "Let's Try It!",
    "rust_lesson3_ex4_description": "各elementを変換domapを学びましょう。",
    "rust_lesson4_ex1_slide3_title": "Let's Try It!",
    "rust_lesson3_ex9_slide2_title": "mut が必要",
    "rust_lesson1_ex6_slide1_content": "# logicaloperator（ろんりえんざんし）\n\n2つ以上の条件を組み合わせたいときにuse記号です。\n\n2つの記号：\n- `&&`（アンドアンド）：「かつ」＝ 両方とも 正しいとき\n- `||`（オアオア）：「Alsoは」＝ どちらか 正しいとき\n\n身近なExample：\n- 遊園地：「18歳以上 かつ チケットあり」なら乗れる\n- おやつ：「宿題終わった Alsoは お手伝いした」ならOK\n\ncodeExample：\n```rust\nif score >= 70 && bonus > 0 {\n    // 70点以上 かつ ボーナスあり → 合格！\n    println!(\"合格！\");\n}\n```",
    "rust_lesson4_ex4_slide3_content": "参照カウントでデータを共有しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex6_slide3_title": "Let's Try It!",
    "rust_lesson2_ex5_slide3_content": "構造体にメソッドを追加する「impl」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex1_slide3_title": "Let's Try It!",
    "rust_lesson1_ex5_slide1_content": "# programに「判断」させよう\n\nconditional は、「もし〜なら、〇〇do」という判断をprogramにさせる仕組みです。\n\n身近なExample：\n- もし80点以上なら → 「合格！」とdisplay\n- もし雨なら → 傘を持っていく\n- もしHPが0なら → ゲームオーバー\n\nRustで Syntax：\n```rust\nif score > 80 {\n    println!(\"合格！\");\n}\n```\n\n読み方：\n- `if` →「もし」\n- `score > 80` →「スコアが80より大きいなら」\n- `{ }` の中 →「これをやる」",
    "rust_lesson4_ex5_title": "HashMap",
    "rust_lesson1_ex2_slide1_content": "# データを保存do「はこ」\n\nvariable（へんすう） は、数字や文字を入れておける「はこ」のことです。名前をつけて、あとでuseことができます。\n\nFor example：\n- 「りんごの数」というラベルの箱に「5」を入れる\n- あとで「りんごの数」と呼べば「5」が出てくる\n\nRustで Syntax：\n```rust\nlet x = 10;  // xという箱に10を入れる\nprintln!(\"{}\", x);  // xの中身（10）を表示\n```\n\n`let` は「この名前で箱をcreateよ」という意味です。",
    "rust_lesson2_ex4_slide3_content": "関連するデータをまとめる「構造体」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex6_slide1_title": "enum ?",
    "rust_lesson2_ex9_title": "トレイトをdefinitionしよう",
    "rust_lesson2_ex4_slide1_title": "構造体（こうぞうたい）?",
    "rust_lesson4_ex2_slide2_content": "# 覚えておくと便利な5つ\n\nよくusederiveトレイト：\n```rust\nDebug     // {:?} でデバッグ表示できる\nClone     // .clone() でコピーを作れる\nCopy      // 代入時に自動でコピー（小さい型向け）\nPartialEq // == で比較できる\nDefault   // 初期値を自動で作れる\n```\n\n複数指定もOK：\n```rust\n#[derive(Debug, Clone, PartialEq)]\nstruct User {\n    name: String,\n    age: u32,\n}\n```\n\n`Debug` は特によくuse。debug時に構造体の中身を見れて便利！",
    "rust_lesson2_ex1_slide1_content": "# データの「持ち主」を決めるルール\n\n所有権 は、Rust最大のFeatureです。「このデータの持ち主は誰か」をはっきりさせる仕組みです。\n\nルール：\n- データには必ず1人だけ「持ち主」がいる\n- 持ち主がいなくなると、データは自dynamicに片付けられる\n\nたとえるなら：\n- おもちゃは1人しか持てない\n- 持ち主が部屋を出たら、おもちゃは片付けられる\n\nこのルールのおかげで、Rustは「memoryリーク」（データが片付けられないバグ）を防げます！",
    "rust_lesson1_ex3_slide2_title": "Let's Try It!",
    "rust_lesson3_ex1_slide2_title": "なぜ必要？",
    "rust_lesson3_ex1_slide2_content": "# 危険なバグを防ぐ\n\nダングリングreference という危険なバグがあります。これは「もう存在しないデータ」を指し続けているreferenceのことです。\n\nExample：\n```rust\nfn longest<'a>(x: &'a str, y: &'a str) -> &'a str {\n    if x.len() > y.len() { x } else { y }\n}\n```\n\n`'a` の意味：\n- argument `x` と `y` は同じライフタイム `'a` を持つ\n- return valueも同じライフタイム `'a` を持つ\n- In other words「xとyが両方有効な間、return valueも有効」という約束\n\nRustはこれを自動でチェックしてくれます！",
    "rust_lesson4_ex6_slide2_title": "set演算",
    "rust_lesson3_ex7_comment1": "? でerrorを伝播",
    "rust_lesson3_ex2_slide2_content": "# | | でargumentを囲む\n\nclosureは `|引数| 処理` という形でwrite。`||` は「パイプ」と呼ばれます。\n\nいろいろなSyntax：\n```rust\n// 引数なし\n|| println!(\"Hello\")\n\n// 引数あり\n|x, y| x + y\n\n// 複数行のブロック\n|x| {\n    let y = x * 2;\n    y + 1\n}\n```\n\nPoint：\n- argumentを `| |` で囲む（functionの `()` の代わり）\n- typeは省略できることが多い（Rustが推測してくれる）",
    "rust_lesson2_ex7_comment1": "Some でvalueがあることを示す",
    "rust_lesson3_ex4_slide3_content": "各要素を変換するmapを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_title": "Rust (ラスト) に挑戦！",
    "rust_lesson2_ex8_description": "成功と失敗を表す「Result」を学びましょう。",
    "rust_lesson3_ex8_description": "Option/Resultのデフォルトvalueを設定しましょう。",
    "rust_lesson4_ex2_slide3_title": "Let's Try It!",
    "rust_lesson2_ex5_slide3_title": "Let's Try It!",
    "rust_lesson4_ex9_description": "iteratorをコレクションに変換しましょう。",
    "rust_lesson1_ex1_slide2_content": "# println! でscreenにdisplay\n\nRustで文字をscreenにdisplayには、`println!`（プリントラインびっくり）をuse。\n\nPoint：\n- `!` がつくのがRustのFeature（マクロと呼ばれます）\n- programは `fn main() { }` の中にwrite\n- `fn` は「function（function）」の略\n\ncodeExample：\n```rust\nfn main() {\n    println!(\"ヤッホー！\");\n}\n// 「ヤッホー！」と画面に表示される\n```\n\n`println!` の `!` は「マクロ」という特別な機能の印です。今は「おまじない」と思っておけばOK！",
    "rust_lesson3_ex6_slide1_title": "fold ?",
    "rust_lesson4_ex8_slide1_title": "impl Trait ?",
    "rust_lesson1_ex1_slide2_title": "Rustの「おまじない」",
    "rust_lesson3_ex10_description": "stringtypeの違いを理解しましょう。",
    "rust_lesson3_ex7_slide3_content": "エラーを簡潔に伝播させましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex1_comment1": "s1 の所有権を移動",
    "rust_lesson2_ex9_slide1_title": "トレイト?",
    "rust_lesson4_ex6_slide2_content": "# 和set、積setなど\n\n```rust\nset1.union(&set2)\nset1.intersection(&set2)\nset1.difference(&set2)\n```",
    "rust_lesson4_ex5_slide3_content": "キーと値のペアを格納しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex8_slide1_title": "Result（リザルト）?",
    "rust_lesson4_ex1_slide1_content": "# 「できること」の約束\n\nトレイト は、typeが持つべきmethodをdefine仕組みです。\n\nFor example：\n- 「あいさつできる」トレイト → greet() methodを持つ\n- 「displayできる」トレイト → display() methodを持つ\n\ncodeExample：\n```rust\ntrait Greet {\n    fn greet(&self) -> String;  // メソッドの「約束」\n}\n```\n\nこれは「Greetできるtypeは、greet()methodを持つ」という約束です。",
    "rust_lesson4_ex2_slide3_content": "トレイトを自動実装するderiveを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex6_title": "fold で畳み込み",
    "rust_lesson3_ex9_slide3_content": "Vecに要素を追加しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex4_slide1_content": "# 関係あるデータをまとめる「設計図」\n\n構造体（struct） は、いくつかのデータをひとまとめにdo仕組みです。\n\nFor example「点（座標）」のデータ：\n- x座標\n- y座標\n\nこの2つは関係があるので、「Point（点）」としてまとめると便利です。\n\nFor example「人」のデータ：\n- 名前\n- 年齢\n\nこれも「Person（人）」としてまとめられます。\n\n構造体は「こういうデータを持つ」という設計図です。",
    "rust_lesson4_ex1_slide1_title": "トレイト?（復習）",
    "rust_lesson2_ex3_description": "reference先のvalueを変更できる「可変reference」を学びましょう。",
    "rust_lesson2_ex7_slide2_content": "# match で安全に取り出す\n\n`match` を使って「ある場合」と「ない場合」で処理を分けます。\n\ncodeExample：\n```rust\nlet x: Option<i32> = Some(5);  // 値あり\n\nmatch x {\n    Some(n) => println!(\"値は{}です\", n),  // 5\n    None => println!(\"値がありません\"),\n}\n```\n\nなぜ安全？\n- `null` のように「あるつもりでアクセスしたら無かった」errorが起きない\n- 「ない場合」の処理を書かないとコンパイルerrorになる\n- 強制的に両方のケースを考えることになる！",
    "rust_lesson4_ex9_comment1": "collect で Vec に変換",
    "rust_lesson3_ex10_title": "String と &str",
    "rust_lesson2_ex7_slide1_title": "Option（オプション）?",
    "rust_lesson3_ex9_description": "Vecにelementを追加しましょう。",
    "rust_lesson2_ex5_comment1": "impl でmethodをimplementation",
    "rust_lesson3_ex1_slide3_content": "参照の有効期間を表すライフタイムを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex6_slide2_content": "複数の条件を組み合わせる「&&（かつ）」と「||（または）」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex5_comment1": "filter で条件に合うelementを絞り込む",
    "rust_lesson2_ex7_slide3_content": "値があるかないかを表す「Option」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex10_slide3_title": "Let's Try It!",
    "rust_lesson4_ex4_slide3_title": "Let's Try It!",
    "rust_lesson3_ex3_comment1": "iter でiteratorを取得",
    "rust_lesson3_ex6_slide3_content": "要素を1つの値にまとめるfoldを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex7_slide2_title": "ベクタの番号は「0」から！",
    "rust_lesson1_ex5_slide1_title": "conditional（じょうけんぶんき）?",
    "rust_lesson1_ex3_description": "割り算の「あまり」を求める「%」（パーセント）operatorを学びましょう。",
    "rust_lesson1_ex1_slide3_content": "Rustを使って画面に文字を表示してみましょう。println! という特別な関数を使います。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex10_slide2_content": "# <T> でtypeを「あとで決める」\n\nfunction名の後に `<T>` をつけて、`T` を「type」としてuse。\n\ncodeExample：\n```rust\n// Tはどんな型でもOK\nfn first<T>(arr: &[T]) -> &T {\n    &arr[0]  // 最初の要素を返す\n}\n\n// 使い方\nfirst(&[1, 2, 3]);         // Tはi32\nfirst(&[\"a\", \"b\", \"c\"]);   // Tは&str\n```\n\n読み方：\n- `<T>` → 「Tという名前のtypeをuseよ」\n- `T` は慣習で「Type（type）」の頭文字\n- 複数のtypeが必要なら `<T, U>` のようにwrite",
    "rust_lesson3_ex2_comment1": "|x| でclosureのargumentをdefinition",
    "rust_lesson3_ex3_description": "elementを順番に処理doiteratorを学びましょう。",
    "rust_lesson1_ex1_slide3_title": "Let's Try It!",
    "rust_lesson2_ex6_slide2_title": "enum のdefinition",
    "rust_lesson2_ex1_title": "所有権のBasic",
    "rust_lesson4_ex3_slide1_title": "Box（ボックス）?",
    "rust_lesson2_ex1_slide3_content": "Rust独自の概念「所有権」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex8_slide3_content": "Option/Resultのデフォルト値を設定しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex7_slide2_title": "使用Example",
    "rust_lesson4_ex10_description": "iteratorにindexを付けましょう。",
    "rust_lesson4_ex9_slide1_title": "collect ?",
    "rust_lesson4_ex10_slide2_content": "# 「何番目か」が必要なとき\n\n番号（index）とelementの両方が必要なときに便利です。\n\ncodeExample：\n```rust\nlet v = vec![10, 20, 30];\nfor (idx, val) in v.iter().enumerate() {\n    println!(\"{}番目の値は{}\", idx, val);\n}\n// 0番目の値は10\n// 1番目の値は20\n// 2番目の値は30\n```\n\nPoint：\n- `(i, x)` でtuple（2つのset）を受け取る\n- `i` にindex、`x` にelementが入る\n- indexは0から始まる",
    "rust_lesson3_ex2_description": "周囲のvariableを使えるanonymous function「closure」を学びましょう。",
    "rust_lesson1_ex4_comment1": "mut で変更可能にdo",
    "rust_lesson1_ex8_slide3_title": "Let's Try It!",
    "rust_lesson1_ex3_slide2_content": "割り算の「あまり」を求める「%」（パーセント）演算子を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex9_slide3_title": "Let's Try It!",
    "rust_lesson3_ex3_title": "iteratorのBasic",
    "rust_lesson3_ex9_title": "Vec のmethod push",
    "rust_lesson1_ex8_comment1": "dictionaryをcreate（keyは'みかん'、valueは'オレンジ'）",
    "rust_lesson1_ex2_comment3": "+ でたし算do",
    "rust_lesson4_ex8_slide2_content": "# ジェネリクスの代わり\n\n```rust\nfn print_all(iter: impl Iterator<Item = i32>) {\n    for x in iter {\n        println!(\"{}\", x);\n    }\n}\n```",
    "rust_lesson2_ex2_slide2_title": "reference Usage",
    "rust_lesson1_ex8_slide3_content": "「辞書（HashMap）」を使うと、名前をつけてデータを保存し、その名前で取り出せます。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex7_slide2_content": "# [ ]で番号を指定して取り出す\n\n`[番号]` で何番目のデータか指定して取り出せます。\n\nImportantなルール：番号は「0」から！\n- 1番目 → `[0]`\n- 2番目 → `[1]`\n- 3番目 → `[2]`\n\ncodeExample：\n```rust\nlet fruits = vec![\"りんご\", \"バナナ\", \"みかん\"];\n//                  ↑0番    ↑1番     ↑2番\nprintln!(\"{}\", fruits[0]);  // りんご\nprintln!(\"{}\", fruits[1]);  // バナナ\n```\n\nプログラミングでは「0から数える」のが世界共通のルールです！",
    "rust_lesson1_ex6_slide1_title": "条件を組み合わせる",
    "rust_lesson2_ex10_slide2_title": "ジェネリックfunction Syntax",
    "rust_lesson1_ex6_description": "複数の条件を組み合わせる「&&（かつ）」と「||（Alsoは）」を学びましょう。",
    "rust_lesson4_ex6_title": "HashSet",
    "rust_lesson2_ex3_slide2_content": "# mut が2か所に必要\n\n変更できるようにdoには、variableとreferenceの両方に `mut` が必要です。\n\ncodeExample：\n```rust\n// 1. 変数を mut で作る\nlet mut s = String::from(\"hello\");\n\n// 2. &mut で可変参照を渡す\nchange(&mut s);\n\nfn change(s: &mut String) {\n    s.push_str(\" world\");  // 変更できる！\n}\n```\n\nPoint：\n- `let mut 変数` でvariableを変更可能に\n- `&mut 変数` で可変referenceをcreate\n- 両方ないと変更できない！",
    "rust_lesson2_ex2_slide1_title": "reference（さんしょう）?",
    "rust_lesson3_ex6_slide2_content": "# 合計、積、結合など\n\n```rust\n// 積\nv.iter().fold(1, |acc, x| acc * x)\n\n// 文字列結合\nwords.iter().fold(String::new(), |acc, s| acc + s)\n```",
    "rust_lesson1_ex1_description": "Rustを使ってscreenに文字をdisplayしてみましょう。println! という特別なfunctionをuse。",
    "rust_lesson3_ex8_slide3_title": "Let's Try It!",
    "rust_lesson4_ex6_description": "一意なvalueのsetを管理しましょう。",
    "rust_lesson2_ex5_slide1_title": "impl ?",
    "rust_lesson1_ex8_title": "名前で引き出す「dictionary」",
    "rust_lesson2_ex7_description": "valueがあるかないかを表す「Option」を学びましょう。",
    "rust_lesson1_ex4_slide2_title": "Let's Try It!",
    "rust_lesson1_ex7_title": "たくさんのデータをまとめましょう「ベクタ」",
    "rust_lesson3_ex7_slide1_content": "# errorの早期リターン\n\n? は、Resultが Err の場合に早期リターンします。\n\n```rust\nfn read_file() -> Result<String, io::Error> {\n    let content = fs::read_to_string(\"file.txt\")?;\n    Ok(content)\n}\n```",
    "rust_lesson3_ex9_slide1_content": "# 末尾に追加\n\npush は、Vecの末尾にelementをadd。\n\n```rust\nlet mut v = vec![1, 2];\nv.push(3);\n// [1, 2, 3]\n```",
    "rust_lesson4_ex8_slide3_content": "トレイトを返す関数を簡潔に書きましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex1_title": "screenにメッセージを出しましょう",
    "rust_lesson2_ex8_slide2_title": "Result  Usage",
    "rust_lesson3_ex2_slide1_title": "closure?",
    "rust_lesson3_ex8_title": "unwrap_or でデフォルトvalue",
    "rust_lesson4_ex10_slide1_content": "# 番号とelementを一緒にもらう\n\nenumerate は、「何番目か」と「そのelement」をsetで取り出せるmethodです。\n\nFor example：\n- 0番目: りんご\n- 1番目: バナナ\n- 2番目: みかん\n\ncodeExample：\n```rust\nfor (i, x) in vec![\"a\", \"b\", \"c\"].iter().enumerate() {\n    println!(\"{}: {}\", i, x);\n}\n// 0: a\n// 1: b\n// 2: c\n```",
    "rust_lesson1_ex7_slide1_content": "# データを並べてまとめる「長い箱」\n\nベクタ（Vec） は、たくさんのデータを順番に並べて入れられる「長い箱」です。\n\nFor example：\n- 買い物listの商品を全部まとめる\n- testの点数を全部まとめる\n- 友だちの名前を全部まとめる\n\n100個でも1000個でも、1つのvariableでまとめて管理できます！\n\n作り方：\n```rust\nlet fruits = vec![\"りんご\", \"バナナ\", \"みかん\"];\n// vec! で ベクタを作る\n```",
    "rust_lesson4_ex8_slide3_title": "Let's Try It!",
    "rust_lesson4_ex7_description": "パターンマッチに条件を追加しましょう。",
    "rust_lesson1_ex4_comment2": "+= で 20 を足す",
    "rust_lesson1_ex2_comment2": "y に 5 を入れる",
    "rust_lesson2_ex3_slide3_title": "Let's Try It!",
    "rust_lesson3_ex4_slide1_title": "map（map）?",
    "rust_lesson1_ex2_slide3_content": "データに名前をつけて保存できる「変数（へんすう）」を使ってみましょう。letで変数を作ります。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex8_slide2_content": "# match で成功と失敗を分ける\n\n`match` で「成功したら」「失敗したら」の処理を書き分けます。\n\ncodeExample：\n```rust\nfn divide(a: i32, b: i32) -> Result<i32, String> {\n    if b == 0 {\n        return Err(\"0で割れません\".to_string());\n    }\n    Ok(a / b)  // 成功なら答えを返す\n}\n\nmatch divide(10, 2) {\n    Ok(v) => println!(\"答えは{}\", v),\n    Err(e) => println!(\"エラー: {}\", e),\n}\n```\n\nPoint：\n- `Ok(値)` で成功をreturn\n- `Err(エラー)` で失敗をreturn",
    "rust_lesson4_ex3_comment1": "Box::new でheapに格納",
    "rust_lesson4_ex8_description": "トレイトをreturnfunctionを簡潔に書きましょう。",
    "rust_lesson2_ex10_description": "typeを後から決められる「ジェネリクス」を学びましょう。",
    "rust_lesson2_ex3_slide1_title": "可変reference（かへんさんしょう）?",
    "rust_lesson2_ex2_description": "所有権を移さずにvalueを借りる「reference」を学びましょう。",
    "rust_lesson3_ex5_slide2_title": "** にNote！",
    "rust_lesson2_ex2_slide3_title": "Let's Try It!",
    "rust_lesson4_ex3_slide3_content": "ヒープにデータを格納するBoxを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex4_title": "累算assignmentoperator（+=、-=）",
    "rust_lesson3_ex3_slide2_content": "# 借りるか、もらうか\n\n3種類の iter があり、所有権の扱いが違います。\n\n3つの違い：\n```rust\nv.iter()       // 参照で借りる（&T）\nv.iter_mut()   // 変更可能で借りる（&mut T）\nv.into_iter()  // 所有権をもらう（T）\n```\n\n使い分け：\n- `iter()` → 見るだけ（元のベクタも使える）\n- `iter_mut()` → 中身を変更したい\n- `into_iter()` → ベクタごともらう（元は使えない）\n\n普通は `iter()` をuseことが多いです。",
    "rust_lesson2_ex1_slide1_title": "所有権（しょゆうけん）?",
    "rust_lesson4_ex6_slide3_content": "一意な値の集合を管理しましょう。\n\n（When you're ready, select \"Start Lesson\".）"
  },
  "es": {
    "rust_lesson1_course_title": "Introduction to Rust",
    "rust_lesson1_course_description": "Learn the basics of Rust programming.",
    "rust_lesson2_course_title": "Rust II - Intermediate",
    "rust_lesson2_course_description": "Learn intermediate Rust concepts.",
    "rust_lesson3_course_title": "Rust III - Advanced",
    "rust_lesson3_course_description": "Master advanced Rust techniques.",
    "rust_lesson4_course_title": "Rust IV - Expert Level",
    "rust_lesson4_course_description": "Expert-level Rust programming.",
    "rust_lesson1_ex5_slide2_content": "条件によって動きを変える if文を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex9_title": "collect で変換",
    "rust_lesson2_ex7_slide1_content": "# 「あるかもしれない、ないかもしれない」\n\nOption<T> は、valueが「あるかもしれないし、ないかもしれない」ことを表すtypeです。\n\nFor example：\n- dictionaryで単語を探す → 見つかるかもしれないし、ないかもしれない\n- ゲームでアイテムを拾う → 落ちてるかもしれないし、ないかもしれない\n\n2つの状態：\n- `Some(値)` → valueがある！\n- `None` → valueがない...\n\n他の言語では `null` をuseが、Rustでは `Option` で安全に扱います。",
    "rust_lesson1_ex2_slide1_title": "variable（へんすう）?",
    "rust_lesson1_ex7_description": "「ベクタ（Vec）」をuseと、たくさんのデータを一つの「長い はこ」にまとめて入れられます。",
    "rust_lesson2_ex9_slide2_content": "# 約束を作って、守る\n\n1. `trait` で「約束」をdefinition\n2. `impl トレイト for 型` で「約束を守る」implementationをdo\n\ncodeExample：\n```rust\n// 1. トレイト（約束）を定義\ntrait Speak {\n    fn speak(&self);  // 鳴くメソッドを持つ約束\n}\n\n// 2. Dog構造体がトレイトを実装\nstruct Dog;\nimpl Speak for Dog {\n    fn speak(&self) {\n        println!(\"woof\");\n    }\n}\n```\n\n「DogはSpeakができる」ということになります。",
    "rust_lesson4_ex4_description": "referenceカウントでデータを共有しましょう。",
    "rust_lesson4_ex5_slide1_content": "# 名前で引ける「dictionary」\n\nHashMap は、「key（名前）」と「value（データ）」をsetで保存dodictionaryです。\n\nFor example：\n- 「青チーム」→ 10点\n- 「赤チーム」→ 15点\n\ncodeExample：\n```rust\nuse std::collections::HashMap;\n\nlet mut scores = HashMap::new();\nscores.insert(\"Blue\", 10);   // 追加\nscores.insert(\"Red\", 15);    // 追加\n```\n\n`use` で機能を読み込んでからuse。",
    "rust_lesson3_ex4_title": "map でiterator変換",
    "rust_lesson4_ex1_slide3_content": "共通の振る舞いを定義するトレイトを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex4_description": "variableのvalueを手軽に増やしたり減らしたりdo「+=」「-=」を学びましょう。",
    "rust_lesson1_ex2_description": "データに名前をつけて保存できる「variable（へんすう）」を使ってみましょう。letでvariableをcreate。",
    "rust_lesson4_ex4_slide2_title": "referenceカウントの仕組み",
    "rust_lesson3_ex8_slide2_title": "unwrap_or_else",
    "rust_lesson4_ex10_comment1": "1番目の i にindex、2番目の item にelementが入る",
    "rust_lesson3_ex6_slide1_content": "# 累積処理\n\nfold は、初期valueとfunctionでelementを1つずつ畳み込みます。\n\n```rust\nlet v = vec![1, 2, 3];\nlet sum = v.iter().fold(0, |acc, x| acc + x);\n// 6\n```",
    "rust_lesson4_ex2_slide2_title": "よくuse derive トレイト",
    "rust_lesson3_ex10_slide3_content": "文字列型の違いを理解しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex4_slide2_content": "変数の値を手軽に増やしたり減らしたりする「+=」「-=」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex4_slide3_title": "Let's Try It!",
    "rust_lesson3_ex5_slide1_title": "filter（filterー）?",
    "rust_lesson4_ex5_description": "keyとvalueのpairを格納しましょう。",
    "rust_lesson3_ex5_description": "条件に合うelementだけを取り出しましょう。",
    "rust_lesson2_ex2_slide2_content": "# functionに借りてもらう\n\nfunctionにデータを渡すとき、`&` をつけると「借りる」形になります。元のvariableはそのまま使い続けられます。\n\ncodeExample：\n```rust\nfn calc_len(s: &String) -> usize {\n    s.len()  // 長さを返す\n}\n\nfn main() {\n    let text = String::from(\"hello\");\n    let len = calc_len(&text);  // textを貸す\n    // text はまだ使える！\n    println!(\"{}の長さは{}\", text, len);\n}\n```\n\n`&String` は「Stringを借りる」という意味です。",
    "rust_lesson4_ex7_slide3_content": "パターンマッチに条件を追加しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex8_slide2_content": "# 遅延評価\n\n```rust\n// クロージャで計算\nlet value = x.unwrap_or_else(|| expensive_computation());\n```",
    "rust_lesson4_ex7_title": "match ガード",
    "rust_lesson3_ex7_title": "? operatorでerror伝播",
    "rust_lesson4_ex1_description": "共通の振る舞いをdefineトレイトを学びましょう。",
    "rust_lesson2_ex1_slide2_content": "# 所有権は「移動」do\n\nvariableを別のvariableにassignmentdoと、所有権が 移動（ムーブ） します。元のvariableは使えなくなります。\n\ncodeExample：\n```rust\nlet s1 = String::from(\"hello\");  // s1 が持ち主\nlet s2 = s1;  // 所有権が s2 に移動！\n// ↓ s1 はもう使えない（エラーになる）\n// println!(\"{}\", s1);  // ダメ！\nprintln!(\"{}\", s2);  // OK！\n```\n\nイメージ：\nおもちゃを友だちにあげたら、自分はもう使えない。これがムーブです。",
    "rust_lesson1_ex8_slide1_title": "dictionary（HashMap）?",
    "rust_lesson4_ex3_slide2_content": "# サイズが決まらないとき\n\nBoxは、コンパイル時にサイズがわからないtypeにuse。\n\nFor examplerecursion的なtype：\n```rust\n// リストは「値 + 次のリスト」の繰り返し\nenum List {\n    Cons(i32, Box<List>),  // Boxで次を指す\n    Nil,                   // 終わり\n}\n```\n\nなぜBoxが必要？\n- `List` の中に `List` がある → 無限に大きくなる？\n- `Box` をuseと、サイズが固定（pointerのサイズ）になる\n\n「中身」ではなく「中身への矢印」を持つイメージです。",
    "rust_lesson2_ex10_title": "ジェネリクスを使おう",
    "rust_lesson2_ex8_slide3_title": "Let's Try It!",
    "rust_lesson3_ex9_slide2_content": "# 可変reference\n\n```rust\n// mut が必要\nlet mut v = Vec::new();\nv.push(1);\nv.push(2);\n```",
    "rust_lesson4_ex4_title": "Rc<T>",
    "rust_lesson2_ex3_comment1": "mut で可変variableにdo",
    "rust_lesson4_ex5_slide3_title": "Let's Try It!",
    "rust_lesson2_ex6_slide2_content": "# バリアントを列挙\n\n`enum 名前 { バリアント1, バリアント2, ... }` でdefine。\n\ncodeExample：\n```rust\nenum Color {\n    Red,\n    Green,\n    Blue,\n}\nlet c = Color::Red;\n```",
    "rust_lesson1_ex1_comment1": "Hello, Rust! とdisplay",
    "rust_lesson1_ex1_slide1_content": "# 安全で速い！最新のプログラミング言語\n\nRust（ラスト）は、「間違いを事前に防ぐ」ことがとても得意なプログラミング言語です。\n\nRustのすごいところ：\n- programのミスをexecute前に見つけてくれる\n- とても速く動く\n- 世界中のプログラマーが「一番好き！」と選ぶ人気の言語\n\nたとえるなら：\n厳しいけど優しい先生のような言語です。「ここ間違ってるよ」と教えてくれるので、安心してprogramが書けます！",
    "rust_lesson3_ex8_slide1_content": "# None/Err の場合のデフォルト\n\nunwrap_or は、None や Err の場合にデフォルトvalueをreturn。\n\n```rust\nlet x: Option<i32> = None;\nlet value = x.unwrap_or(0);  // 0\n```",
    "rust_lesson2_ex7_slide3_title": "Let's Try It!",
    "rust_lesson2_ex6_title": "enum で状態を表す",
    "rust_lesson2_ex8_slide1_content": "# 「成功」か「失敗」かを表す\n\nResult<T, E> は、処理が「成功したか失敗したか」を表すtypeです。\n\nFor example：\n- fileをopen → 成功（内容）か失敗（error）\n- 0で割り算 → 成功（答え）か失敗（0で割れない！）\n\n2つの状態：\n- `Ok(値)` → 成功！valueが入っている\n- `Err(エラー)` → 失敗...error情報が入っている\n\n`Option` は「あるか・ないか」、`Result` は「成功か・失敗か」という違いです。",
    "rust_lesson2_ex8_slide3_content": "成功と失敗を表す「Result」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex6_slide1_title": "HashSet ?",
    "rust_lesson3_ex9_comment1": "push でelementを追加",
    "rust_lesson2_ex7_slide2_title": "Option  Usage",
    "rust_lesson3_ex2_title": "closureのBasic",
    "rust_lesson3_ex7_slide1_title": "? operator?",
    "rust_lesson4_ex6_comment1": "HashSet をimport",
    "rust_lesson2_ex10_slide1_content": "# どんなtypeでも使える「万能」の仕組み\n\nジェネリクス は、typeを後から決められる仕組みです。\n\nなぜ便利？\n同じようなfunctionを何度も書かなくてすみます。\n\nFor example：\n- 数字のarrayの最初のelementを取るfunction\n- stringのarrayの最初のelementを取るfunction\n\n両方とも「最初のelementを取る」のは同じなのに、typeが違うだけで別のfunctionをwriteのは大変！\n\nジェネリクスなら、`<T>` で「typeは後で決める」とwriteだけで、どんなtypeでも使えるfunctionが作れます。",
    "rust_lesson1_ex3_slide1_content": "# 剰余operator（じょうよえんざんし）「%」\n\n`%`（パーセント）は、割り算の 「あまり」 をcalculate特別な記号です。\n\nわかりやすいExample：\n- 10このアメを3人で分けると？\n- 1人3こずつで、1こあまる\n- これを `10 % 3` とwriteと、答えは `1`\n\ncodeExample：\n```rust\nprintln!(\"{}\", 10 % 3);  // 1（あまり1）\nprintln!(\"{}\", 8 % 4);   // 0（あまりなし＝割り切れる）\n```\n\n使いどころ：\n- 偶数か奇数か調べる（`n % 2` が0なら偶数）\n- 時計の計算（24を超えたら0に戻る、など）",
    "rust_lesson3_ex7_description": "errorを簡潔に伝播させましょう。",
    "rust_lesson3_ex8_comment1": "unwrap_or でデフォルトvalueを設定",
    "rust_lesson2_ex8_title": "Result<T, E> でerror処理",
    "rust_lesson2_ex10_comment1": "T をtypeパラメータとしてuse",
    "rust_lesson2_ex6_comment1": "enum で列挙typeをdefinition",
    "rust_lesson3_ex3_slide3_content": "要素を順番に処理するイテレータを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex2_comment1": "derive でトレイトを自動implementation",
    "rust_lesson1_ex8_slide1_content": "# 名前でsearchできる「dictionary」\n\nHashMap（ハッシュmap）は、「名前」と「データ」をsetにして保存できる仕組みです。本物のdictionaryのように使えます。\n\nFor example果物の色dictionary：\n- 「りんご」→「あか」\n- 「バナナ」→「きいろ」\n- 「みかん」→「オレンジ」\n\nuse準備：\n```rust\nuse std::collections::HashMap;  // 機能を読み込む\nlet mut fruits = HashMap::new();  // 空の辞書を作る\nfruits.insert(\"りんご\", \"あか\");  // データを追加\n```\n\n`use` は「この機能をuseよ」というdeclarationです。",
    "rust_lesson3_ex9_slide1_title": "push ?",
    "rust_lesson4_ex1_title": "トレイトのdefinition",
    "rust_lesson4_ex3_description": "heapにデータを格納doBoxを学びましょう。",
    "rust_lesson1_ex2_title": "便利な「はこ」variable（へんすう）",
    "rust_lesson1_ex8_comment2": "中身を出す",
    "rust_lesson3_ex9_slide3_title": "Let's Try It!",
    "rust_lesson1_ex4_comment3": "-= で 50 を引く",
    "rust_lesson1_ex6_comment1": "&& で両方の条件をチェック",
    "rust_lesson4_ex1_slide2_title": "トレイトのimplementation",
    "rust_lesson4_ex7_slide3_title": "Let's Try It!",
    "rust_lesson4_title": "Rust IV - トレイトとスマートpointer",
    "rust_lesson4_ex1_comment1": "trait でトレイトをdefinition",
    "rust_lesson4_ex4_slide1_content": "# 複数の「持ち主」を許可do仕組み\n\nRc<T> は「Reference Counted（referenceカウント）」の略で、複数の所有者でデータを共有できます。\n\n普通の所有権：\n1人だけが持ち主。渡したら元の人は使えない。\n\nRc をuseと：\n複数人が同じデータの「持ち主」になれる！\n\ncodeExample：\n```rust\nuse std::rc::Rc;\n\nlet a = Rc::new(5);       // Rcでラップ\nlet b = Rc::clone(&a);    // bも持ち主になる\n// a も b も使える！\n```",
    "rust_lesson3_ex5_slide1_content": "# 条件に合うものだけ残す\n\nfilter は、条件を満たすelementだけを残し、他を捨てます。\n\nFor example：\n- 80点以上の人だけ残す\n- 偶数だけ残す\n- 「あ」から始まる名前だけ残す\n\ncodeExample：\n```rust\nlet v = vec![1, 2, 3, 4, 5];\nlet evens: Vec<_> = v.iter()\n    .filter(|x| **x % 2 == 0)  // 偶数だけ\n    .collect();\n// [2, 4]\n```\n\n条件が `true` のelementだけが残ります。",
    "rust_lesson3_ex7_slide3_title": "Let's Try It!",
    "rust_lesson1_ex7_comment2": "2番目のデータ（1番）を出す",
    "rust_lesson4_ex8_title": "impl Trait",
    "rust_lesson1_ex5_description": "条件によって動きを変える if文を学びましょう。",
    "rust_lesson3_ex4_slide2_title": "遅延評価（ちえんひょうか）",
    "rust_lesson3_ex1_slide1_content": "# referenceの「寿命」を示す印\n\nライフタイム は、referenceがいつまで使えるかを示す印です。`'a`（アポストロフィ・エー）のようにwrite。\n\nなぜ必要？\nreferenceは「借りている」状態。借りた元のデータが消えたら、referenceも使えなくなります。\n\nFor example：\n- 図書館で借りた本 → 図書館が閉まったら読めない\n- referenceで借りたデータ → 元のデータが消えたら使えない\n\nライフタイムは「このreferenceはこの範囲で有効だよ」とコンパイラに伝える仕組みです。",
    "rust_lesson1_ex1_slide1_title": "Rust（ラスト）?",
    "rust_lesson1_ex2_slide2_title": "計算の記号（operator）",
    "rust_lesson4_ex5_slide2_content": "# get で安全に取り出す\n\n`get()` methodでvalueを取り出せます。見つからない可能性があるので、`Option` が返ってきます。\n\ncodeExample：\n```rust\n// getはOption<&V>を返す\nif let Some(score) = scores.get(\"Blue\") {\n    println!(\"青チームは{}点\", score);\n}\n```\n\nPoint：\n- keyがあれば `Some(値)` が返る\n- keyがなければ `None` が返る\n- `if let` で安全に取り出せる\n\n存在しないkeyでアクセスしてもprogramが落ちない！",
    "rust_lesson4_ex7_slide1_title": "match ガード?",
    "rust_lesson3_title": "Rust III - ライフタイムとiterator",
    "rust_lesson4_ex3_title": "Box<T>",
    "rust_lesson1_ex4_slide1_title": "累算assignmentoperator（るいさんだいにゅう）?",
    "rust_lesson2_ex9_comment1": "trait でトレイトをdefinition",
    "rust_lesson2_ex1_description": "Rust独自の概念「所有権」を学びましょう。",
    "rust_lesson2_ex3_slide3_content": "参照先の値を変更できる「可変参照」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex1_slide3_title": "Let's Try It!",
    "rust_lesson3_ex6_slide2_title": "様々な畳み込み",
    "rust_lesson4_ex9_slide3_title": "Let's Try It!",
    "rust_lesson2_ex5_title": "impl でmethodを追加",
    "rust_lesson2_ex6_slide1_content": "# 複数の選択肢\n\nenum は、valueがいくつかの種類のうちの一つであることを表します。各バリアントにデータを持たせることもできます。",
    "rust_lesson2_ex4_comment1": "struct で構造体をdefinition",
    "rust_lesson1_ex3_title": "剰余operator（%）",
    "rust_lesson1_ex7_comment1": "colors というベクタをcreate（'あか', 'あお'の順）",
    "rust_lesson1_ex4_slide1_content": "# valueをかんたんに増やす・減らす\n\n`+=`（プラスイコール）と `-=`（マイナスイコール）は、variableの中身を増やしたり減らしたりdo便利な記号です。\n\nRustのImportantなルール：`mut`が必要！\nRustでは、variableをchangeには `let mut`（レット ミュート）とwrite必要があります。`mut` は「mutable（変更できる）」の略です。\n\ncodeExample：\n```rust\nlet mut score = 100;  // mut をつけて変更可能に\nscore += 10;          // 10を足す → 110に\nscore -= 50;          // 50を引く → 60に\n```\n\n`mut` がないと「このvariableは変えちゃダメ！」とRustが怒ります。",
    "rust_lesson2_ex1_slide2_title": "ムーブ（移動）",
    "rust_lesson3_ex4_comment1": "map で各elementを変換",
    "rust_lesson3_ex8_slide1_title": "unwrap_or ?",
    "rust_lesson2_ex5_slide1_content": "# implementationブロック\n\nimpl ブロックで、構造体にmethodを追加できます。`self` で自分自身をreferenceします。",
    "rust_lesson2_ex10_slide1_title": "ジェネリクス?",
    "rust_lesson1_ex8_slide2_content": "# 名前（key）で取り出す\n\ndictionaryに入れたデータは、名前（key）を指定して取り出せます。\n\ncodeExample：\n```rust\nuse std::collections::HashMap;\nfn main() {\n    let mut fruits = HashMap::new();\n    fruits.insert(\"りんご\", \"あか\");  // 追加\n    fruits.insert(\"バナナ\", \"きいろ\");  // 追加\n    \n    println!(\"{}\", fruits[\"りんご\"]);  // あか と表示\n}\n```\n\nPoint：\n- `insert(名前, データ)` で追加\n- `辞書[名前]` で取り出し\n- 番号ではなく「名前」で探せるのが便利！",
    "rust_lesson4_ex9_slide1_content": "# iteratorをコレクションに\n\ncollect は、iteratorをVecやHashMapなどに変換します。\n\n```rust\nlet v: Vec<_> = (0..5).collect();\nlet s: String = vec!['a', 'b'].into_iter().collect();\n```",
    "rust_lesson2_ex2_slide3_content": "所有権を移さずに値を借りる「参照」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex2_slide3_content": "周囲の変数を使える無名関数「クロージャ」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex4_slide2_content": "# struct keyワードでdefinition\n\n`struct 名前 { フィールド }` で構造体をdefine。フィールドには名前とtypeをwrite。\n\ncodeExample：\n```rust\n// Point 構造体を定義\nstruct Point {\n    x: i32,  // xフィールド（整数）\n    y: i32,  // yフィールド（整数）\n}\n\n// 使い方\nlet p = Point { x: 10, y: 20 };\nprintln!(\"x={}, y={}\", p.x, p.y);\n```\n\nPoint：\n- `struct 名前` で構造体をcreate\n- `{ フィールド名: 型 }` でどんなデータを持つか決める\n- `.フィールド名` でアクセス",
    "rust_lesson2_ex10_slide3_content": "型を後から決められる「ジェネリクス」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex6_slide3_title": "Let's Try It!",
    "rust_lesson4_ex6_slide1_content": "# 一意なvalueのset\n\nHashSet は、重複のないvalueのsetです。\n\n```rust\nuse std::collections::HashSet;\n\nlet mut set = HashSet::new();\nset.insert(1);\nset.insert(2);\nset.insert(1); // 重複は無視\n```",
    "rust_lesson4_ex2_title": "derive 属性",
    "rust_lesson4_ex2_slide1_content": "# トレイトを「自動で」implementation\n\n#[derive(...)] をuseと、よくuseトレイトを自分で書かなくても自動でimplementationしてくれます。\n\nFor example：\n構造体を `println!` でdisplayしたいとき、普通は Display トレイトをimplementationdo必要がありますが、`#[derive(Debug)]` をwriteだけでOK！\n\ncodeExample：\n```rust\n#[derive(Debug)]  // Debug トレイトを自動実装\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nlet p = Point { x: 1, y: 2 };\nprintln!(\"{:?}\", p);  // Point { x: 1, y: 2 }\n```",
    "rust_lesson1_ex6_slide2_title": "Let's Try It!",
    "rust_lesson3_ex3_slide2_title": "3つの iter method",
    "rust_lesson4_ex7_slide2_content": "# 複雑なconditional\n\n```rust\nmatch Some(5) {\n    Some(x) if x % 2 == 0 => println!(\"even\"),\n    Some(x) => println!(\"odd: {}\", x),\n    None => println!(\"none\"),\n}\n```",
    "rust_lesson3_ex3_slide1_content": "# elementを1つずつ取り出す仕組み\n\niterator は、ベクタなどのデータを「1つずつ順番に」取り出す仕組みです。\n\nFor example：\n- 行列に並んでいる人を1人ずつ呼ぶ\n- 引き出しの中身を1つずつ出す\n\ncodeExample：\n```rust\nlet v = vec![1, 2, 3];\nfor x in v.iter() {\n    println!(\"{}\", x);  // 1, 2, 3 と順番に表示\n}\n```\n\n`iter()` で「順番に取り出す準備」をして、`for` で1つずつ処理します。",
    "rust_lesson3_ex3_slide1_title": "iterator?",
    "rust_lesson4_ex2_description": "トレイトを自動implementationdoderiveを学びましょう。",
    "rust_lesson3_ex4_slide1_content": "# 全部を同じように変換do\n\n**map** は、iteratorの各elementを「同じ方法で」変換します。\n\nFor example：\n- 全員の身長を2倍にdo\n- 全員の名前を大文字にdo\n- 全部の数を2乗do\n\ncodeExample：\n```rust\nlet v = vec![1, 2, 3];\nlet doubled: Vec<_> = v.iter()\n    .map(|x| x * 2)  // 各要素を2倍に\n    .collect();      // ベクタに戻す\n// [2, 4, 6]\n```\n\n`|x| x * 2` は「xを受け取って、x*2をreturn」closureです。",
    "rust_lesson1_ex3_slide1_title": "あまりを求める",
    "rust_lesson3_ex10_slide1_content": "# 所有権の違い\n\nString は所有権を持つheap上のstring、&str はreferenceです。\n\n```rust\nlet s1: String = String::from(\"hello\");\nlet s2: &str = \"hello\";\n```",
    "rust_lesson4_ex2_slide1_title": "derive（デライブ）?",
    "rust_lesson2_ex2_comment1": "& でreferenceを渡す",
    "rust_lesson4_ex5_slide1_title": "HashMap（ハッシュmap）?",
    "rust_lesson2_ex3_slide2_title": "&mut  Usage",
    "rust_lesson3_ex5_title": "filter で絞り込み",
    "rust_lesson4_ex3_slide2_title": "いつuse？",
    "rust_lesson2_ex2_title": "referenceと借用",
    "rust_lesson2_ex7_title": "Option<T> で null を安全に",
    "rust_lesson4_ex10_slide3_title": "Let's Try It!",
    "rust_lesson3_ex5_slide3_title": "Let's Try It!",
    "rust_lesson4_ex10_title": "enumerate でindex付き",
    "rust_lesson2_ex2_slide1_content": "# 所有権を渡さずに「借りる」\n\nreference をuseと、所有権を移さずにデータを「見せてもらう」ことができます。\n\nたとえるなら：\n- ムーブ = おもちゃをあげる（自分は使えない）\n- reference = おもちゃを見せる（自分も使える）\n\n作り方：\n`&`（アンパサンド）をつけるとreferenceを作れます。\n\n```rust\nlet s = String::from(\"hello\");\nlet r = &s;  // sを借りる（見せてもらう）\n// s も r も使える！\n```",
    "rust_lesson2_ex5_slide2_content": "# &self をuse\n\nmethodの最初のargumentは `&self` です。\n\ncodeExample：\n```rust\nimpl Rect {\n    fn area(&self) -> i32 {\n        self.width * self.height\n    }\n}\n```",
    "rust_lesson1_ex5_slide2_title": "Let's Try It!",
    "rust_lesson2_ex4_slide3_title": "Let's Try It!",
    "rust_lesson4_ex3_slide3_title": "Let's Try It!",
    "rust_lesson2_ex9_slide3_content": "共通の振る舞いを定義する「トレイト」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex1_slide2_content": "# impl で約束を守る\n\n構造体にトレイトをimplementationdoと、その構造体は「約束を守る」ことになります。\n\ncodeExample：\n```rust\nstruct Person { name: String }\n\nimpl Greet for Person {\n    fn greet(&self) -> String {\n        format!(\"Hello, {}\", self.name)\n    }\n}\n```\n\n読み方：\n- `impl Greet for Person` → 「PersonはGreetをimplementationdo」\n- これでPersonは「あいさつできる」ようになった！",
    "rust_lesson4_ex4_comment1": "clone でreferenceカウントを増やす",
    "rust_lesson3_ex4_slide2_content": "# map だけではexecuteされない！\n\nRustのiteratorは 遅延評価 といって、「本当に必要になるまで処理しない」仕組みです。\n\nなぜ？\n無駄な計算を省けるから。100万件あっても、最初の10件だけ欲しいなら10件だけ処理すればいい。\n\ncollect() でexecute：\n```rust\n// これだけでは何も起きない\nv.iter().map(|x| x * 2);\n\n// collect() で実行してベクタに変換\nlet result: Vec<_> = v.iter().map(|x| x * 2).collect();\n```\n\n`collect()` は「今すぐ全部処理してResultをちょうだい」という意味です。",
    "rust_lesson2_ex4_slide2_title": "struct のdefinitionのしかた",
    "rust_lesson2_ex3_slide1_content": "# 「書き換えできる」借り方\n\n普通のreference `&` は「見るだけ」ですが、可変reference `&mut` は「変更もできる」借り方です。\n\nたとえるなら：\n- `&` = 本を見せてもらう（readだけ）\n- `&mut` = ノートを借りる（writeOK）\n\nImportantなルール：\n- 可変referenceは同時に1つだけ！\n- 「みんなで見る」か「1人でwrite」かのどちらか\n\nこのルールで、データが同時に書き換えられるバグを防いでいます。",
    "rust_lesson2_ex10_slide3_title": "Let's Try It!",
    "rust_lesson2_ex4_title": "構造体をdefinitionしよう",
    "rust_lesson3_ex10_slide2_content": "# 相互変換\n\n```rust\n// &str -> String\nlet s = \"hello\".to_string();\n\n// String -> &str\nlet slice: &str = &s;\n```",
    "rust_lesson4_ex10_slide3_content": "イテレータにインデックスを付けましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex4_slide2_content": "# 「何人が持っているか」を数える\n\nRcは「今何人がこのデータを持っているか」を数えています。\n\ncodeExample：\n```rust\nlet a = Rc::new(5);\nprintln!(\"{}\", Rc::strong_count(&a));  // 1\n\nlet b = Rc::clone(&a);\nprintln!(\"{}\", Rc::strong_count(&a));  // 2\n```\n\nいつデータが消える？\n- カウントが0になったとき（誰も持っていないとき）\n- 最後の持ち主がいなくなると自動で片付けられる\n\n`Rc::clone` は「持ち主を1人増やす」操作です。",
    "rust_lesson1_ex8_slide2_title": "dictionary Usage",
    "rust_lesson4_ex3_slide1_content": "# データを「heap」に置く箱\n\nBox<T> は、データを「heap」という特別な場所に置くための箱です。\n\nmemoryの2つの場所：\n- stack：小さくて速い。サイズが決まっているデータ向け\n- heap：大きくて柔軟。サイズが大きいor変わるデータ向け\n\ncodeExample：\n```rust\nlet b = Box::new(5);  // 5をヒープに置く\nprintln!(\"{}\", *b);   // *で中身を取り出す → 5\n```\n\n`*` は「箱を開けて中身を見る」操作です。",
    "rust_lesson3_ex2_slide2_title": "closure Syntax",
    "rust_lesson4_ex4_slide1_title": "Rc（アールシー）?",
    "rust_lesson4_ex7_slide1_content": "# 追加条件\n\n**if** でパターンに追加条件をつけられます。\n\n```rust\nmatch x {\n    n if n < 0 => println!(\"negative\"),\n    n if n > 0 => println!(\"positive\"),\n    _ => println!(\"zero\"),\n}\n```",
    "rust_lesson2_ex3_title": "可変reference",
    "rust_lesson3_ex10_comment1": "to_string で String に変換",
    "rust_lesson3_ex10_slide2_title": "変換",
    "rust_lesson3_ex1_description": "referenceの有効期間を表すライフタイムを学びましょう。",
    "rust_lesson3_ex2_slide1_content": "# 名前のない「即席」function\n\nclosure は、名前をつけずにその場でcreatefunctionです。そして特別な能力があります：周りのvariableを使えるのです！\n\nFor example：\n```rust\nlet x = 5;  // 外側の変数\nlet add_x = |n| n + x;  // xを使えるクロージャ\nprintln!(\"{}\", add_x(10));  // 15\n```\n\n普通のfunctionとの違い：\n- 普通のfunction：argumentしか使えない\n- closure：argument + 周りのvariableも使える\n\n「その場の空気を読める」functionというイメージです！",
    "rust_lesson1_ex2_comment1": "x に 10 を入れる",
    "rust_lesson1_ex7_slide3_title": "Let's Try It!",
    "rust_lesson1_ex5_title": "「もし〜なら」で分けましょう",
    "rust_lesson3_ex2_slide3_title": "Let's Try It!",
    "rust_lesson3_ex7_slide2_content": "# 簡潔なerror処理\n\n```rust\n// ? を使わない場合\nmatch result {\n    Ok(v) => v,\n    Err(e) => return Err(e),\n}\n\n// ? を使う\nresult?\n```",
    "rust_lesson3_ex6_slide3_title": "Let's Try It!",
    "rust_lesson4_ex9_slide3_content": "イテレータをコレクションに変換しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex6_description": "elementを1つのvalueにまとめるfoldを学びましょう。",
    "rust_lesson2_ex9_description": "共通の振る舞いをdefine「トレイト」を学びましょう。",
    "rust_lesson2_ex8_comment1": "Ok で成功をreturn",
    "rust_lesson3_ex5_slide2_content": "# filter はreferenceのreferenceを受け取る\n\n`filter` のclosureは、referenceのreference（`&&T`）を受け取ります。そのため、valueをuseには `**x` と2回referenceを外す必要があります。\n\nなぜ？\n- `iter()` はreference（`&T`）をreturn\n- `filter` はそれをFurthermorereferenceで渡す（`&&T`）\n\nSyntax：\n```rust\n// **x で値を取り出す\n.filter(|x| **x > 2)\n\n// または * を引数につける\n.filter(|&x| *x > 2)\n```\n\n最初は混乱しますが、慣れれば大丈夫！",
    "rust_lesson1_ex5_comment1": "> でcompare",
    "rust_lesson2_ex4_description": "関連doデータをまとめる「構造体」を学びましょう。",
    "rust_lesson3_ex5_slide3_content": "条件に合う要素だけを取り出しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex7_slide3_content": "「ベクタ（Vec）」を使うと、たくさんのデータを一つの「長い はこ」にまとめて入れられます。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex5_slide2_title": "valueの取得",
    "rust_lesson3_ex1_slide1_title": "ライフタイム?",
    "rust_lesson1_ex3_comment1": "10 を 3 で割ったあまりをoutput",
    "rust_lesson3_ex1_comment1": "'a でライフタイムをdefinition",
    "rust_lesson3_ex10_slide1_title": "String vs &str",
    "rust_lesson2_title": "Rust II - 所有権とトレイト",
    "rust_lesson2_ex5_slide2_title": "methodのdefinition",
    "rust_lesson4_ex5_comment1": "insert でkeyとvalueを追加",
    "rust_lesson2_ex9_slide1_content": "# 「できること」の約束\n\nトレイト は、「このtypeはこういうことができる」という約束をdefine。\n\nFor example「鳴ける」という約束：\n- 犬は「ワン」と鳴く\n- 猫は「ニャー」と鳴く\n- 両方とも「鳴ける」能力がある\n\nトレイトは「鳴ける動物は、鳴き声を出すmethodを持つ」という約束です。\n\n他の言語とのcomparison：\n- Java: interface\n- TypeScript: interface\n\nに似た概念です。",
    "rust_lesson1_ex2_slide3_title": "Let's Try It!",
    "rust_lesson4_ex8_slide1_content": "# return valueのtypeをabstract化\n\nimpl Trait で、トレイトをimplementationdotypeを返せます。\n\n```rust\nfn make_iter() -> impl Iterator<Item = i32> {\n    vec![1, 2, 3].into_iter()\n}\n```",
    "rust_lesson1_ex2_slide2_content": "# 四則演算（しそくえんざん）\n\nRustでも算数と同じ記号で計算ができます。\n\n4つのBasic記号：\n- +（プラス）: たし算\n- -（マイナス）: ひき算\n- \\*（アスタリスク）: かけ算（×の代わり）\n- /（スラッシュ）: わり算（÷の代わり）\n\ncodeExample：\n```rust\nlet a = 10;\nlet b = 5;\nprintln!(\"{}\", a + b);  // 15 と表示される\n```\n\n`println!` の `{}` は「ここにvalueを入れてね」という目印です。",
    "rust_lesson4_ex9_slide2_content": "# 変換先を指定\n\n```rust\n// ターボフィッシュ構文\nlet v = (0..5).collect::<Vec<_>>();\n\n// 変数の型注釈\nlet v: Vec<i32> = (0..5).collect();\n```",
    "rust_lesson1_ex8_description": "「dictionary（HashMap）」をuseと、名前をつけてデータを保存し、その名前で取り出せます。",
    "rust_lesson4_ex9_slide2_title": "typeHint",
    "rust_lesson3_ex1_title": "ライフタイムのBasic",
    "rust_lesson2_ex5_description": "構造体にmethodをadd「impl」を学びましょう。",
    "rust_lesson4_ex8_comment1": "impl でトレイトをimplementationdotypeをreturn",
    "rust_lesson4_ex8_slide2_title": "argumentにも使える",
    "rust_lesson4_ex7_comment1": "if でマッチガードを追加",
    "rust_lesson2_ex9_slide2_title": "trait のdefinitionとimplementation",
    "rust_lesson4_ex10_slide2_title": "いつuse？",
    "rust_lesson3_ex7_slide2_title": "match の省略形",
    "rust_lesson1_ex6_title": "logicaloperator（&&、||）",
    "rust_lesson3_ex6_comment1": "fold で畳み込み",
    "rust_lesson2_ex6_description": "複数の状態を表す「列挙type（enum）」を学びましょう。",
    "rust_lesson4_ex10_slide1_title": "enumerate（イニュメレート）?",
    "rust_lesson1_ex7_slide1_title": "ベクタ（Vec）?",
    "rust_lesson2_ex6_slide3_content": "複数の状態を表す「列挙型（enum）」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex3_slide3_title": "Let's Try It!",
    "rust_lesson3_ex4_description": "各elementを変換domapを学びましょう。",
    "rust_lesson4_ex1_slide3_title": "Let's Try It!",
    "rust_lesson3_ex9_slide2_title": "mut が必要",
    "rust_lesson1_ex6_slide1_content": "# logicaloperator（ろんりえんざんし）\n\n2つ以上の条件を組み合わせたいときにuse記号です。\n\n2つの記号：\n- `&&`（アンドアンド）：「かつ」＝ 両方とも 正しいとき\n- `||`（オアオア）：「Alsoは」＝ どちらか 正しいとき\n\n身近なExample：\n- 遊園地：「18歳以上 かつ チケットあり」なら乗れる\n- おやつ：「宿題終わった Alsoは お手伝いした」ならOK\n\ncodeExample：\n```rust\nif score >= 70 && bonus > 0 {\n    // 70点以上 かつ ボーナスあり → 合格！\n    println!(\"合格！\");\n}\n```",
    "rust_lesson4_ex4_slide3_content": "参照カウントでデータを共有しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex6_slide3_title": "Let's Try It!",
    "rust_lesson2_ex5_slide3_content": "構造体にメソッドを追加する「impl」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex1_slide3_title": "Let's Try It!",
    "rust_lesson1_ex5_slide1_content": "# programに「判断」させよう\n\nconditional は、「もし〜なら、〇〇do」という判断をprogramにさせる仕組みです。\n\n身近なExample：\n- もし80点以上なら → 「合格！」とdisplay\n- もし雨なら → 傘を持っていく\n- もしHPが0なら → ゲームオーバー\n\nRustで Syntax：\n```rust\nif score > 80 {\n    println!(\"合格！\");\n}\n```\n\n読み方：\n- `if` →「もし」\n- `score > 80` →「スコアが80より大きいなら」\n- `{ }` の中 →「これをやる」",
    "rust_lesson4_ex5_title": "HashMap",
    "rust_lesson1_ex2_slide1_content": "# データを保存do「はこ」\n\nvariable（へんすう） は、数字や文字を入れておける「はこ」のことです。名前をつけて、あとでuseことができます。\n\nFor example：\n- 「りんごの数」というラベルの箱に「5」を入れる\n- あとで「りんごの数」と呼べば「5」が出てくる\n\nRustで Syntax：\n```rust\nlet x = 10;  // xという箱に10を入れる\nprintln!(\"{}\", x);  // xの中身（10）を表示\n```\n\n`let` は「この名前で箱をcreateよ」という意味です。",
    "rust_lesson2_ex4_slide3_content": "関連するデータをまとめる「構造体」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex6_slide1_title": "enum ?",
    "rust_lesson2_ex9_title": "トレイトをdefinitionしよう",
    "rust_lesson2_ex4_slide1_title": "構造体（こうぞうたい）?",
    "rust_lesson4_ex2_slide2_content": "# 覚えておくと便利な5つ\n\nよくusederiveトレイト：\n```rust\nDebug     // {:?} でデバッグ表示できる\nClone     // .clone() でコピーを作れる\nCopy      // 代入時に自動でコピー（小さい型向け）\nPartialEq // == で比較できる\nDefault   // 初期値を自動で作れる\n```\n\n複数指定もOK：\n```rust\n#[derive(Debug, Clone, PartialEq)]\nstruct User {\n    name: String,\n    age: u32,\n}\n```\n\n`Debug` は特によくuse。debug時に構造体の中身を見れて便利！",
    "rust_lesson2_ex1_slide1_content": "# データの「持ち主」を決めるルール\n\n所有権 は、Rust最大のFeatureです。「このデータの持ち主は誰か」をはっきりさせる仕組みです。\n\nルール：\n- データには必ず1人だけ「持ち主」がいる\n- 持ち主がいなくなると、データは自dynamicに片付けられる\n\nたとえるなら：\n- おもちゃは1人しか持てない\n- 持ち主が部屋を出たら、おもちゃは片付けられる\n\nこのルールのおかげで、Rustは「memoryリーク」（データが片付けられないバグ）を防げます！",
    "rust_lesson1_ex3_slide2_title": "Let's Try It!",
    "rust_lesson3_ex1_slide2_title": "なぜ必要？",
    "rust_lesson3_ex1_slide2_content": "# 危険なバグを防ぐ\n\nダングリングreference という危険なバグがあります。これは「もう存在しないデータ」を指し続けているreferenceのことです。\n\nExample：\n```rust\nfn longest<'a>(x: &'a str, y: &'a str) -> &'a str {\n    if x.len() > y.len() { x } else { y }\n}\n```\n\n`'a` の意味：\n- argument `x` と `y` は同じライフタイム `'a` を持つ\n- return valueも同じライフタイム `'a` を持つ\n- In other words「xとyが両方有効な間、return valueも有効」という約束\n\nRustはこれを自動でチェックしてくれます！",
    "rust_lesson4_ex6_slide2_title": "set演算",
    "rust_lesson3_ex7_comment1": "? でerrorを伝播",
    "rust_lesson3_ex2_slide2_content": "# | | でargumentを囲む\n\nclosureは `|引数| 処理` という形でwrite。`||` は「パイプ」と呼ばれます。\n\nいろいろなSyntax：\n```rust\n// 引数なし\n|| println!(\"Hello\")\n\n// 引数あり\n|x, y| x + y\n\n// 複数行のブロック\n|x| {\n    let y = x * 2;\n    y + 1\n}\n```\n\nPoint：\n- argumentを `| |` で囲む（functionの `()` の代わり）\n- typeは省略できることが多い（Rustが推測してくれる）",
    "rust_lesson2_ex7_comment1": "Some でvalueがあることを示す",
    "rust_lesson3_ex4_slide3_content": "各要素を変換するmapを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_title": "Rust (ラスト) に挑戦！",
    "rust_lesson2_ex8_description": "成功と失敗を表す「Result」を学びましょう。",
    "rust_lesson3_ex8_description": "Option/Resultのデフォルトvalueを設定しましょう。",
    "rust_lesson4_ex2_slide3_title": "Let's Try It!",
    "rust_lesson2_ex5_slide3_title": "Let's Try It!",
    "rust_lesson4_ex9_description": "iteratorをコレクションに変換しましょう。",
    "rust_lesson1_ex1_slide2_content": "# println! でscreenにdisplay\n\nRustで文字をscreenにdisplayには、`println!`（プリントラインびっくり）をuse。\n\nPoint：\n- `!` がつくのがRustのFeature（マクロと呼ばれます）\n- programは `fn main() { }` の中にwrite\n- `fn` は「function（function）」の略\n\ncodeExample：\n```rust\nfn main() {\n    println!(\"ヤッホー！\");\n}\n// 「ヤッホー！」と画面に表示される\n```\n\n`println!` の `!` は「マクロ」という特別な機能の印です。今は「おまじない」と思っておけばOK！",
    "rust_lesson3_ex6_slide1_title": "fold ?",
    "rust_lesson4_ex8_slide1_title": "impl Trait ?",
    "rust_lesson1_ex1_slide2_title": "Rustの「おまじない」",
    "rust_lesson3_ex10_description": "stringtypeの違いを理解しましょう。",
    "rust_lesson3_ex7_slide3_content": "エラーを簡潔に伝播させましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex1_comment1": "s1 の所有権を移動",
    "rust_lesson2_ex9_slide1_title": "トレイト?",
    "rust_lesson4_ex6_slide2_content": "# 和set、積setなど\n\n```rust\nset1.union(&set2)\nset1.intersection(&set2)\nset1.difference(&set2)\n```",
    "rust_lesson4_ex5_slide3_content": "キーと値のペアを格納しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex8_slide1_title": "Result（リザルト）?",
    "rust_lesson4_ex1_slide1_content": "# 「できること」の約束\n\nトレイト は、typeが持つべきmethodをdefine仕組みです。\n\nFor example：\n- 「あいさつできる」トレイト → greet() methodを持つ\n- 「displayできる」トレイト → display() methodを持つ\n\ncodeExample：\n```rust\ntrait Greet {\n    fn greet(&self) -> String;  // メソッドの「約束」\n}\n```\n\nこれは「Greetできるtypeは、greet()methodを持つ」という約束です。",
    "rust_lesson4_ex2_slide3_content": "トレイトを自動実装するderiveを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex6_title": "fold で畳み込み",
    "rust_lesson3_ex9_slide3_content": "Vecに要素を追加しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex4_slide1_content": "# 関係あるデータをまとめる「設計図」\n\n構造体（struct） は、いくつかのデータをひとまとめにdo仕組みです。\n\nFor example「点（座標）」のデータ：\n- x座標\n- y座標\n\nこの2つは関係があるので、「Point（点）」としてまとめると便利です。\n\nFor example「人」のデータ：\n- 名前\n- 年齢\n\nこれも「Person（人）」としてまとめられます。\n\n構造体は「こういうデータを持つ」という設計図です。",
    "rust_lesson4_ex1_slide1_title": "トレイト?（復習）",
    "rust_lesson2_ex3_description": "reference先のvalueを変更できる「可変reference」を学びましょう。",
    "rust_lesson2_ex7_slide2_content": "# match で安全に取り出す\n\n`match` を使って「ある場合」と「ない場合」で処理を分けます。\n\ncodeExample：\n```rust\nlet x: Option<i32> = Some(5);  // 値あり\n\nmatch x {\n    Some(n) => println!(\"値は{}です\", n),  // 5\n    None => println!(\"値がありません\"),\n}\n```\n\nなぜ安全？\n- `null` のように「あるつもりでアクセスしたら無かった」errorが起きない\n- 「ない場合」の処理を書かないとコンパイルerrorになる\n- 強制的に両方のケースを考えることになる！",
    "rust_lesson4_ex9_comment1": "collect で Vec に変換",
    "rust_lesson3_ex10_title": "String と &str",
    "rust_lesson2_ex7_slide1_title": "Option（オプション）?",
    "rust_lesson3_ex9_description": "Vecにelementを追加しましょう。",
    "rust_lesson2_ex5_comment1": "impl でmethodをimplementation",
    "rust_lesson3_ex1_slide3_content": "参照の有効期間を表すライフタイムを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex6_slide2_content": "複数の条件を組み合わせる「&&（かつ）」と「||（または）」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex5_comment1": "filter で条件に合うelementを絞り込む",
    "rust_lesson2_ex7_slide3_content": "値があるかないかを表す「Option」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex10_slide3_title": "Let's Try It!",
    "rust_lesson4_ex4_slide3_title": "Let's Try It!",
    "rust_lesson3_ex3_comment1": "iter でiteratorを取得",
    "rust_lesson3_ex6_slide3_content": "要素を1つの値にまとめるfoldを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex7_slide2_title": "ベクタの番号は「0」から！",
    "rust_lesson1_ex5_slide1_title": "conditional（じょうけんぶんき）?",
    "rust_lesson1_ex3_description": "割り算の「あまり」を求める「%」（パーセント）operatorを学びましょう。",
    "rust_lesson1_ex1_slide3_content": "Rustを使って画面に文字を表示してみましょう。println! という特別な関数を使います。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex10_slide2_content": "# <T> でtypeを「あとで決める」\n\nfunction名の後に `<T>` をつけて、`T` を「type」としてuse。\n\ncodeExample：\n```rust\n// Tはどんな型でもOK\nfn first<T>(arr: &[T]) -> &T {\n    &arr[0]  // 最初の要素を返す\n}\n\n// 使い方\nfirst(&[1, 2, 3]);         // Tはi32\nfirst(&[\"a\", \"b\", \"c\"]);   // Tは&str\n```\n\n読み方：\n- `<T>` → 「Tという名前のtypeをuseよ」\n- `T` は慣習で「Type（type）」の頭文字\n- 複数のtypeが必要なら `<T, U>` のようにwrite",
    "rust_lesson3_ex2_comment1": "|x| でclosureのargumentをdefinition",
    "rust_lesson3_ex3_description": "elementを順番に処理doiteratorを学びましょう。",
    "rust_lesson1_ex1_slide3_title": "Let's Try It!",
    "rust_lesson2_ex6_slide2_title": "enum のdefinition",
    "rust_lesson2_ex1_title": "所有権のBasic",
    "rust_lesson4_ex3_slide1_title": "Box（ボックス）?",
    "rust_lesson2_ex1_slide3_content": "Rust独自の概念「所有権」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex8_slide3_content": "Option/Resultのデフォルト値を設定しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex7_slide2_title": "使用Example",
    "rust_lesson4_ex10_description": "iteratorにindexを付けましょう。",
    "rust_lesson4_ex9_slide1_title": "collect ?",
    "rust_lesson4_ex10_slide2_content": "# 「何番目か」が必要なとき\n\n番号（index）とelementの両方が必要なときに便利です。\n\ncodeExample：\n```rust\nlet v = vec![10, 20, 30];\nfor (idx, val) in v.iter().enumerate() {\n    println!(\"{}番目の値は{}\", idx, val);\n}\n// 0番目の値は10\n// 1番目の値は20\n// 2番目の値は30\n```\n\nPoint：\n- `(i, x)` でtuple（2つのset）を受け取る\n- `i` にindex、`x` にelementが入る\n- indexは0から始まる",
    "rust_lesson3_ex2_description": "周囲のvariableを使えるanonymous function「closure」を学びましょう。",
    "rust_lesson1_ex4_comment1": "mut で変更可能にdo",
    "rust_lesson1_ex8_slide3_title": "Let's Try It!",
    "rust_lesson1_ex3_slide2_content": "割り算の「あまり」を求める「%」（パーセント）演算子を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex9_slide3_title": "Let's Try It!",
    "rust_lesson3_ex3_title": "iteratorのBasic",
    "rust_lesson3_ex9_title": "Vec のmethod push",
    "rust_lesson1_ex8_comment1": "dictionaryをcreate（keyは'みかん'、valueは'オレンジ'）",
    "rust_lesson1_ex2_comment3": "+ でたし算do",
    "rust_lesson4_ex8_slide2_content": "# ジェネリクスの代わり\n\n```rust\nfn print_all(iter: impl Iterator<Item = i32>) {\n    for x in iter {\n        println!(\"{}\", x);\n    }\n}\n```",
    "rust_lesson2_ex2_slide2_title": "reference Usage",
    "rust_lesson1_ex8_slide3_content": "「辞書（HashMap）」を使うと、名前をつけてデータを保存し、その名前で取り出せます。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex7_slide2_content": "# [ ]で番号を指定して取り出す\n\n`[番号]` で何番目のデータか指定して取り出せます。\n\nImportantなルール：番号は「0」から！\n- 1番目 → `[0]`\n- 2番目 → `[1]`\n- 3番目 → `[2]`\n\ncodeExample：\n```rust\nlet fruits = vec![\"りんご\", \"バナナ\", \"みかん\"];\n//                  ↑0番    ↑1番     ↑2番\nprintln!(\"{}\", fruits[0]);  // りんご\nprintln!(\"{}\", fruits[1]);  // バナナ\n```\n\nプログラミングでは「0から数える」のが世界共通のルールです！",
    "rust_lesson1_ex6_slide1_title": "条件を組み合わせる",
    "rust_lesson2_ex10_slide2_title": "ジェネリックfunction Syntax",
    "rust_lesson1_ex6_description": "複数の条件を組み合わせる「&&（かつ）」と「||（Alsoは）」を学びましょう。",
    "rust_lesson4_ex6_title": "HashSet",
    "rust_lesson2_ex3_slide2_content": "# mut が2か所に必要\n\n変更できるようにdoには、variableとreferenceの両方に `mut` が必要です。\n\ncodeExample：\n```rust\n// 1. 変数を mut で作る\nlet mut s = String::from(\"hello\");\n\n// 2. &mut で可変参照を渡す\nchange(&mut s);\n\nfn change(s: &mut String) {\n    s.push_str(\" world\");  // 変更できる！\n}\n```\n\nPoint：\n- `let mut 変数` でvariableを変更可能に\n- `&mut 変数` で可変referenceをcreate\n- 両方ないと変更できない！",
    "rust_lesson2_ex2_slide1_title": "reference（さんしょう）?",
    "rust_lesson3_ex6_slide2_content": "# 合計、積、結合など\n\n```rust\n// 積\nv.iter().fold(1, |acc, x| acc * x)\n\n// 文字列結合\nwords.iter().fold(String::new(), |acc, s| acc + s)\n```",
    "rust_lesson1_ex1_description": "Rustを使ってscreenに文字をdisplayしてみましょう。println! という特別なfunctionをuse。",
    "rust_lesson3_ex8_slide3_title": "Let's Try It!",
    "rust_lesson4_ex6_description": "一意なvalueのsetを管理しましょう。",
    "rust_lesson2_ex5_slide1_title": "impl ?",
    "rust_lesson1_ex8_title": "名前で引き出す「dictionary」",
    "rust_lesson2_ex7_description": "valueがあるかないかを表す「Option」を学びましょう。",
    "rust_lesson1_ex4_slide2_title": "Let's Try It!",
    "rust_lesson1_ex7_title": "たくさんのデータをまとめましょう「ベクタ」",
    "rust_lesson3_ex7_slide1_content": "# errorの早期リターン\n\n? は、Resultが Err の場合に早期リターンします。\n\n```rust\nfn read_file() -> Result<String, io::Error> {\n    let content = fs::read_to_string(\"file.txt\")?;\n    Ok(content)\n}\n```",
    "rust_lesson3_ex9_slide1_content": "# 末尾に追加\n\npush は、Vecの末尾にelementをadd。\n\n```rust\nlet mut v = vec![1, 2];\nv.push(3);\n// [1, 2, 3]\n```",
    "rust_lesson4_ex8_slide3_content": "トレイトを返す関数を簡潔に書きましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex1_title": "screenにメッセージを出しましょう",
    "rust_lesson2_ex8_slide2_title": "Result  Usage",
    "rust_lesson3_ex2_slide1_title": "closure?",
    "rust_lesson3_ex8_title": "unwrap_or でデフォルトvalue",
    "rust_lesson4_ex10_slide1_content": "# 番号とelementを一緒にもらう\n\nenumerate は、「何番目か」と「そのelement」をsetで取り出せるmethodです。\n\nFor example：\n- 0番目: りんご\n- 1番目: バナナ\n- 2番目: みかん\n\ncodeExample：\n```rust\nfor (i, x) in vec![\"a\", \"b\", \"c\"].iter().enumerate() {\n    println!(\"{}: {}\", i, x);\n}\n// 0: a\n// 1: b\n// 2: c\n```",
    "rust_lesson1_ex7_slide1_content": "# データを並べてまとめる「長い箱」\n\nベクタ（Vec） は、たくさんのデータを順番に並べて入れられる「長い箱」です。\n\nFor example：\n- 買い物listの商品を全部まとめる\n- testの点数を全部まとめる\n- 友だちの名前を全部まとめる\n\n100個でも1000個でも、1つのvariableでまとめて管理できます！\n\n作り方：\n```rust\nlet fruits = vec![\"りんご\", \"バナナ\", \"みかん\"];\n// vec! で ベクタを作る\n```",
    "rust_lesson4_ex8_slide3_title": "Let's Try It!",
    "rust_lesson4_ex7_description": "パターンマッチに条件を追加しましょう。",
    "rust_lesson1_ex4_comment2": "+= で 20 を足す",
    "rust_lesson1_ex2_comment2": "y に 5 を入れる",
    "rust_lesson2_ex3_slide3_title": "Let's Try It!",
    "rust_lesson3_ex4_slide1_title": "map（map）?",
    "rust_lesson1_ex2_slide3_content": "データに名前をつけて保存できる「変数（へんすう）」を使ってみましょう。letで変数を作ります。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex8_slide2_content": "# match で成功と失敗を分ける\n\n`match` で「成功したら」「失敗したら」の処理を書き分けます。\n\ncodeExample：\n```rust\nfn divide(a: i32, b: i32) -> Result<i32, String> {\n    if b == 0 {\n        return Err(\"0で割れません\".to_string());\n    }\n    Ok(a / b)  // 成功なら答えを返す\n}\n\nmatch divide(10, 2) {\n    Ok(v) => println!(\"答えは{}\", v),\n    Err(e) => println!(\"エラー: {}\", e),\n}\n```\n\nPoint：\n- `Ok(値)` で成功をreturn\n- `Err(エラー)` で失敗をreturn",
    "rust_lesson4_ex3_comment1": "Box::new でheapに格納",
    "rust_lesson4_ex8_description": "トレイトをreturnfunctionを簡潔に書きましょう。",
    "rust_lesson2_ex10_description": "typeを後から決められる「ジェネリクス」を学びましょう。",
    "rust_lesson2_ex3_slide1_title": "可変reference（かへんさんしょう）?",
    "rust_lesson2_ex2_description": "所有権を移さずにvalueを借りる「reference」を学びましょう。",
    "rust_lesson3_ex5_slide2_title": "** にNote！",
    "rust_lesson2_ex2_slide3_title": "Let's Try It!",
    "rust_lesson4_ex3_slide3_content": "ヒープにデータを格納するBoxを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex4_title": "累算assignmentoperator（+=、-=）",
    "rust_lesson3_ex3_slide2_content": "# 借りるか、もらうか\n\n3種類の iter があり、所有権の扱いが違います。\n\n3つの違い：\n```rust\nv.iter()       // 参照で借りる（&T）\nv.iter_mut()   // 変更可能で借りる（&mut T）\nv.into_iter()  // 所有権をもらう（T）\n```\n\n使い分け：\n- `iter()` → 見るだけ（元のベクタも使える）\n- `iter_mut()` → 中身を変更したい\n- `into_iter()` → ベクタごともらう（元は使えない）\n\n普通は `iter()` をuseことが多いです。",
    "rust_lesson2_ex1_slide1_title": "所有権（しょゆうけん）?",
    "rust_lesson4_ex6_slide3_content": "一意な値の集合を管理しましょう。\n\n（When you're ready, select \"Start Lesson\".）"
  },
  "sv": {
    "rust_lesson1_course_title": "Introduction to Rust",
    "rust_lesson1_course_description": "Learn the basics of Rust programming.",
    "rust_lesson2_course_title": "Rust II - Intermediate",
    "rust_lesson2_course_description": "Learn intermediate Rust concepts.",
    "rust_lesson3_course_title": "Rust III - Advanced",
    "rust_lesson3_course_description": "Master advanced Rust techniques.",
    "rust_lesson4_course_title": "Rust IV - Expert Level",
    "rust_lesson4_course_description": "Expert-level Rust programming.",
    "rust_lesson1_ex5_slide2_content": "条件によって動きを変える if文を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex9_title": "collect で変換",
    "rust_lesson2_ex7_slide1_content": "# 「あるかもしれない、ないかもしれない」\n\nOption<T> は、valueが「あるかもしれないし、ないかもしれない」ことを表すtypeです。\n\nFor example：\n- dictionaryで単語を探す → 見つかるかもしれないし、ないかもしれない\n- ゲームでアイテムを拾う → 落ちてるかもしれないし、ないかもしれない\n\n2つの状態：\n- `Some(値)` → valueがある！\n- `None` → valueがない...\n\n他の言語では `null` をuseが、Rustでは `Option` で安全に扱います。",
    "rust_lesson1_ex2_slide1_title": "variable（へんすう）?",
    "rust_lesson1_ex7_description": "「ベクタ（Vec）」をuseと、たくさんのデータを一つの「長い はこ」にまとめて入れられます。",
    "rust_lesson2_ex9_slide2_content": "# 約束を作って、守る\n\n1. `trait` で「約束」をdefinition\n2. `impl トレイト for 型` で「約束を守る」implementationをdo\n\ncodeExample：\n```rust\n// 1. トレイト（約束）を定義\ntrait Speak {\n    fn speak(&self);  // 鳴くメソッドを持つ約束\n}\n\n// 2. Dog構造体がトレイトを実装\nstruct Dog;\nimpl Speak for Dog {\n    fn speak(&self) {\n        println!(\"woof\");\n    }\n}\n```\n\n「DogはSpeakができる」ということになります。",
    "rust_lesson4_ex4_description": "referenceカウントでデータを共有しましょう。",
    "rust_lesson4_ex5_slide1_content": "# 名前で引ける「dictionary」\n\nHashMap は、「key（名前）」と「value（データ）」をsetで保存dodictionaryです。\n\nFor example：\n- 「青チーム」→ 10点\n- 「赤チーム」→ 15点\n\ncodeExample：\n```rust\nuse std::collections::HashMap;\n\nlet mut scores = HashMap::new();\nscores.insert(\"Blue\", 10);   // 追加\nscores.insert(\"Red\", 15);    // 追加\n```\n\n`use` で機能を読み込んでからuse。",
    "rust_lesson3_ex4_title": "map でiterator変換",
    "rust_lesson4_ex1_slide3_content": "共通の振る舞いを定義するトレイトを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex4_description": "variableのvalueを手軽に増やしたり減らしたりdo「+=」「-=」を学びましょう。",
    "rust_lesson1_ex2_description": "データに名前をつけて保存できる「variable（へんすう）」を使ってみましょう。letでvariableをcreate。",
    "rust_lesson4_ex4_slide2_title": "referenceカウントの仕組み",
    "rust_lesson3_ex8_slide2_title": "unwrap_or_else",
    "rust_lesson4_ex10_comment1": "1番目の i にindex、2番目の item にelementが入る",
    "rust_lesson3_ex6_slide1_content": "# 累積処理\n\nfold は、初期valueとfunctionでelementを1つずつ畳み込みます。\n\n```rust\nlet v = vec![1, 2, 3];\nlet sum = v.iter().fold(0, |acc, x| acc + x);\n// 6\n```",
    "rust_lesson4_ex2_slide2_title": "よくuse derive トレイト",
    "rust_lesson3_ex10_slide3_content": "文字列型の違いを理解しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex4_slide2_content": "変数の値を手軽に増やしたり減らしたりする「+=」「-=」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex4_slide3_title": "Let's Try It!",
    "rust_lesson3_ex5_slide1_title": "filter（filterー）?",
    "rust_lesson4_ex5_description": "keyとvalueのpairを格納しましょう。",
    "rust_lesson3_ex5_description": "条件に合うelementだけを取り出しましょう。",
    "rust_lesson2_ex2_slide2_content": "# functionに借りてもらう\n\nfunctionにデータを渡すとき、`&` をつけると「借りる」形になります。元のvariableはそのまま使い続けられます。\n\ncodeExample：\n```rust\nfn calc_len(s: &String) -> usize {\n    s.len()  // 長さを返す\n}\n\nfn main() {\n    let text = String::from(\"hello\");\n    let len = calc_len(&text);  // textを貸す\n    // text はまだ使える！\n    println!(\"{}の長さは{}\", text, len);\n}\n```\n\n`&String` は「Stringを借りる」という意味です。",
    "rust_lesson4_ex7_slide3_content": "パターンマッチに条件を追加しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex8_slide2_content": "# 遅延評価\n\n```rust\n// クロージャで計算\nlet value = x.unwrap_or_else(|| expensive_computation());\n```",
    "rust_lesson4_ex7_title": "match ガード",
    "rust_lesson3_ex7_title": "? operatorでerror伝播",
    "rust_lesson4_ex1_description": "共通の振る舞いをdefineトレイトを学びましょう。",
    "rust_lesson2_ex1_slide2_content": "# 所有権は「移動」do\n\nvariableを別のvariableにassignmentdoと、所有権が 移動（ムーブ） します。元のvariableは使えなくなります。\n\ncodeExample：\n```rust\nlet s1 = String::from(\"hello\");  // s1 が持ち主\nlet s2 = s1;  // 所有権が s2 に移動！\n// ↓ s1 はもう使えない（エラーになる）\n// println!(\"{}\", s1);  // ダメ！\nprintln!(\"{}\", s2);  // OK！\n```\n\nイメージ：\nおもちゃを友だちにあげたら、自分はもう使えない。これがムーブです。",
    "rust_lesson1_ex8_slide1_title": "dictionary（HashMap）?",
    "rust_lesson4_ex3_slide2_content": "# サイズが決まらないとき\n\nBoxは、コンパイル時にサイズがわからないtypeにuse。\n\nFor examplerecursion的なtype：\n```rust\n// リストは「値 + 次のリスト」の繰り返し\nenum List {\n    Cons(i32, Box<List>),  // Boxで次を指す\n    Nil,                   // 終わり\n}\n```\n\nなぜBoxが必要？\n- `List` の中に `List` がある → 無限に大きくなる？\n- `Box` をuseと、サイズが固定（pointerのサイズ）になる\n\n「中身」ではなく「中身への矢印」を持つイメージです。",
    "rust_lesson2_ex10_title": "ジェネリクスを使おう",
    "rust_lesson2_ex8_slide3_title": "Let's Try It!",
    "rust_lesson3_ex9_slide2_content": "# 可変reference\n\n```rust\n// mut が必要\nlet mut v = Vec::new();\nv.push(1);\nv.push(2);\n```",
    "rust_lesson4_ex4_title": "Rc<T>",
    "rust_lesson2_ex3_comment1": "mut で可変variableにdo",
    "rust_lesson4_ex5_slide3_title": "Let's Try It!",
    "rust_lesson2_ex6_slide2_content": "# バリアントを列挙\n\n`enum 名前 { バリアント1, バリアント2, ... }` でdefine。\n\ncodeExample：\n```rust\nenum Color {\n    Red,\n    Green,\n    Blue,\n}\nlet c = Color::Red;\n```",
    "rust_lesson1_ex1_comment1": "Hello, Rust! とdisplay",
    "rust_lesson1_ex1_slide1_content": "# 安全で速い！最新のプログラミング言語\n\nRust（ラスト）は、「間違いを事前に防ぐ」ことがとても得意なプログラミング言語です。\n\nRustのすごいところ：\n- programのミスをexecute前に見つけてくれる\n- とても速く動く\n- 世界中のプログラマーが「一番好き！」と選ぶ人気の言語\n\nたとえるなら：\n厳しいけど優しい先生のような言語です。「ここ間違ってるよ」と教えてくれるので、安心してprogramが書けます！",
    "rust_lesson3_ex8_slide1_content": "# None/Err の場合のデフォルト\n\nunwrap_or は、None や Err の場合にデフォルトvalueをreturn。\n\n```rust\nlet x: Option<i32> = None;\nlet value = x.unwrap_or(0);  // 0\n```",
    "rust_lesson2_ex7_slide3_title": "Let's Try It!",
    "rust_lesson2_ex6_title": "enum で状態を表す",
    "rust_lesson2_ex8_slide1_content": "# 「成功」か「失敗」かを表す\n\nResult<T, E> は、処理が「成功したか失敗したか」を表すtypeです。\n\nFor example：\n- fileをopen → 成功（内容）か失敗（error）\n- 0で割り算 → 成功（答え）か失敗（0で割れない！）\n\n2つの状態：\n- `Ok(値)` → 成功！valueが入っている\n- `Err(エラー)` → 失敗...error情報が入っている\n\n`Option` は「あるか・ないか」、`Result` は「成功か・失敗か」という違いです。",
    "rust_lesson2_ex8_slide3_content": "成功と失敗を表す「Result」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex6_slide1_title": "HashSet ?",
    "rust_lesson3_ex9_comment1": "push でelementを追加",
    "rust_lesson2_ex7_slide2_title": "Option  Usage",
    "rust_lesson3_ex2_title": "closureのBasic",
    "rust_lesson3_ex7_slide1_title": "? operator?",
    "rust_lesson4_ex6_comment1": "HashSet をimport",
    "rust_lesson2_ex10_slide1_content": "# どんなtypeでも使える「万能」の仕組み\n\nジェネリクス は、typeを後から決められる仕組みです。\n\nなぜ便利？\n同じようなfunctionを何度も書かなくてすみます。\n\nFor example：\n- 数字のarrayの最初のelementを取るfunction\n- stringのarrayの最初のelementを取るfunction\n\n両方とも「最初のelementを取る」のは同じなのに、typeが違うだけで別のfunctionをwriteのは大変！\n\nジェネリクスなら、`<T>` で「typeは後で決める」とwriteだけで、どんなtypeでも使えるfunctionが作れます。",
    "rust_lesson1_ex3_slide1_content": "# 剰余operator（じょうよえんざんし）「%」\n\n`%`（パーセント）は、割り算の 「あまり」 をcalculate特別な記号です。\n\nわかりやすいExample：\n- 10このアメを3人で分けると？\n- 1人3こずつで、1こあまる\n- これを `10 % 3` とwriteと、答えは `1`\n\ncodeExample：\n```rust\nprintln!(\"{}\", 10 % 3);  // 1（あまり1）\nprintln!(\"{}\", 8 % 4);   // 0（あまりなし＝割り切れる）\n```\n\n使いどころ：\n- 偶数か奇数か調べる（`n % 2` が0なら偶数）\n- 時計の計算（24を超えたら0に戻る、など）",
    "rust_lesson3_ex7_description": "errorを簡潔に伝播させましょう。",
    "rust_lesson3_ex8_comment1": "unwrap_or でデフォルトvalueを設定",
    "rust_lesson2_ex8_title": "Result<T, E> でerror処理",
    "rust_lesson2_ex10_comment1": "T をtypeパラメータとしてuse",
    "rust_lesson2_ex6_comment1": "enum で列挙typeをdefinition",
    "rust_lesson3_ex3_slide3_content": "要素を順番に処理するイテレータを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex2_comment1": "derive でトレイトを自動implementation",
    "rust_lesson1_ex8_slide1_content": "# 名前でsearchできる「dictionary」\n\nHashMap（ハッシュmap）は、「名前」と「データ」をsetにして保存できる仕組みです。本物のdictionaryのように使えます。\n\nFor example果物の色dictionary：\n- 「りんご」→「あか」\n- 「バナナ」→「きいろ」\n- 「みかん」→「オレンジ」\n\nuse準備：\n```rust\nuse std::collections::HashMap;  // 機能を読み込む\nlet mut fruits = HashMap::new();  // 空の辞書を作る\nfruits.insert(\"りんご\", \"あか\");  // データを追加\n```\n\n`use` は「この機能をuseよ」というdeclarationです。",
    "rust_lesson3_ex9_slide1_title": "push ?",
    "rust_lesson4_ex1_title": "トレイトのdefinition",
    "rust_lesson4_ex3_description": "heapにデータを格納doBoxを学びましょう。",
    "rust_lesson1_ex2_title": "便利な「はこ」variable（へんすう）",
    "rust_lesson1_ex8_comment2": "中身を出す",
    "rust_lesson3_ex9_slide3_title": "Let's Try It!",
    "rust_lesson1_ex4_comment3": "-= で 50 を引く",
    "rust_lesson1_ex6_comment1": "&& で両方の条件をチェック",
    "rust_lesson4_ex1_slide2_title": "トレイトのimplementation",
    "rust_lesson4_ex7_slide3_title": "Let's Try It!",
    "rust_lesson4_title": "Rust IV - トレイトとスマートpointer",
    "rust_lesson4_ex1_comment1": "trait でトレイトをdefinition",
    "rust_lesson4_ex4_slide1_content": "# 複数の「持ち主」を許可do仕組み\n\nRc<T> は「Reference Counted（referenceカウント）」の略で、複数の所有者でデータを共有できます。\n\n普通の所有権：\n1人だけが持ち主。渡したら元の人は使えない。\n\nRc をuseと：\n複数人が同じデータの「持ち主」になれる！\n\ncodeExample：\n```rust\nuse std::rc::Rc;\n\nlet a = Rc::new(5);       // Rcでラップ\nlet b = Rc::clone(&a);    // bも持ち主になる\n// a も b も使える！\n```",
    "rust_lesson3_ex5_slide1_content": "# 条件に合うものだけ残す\n\nfilter は、条件を満たすelementだけを残し、他を捨てます。\n\nFor example：\n- 80点以上の人だけ残す\n- 偶数だけ残す\n- 「あ」から始まる名前だけ残す\n\ncodeExample：\n```rust\nlet v = vec![1, 2, 3, 4, 5];\nlet evens: Vec<_> = v.iter()\n    .filter(|x| **x % 2 == 0)  // 偶数だけ\n    .collect();\n// [2, 4]\n```\n\n条件が `true` のelementだけが残ります。",
    "rust_lesson3_ex7_slide3_title": "Let's Try It!",
    "rust_lesson1_ex7_comment2": "2番目のデータ（1番）を出す",
    "rust_lesson4_ex8_title": "impl Trait",
    "rust_lesson1_ex5_description": "条件によって動きを変える if文を学びましょう。",
    "rust_lesson3_ex4_slide2_title": "遅延評価（ちえんひょうか）",
    "rust_lesson3_ex1_slide1_content": "# referenceの「寿命」を示す印\n\nライフタイム は、referenceがいつまで使えるかを示す印です。`'a`（アポストロフィ・エー）のようにwrite。\n\nなぜ必要？\nreferenceは「借りている」状態。借りた元のデータが消えたら、referenceも使えなくなります。\n\nFor example：\n- 図書館で借りた本 → 図書館が閉まったら読めない\n- referenceで借りたデータ → 元のデータが消えたら使えない\n\nライフタイムは「このreferenceはこの範囲で有効だよ」とコンパイラに伝える仕組みです。",
    "rust_lesson1_ex1_slide1_title": "Rust（ラスト）?",
    "rust_lesson1_ex2_slide2_title": "計算の記号（operator）",
    "rust_lesson4_ex5_slide2_content": "# get で安全に取り出す\n\n`get()` methodでvalueを取り出せます。見つからない可能性があるので、`Option` が返ってきます。\n\ncodeExample：\n```rust\n// getはOption<&V>を返す\nif let Some(score) = scores.get(\"Blue\") {\n    println!(\"青チームは{}点\", score);\n}\n```\n\nPoint：\n- keyがあれば `Some(値)` が返る\n- keyがなければ `None` が返る\n- `if let` で安全に取り出せる\n\n存在しないkeyでアクセスしてもprogramが落ちない！",
    "rust_lesson4_ex7_slide1_title": "match ガード?",
    "rust_lesson3_title": "Rust III - ライフタイムとiterator",
    "rust_lesson4_ex3_title": "Box<T>",
    "rust_lesson1_ex4_slide1_title": "累算assignmentoperator（るいさんだいにゅう）?",
    "rust_lesson2_ex9_comment1": "trait でトレイトをdefinition",
    "rust_lesson2_ex1_description": "Rust独自の概念「所有権」を学びましょう。",
    "rust_lesson2_ex3_slide3_content": "参照先の値を変更できる「可変参照」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex1_slide3_title": "Let's Try It!",
    "rust_lesson3_ex6_slide2_title": "様々な畳み込み",
    "rust_lesson4_ex9_slide3_title": "Let's Try It!",
    "rust_lesson2_ex5_title": "impl でmethodを追加",
    "rust_lesson2_ex6_slide1_content": "# 複数の選択肢\n\nenum は、valueがいくつかの種類のうちの一つであることを表します。各バリアントにデータを持たせることもできます。",
    "rust_lesson2_ex4_comment1": "struct で構造体をdefinition",
    "rust_lesson1_ex3_title": "剰余operator（%）",
    "rust_lesson1_ex7_comment1": "colors というベクタをcreate（'あか', 'あお'の順）",
    "rust_lesson1_ex4_slide1_content": "# valueをかんたんに増やす・減らす\n\n`+=`（プラスイコール）と `-=`（マイナスイコール）は、variableの中身を増やしたり減らしたりdo便利な記号です。\n\nRustのImportantなルール：`mut`が必要！\nRustでは、variableをchangeには `let mut`（レット ミュート）とwrite必要があります。`mut` は「mutable（変更できる）」の略です。\n\ncodeExample：\n```rust\nlet mut score = 100;  // mut をつけて変更可能に\nscore += 10;          // 10を足す → 110に\nscore -= 50;          // 50を引く → 60に\n```\n\n`mut` がないと「このvariableは変えちゃダメ！」とRustが怒ります。",
    "rust_lesson2_ex1_slide2_title": "ムーブ（移動）",
    "rust_lesson3_ex4_comment1": "map で各elementを変換",
    "rust_lesson3_ex8_slide1_title": "unwrap_or ?",
    "rust_lesson2_ex5_slide1_content": "# implementationブロック\n\nimpl ブロックで、構造体にmethodを追加できます。`self` で自分自身をreferenceします。",
    "rust_lesson2_ex10_slide1_title": "ジェネリクス?",
    "rust_lesson1_ex8_slide2_content": "# 名前（key）で取り出す\n\ndictionaryに入れたデータは、名前（key）を指定して取り出せます。\n\ncodeExample：\n```rust\nuse std::collections::HashMap;\nfn main() {\n    let mut fruits = HashMap::new();\n    fruits.insert(\"りんご\", \"あか\");  // 追加\n    fruits.insert(\"バナナ\", \"きいろ\");  // 追加\n    \n    println!(\"{}\", fruits[\"りんご\"]);  // あか と表示\n}\n```\n\nPoint：\n- `insert(名前, データ)` で追加\n- `辞書[名前]` で取り出し\n- 番号ではなく「名前」で探せるのが便利！",
    "rust_lesson4_ex9_slide1_content": "# iteratorをコレクションに\n\ncollect は、iteratorをVecやHashMapなどに変換します。\n\n```rust\nlet v: Vec<_> = (0..5).collect();\nlet s: String = vec!['a', 'b'].into_iter().collect();\n```",
    "rust_lesson2_ex2_slide3_content": "所有権を移さずに値を借りる「参照」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex2_slide3_content": "周囲の変数を使える無名関数「クロージャ」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex4_slide2_content": "# struct keyワードでdefinition\n\n`struct 名前 { フィールド }` で構造体をdefine。フィールドには名前とtypeをwrite。\n\ncodeExample：\n```rust\n// Point 構造体を定義\nstruct Point {\n    x: i32,  // xフィールド（整数）\n    y: i32,  // yフィールド（整数）\n}\n\n// 使い方\nlet p = Point { x: 10, y: 20 };\nprintln!(\"x={}, y={}\", p.x, p.y);\n```\n\nPoint：\n- `struct 名前` で構造体をcreate\n- `{ フィールド名: 型 }` でどんなデータを持つか決める\n- `.フィールド名` でアクセス",
    "rust_lesson2_ex10_slide3_content": "型を後から決められる「ジェネリクス」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex6_slide3_title": "Let's Try It!",
    "rust_lesson4_ex6_slide1_content": "# 一意なvalueのset\n\nHashSet は、重複のないvalueのsetです。\n\n```rust\nuse std::collections::HashSet;\n\nlet mut set = HashSet::new();\nset.insert(1);\nset.insert(2);\nset.insert(1); // 重複は無視\n```",
    "rust_lesson4_ex2_title": "derive 属性",
    "rust_lesson4_ex2_slide1_content": "# トレイトを「自動で」implementation\n\n#[derive(...)] をuseと、よくuseトレイトを自分で書かなくても自動でimplementationしてくれます。\n\nFor example：\n構造体を `println!` でdisplayしたいとき、普通は Display トレイトをimplementationdo必要がありますが、`#[derive(Debug)]` をwriteだけでOK！\n\ncodeExample：\n```rust\n#[derive(Debug)]  // Debug トレイトを自動実装\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nlet p = Point { x: 1, y: 2 };\nprintln!(\"{:?}\", p);  // Point { x: 1, y: 2 }\n```",
    "rust_lesson1_ex6_slide2_title": "Let's Try It!",
    "rust_lesson3_ex3_slide2_title": "3つの iter method",
    "rust_lesson4_ex7_slide2_content": "# 複雑なconditional\n\n```rust\nmatch Some(5) {\n    Some(x) if x % 2 == 0 => println!(\"even\"),\n    Some(x) => println!(\"odd: {}\", x),\n    None => println!(\"none\"),\n}\n```",
    "rust_lesson3_ex3_slide1_content": "# elementを1つずつ取り出す仕組み\n\niterator は、ベクタなどのデータを「1つずつ順番に」取り出す仕組みです。\n\nFor example：\n- 行列に並んでいる人を1人ずつ呼ぶ\n- 引き出しの中身を1つずつ出す\n\ncodeExample：\n```rust\nlet v = vec![1, 2, 3];\nfor x in v.iter() {\n    println!(\"{}\", x);  // 1, 2, 3 と順番に表示\n}\n```\n\n`iter()` で「順番に取り出す準備」をして、`for` で1つずつ処理します。",
    "rust_lesson3_ex3_slide1_title": "iterator?",
    "rust_lesson4_ex2_description": "トレイトを自動implementationdoderiveを学びましょう。",
    "rust_lesson3_ex4_slide1_content": "# 全部を同じように変換do\n\n**map** は、iteratorの各elementを「同じ方法で」変換します。\n\nFor example：\n- 全員の身長を2倍にdo\n- 全員の名前を大文字にdo\n- 全部の数を2乗do\n\ncodeExample：\n```rust\nlet v = vec![1, 2, 3];\nlet doubled: Vec<_> = v.iter()\n    .map(|x| x * 2)  // 各要素を2倍に\n    .collect();      // ベクタに戻す\n// [2, 4, 6]\n```\n\n`|x| x * 2` は「xを受け取って、x*2をreturn」closureです。",
    "rust_lesson1_ex3_slide1_title": "あまりを求める",
    "rust_lesson3_ex10_slide1_content": "# 所有権の違い\n\nString は所有権を持つheap上のstring、&str はreferenceです。\n\n```rust\nlet s1: String = String::from(\"hello\");\nlet s2: &str = \"hello\";\n```",
    "rust_lesson4_ex2_slide1_title": "derive（デライブ）?",
    "rust_lesson2_ex2_comment1": "& でreferenceを渡す",
    "rust_lesson4_ex5_slide1_title": "HashMap（ハッシュmap）?",
    "rust_lesson2_ex3_slide2_title": "&mut  Usage",
    "rust_lesson3_ex5_title": "filter で絞り込み",
    "rust_lesson4_ex3_slide2_title": "いつuse？",
    "rust_lesson2_ex2_title": "referenceと借用",
    "rust_lesson2_ex7_title": "Option<T> で null を安全に",
    "rust_lesson4_ex10_slide3_title": "Let's Try It!",
    "rust_lesson3_ex5_slide3_title": "Let's Try It!",
    "rust_lesson4_ex10_title": "enumerate でindex付き",
    "rust_lesson2_ex2_slide1_content": "# 所有権を渡さずに「借りる」\n\nreference をuseと、所有権を移さずにデータを「見せてもらう」ことができます。\n\nたとえるなら：\n- ムーブ = おもちゃをあげる（自分は使えない）\n- reference = おもちゃを見せる（自分も使える）\n\n作り方：\n`&`（アンパサンド）をつけるとreferenceを作れます。\n\n```rust\nlet s = String::from(\"hello\");\nlet r = &s;  // sを借りる（見せてもらう）\n// s も r も使える！\n```",
    "rust_lesson2_ex5_slide2_content": "# &self をuse\n\nmethodの最初のargumentは `&self` です。\n\ncodeExample：\n```rust\nimpl Rect {\n    fn area(&self) -> i32 {\n        self.width * self.height\n    }\n}\n```",
    "rust_lesson1_ex5_slide2_title": "Let's Try It!",
    "rust_lesson2_ex4_slide3_title": "Let's Try It!",
    "rust_lesson4_ex3_slide3_title": "Let's Try It!",
    "rust_lesson2_ex9_slide3_content": "共通の振る舞いを定義する「トレイト」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex1_slide2_content": "# impl で約束を守る\n\n構造体にトレイトをimplementationdoと、その構造体は「約束を守る」ことになります。\n\ncodeExample：\n```rust\nstruct Person { name: String }\n\nimpl Greet for Person {\n    fn greet(&self) -> String {\n        format!(\"Hello, {}\", self.name)\n    }\n}\n```\n\n読み方：\n- `impl Greet for Person` → 「PersonはGreetをimplementationdo」\n- これでPersonは「あいさつできる」ようになった！",
    "rust_lesson4_ex4_comment1": "clone でreferenceカウントを増やす",
    "rust_lesson3_ex4_slide2_content": "# map だけではexecuteされない！\n\nRustのiteratorは 遅延評価 といって、「本当に必要になるまで処理しない」仕組みです。\n\nなぜ？\n無駄な計算を省けるから。100万件あっても、最初の10件だけ欲しいなら10件だけ処理すればいい。\n\ncollect() でexecute：\n```rust\n// これだけでは何も起きない\nv.iter().map(|x| x * 2);\n\n// collect() で実行してベクタに変換\nlet result: Vec<_> = v.iter().map(|x| x * 2).collect();\n```\n\n`collect()` は「今すぐ全部処理してResultをちょうだい」という意味です。",
    "rust_lesson2_ex4_slide2_title": "struct のdefinitionのしかた",
    "rust_lesson2_ex3_slide1_content": "# 「書き換えできる」借り方\n\n普通のreference `&` は「見るだけ」ですが、可変reference `&mut` は「変更もできる」借り方です。\n\nたとえるなら：\n- `&` = 本を見せてもらう（readだけ）\n- `&mut` = ノートを借りる（writeOK）\n\nImportantなルール：\n- 可変referenceは同時に1つだけ！\n- 「みんなで見る」か「1人でwrite」かのどちらか\n\nこのルールで、データが同時に書き換えられるバグを防いでいます。",
    "rust_lesson2_ex10_slide3_title": "Let's Try It!",
    "rust_lesson2_ex4_title": "構造体をdefinitionしよう",
    "rust_lesson3_ex10_slide2_content": "# 相互変換\n\n```rust\n// &str -> String\nlet s = \"hello\".to_string();\n\n// String -> &str\nlet slice: &str = &s;\n```",
    "rust_lesson4_ex10_slide3_content": "イテレータにインデックスを付けましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex4_slide2_content": "# 「何人が持っているか」を数える\n\nRcは「今何人がこのデータを持っているか」を数えています。\n\ncodeExample：\n```rust\nlet a = Rc::new(5);\nprintln!(\"{}\", Rc::strong_count(&a));  // 1\n\nlet b = Rc::clone(&a);\nprintln!(\"{}\", Rc::strong_count(&a));  // 2\n```\n\nいつデータが消える？\n- カウントが0になったとき（誰も持っていないとき）\n- 最後の持ち主がいなくなると自動で片付けられる\n\n`Rc::clone` は「持ち主を1人増やす」操作です。",
    "rust_lesson1_ex8_slide2_title": "dictionary Usage",
    "rust_lesson4_ex3_slide1_content": "# データを「heap」に置く箱\n\nBox<T> は、データを「heap」という特別な場所に置くための箱です。\n\nmemoryの2つの場所：\n- stack：小さくて速い。サイズが決まっているデータ向け\n- heap：大きくて柔軟。サイズが大きいor変わるデータ向け\n\ncodeExample：\n```rust\nlet b = Box::new(5);  // 5をヒープに置く\nprintln!(\"{}\", *b);   // *で中身を取り出す → 5\n```\n\n`*` は「箱を開けて中身を見る」操作です。",
    "rust_lesson3_ex2_slide2_title": "closure Syntax",
    "rust_lesson4_ex4_slide1_title": "Rc（アールシー）?",
    "rust_lesson4_ex7_slide1_content": "# 追加条件\n\n**if** でパターンに追加条件をつけられます。\n\n```rust\nmatch x {\n    n if n < 0 => println!(\"negative\"),\n    n if n > 0 => println!(\"positive\"),\n    _ => println!(\"zero\"),\n}\n```",
    "rust_lesson2_ex3_title": "可変reference",
    "rust_lesson3_ex10_comment1": "to_string で String に変換",
    "rust_lesson3_ex10_slide2_title": "変換",
    "rust_lesson3_ex1_description": "referenceの有効期間を表すライフタイムを学びましょう。",
    "rust_lesson3_ex2_slide1_content": "# 名前のない「即席」function\n\nclosure は、名前をつけずにその場でcreatefunctionです。そして特別な能力があります：周りのvariableを使えるのです！\n\nFor example：\n```rust\nlet x = 5;  // 外側の変数\nlet add_x = |n| n + x;  // xを使えるクロージャ\nprintln!(\"{}\", add_x(10));  // 15\n```\n\n普通のfunctionとの違い：\n- 普通のfunction：argumentしか使えない\n- closure：argument + 周りのvariableも使える\n\n「その場の空気を読める」functionというイメージです！",
    "rust_lesson1_ex2_comment1": "x に 10 を入れる",
    "rust_lesson1_ex7_slide3_title": "Let's Try It!",
    "rust_lesson1_ex5_title": "「もし〜なら」で分けましょう",
    "rust_lesson3_ex2_slide3_title": "Let's Try It!",
    "rust_lesson3_ex7_slide2_content": "# 簡潔なerror処理\n\n```rust\n// ? を使わない場合\nmatch result {\n    Ok(v) => v,\n    Err(e) => return Err(e),\n}\n\n// ? を使う\nresult?\n```",
    "rust_lesson3_ex6_slide3_title": "Let's Try It!",
    "rust_lesson4_ex9_slide3_content": "イテレータをコレクションに変換しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex6_description": "elementを1つのvalueにまとめるfoldを学びましょう。",
    "rust_lesson2_ex9_description": "共通の振る舞いをdefine「トレイト」を学びましょう。",
    "rust_lesson2_ex8_comment1": "Ok で成功をreturn",
    "rust_lesson3_ex5_slide2_content": "# filter はreferenceのreferenceを受け取る\n\n`filter` のclosureは、referenceのreference（`&&T`）を受け取ります。そのため、valueをuseには `**x` と2回referenceを外す必要があります。\n\nなぜ？\n- `iter()` はreference（`&T`）をreturn\n- `filter` はそれをFurthermorereferenceで渡す（`&&T`）\n\nSyntax：\n```rust\n// **x で値を取り出す\n.filter(|x| **x > 2)\n\n// または * を引数につける\n.filter(|&x| *x > 2)\n```\n\n最初は混乱しますが、慣れれば大丈夫！",
    "rust_lesson1_ex5_comment1": "> でcompare",
    "rust_lesson2_ex4_description": "関連doデータをまとめる「構造体」を学びましょう。",
    "rust_lesson3_ex5_slide3_content": "条件に合う要素だけを取り出しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex7_slide3_content": "「ベクタ（Vec）」を使うと、たくさんのデータを一つの「長い はこ」にまとめて入れられます。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex5_slide2_title": "valueの取得",
    "rust_lesson3_ex1_slide1_title": "ライフタイム?",
    "rust_lesson1_ex3_comment1": "10 を 3 で割ったあまりをoutput",
    "rust_lesson3_ex1_comment1": "'a でライフタイムをdefinition",
    "rust_lesson3_ex10_slide1_title": "String vs &str",
    "rust_lesson2_title": "Rust II - 所有権とトレイト",
    "rust_lesson2_ex5_slide2_title": "methodのdefinition",
    "rust_lesson4_ex5_comment1": "insert でkeyとvalueを追加",
    "rust_lesson2_ex9_slide1_content": "# 「できること」の約束\n\nトレイト は、「このtypeはこういうことができる」という約束をdefine。\n\nFor example「鳴ける」という約束：\n- 犬は「ワン」と鳴く\n- 猫は「ニャー」と鳴く\n- 両方とも「鳴ける」能力がある\n\nトレイトは「鳴ける動物は、鳴き声を出すmethodを持つ」という約束です。\n\n他の言語とのcomparison：\n- Java: interface\n- TypeScript: interface\n\nに似た概念です。",
    "rust_lesson1_ex2_slide3_title": "Let's Try It!",
    "rust_lesson4_ex8_slide1_content": "# return valueのtypeをabstract化\n\nimpl Trait で、トレイトをimplementationdotypeを返せます。\n\n```rust\nfn make_iter() -> impl Iterator<Item = i32> {\n    vec![1, 2, 3].into_iter()\n}\n```",
    "rust_lesson1_ex2_slide2_content": "# 四則演算（しそくえんざん）\n\nRustでも算数と同じ記号で計算ができます。\n\n4つのBasic記号：\n- +（プラス）: たし算\n- -（マイナス）: ひき算\n- \\*（アスタリスク）: かけ算（×の代わり）\n- /（スラッシュ）: わり算（÷の代わり）\n\ncodeExample：\n```rust\nlet a = 10;\nlet b = 5;\nprintln!(\"{}\", a + b);  // 15 と表示される\n```\n\n`println!` の `{}` は「ここにvalueを入れてね」という目印です。",
    "rust_lesson4_ex9_slide2_content": "# 変換先を指定\n\n```rust\n// ターボフィッシュ構文\nlet v = (0..5).collect::<Vec<_>>();\n\n// 変数の型注釈\nlet v: Vec<i32> = (0..5).collect();\n```",
    "rust_lesson1_ex8_description": "「dictionary（HashMap）」をuseと、名前をつけてデータを保存し、その名前で取り出せます。",
    "rust_lesson4_ex9_slide2_title": "typeHint",
    "rust_lesson3_ex1_title": "ライフタイムのBasic",
    "rust_lesson2_ex5_description": "構造体にmethodをadd「impl」を学びましょう。",
    "rust_lesson4_ex8_comment1": "impl でトレイトをimplementationdotypeをreturn",
    "rust_lesson4_ex8_slide2_title": "argumentにも使える",
    "rust_lesson4_ex7_comment1": "if でマッチガードを追加",
    "rust_lesson2_ex9_slide2_title": "trait のdefinitionとimplementation",
    "rust_lesson4_ex10_slide2_title": "いつuse？",
    "rust_lesson3_ex7_slide2_title": "match の省略形",
    "rust_lesson1_ex6_title": "logicaloperator（&&、||）",
    "rust_lesson3_ex6_comment1": "fold で畳み込み",
    "rust_lesson2_ex6_description": "複数の状態を表す「列挙type（enum）」を学びましょう。",
    "rust_lesson4_ex10_slide1_title": "enumerate（イニュメレート）?",
    "rust_lesson1_ex7_slide1_title": "ベクタ（Vec）?",
    "rust_lesson2_ex6_slide3_content": "複数の状態を表す「列挙型（enum）」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex3_slide3_title": "Let's Try It!",
    "rust_lesson3_ex4_description": "各elementを変換domapを学びましょう。",
    "rust_lesson4_ex1_slide3_title": "Let's Try It!",
    "rust_lesson3_ex9_slide2_title": "mut が必要",
    "rust_lesson1_ex6_slide1_content": "# logicaloperator（ろんりえんざんし）\n\n2つ以上の条件を組み合わせたいときにuse記号です。\n\n2つの記号：\n- `&&`（アンドアンド）：「かつ」＝ 両方とも 正しいとき\n- `||`（オアオア）：「Alsoは」＝ どちらか 正しいとき\n\n身近なExample：\n- 遊園地：「18歳以上 かつ チケットあり」なら乗れる\n- おやつ：「宿題終わった Alsoは お手伝いした」ならOK\n\ncodeExample：\n```rust\nif score >= 70 && bonus > 0 {\n    // 70点以上 かつ ボーナスあり → 合格！\n    println!(\"合格！\");\n}\n```",
    "rust_lesson4_ex4_slide3_content": "参照カウントでデータを共有しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex6_slide3_title": "Let's Try It!",
    "rust_lesson2_ex5_slide3_content": "構造体にメソッドを追加する「impl」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex1_slide3_title": "Let's Try It!",
    "rust_lesson1_ex5_slide1_content": "# programに「判断」させよう\n\nconditional は、「もし〜なら、〇〇do」という判断をprogramにさせる仕組みです。\n\n身近なExample：\n- もし80点以上なら → 「合格！」とdisplay\n- もし雨なら → 傘を持っていく\n- もしHPが0なら → ゲームオーバー\n\nRustで Syntax：\n```rust\nif score > 80 {\n    println!(\"合格！\");\n}\n```\n\n読み方：\n- `if` →「もし」\n- `score > 80` →「スコアが80より大きいなら」\n- `{ }` の中 →「これをやる」",
    "rust_lesson4_ex5_title": "HashMap",
    "rust_lesson1_ex2_slide1_content": "# データを保存do「はこ」\n\nvariable（へんすう） は、数字や文字を入れておける「はこ」のことです。名前をつけて、あとでuseことができます。\n\nFor example：\n- 「りんごの数」というラベルの箱に「5」を入れる\n- あとで「りんごの数」と呼べば「5」が出てくる\n\nRustで Syntax：\n```rust\nlet x = 10;  // xという箱に10を入れる\nprintln!(\"{}\", x);  // xの中身（10）を表示\n```\n\n`let` は「この名前で箱をcreateよ」という意味です。",
    "rust_lesson2_ex4_slide3_content": "関連するデータをまとめる「構造体」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex6_slide1_title": "enum ?",
    "rust_lesson2_ex9_title": "トレイトをdefinitionしよう",
    "rust_lesson2_ex4_slide1_title": "構造体（こうぞうたい）?",
    "rust_lesson4_ex2_slide2_content": "# 覚えておくと便利な5つ\n\nよくusederiveトレイト：\n```rust\nDebug     // {:?} でデバッグ表示できる\nClone     // .clone() でコピーを作れる\nCopy      // 代入時に自動でコピー（小さい型向け）\nPartialEq // == で比較できる\nDefault   // 初期値を自動で作れる\n```\n\n複数指定もOK：\n```rust\n#[derive(Debug, Clone, PartialEq)]\nstruct User {\n    name: String,\n    age: u32,\n}\n```\n\n`Debug` は特によくuse。debug時に構造体の中身を見れて便利！",
    "rust_lesson2_ex1_slide1_content": "# データの「持ち主」を決めるルール\n\n所有権 は、Rust最大のFeatureです。「このデータの持ち主は誰か」をはっきりさせる仕組みです。\n\nルール：\n- データには必ず1人だけ「持ち主」がいる\n- 持ち主がいなくなると、データは自dynamicに片付けられる\n\nたとえるなら：\n- おもちゃは1人しか持てない\n- 持ち主が部屋を出たら、おもちゃは片付けられる\n\nこのルールのおかげで、Rustは「memoryリーク」（データが片付けられないバグ）を防げます！",
    "rust_lesson1_ex3_slide2_title": "Let's Try It!",
    "rust_lesson3_ex1_slide2_title": "なぜ必要？",
    "rust_lesson3_ex1_slide2_content": "# 危険なバグを防ぐ\n\nダングリングreference という危険なバグがあります。これは「もう存在しないデータ」を指し続けているreferenceのことです。\n\nExample：\n```rust\nfn longest<'a>(x: &'a str, y: &'a str) -> &'a str {\n    if x.len() > y.len() { x } else { y }\n}\n```\n\n`'a` の意味：\n- argument `x` と `y` は同じライフタイム `'a` を持つ\n- return valueも同じライフタイム `'a` を持つ\n- In other words「xとyが両方有効な間、return valueも有効」という約束\n\nRustはこれを自動でチェックしてくれます！",
    "rust_lesson4_ex6_slide2_title": "set演算",
    "rust_lesson3_ex7_comment1": "? でerrorを伝播",
    "rust_lesson3_ex2_slide2_content": "# | | でargumentを囲む\n\nclosureは `|引数| 処理` という形でwrite。`||` は「パイプ」と呼ばれます。\n\nいろいろなSyntax：\n```rust\n// 引数なし\n|| println!(\"Hello\")\n\n// 引数あり\n|x, y| x + y\n\n// 複数行のブロック\n|x| {\n    let y = x * 2;\n    y + 1\n}\n```\n\nPoint：\n- argumentを `| |` で囲む（functionの `()` の代わり）\n- typeは省略できることが多い（Rustが推測してくれる）",
    "rust_lesson2_ex7_comment1": "Some でvalueがあることを示す",
    "rust_lesson3_ex4_slide3_content": "各要素を変換するmapを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_title": "Rust (ラスト) に挑戦！",
    "rust_lesson2_ex8_description": "成功と失敗を表す「Result」を学びましょう。",
    "rust_lesson3_ex8_description": "Option/Resultのデフォルトvalueを設定しましょう。",
    "rust_lesson4_ex2_slide3_title": "Let's Try It!",
    "rust_lesson2_ex5_slide3_title": "Let's Try It!",
    "rust_lesson4_ex9_description": "iteratorをコレクションに変換しましょう。",
    "rust_lesson1_ex1_slide2_content": "# println! でscreenにdisplay\n\nRustで文字をscreenにdisplayには、`println!`（プリントラインびっくり）をuse。\n\nPoint：\n- `!` がつくのがRustのFeature（マクロと呼ばれます）\n- programは `fn main() { }` の中にwrite\n- `fn` は「function（function）」の略\n\ncodeExample：\n```rust\nfn main() {\n    println!(\"ヤッホー！\");\n}\n// 「ヤッホー！」と画面に表示される\n```\n\n`println!` の `!` は「マクロ」という特別な機能の印です。今は「おまじない」と思っておけばOK！",
    "rust_lesson3_ex6_slide1_title": "fold ?",
    "rust_lesson4_ex8_slide1_title": "impl Trait ?",
    "rust_lesson1_ex1_slide2_title": "Rustの「おまじない」",
    "rust_lesson3_ex10_description": "stringtypeの違いを理解しましょう。",
    "rust_lesson3_ex7_slide3_content": "エラーを簡潔に伝播させましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex1_comment1": "s1 の所有権を移動",
    "rust_lesson2_ex9_slide1_title": "トレイト?",
    "rust_lesson4_ex6_slide2_content": "# 和set、積setなど\n\n```rust\nset1.union(&set2)\nset1.intersection(&set2)\nset1.difference(&set2)\n```",
    "rust_lesson4_ex5_slide3_content": "キーと値のペアを格納しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex8_slide1_title": "Result（リザルト）?",
    "rust_lesson4_ex1_slide1_content": "# 「できること」の約束\n\nトレイト は、typeが持つべきmethodをdefine仕組みです。\n\nFor example：\n- 「あいさつできる」トレイト → greet() methodを持つ\n- 「displayできる」トレイト → display() methodを持つ\n\ncodeExample：\n```rust\ntrait Greet {\n    fn greet(&self) -> String;  // メソッドの「約束」\n}\n```\n\nこれは「Greetできるtypeは、greet()methodを持つ」という約束です。",
    "rust_lesson4_ex2_slide3_content": "トレイトを自動実装するderiveを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex6_title": "fold で畳み込み",
    "rust_lesson3_ex9_slide3_content": "Vecに要素を追加しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex4_slide1_content": "# 関係あるデータをまとめる「設計図」\n\n構造体（struct） は、いくつかのデータをひとまとめにdo仕組みです。\n\nFor example「点（座標）」のデータ：\n- x座標\n- y座標\n\nこの2つは関係があるので、「Point（点）」としてまとめると便利です。\n\nFor example「人」のデータ：\n- 名前\n- 年齢\n\nこれも「Person（人）」としてまとめられます。\n\n構造体は「こういうデータを持つ」という設計図です。",
    "rust_lesson4_ex1_slide1_title": "トレイト?（復習）",
    "rust_lesson2_ex3_description": "reference先のvalueを変更できる「可変reference」を学びましょう。",
    "rust_lesson2_ex7_slide2_content": "# match で安全に取り出す\n\n`match` を使って「ある場合」と「ない場合」で処理を分けます。\n\ncodeExample：\n```rust\nlet x: Option<i32> = Some(5);  // 値あり\n\nmatch x {\n    Some(n) => println!(\"値は{}です\", n),  // 5\n    None => println!(\"値がありません\"),\n}\n```\n\nなぜ安全？\n- `null` のように「あるつもりでアクセスしたら無かった」errorが起きない\n- 「ない場合」の処理を書かないとコンパイルerrorになる\n- 強制的に両方のケースを考えることになる！",
    "rust_lesson4_ex9_comment1": "collect で Vec に変換",
    "rust_lesson3_ex10_title": "String と &str",
    "rust_lesson2_ex7_slide1_title": "Option（オプション）?",
    "rust_lesson3_ex9_description": "Vecにelementを追加しましょう。",
    "rust_lesson2_ex5_comment1": "impl でmethodをimplementation",
    "rust_lesson3_ex1_slide3_content": "参照の有効期間を表すライフタイムを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex6_slide2_content": "複数の条件を組み合わせる「&&（かつ）」と「||（または）」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex5_comment1": "filter で条件に合うelementを絞り込む",
    "rust_lesson2_ex7_slide3_content": "値があるかないかを表す「Option」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex10_slide3_title": "Let's Try It!",
    "rust_lesson4_ex4_slide3_title": "Let's Try It!",
    "rust_lesson3_ex3_comment1": "iter でiteratorを取得",
    "rust_lesson3_ex6_slide3_content": "要素を1つの値にまとめるfoldを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex7_slide2_title": "ベクタの番号は「0」から！",
    "rust_lesson1_ex5_slide1_title": "conditional（じょうけんぶんき）?",
    "rust_lesson1_ex3_description": "割り算の「あまり」を求める「%」（パーセント）operatorを学びましょう。",
    "rust_lesson1_ex1_slide3_content": "Rustを使って画面に文字を表示してみましょう。println! という特別な関数を使います。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex10_slide2_content": "# <T> でtypeを「あとで決める」\n\nfunction名の後に `<T>` をつけて、`T` を「type」としてuse。\n\ncodeExample：\n```rust\n// Tはどんな型でもOK\nfn first<T>(arr: &[T]) -> &T {\n    &arr[0]  // 最初の要素を返す\n}\n\n// 使い方\nfirst(&[1, 2, 3]);         // Tはi32\nfirst(&[\"a\", \"b\", \"c\"]);   // Tは&str\n```\n\n読み方：\n- `<T>` → 「Tという名前のtypeをuseよ」\n- `T` は慣習で「Type（type）」の頭文字\n- 複数のtypeが必要なら `<T, U>` のようにwrite",
    "rust_lesson3_ex2_comment1": "|x| でclosureのargumentをdefinition",
    "rust_lesson3_ex3_description": "elementを順番に処理doiteratorを学びましょう。",
    "rust_lesson1_ex1_slide3_title": "Let's Try It!",
    "rust_lesson2_ex6_slide2_title": "enum のdefinition",
    "rust_lesson2_ex1_title": "所有権のBasic",
    "rust_lesson4_ex3_slide1_title": "Box（ボックス）?",
    "rust_lesson2_ex1_slide3_content": "Rust独自の概念「所有権」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex8_slide3_content": "Option/Resultのデフォルト値を設定しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex7_slide2_title": "使用Example",
    "rust_lesson4_ex10_description": "iteratorにindexを付けましょう。",
    "rust_lesson4_ex9_slide1_title": "collect ?",
    "rust_lesson4_ex10_slide2_content": "# 「何番目か」が必要なとき\n\n番号（index）とelementの両方が必要なときに便利です。\n\ncodeExample：\n```rust\nlet v = vec![10, 20, 30];\nfor (idx, val) in v.iter().enumerate() {\n    println!(\"{}番目の値は{}\", idx, val);\n}\n// 0番目の値は10\n// 1番目の値は20\n// 2番目の値は30\n```\n\nPoint：\n- `(i, x)` でtuple（2つのset）を受け取る\n- `i` にindex、`x` にelementが入る\n- indexは0から始まる",
    "rust_lesson3_ex2_description": "周囲のvariableを使えるanonymous function「closure」を学びましょう。",
    "rust_lesson1_ex4_comment1": "mut で変更可能にdo",
    "rust_lesson1_ex8_slide3_title": "Let's Try It!",
    "rust_lesson1_ex3_slide2_content": "割り算の「あまり」を求める「%」（パーセント）演算子を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex9_slide3_title": "Let's Try It!",
    "rust_lesson3_ex3_title": "iteratorのBasic",
    "rust_lesson3_ex9_title": "Vec のmethod push",
    "rust_lesson1_ex8_comment1": "dictionaryをcreate（keyは'みかん'、valueは'オレンジ'）",
    "rust_lesson1_ex2_comment3": "+ でたし算do",
    "rust_lesson4_ex8_slide2_content": "# ジェネリクスの代わり\n\n```rust\nfn print_all(iter: impl Iterator<Item = i32>) {\n    for x in iter {\n        println!(\"{}\", x);\n    }\n}\n```",
    "rust_lesson2_ex2_slide2_title": "reference Usage",
    "rust_lesson1_ex8_slide3_content": "「辞書（HashMap）」を使うと、名前をつけてデータを保存し、その名前で取り出せます。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex7_slide2_content": "# [ ]で番号を指定して取り出す\n\n`[番号]` で何番目のデータか指定して取り出せます。\n\nImportantなルール：番号は「0」から！\n- 1番目 → `[0]`\n- 2番目 → `[1]`\n- 3番目 → `[2]`\n\ncodeExample：\n```rust\nlet fruits = vec![\"りんご\", \"バナナ\", \"みかん\"];\n//                  ↑0番    ↑1番     ↑2番\nprintln!(\"{}\", fruits[0]);  // りんご\nprintln!(\"{}\", fruits[1]);  // バナナ\n```\n\nプログラミングでは「0から数える」のが世界共通のルールです！",
    "rust_lesson1_ex6_slide1_title": "条件を組み合わせる",
    "rust_lesson2_ex10_slide2_title": "ジェネリックfunction Syntax",
    "rust_lesson1_ex6_description": "複数の条件を組み合わせる「&&（かつ）」と「||（Alsoは）」を学びましょう。",
    "rust_lesson4_ex6_title": "HashSet",
    "rust_lesson2_ex3_slide2_content": "# mut が2か所に必要\n\n変更できるようにdoには、variableとreferenceの両方に `mut` が必要です。\n\ncodeExample：\n```rust\n// 1. 変数を mut で作る\nlet mut s = String::from(\"hello\");\n\n// 2. &mut で可変参照を渡す\nchange(&mut s);\n\nfn change(s: &mut String) {\n    s.push_str(\" world\");  // 変更できる！\n}\n```\n\nPoint：\n- `let mut 変数` でvariableを変更可能に\n- `&mut 変数` で可変referenceをcreate\n- 両方ないと変更できない！",
    "rust_lesson2_ex2_slide1_title": "reference（さんしょう）?",
    "rust_lesson3_ex6_slide2_content": "# 合計、積、結合など\n\n```rust\n// 積\nv.iter().fold(1, |acc, x| acc * x)\n\n// 文字列結合\nwords.iter().fold(String::new(), |acc, s| acc + s)\n```",
    "rust_lesson1_ex1_description": "Rustを使ってscreenに文字をdisplayしてみましょう。println! という特別なfunctionをuse。",
    "rust_lesson3_ex8_slide3_title": "Let's Try It!",
    "rust_lesson4_ex6_description": "一意なvalueのsetを管理しましょう。",
    "rust_lesson2_ex5_slide1_title": "impl ?",
    "rust_lesson1_ex8_title": "名前で引き出す「dictionary」",
    "rust_lesson2_ex7_description": "valueがあるかないかを表す「Option」を学びましょう。",
    "rust_lesson1_ex4_slide2_title": "Let's Try It!",
    "rust_lesson1_ex7_title": "たくさんのデータをまとめましょう「ベクタ」",
    "rust_lesson3_ex7_slide1_content": "# errorの早期リターン\n\n? は、Resultが Err の場合に早期リターンします。\n\n```rust\nfn read_file() -> Result<String, io::Error> {\n    let content = fs::read_to_string(\"file.txt\")?;\n    Ok(content)\n}\n```",
    "rust_lesson3_ex9_slide1_content": "# 末尾に追加\n\npush は、Vecの末尾にelementをadd。\n\n```rust\nlet mut v = vec![1, 2];\nv.push(3);\n// [1, 2, 3]\n```",
    "rust_lesson4_ex8_slide3_content": "トレイトを返す関数を簡潔に書きましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex1_title": "screenにメッセージを出しましょう",
    "rust_lesson2_ex8_slide2_title": "Result  Usage",
    "rust_lesson3_ex2_slide1_title": "closure?",
    "rust_lesson3_ex8_title": "unwrap_or でデフォルトvalue",
    "rust_lesson4_ex10_slide1_content": "# 番号とelementを一緒にもらう\n\nenumerate は、「何番目か」と「そのelement」をsetで取り出せるmethodです。\n\nFor example：\n- 0番目: りんご\n- 1番目: バナナ\n- 2番目: みかん\n\ncodeExample：\n```rust\nfor (i, x) in vec![\"a\", \"b\", \"c\"].iter().enumerate() {\n    println!(\"{}: {}\", i, x);\n}\n// 0: a\n// 1: b\n// 2: c\n```",
    "rust_lesson1_ex7_slide1_content": "# データを並べてまとめる「長い箱」\n\nベクタ（Vec） は、たくさんのデータを順番に並べて入れられる「長い箱」です。\n\nFor example：\n- 買い物listの商品を全部まとめる\n- testの点数を全部まとめる\n- 友だちの名前を全部まとめる\n\n100個でも1000個でも、1つのvariableでまとめて管理できます！\n\n作り方：\n```rust\nlet fruits = vec![\"りんご\", \"バナナ\", \"みかん\"];\n// vec! で ベクタを作る\n```",
    "rust_lesson4_ex8_slide3_title": "Let's Try It!",
    "rust_lesson4_ex7_description": "パターンマッチに条件を追加しましょう。",
    "rust_lesson1_ex4_comment2": "+= で 20 を足す",
    "rust_lesson1_ex2_comment2": "y に 5 を入れる",
    "rust_lesson2_ex3_slide3_title": "Let's Try It!",
    "rust_lesson3_ex4_slide1_title": "map（map）?",
    "rust_lesson1_ex2_slide3_content": "データに名前をつけて保存できる「変数（へんすう）」を使ってみましょう。letで変数を作ります。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex8_slide2_content": "# match で成功と失敗を分ける\n\n`match` で「成功したら」「失敗したら」の処理を書き分けます。\n\ncodeExample：\n```rust\nfn divide(a: i32, b: i32) -> Result<i32, String> {\n    if b == 0 {\n        return Err(\"0で割れません\".to_string());\n    }\n    Ok(a / b)  // 成功なら答えを返す\n}\n\nmatch divide(10, 2) {\n    Ok(v) => println!(\"答えは{}\", v),\n    Err(e) => println!(\"エラー: {}\", e),\n}\n```\n\nPoint：\n- `Ok(値)` で成功をreturn\n- `Err(エラー)` で失敗をreturn",
    "rust_lesson4_ex3_comment1": "Box::new でheapに格納",
    "rust_lesson4_ex8_description": "トレイトをreturnfunctionを簡潔に書きましょう。",
    "rust_lesson2_ex10_description": "typeを後から決められる「ジェネリクス」を学びましょう。",
    "rust_lesson2_ex3_slide1_title": "可変reference（かへんさんしょう）?",
    "rust_lesson2_ex2_description": "所有権を移さずにvalueを借りる「reference」を学びましょう。",
    "rust_lesson3_ex5_slide2_title": "** にNote！",
    "rust_lesson2_ex2_slide3_title": "Let's Try It!",
    "rust_lesson4_ex3_slide3_content": "ヒープにデータを格納するBoxを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex4_title": "累算assignmentoperator（+=、-=）",
    "rust_lesson3_ex3_slide2_content": "# 借りるか、もらうか\n\n3種類の iter があり、所有権の扱いが違います。\n\n3つの違い：\n```rust\nv.iter()       // 参照で借りる（&T）\nv.iter_mut()   // 変更可能で借りる（&mut T）\nv.into_iter()  // 所有権をもらう（T）\n```\n\n使い分け：\n- `iter()` → 見るだけ（元のベクタも使える）\n- `iter_mut()` → 中身を変更したい\n- `into_iter()` → ベクタごともらう（元は使えない）\n\n普通は `iter()` をuseことが多いです。",
    "rust_lesson2_ex1_slide1_title": "所有権（しょゆうけん）?",
    "rust_lesson4_ex6_slide3_content": "一意な値の集合を管理しましょう。\n\n（When you're ready, select \"Start Lesson\".）"
  },
  "tr": {
    "rust_lesson1_course_title": "Introduction to Rust",
    "rust_lesson1_course_description": "Learn the basics of Rust programming.",
    "rust_lesson2_course_title": "Rust II - Intermediate",
    "rust_lesson2_course_description": "Learn intermediate Rust concepts.",
    "rust_lesson3_course_title": "Rust III - Advanced",
    "rust_lesson3_course_description": "Master advanced Rust techniques.",
    "rust_lesson4_course_title": "Rust IV - Expert Level",
    "rust_lesson4_course_description": "Expert-level Rust programming.",
    "rust_lesson1_ex5_slide2_content": "条件によって動きを変える if文を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex9_title": "collect で変換",
    "rust_lesson2_ex7_slide1_content": "# 「あるかもしれない、ないかもしれない」\n\nOption<T> は、valueが「あるかもしれないし、ないかもしれない」ことを表すtypeです。\n\nFor example：\n- dictionaryで単語を探す → 見つかるかもしれないし、ないかもしれない\n- ゲームでアイテムを拾う → 落ちてるかもしれないし、ないかもしれない\n\n2つの状態：\n- `Some(値)` → valueがある！\n- `None` → valueがない...\n\n他の言語では `null` をuseが、Rustでは `Option` で安全に扱います。",
    "rust_lesson1_ex2_slide1_title": "variable（へんすう）?",
    "rust_lesson1_ex7_description": "「ベクタ（Vec）」をuseと、たくさんのデータを一つの「長い はこ」にまとめて入れられます。",
    "rust_lesson2_ex9_slide2_content": "# 約束を作って、守る\n\n1. `trait` で「約束」をdefinition\n2. `impl トレイト for 型` で「約束を守る」implementationをdo\n\ncodeExample：\n```rust\n// 1. トレイト（約束）を定義\ntrait Speak {\n    fn speak(&self);  // 鳴くメソッドを持つ約束\n}\n\n// 2. Dog構造体がトレイトを実装\nstruct Dog;\nimpl Speak for Dog {\n    fn speak(&self) {\n        println!(\"woof\");\n    }\n}\n```\n\n「DogはSpeakができる」ということになります。",
    "rust_lesson4_ex4_description": "referenceカウントでデータを共有しましょう。",
    "rust_lesson4_ex5_slide1_content": "# 名前で引ける「dictionary」\n\nHashMap は、「key（名前）」と「value（データ）」をsetで保存dodictionaryです。\n\nFor example：\n- 「青チーム」→ 10点\n- 「赤チーム」→ 15点\n\ncodeExample：\n```rust\nuse std::collections::HashMap;\n\nlet mut scores = HashMap::new();\nscores.insert(\"Blue\", 10);   // 追加\nscores.insert(\"Red\", 15);    // 追加\n```\n\n`use` で機能を読み込んでからuse。",
    "rust_lesson3_ex4_title": "map でiterator変換",
    "rust_lesson4_ex1_slide3_content": "共通の振る舞いを定義するトレイトを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex4_description": "variableのvalueを手軽に増やしたり減らしたりdo「+=」「-=」を学びましょう。",
    "rust_lesson1_ex2_description": "データに名前をつけて保存できる「variable（へんすう）」を使ってみましょう。letでvariableをcreate。",
    "rust_lesson4_ex4_slide2_title": "referenceカウントの仕組み",
    "rust_lesson3_ex8_slide2_title": "unwrap_or_else",
    "rust_lesson4_ex10_comment1": "1番目の i にindex、2番目の item にelementが入る",
    "rust_lesson3_ex6_slide1_content": "# 累積処理\n\nfold は、初期valueとfunctionでelementを1つずつ畳み込みます。\n\n```rust\nlet v = vec![1, 2, 3];\nlet sum = v.iter().fold(0, |acc, x| acc + x);\n// 6\n```",
    "rust_lesson4_ex2_slide2_title": "よくuse derive トレイト",
    "rust_lesson3_ex10_slide3_content": "文字列型の違いを理解しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex4_slide2_content": "変数の値を手軽に増やしたり減らしたりする「+=」「-=」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex4_slide3_title": "Let's Try It!",
    "rust_lesson3_ex5_slide1_title": "filter（filterー）?",
    "rust_lesson4_ex5_description": "keyとvalueのpairを格納しましょう。",
    "rust_lesson3_ex5_description": "条件に合うelementだけを取り出しましょう。",
    "rust_lesson2_ex2_slide2_content": "# functionに借りてもらう\n\nfunctionにデータを渡すとき、`&` をつけると「借りる」形になります。元のvariableはそのまま使い続けられます。\n\ncodeExample：\n```rust\nfn calc_len(s: &String) -> usize {\n    s.len()  // 長さを返す\n}\n\nfn main() {\n    let text = String::from(\"hello\");\n    let len = calc_len(&text);  // textを貸す\n    // text はまだ使える！\n    println!(\"{}の長さは{}\", text, len);\n}\n```\n\n`&String` は「Stringを借りる」という意味です。",
    "rust_lesson4_ex7_slide3_content": "パターンマッチに条件を追加しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex8_slide2_content": "# 遅延評価\n\n```rust\n// クロージャで計算\nlet value = x.unwrap_or_else(|| expensive_computation());\n```",
    "rust_lesson4_ex7_title": "match ガード",
    "rust_lesson3_ex7_title": "? operatorでerror伝播",
    "rust_lesson4_ex1_description": "共通の振る舞いをdefineトレイトを学びましょう。",
    "rust_lesson2_ex1_slide2_content": "# 所有権は「移動」do\n\nvariableを別のvariableにassignmentdoと、所有権が 移動（ムーブ） します。元のvariableは使えなくなります。\n\ncodeExample：\n```rust\nlet s1 = String::from(\"hello\");  // s1 が持ち主\nlet s2 = s1;  // 所有権が s2 に移動！\n// ↓ s1 はもう使えない（エラーになる）\n// println!(\"{}\", s1);  // ダメ！\nprintln!(\"{}\", s2);  // OK！\n```\n\nイメージ：\nおもちゃを友だちにあげたら、自分はもう使えない。これがムーブです。",
    "rust_lesson1_ex8_slide1_title": "dictionary（HashMap）?",
    "rust_lesson4_ex3_slide2_content": "# サイズが決まらないとき\n\nBoxは、コンパイル時にサイズがわからないtypeにuse。\n\nFor examplerecursion的なtype：\n```rust\n// リストは「値 + 次のリスト」の繰り返し\nenum List {\n    Cons(i32, Box<List>),  // Boxで次を指す\n    Nil,                   // 終わり\n}\n```\n\nなぜBoxが必要？\n- `List` の中に `List` がある → 無限に大きくなる？\n- `Box` をuseと、サイズが固定（pointerのサイズ）になる\n\n「中身」ではなく「中身への矢印」を持つイメージです。",
    "rust_lesson2_ex10_title": "ジェネリクスを使おう",
    "rust_lesson2_ex8_slide3_title": "Let's Try It!",
    "rust_lesson3_ex9_slide2_content": "# 可変reference\n\n```rust\n// mut が必要\nlet mut v = Vec::new();\nv.push(1);\nv.push(2);\n```",
    "rust_lesson4_ex4_title": "Rc<T>",
    "rust_lesson2_ex3_comment1": "mut で可変variableにdo",
    "rust_lesson4_ex5_slide3_title": "Let's Try It!",
    "rust_lesson2_ex6_slide2_content": "# バリアントを列挙\n\n`enum 名前 { バリアント1, バリアント2, ... }` でdefine。\n\ncodeExample：\n```rust\nenum Color {\n    Red,\n    Green,\n    Blue,\n}\nlet c = Color::Red;\n```",
    "rust_lesson1_ex1_comment1": "Hello, Rust! とdisplay",
    "rust_lesson1_ex1_slide1_content": "# 安全で速い！最新のプログラミング言語\n\nRust（ラスト）は、「間違いを事前に防ぐ」ことがとても得意なプログラミング言語です。\n\nRustのすごいところ：\n- programのミスをexecute前に見つけてくれる\n- とても速く動く\n- 世界中のプログラマーが「一番好き！」と選ぶ人気の言語\n\nたとえるなら：\n厳しいけど優しい先生のような言語です。「ここ間違ってるよ」と教えてくれるので、安心してprogramが書けます！",
    "rust_lesson3_ex8_slide1_content": "# None/Err の場合のデフォルト\n\nunwrap_or は、None や Err の場合にデフォルトvalueをreturn。\n\n```rust\nlet x: Option<i32> = None;\nlet value = x.unwrap_or(0);  // 0\n```",
    "rust_lesson2_ex7_slide3_title": "Let's Try It!",
    "rust_lesson2_ex6_title": "enum で状態を表す",
    "rust_lesson2_ex8_slide1_content": "# 「成功」か「失敗」かを表す\n\nResult<T, E> は、処理が「成功したか失敗したか」を表すtypeです。\n\nFor example：\n- fileをopen → 成功（内容）か失敗（error）\n- 0で割り算 → 成功（答え）か失敗（0で割れない！）\n\n2つの状態：\n- `Ok(値)` → 成功！valueが入っている\n- `Err(エラー)` → 失敗...error情報が入っている\n\n`Option` は「あるか・ないか」、`Result` は「成功か・失敗か」という違いです。",
    "rust_lesson2_ex8_slide3_content": "成功と失敗を表す「Result」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex6_slide1_title": "HashSet ?",
    "rust_lesson3_ex9_comment1": "push でelementを追加",
    "rust_lesson2_ex7_slide2_title": "Option  Usage",
    "rust_lesson3_ex2_title": "closureのBasic",
    "rust_lesson3_ex7_slide1_title": "? operator?",
    "rust_lesson4_ex6_comment1": "HashSet をimport",
    "rust_lesson2_ex10_slide1_content": "# どんなtypeでも使える「万能」の仕組み\n\nジェネリクス は、typeを後から決められる仕組みです。\n\nなぜ便利？\n同じようなfunctionを何度も書かなくてすみます。\n\nFor example：\n- 数字のarrayの最初のelementを取るfunction\n- stringのarrayの最初のelementを取るfunction\n\n両方とも「最初のelementを取る」のは同じなのに、typeが違うだけで別のfunctionをwriteのは大変！\n\nジェネリクスなら、`<T>` で「typeは後で決める」とwriteだけで、どんなtypeでも使えるfunctionが作れます。",
    "rust_lesson1_ex3_slide1_content": "# 剰余operator（じょうよえんざんし）「%」\n\n`%`（パーセント）は、割り算の 「あまり」 をcalculate特別な記号です。\n\nわかりやすいExample：\n- 10このアメを3人で分けると？\n- 1人3こずつで、1こあまる\n- これを `10 % 3` とwriteと、答えは `1`\n\ncodeExample：\n```rust\nprintln!(\"{}\", 10 % 3);  // 1（あまり1）\nprintln!(\"{}\", 8 % 4);   // 0（あまりなし＝割り切れる）\n```\n\n使いどころ：\n- 偶数か奇数か調べる（`n % 2` が0なら偶数）\n- 時計の計算（24を超えたら0に戻る、など）",
    "rust_lesson3_ex7_description": "errorを簡潔に伝播させましょう。",
    "rust_lesson3_ex8_comment1": "unwrap_or でデフォルトvalueを設定",
    "rust_lesson2_ex8_title": "Result<T, E> でerror処理",
    "rust_lesson2_ex10_comment1": "T をtypeパラメータとしてuse",
    "rust_lesson2_ex6_comment1": "enum で列挙typeをdefinition",
    "rust_lesson3_ex3_slide3_content": "要素を順番に処理するイテレータを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex2_comment1": "derive でトレイトを自動implementation",
    "rust_lesson1_ex8_slide1_content": "# 名前でsearchできる「dictionary」\n\nHashMap（ハッシュmap）は、「名前」と「データ」をsetにして保存できる仕組みです。本物のdictionaryのように使えます。\n\nFor example果物の色dictionary：\n- 「りんご」→「あか」\n- 「バナナ」→「きいろ」\n- 「みかん」→「オレンジ」\n\nuse準備：\n```rust\nuse std::collections::HashMap;  // 機能を読み込む\nlet mut fruits = HashMap::new();  // 空の辞書を作る\nfruits.insert(\"りんご\", \"あか\");  // データを追加\n```\n\n`use` は「この機能をuseよ」というdeclarationです。",
    "rust_lesson3_ex9_slide1_title": "push ?",
    "rust_lesson4_ex1_title": "トレイトのdefinition",
    "rust_lesson4_ex3_description": "heapにデータを格納doBoxを学びましょう。",
    "rust_lesson1_ex2_title": "便利な「はこ」variable（へんすう）",
    "rust_lesson1_ex8_comment2": "中身を出す",
    "rust_lesson3_ex9_slide3_title": "Let's Try It!",
    "rust_lesson1_ex4_comment3": "-= で 50 を引く",
    "rust_lesson1_ex6_comment1": "&& で両方の条件をチェック",
    "rust_lesson4_ex1_slide2_title": "トレイトのimplementation",
    "rust_lesson4_ex7_slide3_title": "Let's Try It!",
    "rust_lesson4_title": "Rust IV - トレイトとスマートpointer",
    "rust_lesson4_ex1_comment1": "trait でトレイトをdefinition",
    "rust_lesson4_ex4_slide1_content": "# 複数の「持ち主」を許可do仕組み\n\nRc<T> は「Reference Counted（referenceカウント）」の略で、複数の所有者でデータを共有できます。\n\n普通の所有権：\n1人だけが持ち主。渡したら元の人は使えない。\n\nRc をuseと：\n複数人が同じデータの「持ち主」になれる！\n\ncodeExample：\n```rust\nuse std::rc::Rc;\n\nlet a = Rc::new(5);       // Rcでラップ\nlet b = Rc::clone(&a);    // bも持ち主になる\n// a も b も使える！\n```",
    "rust_lesson3_ex5_slide1_content": "# 条件に合うものだけ残す\n\nfilter は、条件を満たすelementだけを残し、他を捨てます。\n\nFor example：\n- 80点以上の人だけ残す\n- 偶数だけ残す\n- 「あ」から始まる名前だけ残す\n\ncodeExample：\n```rust\nlet v = vec![1, 2, 3, 4, 5];\nlet evens: Vec<_> = v.iter()\n    .filter(|x| **x % 2 == 0)  // 偶数だけ\n    .collect();\n// [2, 4]\n```\n\n条件が `true` のelementだけが残ります。",
    "rust_lesson3_ex7_slide3_title": "Let's Try It!",
    "rust_lesson1_ex7_comment2": "2番目のデータ（1番）を出す",
    "rust_lesson4_ex8_title": "impl Trait",
    "rust_lesson1_ex5_description": "条件によって動きを変える if文を学びましょう。",
    "rust_lesson3_ex4_slide2_title": "遅延評価（ちえんひょうか）",
    "rust_lesson3_ex1_slide1_content": "# referenceの「寿命」を示す印\n\nライフタイム は、referenceがいつまで使えるかを示す印です。`'a`（アポストロフィ・エー）のようにwrite。\n\nなぜ必要？\nreferenceは「借りている」状態。借りた元のデータが消えたら、referenceも使えなくなります。\n\nFor example：\n- 図書館で借りた本 → 図書館が閉まったら読めない\n- referenceで借りたデータ → 元のデータが消えたら使えない\n\nライフタイムは「このreferenceはこの範囲で有効だよ」とコンパイラに伝える仕組みです。",
    "rust_lesson1_ex1_slide1_title": "Rust（ラスト）?",
    "rust_lesson1_ex2_slide2_title": "計算の記号（operator）",
    "rust_lesson4_ex5_slide2_content": "# get で安全に取り出す\n\n`get()` methodでvalueを取り出せます。見つからない可能性があるので、`Option` が返ってきます。\n\ncodeExample：\n```rust\n// getはOption<&V>を返す\nif let Some(score) = scores.get(\"Blue\") {\n    println!(\"青チームは{}点\", score);\n}\n```\n\nPoint：\n- keyがあれば `Some(値)` が返る\n- keyがなければ `None` が返る\n- `if let` で安全に取り出せる\n\n存在しないkeyでアクセスしてもprogramが落ちない！",
    "rust_lesson4_ex7_slide1_title": "match ガード?",
    "rust_lesson3_title": "Rust III - ライフタイムとiterator",
    "rust_lesson4_ex3_title": "Box<T>",
    "rust_lesson1_ex4_slide1_title": "累算assignmentoperator（るいさんだいにゅう）?",
    "rust_lesson2_ex9_comment1": "trait でトレイトをdefinition",
    "rust_lesson2_ex1_description": "Rust独自の概念「所有権」を学びましょう。",
    "rust_lesson2_ex3_slide3_content": "参照先の値を変更できる「可変参照」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex1_slide3_title": "Let's Try It!",
    "rust_lesson3_ex6_slide2_title": "様々な畳み込み",
    "rust_lesson4_ex9_slide3_title": "Let's Try It!",
    "rust_lesson2_ex5_title": "impl でmethodを追加",
    "rust_lesson2_ex6_slide1_content": "# 複数の選択肢\n\nenum は、valueがいくつかの種類のうちの一つであることを表します。各バリアントにデータを持たせることもできます。",
    "rust_lesson2_ex4_comment1": "struct で構造体をdefinition",
    "rust_lesson1_ex3_title": "剰余operator（%）",
    "rust_lesson1_ex7_comment1": "colors というベクタをcreate（'あか', 'あお'の順）",
    "rust_lesson1_ex4_slide1_content": "# valueをかんたんに増やす・減らす\n\n`+=`（プラスイコール）と `-=`（マイナスイコール）は、variableの中身を増やしたり減らしたりdo便利な記号です。\n\nRustのImportantなルール：`mut`が必要！\nRustでは、variableをchangeには `let mut`（レット ミュート）とwrite必要があります。`mut` は「mutable（変更できる）」の略です。\n\ncodeExample：\n```rust\nlet mut score = 100;  // mut をつけて変更可能に\nscore += 10;          // 10を足す → 110に\nscore -= 50;          // 50を引く → 60に\n```\n\n`mut` がないと「このvariableは変えちゃダメ！」とRustが怒ります。",
    "rust_lesson2_ex1_slide2_title": "ムーブ（移動）",
    "rust_lesson3_ex4_comment1": "map で各elementを変換",
    "rust_lesson3_ex8_slide1_title": "unwrap_or ?",
    "rust_lesson2_ex5_slide1_content": "# implementationブロック\n\nimpl ブロックで、構造体にmethodを追加できます。`self` で自分自身をreferenceします。",
    "rust_lesson2_ex10_slide1_title": "ジェネリクス?",
    "rust_lesson1_ex8_slide2_content": "# 名前（key）で取り出す\n\ndictionaryに入れたデータは、名前（key）を指定して取り出せます。\n\ncodeExample：\n```rust\nuse std::collections::HashMap;\nfn main() {\n    let mut fruits = HashMap::new();\n    fruits.insert(\"りんご\", \"あか\");  // 追加\n    fruits.insert(\"バナナ\", \"きいろ\");  // 追加\n    \n    println!(\"{}\", fruits[\"りんご\"]);  // あか と表示\n}\n```\n\nPoint：\n- `insert(名前, データ)` で追加\n- `辞書[名前]` で取り出し\n- 番号ではなく「名前」で探せるのが便利！",
    "rust_lesson4_ex9_slide1_content": "# iteratorをコレクションに\n\ncollect は、iteratorをVecやHashMapなどに変換します。\n\n```rust\nlet v: Vec<_> = (0..5).collect();\nlet s: String = vec!['a', 'b'].into_iter().collect();\n```",
    "rust_lesson2_ex2_slide3_content": "所有権を移さずに値を借りる「参照」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex2_slide3_content": "周囲の変数を使える無名関数「クロージャ」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex4_slide2_content": "# struct keyワードでdefinition\n\n`struct 名前 { フィールド }` で構造体をdefine。フィールドには名前とtypeをwrite。\n\ncodeExample：\n```rust\n// Point 構造体を定義\nstruct Point {\n    x: i32,  // xフィールド（整数）\n    y: i32,  // yフィールド（整数）\n}\n\n// 使い方\nlet p = Point { x: 10, y: 20 };\nprintln!(\"x={}, y={}\", p.x, p.y);\n```\n\nPoint：\n- `struct 名前` で構造体をcreate\n- `{ フィールド名: 型 }` でどんなデータを持つか決める\n- `.フィールド名` でアクセス",
    "rust_lesson2_ex10_slide3_content": "型を後から決められる「ジェネリクス」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex6_slide3_title": "Let's Try It!",
    "rust_lesson4_ex6_slide1_content": "# 一意なvalueのset\n\nHashSet は、重複のないvalueのsetです。\n\n```rust\nuse std::collections::HashSet;\n\nlet mut set = HashSet::new();\nset.insert(1);\nset.insert(2);\nset.insert(1); // 重複は無視\n```",
    "rust_lesson4_ex2_title": "derive 属性",
    "rust_lesson4_ex2_slide1_content": "# トレイトを「自動で」implementation\n\n#[derive(...)] をuseと、よくuseトレイトを自分で書かなくても自動でimplementationしてくれます。\n\nFor example：\n構造体を `println!` でdisplayしたいとき、普通は Display トレイトをimplementationdo必要がありますが、`#[derive(Debug)]` をwriteだけでOK！\n\ncodeExample：\n```rust\n#[derive(Debug)]  // Debug トレイトを自動実装\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nlet p = Point { x: 1, y: 2 };\nprintln!(\"{:?}\", p);  // Point { x: 1, y: 2 }\n```",
    "rust_lesson1_ex6_slide2_title": "Let's Try It!",
    "rust_lesson3_ex3_slide2_title": "3つの iter method",
    "rust_lesson4_ex7_slide2_content": "# 複雑なconditional\n\n```rust\nmatch Some(5) {\n    Some(x) if x % 2 == 0 => println!(\"even\"),\n    Some(x) => println!(\"odd: {}\", x),\n    None => println!(\"none\"),\n}\n```",
    "rust_lesson3_ex3_slide1_content": "# elementを1つずつ取り出す仕組み\n\niterator は、ベクタなどのデータを「1つずつ順番に」取り出す仕組みです。\n\nFor example：\n- 行列に並んでいる人を1人ずつ呼ぶ\n- 引き出しの中身を1つずつ出す\n\ncodeExample：\n```rust\nlet v = vec![1, 2, 3];\nfor x in v.iter() {\n    println!(\"{}\", x);  // 1, 2, 3 と順番に表示\n}\n```\n\n`iter()` で「順番に取り出す準備」をして、`for` で1つずつ処理します。",
    "rust_lesson3_ex3_slide1_title": "iterator?",
    "rust_lesson4_ex2_description": "トレイトを自動implementationdoderiveを学びましょう。",
    "rust_lesson3_ex4_slide1_content": "# 全部を同じように変換do\n\n**map** は、iteratorの各elementを「同じ方法で」変換します。\n\nFor example：\n- 全員の身長を2倍にdo\n- 全員の名前を大文字にdo\n- 全部の数を2乗do\n\ncodeExample：\n```rust\nlet v = vec![1, 2, 3];\nlet doubled: Vec<_> = v.iter()\n    .map(|x| x * 2)  // 各要素を2倍に\n    .collect();      // ベクタに戻す\n// [2, 4, 6]\n```\n\n`|x| x * 2` は「xを受け取って、x*2をreturn」closureです。",
    "rust_lesson1_ex3_slide1_title": "あまりを求める",
    "rust_lesson3_ex10_slide1_content": "# 所有権の違い\n\nString は所有権を持つheap上のstring、&str はreferenceです。\n\n```rust\nlet s1: String = String::from(\"hello\");\nlet s2: &str = \"hello\";\n```",
    "rust_lesson4_ex2_slide1_title": "derive（デライブ）?",
    "rust_lesson2_ex2_comment1": "& でreferenceを渡す",
    "rust_lesson4_ex5_slide1_title": "HashMap（ハッシュmap）?",
    "rust_lesson2_ex3_slide2_title": "&mut  Usage",
    "rust_lesson3_ex5_title": "filter で絞り込み",
    "rust_lesson4_ex3_slide2_title": "いつuse？",
    "rust_lesson2_ex2_title": "referenceと借用",
    "rust_lesson2_ex7_title": "Option<T> で null を安全に",
    "rust_lesson4_ex10_slide3_title": "Let's Try It!",
    "rust_lesson3_ex5_slide3_title": "Let's Try It!",
    "rust_lesson4_ex10_title": "enumerate でindex付き",
    "rust_lesson2_ex2_slide1_content": "# 所有権を渡さずに「借りる」\n\nreference をuseと、所有権を移さずにデータを「見せてもらう」ことができます。\n\nたとえるなら：\n- ムーブ = おもちゃをあげる（自分は使えない）\n- reference = おもちゃを見せる（自分も使える）\n\n作り方：\n`&`（アンパサンド）をつけるとreferenceを作れます。\n\n```rust\nlet s = String::from(\"hello\");\nlet r = &s;  // sを借りる（見せてもらう）\n// s も r も使える！\n```",
    "rust_lesson2_ex5_slide2_content": "# &self をuse\n\nmethodの最初のargumentは `&self` です。\n\ncodeExample：\n```rust\nimpl Rect {\n    fn area(&self) -> i32 {\n        self.width * self.height\n    }\n}\n```",
    "rust_lesson1_ex5_slide2_title": "Let's Try It!",
    "rust_lesson2_ex4_slide3_title": "Let's Try It!",
    "rust_lesson4_ex3_slide3_title": "Let's Try It!",
    "rust_lesson2_ex9_slide3_content": "共通の振る舞いを定義する「トレイト」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex1_slide2_content": "# impl で約束を守る\n\n構造体にトレイトをimplementationdoと、その構造体は「約束を守る」ことになります。\n\ncodeExample：\n```rust\nstruct Person { name: String }\n\nimpl Greet for Person {\n    fn greet(&self) -> String {\n        format!(\"Hello, {}\", self.name)\n    }\n}\n```\n\n読み方：\n- `impl Greet for Person` → 「PersonはGreetをimplementationdo」\n- これでPersonは「あいさつできる」ようになった！",
    "rust_lesson4_ex4_comment1": "clone でreferenceカウントを増やす",
    "rust_lesson3_ex4_slide2_content": "# map だけではexecuteされない！\n\nRustのiteratorは 遅延評価 といって、「本当に必要になるまで処理しない」仕組みです。\n\nなぜ？\n無駄な計算を省けるから。100万件あっても、最初の10件だけ欲しいなら10件だけ処理すればいい。\n\ncollect() でexecute：\n```rust\n// これだけでは何も起きない\nv.iter().map(|x| x * 2);\n\n// collect() で実行してベクタに変換\nlet result: Vec<_> = v.iter().map(|x| x * 2).collect();\n```\n\n`collect()` は「今すぐ全部処理してResultをちょうだい」という意味です。",
    "rust_lesson2_ex4_slide2_title": "struct のdefinitionのしかた",
    "rust_lesson2_ex3_slide1_content": "# 「書き換えできる」借り方\n\n普通のreference `&` は「見るだけ」ですが、可変reference `&mut` は「変更もできる」借り方です。\n\nたとえるなら：\n- `&` = 本を見せてもらう（readだけ）\n- `&mut` = ノートを借りる（writeOK）\n\nImportantなルール：\n- 可変referenceは同時に1つだけ！\n- 「みんなで見る」か「1人でwrite」かのどちらか\n\nこのルールで、データが同時に書き換えられるバグを防いでいます。",
    "rust_lesson2_ex10_slide3_title": "Let's Try It!",
    "rust_lesson2_ex4_title": "構造体をdefinitionしよう",
    "rust_lesson3_ex10_slide2_content": "# 相互変換\n\n```rust\n// &str -> String\nlet s = \"hello\".to_string();\n\n// String -> &str\nlet slice: &str = &s;\n```",
    "rust_lesson4_ex10_slide3_content": "イテレータにインデックスを付けましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex4_slide2_content": "# 「何人が持っているか」を数える\n\nRcは「今何人がこのデータを持っているか」を数えています。\n\ncodeExample：\n```rust\nlet a = Rc::new(5);\nprintln!(\"{}\", Rc::strong_count(&a));  // 1\n\nlet b = Rc::clone(&a);\nprintln!(\"{}\", Rc::strong_count(&a));  // 2\n```\n\nいつデータが消える？\n- カウントが0になったとき（誰も持っていないとき）\n- 最後の持ち主がいなくなると自動で片付けられる\n\n`Rc::clone` は「持ち主を1人増やす」操作です。",
    "rust_lesson1_ex8_slide2_title": "dictionary Usage",
    "rust_lesson4_ex3_slide1_content": "# データを「heap」に置く箱\n\nBox<T> は、データを「heap」という特別な場所に置くための箱です。\n\nmemoryの2つの場所：\n- stack：小さくて速い。サイズが決まっているデータ向け\n- heap：大きくて柔軟。サイズが大きいor変わるデータ向け\n\ncodeExample：\n```rust\nlet b = Box::new(5);  // 5をヒープに置く\nprintln!(\"{}\", *b);   // *で中身を取り出す → 5\n```\n\n`*` は「箱を開けて中身を見る」操作です。",
    "rust_lesson3_ex2_slide2_title": "closure Syntax",
    "rust_lesson4_ex4_slide1_title": "Rc（アールシー）?",
    "rust_lesson4_ex7_slide1_content": "# 追加条件\n\n**if** でパターンに追加条件をつけられます。\n\n```rust\nmatch x {\n    n if n < 0 => println!(\"negative\"),\n    n if n > 0 => println!(\"positive\"),\n    _ => println!(\"zero\"),\n}\n```",
    "rust_lesson2_ex3_title": "可変reference",
    "rust_lesson3_ex10_comment1": "to_string で String に変換",
    "rust_lesson3_ex10_slide2_title": "変換",
    "rust_lesson3_ex1_description": "referenceの有効期間を表すライフタイムを学びましょう。",
    "rust_lesson3_ex2_slide1_content": "# 名前のない「即席」function\n\nclosure は、名前をつけずにその場でcreatefunctionです。そして特別な能力があります：周りのvariableを使えるのです！\n\nFor example：\n```rust\nlet x = 5;  // 外側の変数\nlet add_x = |n| n + x;  // xを使えるクロージャ\nprintln!(\"{}\", add_x(10));  // 15\n```\n\n普通のfunctionとの違い：\n- 普通のfunction：argumentしか使えない\n- closure：argument + 周りのvariableも使える\n\n「その場の空気を読める」functionというイメージです！",
    "rust_lesson1_ex2_comment1": "x に 10 を入れる",
    "rust_lesson1_ex7_slide3_title": "Let's Try It!",
    "rust_lesson1_ex5_title": "「もし〜なら」で分けましょう",
    "rust_lesson3_ex2_slide3_title": "Let's Try It!",
    "rust_lesson3_ex7_slide2_content": "# 簡潔なerror処理\n\n```rust\n// ? を使わない場合\nmatch result {\n    Ok(v) => v,\n    Err(e) => return Err(e),\n}\n\n// ? を使う\nresult?\n```",
    "rust_lesson3_ex6_slide3_title": "Let's Try It!",
    "rust_lesson4_ex9_slide3_content": "イテレータをコレクションに変換しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex6_description": "elementを1つのvalueにまとめるfoldを学びましょう。",
    "rust_lesson2_ex9_description": "共通の振る舞いをdefine「トレイト」を学びましょう。",
    "rust_lesson2_ex8_comment1": "Ok で成功をreturn",
    "rust_lesson3_ex5_slide2_content": "# filter はreferenceのreferenceを受け取る\n\n`filter` のclosureは、referenceのreference（`&&T`）を受け取ります。そのため、valueをuseには `**x` と2回referenceを外す必要があります。\n\nなぜ？\n- `iter()` はreference（`&T`）をreturn\n- `filter` はそれをFurthermorereferenceで渡す（`&&T`）\n\nSyntax：\n```rust\n// **x で値を取り出す\n.filter(|x| **x > 2)\n\n// または * を引数につける\n.filter(|&x| *x > 2)\n```\n\n最初は混乱しますが、慣れれば大丈夫！",
    "rust_lesson1_ex5_comment1": "> でcompare",
    "rust_lesson2_ex4_description": "関連doデータをまとめる「構造体」を学びましょう。",
    "rust_lesson3_ex5_slide3_content": "条件に合う要素だけを取り出しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex7_slide3_content": "「ベクタ（Vec）」を使うと、たくさんのデータを一つの「長い はこ」にまとめて入れられます。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex5_slide2_title": "valueの取得",
    "rust_lesson3_ex1_slide1_title": "ライフタイム?",
    "rust_lesson1_ex3_comment1": "10 を 3 で割ったあまりをoutput",
    "rust_lesson3_ex1_comment1": "'a でライフタイムをdefinition",
    "rust_lesson3_ex10_slide1_title": "String vs &str",
    "rust_lesson2_title": "Rust II - 所有権とトレイト",
    "rust_lesson2_ex5_slide2_title": "methodのdefinition",
    "rust_lesson4_ex5_comment1": "insert でkeyとvalueを追加",
    "rust_lesson2_ex9_slide1_content": "# 「できること」の約束\n\nトレイト は、「このtypeはこういうことができる」という約束をdefine。\n\nFor example「鳴ける」という約束：\n- 犬は「ワン」と鳴く\n- 猫は「ニャー」と鳴く\n- 両方とも「鳴ける」能力がある\n\nトレイトは「鳴ける動物は、鳴き声を出すmethodを持つ」という約束です。\n\n他の言語とのcomparison：\n- Java: interface\n- TypeScript: interface\n\nに似た概念です。",
    "rust_lesson1_ex2_slide3_title": "Let's Try It!",
    "rust_lesson4_ex8_slide1_content": "# return valueのtypeをabstract化\n\nimpl Trait で、トレイトをimplementationdotypeを返せます。\n\n```rust\nfn make_iter() -> impl Iterator<Item = i32> {\n    vec![1, 2, 3].into_iter()\n}\n```",
    "rust_lesson1_ex2_slide2_content": "# 四則演算（しそくえんざん）\n\nRustでも算数と同じ記号で計算ができます。\n\n4つのBasic記号：\n- +（プラス）: たし算\n- -（マイナス）: ひき算\n- \\*（アスタリスク）: かけ算（×の代わり）\n- /（スラッシュ）: わり算（÷の代わり）\n\ncodeExample：\n```rust\nlet a = 10;\nlet b = 5;\nprintln!(\"{}\", a + b);  // 15 と表示される\n```\n\n`println!` の `{}` は「ここにvalueを入れてね」という目印です。",
    "rust_lesson4_ex9_slide2_content": "# 変換先を指定\n\n```rust\n// ターボフィッシュ構文\nlet v = (0..5).collect::<Vec<_>>();\n\n// 変数の型注釈\nlet v: Vec<i32> = (0..5).collect();\n```",
    "rust_lesson1_ex8_description": "「dictionary（HashMap）」をuseと、名前をつけてデータを保存し、その名前で取り出せます。",
    "rust_lesson4_ex9_slide2_title": "typeHint",
    "rust_lesson3_ex1_title": "ライフタイムのBasic",
    "rust_lesson2_ex5_description": "構造体にmethodをadd「impl」を学びましょう。",
    "rust_lesson4_ex8_comment1": "impl でトレイトをimplementationdotypeをreturn",
    "rust_lesson4_ex8_slide2_title": "argumentにも使える",
    "rust_lesson4_ex7_comment1": "if でマッチガードを追加",
    "rust_lesson2_ex9_slide2_title": "trait のdefinitionとimplementation",
    "rust_lesson4_ex10_slide2_title": "いつuse？",
    "rust_lesson3_ex7_slide2_title": "match の省略形",
    "rust_lesson1_ex6_title": "logicaloperator（&&、||）",
    "rust_lesson3_ex6_comment1": "fold で畳み込み",
    "rust_lesson2_ex6_description": "複数の状態を表す「列挙type（enum）」を学びましょう。",
    "rust_lesson4_ex10_slide1_title": "enumerate（イニュメレート）?",
    "rust_lesson1_ex7_slide1_title": "ベクタ（Vec）?",
    "rust_lesson2_ex6_slide3_content": "複数の状態を表す「列挙型（enum）」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex3_slide3_title": "Let's Try It!",
    "rust_lesson3_ex4_description": "各elementを変換domapを学びましょう。",
    "rust_lesson4_ex1_slide3_title": "Let's Try It!",
    "rust_lesson3_ex9_slide2_title": "mut が必要",
    "rust_lesson1_ex6_slide1_content": "# logicaloperator（ろんりえんざんし）\n\n2つ以上の条件を組み合わせたいときにuse記号です。\n\n2つの記号：\n- `&&`（アンドアンド）：「かつ」＝ 両方とも 正しいとき\n- `||`（オアオア）：「Alsoは」＝ どちらか 正しいとき\n\n身近なExample：\n- 遊園地：「18歳以上 かつ チケットあり」なら乗れる\n- おやつ：「宿題終わった Alsoは お手伝いした」ならOK\n\ncodeExample：\n```rust\nif score >= 70 && bonus > 0 {\n    // 70点以上 かつ ボーナスあり → 合格！\n    println!(\"合格！\");\n}\n```",
    "rust_lesson4_ex4_slide3_content": "参照カウントでデータを共有しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex6_slide3_title": "Let's Try It!",
    "rust_lesson2_ex5_slide3_content": "構造体にメソッドを追加する「impl」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex1_slide3_title": "Let's Try It!",
    "rust_lesson1_ex5_slide1_content": "# programに「判断」させよう\n\nconditional は、「もし〜なら、〇〇do」という判断をprogramにさせる仕組みです。\n\n身近なExample：\n- もし80点以上なら → 「合格！」とdisplay\n- もし雨なら → 傘を持っていく\n- もしHPが0なら → ゲームオーバー\n\nRustで Syntax：\n```rust\nif score > 80 {\n    println!(\"合格！\");\n}\n```\n\n読み方：\n- `if` →「もし」\n- `score > 80` →「スコアが80より大きいなら」\n- `{ }` の中 →「これをやる」",
    "rust_lesson4_ex5_title": "HashMap",
    "rust_lesson1_ex2_slide1_content": "# データを保存do「はこ」\n\nvariable（へんすう） は、数字や文字を入れておける「はこ」のことです。名前をつけて、あとでuseことができます。\n\nFor example：\n- 「りんごの数」というラベルの箱に「5」を入れる\n- あとで「りんごの数」と呼べば「5」が出てくる\n\nRustで Syntax：\n```rust\nlet x = 10;  // xという箱に10を入れる\nprintln!(\"{}\", x);  // xの中身（10）を表示\n```\n\n`let` は「この名前で箱をcreateよ」という意味です。",
    "rust_lesson2_ex4_slide3_content": "関連するデータをまとめる「構造体」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex6_slide1_title": "enum ?",
    "rust_lesson2_ex9_title": "トレイトをdefinitionしよう",
    "rust_lesson2_ex4_slide1_title": "構造体（こうぞうたい）?",
    "rust_lesson4_ex2_slide2_content": "# 覚えておくと便利な5つ\n\nよくusederiveトレイト：\n```rust\nDebug     // {:?} でデバッグ表示できる\nClone     // .clone() でコピーを作れる\nCopy      // 代入時に自動でコピー（小さい型向け）\nPartialEq // == で比較できる\nDefault   // 初期値を自動で作れる\n```\n\n複数指定もOK：\n```rust\n#[derive(Debug, Clone, PartialEq)]\nstruct User {\n    name: String,\n    age: u32,\n}\n```\n\n`Debug` は特によくuse。debug時に構造体の中身を見れて便利！",
    "rust_lesson2_ex1_slide1_content": "# データの「持ち主」を決めるルール\n\n所有権 は、Rust最大のFeatureです。「このデータの持ち主は誰か」をはっきりさせる仕組みです。\n\nルール：\n- データには必ず1人だけ「持ち主」がいる\n- 持ち主がいなくなると、データは自dynamicに片付けられる\n\nたとえるなら：\n- おもちゃは1人しか持てない\n- 持ち主が部屋を出たら、おもちゃは片付けられる\n\nこのルールのおかげで、Rustは「memoryリーク」（データが片付けられないバグ）を防げます！",
    "rust_lesson1_ex3_slide2_title": "Let's Try It!",
    "rust_lesson3_ex1_slide2_title": "なぜ必要？",
    "rust_lesson3_ex1_slide2_content": "# 危険なバグを防ぐ\n\nダングリングreference という危険なバグがあります。これは「もう存在しないデータ」を指し続けているreferenceのことです。\n\nExample：\n```rust\nfn longest<'a>(x: &'a str, y: &'a str) -> &'a str {\n    if x.len() > y.len() { x } else { y }\n}\n```\n\n`'a` の意味：\n- argument `x` と `y` は同じライフタイム `'a` を持つ\n- return valueも同じライフタイム `'a` を持つ\n- In other words「xとyが両方有効な間、return valueも有効」という約束\n\nRustはこれを自動でチェックしてくれます！",
    "rust_lesson4_ex6_slide2_title": "set演算",
    "rust_lesson3_ex7_comment1": "? でerrorを伝播",
    "rust_lesson3_ex2_slide2_content": "# | | でargumentを囲む\n\nclosureは `|引数| 処理` という形でwrite。`||` は「パイプ」と呼ばれます。\n\nいろいろなSyntax：\n```rust\n// 引数なし\n|| println!(\"Hello\")\n\n// 引数あり\n|x, y| x + y\n\n// 複数行のブロック\n|x| {\n    let y = x * 2;\n    y + 1\n}\n```\n\nPoint：\n- argumentを `| |` で囲む（functionの `()` の代わり）\n- typeは省略できることが多い（Rustが推測してくれる）",
    "rust_lesson2_ex7_comment1": "Some でvalueがあることを示す",
    "rust_lesson3_ex4_slide3_content": "各要素を変換するmapを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_title": "Rust (ラスト) に挑戦！",
    "rust_lesson2_ex8_description": "成功と失敗を表す「Result」を学びましょう。",
    "rust_lesson3_ex8_description": "Option/Resultのデフォルトvalueを設定しましょう。",
    "rust_lesson4_ex2_slide3_title": "Let's Try It!",
    "rust_lesson2_ex5_slide3_title": "Let's Try It!",
    "rust_lesson4_ex9_description": "iteratorをコレクションに変換しましょう。",
    "rust_lesson1_ex1_slide2_content": "# println! でscreenにdisplay\n\nRustで文字をscreenにdisplayには、`println!`（プリントラインびっくり）をuse。\n\nPoint：\n- `!` がつくのがRustのFeature（マクロと呼ばれます）\n- programは `fn main() { }` の中にwrite\n- `fn` は「function（function）」の略\n\ncodeExample：\n```rust\nfn main() {\n    println!(\"ヤッホー！\");\n}\n// 「ヤッホー！」と画面に表示される\n```\n\n`println!` の `!` は「マクロ」という特別な機能の印です。今は「おまじない」と思っておけばOK！",
    "rust_lesson3_ex6_slide1_title": "fold ?",
    "rust_lesson4_ex8_slide1_title": "impl Trait ?",
    "rust_lesson1_ex1_slide2_title": "Rustの「おまじない」",
    "rust_lesson3_ex10_description": "stringtypeの違いを理解しましょう。",
    "rust_lesson3_ex7_slide3_content": "エラーを簡潔に伝播させましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex1_comment1": "s1 の所有権を移動",
    "rust_lesson2_ex9_slide1_title": "トレイト?",
    "rust_lesson4_ex6_slide2_content": "# 和set、積setなど\n\n```rust\nset1.union(&set2)\nset1.intersection(&set2)\nset1.difference(&set2)\n```",
    "rust_lesson4_ex5_slide3_content": "キーと値のペアを格納しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex8_slide1_title": "Result（リザルト）?",
    "rust_lesson4_ex1_slide1_content": "# 「できること」の約束\n\nトレイト は、typeが持つべきmethodをdefine仕組みです。\n\nFor example：\n- 「あいさつできる」トレイト → greet() methodを持つ\n- 「displayできる」トレイト → display() methodを持つ\n\ncodeExample：\n```rust\ntrait Greet {\n    fn greet(&self) -> String;  // メソッドの「約束」\n}\n```\n\nこれは「Greetできるtypeは、greet()methodを持つ」という約束です。",
    "rust_lesson4_ex2_slide3_content": "トレイトを自動実装するderiveを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex6_title": "fold で畳み込み",
    "rust_lesson3_ex9_slide3_content": "Vecに要素を追加しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex4_slide1_content": "# 関係あるデータをまとめる「設計図」\n\n構造体（struct） は、いくつかのデータをひとまとめにdo仕組みです。\n\nFor example「点（座標）」のデータ：\n- x座標\n- y座標\n\nこの2つは関係があるので、「Point（点）」としてまとめると便利です。\n\nFor example「人」のデータ：\n- 名前\n- 年齢\n\nこれも「Person（人）」としてまとめられます。\n\n構造体は「こういうデータを持つ」という設計図です。",
    "rust_lesson4_ex1_slide1_title": "トレイト?（復習）",
    "rust_lesson2_ex3_description": "reference先のvalueを変更できる「可変reference」を学びましょう。",
    "rust_lesson2_ex7_slide2_content": "# match で安全に取り出す\n\n`match` を使って「ある場合」と「ない場合」で処理を分けます。\n\ncodeExample：\n```rust\nlet x: Option<i32> = Some(5);  // 値あり\n\nmatch x {\n    Some(n) => println!(\"値は{}です\", n),  // 5\n    None => println!(\"値がありません\"),\n}\n```\n\nなぜ安全？\n- `null` のように「あるつもりでアクセスしたら無かった」errorが起きない\n- 「ない場合」の処理を書かないとコンパイルerrorになる\n- 強制的に両方のケースを考えることになる！",
    "rust_lesson4_ex9_comment1": "collect で Vec に変換",
    "rust_lesson3_ex10_title": "String と &str",
    "rust_lesson2_ex7_slide1_title": "Option（オプション）?",
    "rust_lesson3_ex9_description": "Vecにelementを追加しましょう。",
    "rust_lesson2_ex5_comment1": "impl でmethodをimplementation",
    "rust_lesson3_ex1_slide3_content": "参照の有効期間を表すライフタイムを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex6_slide2_content": "複数の条件を組み合わせる「&&（かつ）」と「||（または）」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex5_comment1": "filter で条件に合うelementを絞り込む",
    "rust_lesson2_ex7_slide3_content": "値があるかないかを表す「Option」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex10_slide3_title": "Let's Try It!",
    "rust_lesson4_ex4_slide3_title": "Let's Try It!",
    "rust_lesson3_ex3_comment1": "iter でiteratorを取得",
    "rust_lesson3_ex6_slide3_content": "要素を1つの値にまとめるfoldを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex7_slide2_title": "ベクタの番号は「0」から！",
    "rust_lesson1_ex5_slide1_title": "conditional（じょうけんぶんき）?",
    "rust_lesson1_ex3_description": "割り算の「あまり」を求める「%」（パーセント）operatorを学びましょう。",
    "rust_lesson1_ex1_slide3_content": "Rustを使って画面に文字を表示してみましょう。println! という特別な関数を使います。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex10_slide2_content": "# <T> でtypeを「あとで決める」\n\nfunction名の後に `<T>` をつけて、`T` を「type」としてuse。\n\ncodeExample：\n```rust\n// Tはどんな型でもOK\nfn first<T>(arr: &[T]) -> &T {\n    &arr[0]  // 最初の要素を返す\n}\n\n// 使い方\nfirst(&[1, 2, 3]);         // Tはi32\nfirst(&[\"a\", \"b\", \"c\"]);   // Tは&str\n```\n\n読み方：\n- `<T>` → 「Tという名前のtypeをuseよ」\n- `T` は慣習で「Type（type）」の頭文字\n- 複数のtypeが必要なら `<T, U>` のようにwrite",
    "rust_lesson3_ex2_comment1": "|x| でclosureのargumentをdefinition",
    "rust_lesson3_ex3_description": "elementを順番に処理doiteratorを学びましょう。",
    "rust_lesson1_ex1_slide3_title": "Let's Try It!",
    "rust_lesson2_ex6_slide2_title": "enum のdefinition",
    "rust_lesson2_ex1_title": "所有権のBasic",
    "rust_lesson4_ex3_slide1_title": "Box（ボックス）?",
    "rust_lesson2_ex1_slide3_content": "Rust独自の概念「所有権」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex8_slide3_content": "Option/Resultのデフォルト値を設定しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex7_slide2_title": "使用Example",
    "rust_lesson4_ex10_description": "iteratorにindexを付けましょう。",
    "rust_lesson4_ex9_slide1_title": "collect ?",
    "rust_lesson4_ex10_slide2_content": "# 「何番目か」が必要なとき\n\n番号（index）とelementの両方が必要なときに便利です。\n\ncodeExample：\n```rust\nlet v = vec![10, 20, 30];\nfor (idx, val) in v.iter().enumerate() {\n    println!(\"{}番目の値は{}\", idx, val);\n}\n// 0番目の値は10\n// 1番目の値は20\n// 2番目の値は30\n```\n\nPoint：\n- `(i, x)` でtuple（2つのset）を受け取る\n- `i` にindex、`x` にelementが入る\n- indexは0から始まる",
    "rust_lesson3_ex2_description": "周囲のvariableを使えるanonymous function「closure」を学びましょう。",
    "rust_lesson1_ex4_comment1": "mut で変更可能にdo",
    "rust_lesson1_ex8_slide3_title": "Let's Try It!",
    "rust_lesson1_ex3_slide2_content": "割り算の「あまり」を求める「%」（パーセント）演算子を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex9_slide3_title": "Let's Try It!",
    "rust_lesson3_ex3_title": "iteratorのBasic",
    "rust_lesson3_ex9_title": "Vec のmethod push",
    "rust_lesson1_ex8_comment1": "dictionaryをcreate（keyは'みかん'、valueは'オレンジ'）",
    "rust_lesson1_ex2_comment3": "+ でたし算do",
    "rust_lesson4_ex8_slide2_content": "# ジェネリクスの代わり\n\n```rust\nfn print_all(iter: impl Iterator<Item = i32>) {\n    for x in iter {\n        println!(\"{}\", x);\n    }\n}\n```",
    "rust_lesson2_ex2_slide2_title": "reference Usage",
    "rust_lesson1_ex8_slide3_content": "「辞書（HashMap）」を使うと、名前をつけてデータを保存し、その名前で取り出せます。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex7_slide2_content": "# [ ]で番号を指定して取り出す\n\n`[番号]` で何番目のデータか指定して取り出せます。\n\nImportantなルール：番号は「0」から！\n- 1番目 → `[0]`\n- 2番目 → `[1]`\n- 3番目 → `[2]`\n\ncodeExample：\n```rust\nlet fruits = vec![\"りんご\", \"バナナ\", \"みかん\"];\n//                  ↑0番    ↑1番     ↑2番\nprintln!(\"{}\", fruits[0]);  // りんご\nprintln!(\"{}\", fruits[1]);  // バナナ\n```\n\nプログラミングでは「0から数える」のが世界共通のルールです！",
    "rust_lesson1_ex6_slide1_title": "条件を組み合わせる",
    "rust_lesson2_ex10_slide2_title": "ジェネリックfunction Syntax",
    "rust_lesson1_ex6_description": "複数の条件を組み合わせる「&&（かつ）」と「||（Alsoは）」を学びましょう。",
    "rust_lesson4_ex6_title": "HashSet",
    "rust_lesson2_ex3_slide2_content": "# mut が2か所に必要\n\n変更できるようにdoには、variableとreferenceの両方に `mut` が必要です。\n\ncodeExample：\n```rust\n// 1. 変数を mut で作る\nlet mut s = String::from(\"hello\");\n\n// 2. &mut で可変参照を渡す\nchange(&mut s);\n\nfn change(s: &mut String) {\n    s.push_str(\" world\");  // 変更できる！\n}\n```\n\nPoint：\n- `let mut 変数` でvariableを変更可能に\n- `&mut 変数` で可変referenceをcreate\n- 両方ないと変更できない！",
    "rust_lesson2_ex2_slide1_title": "reference（さんしょう）?",
    "rust_lesson3_ex6_slide2_content": "# 合計、積、結合など\n\n```rust\n// 積\nv.iter().fold(1, |acc, x| acc * x)\n\n// 文字列結合\nwords.iter().fold(String::new(), |acc, s| acc + s)\n```",
    "rust_lesson1_ex1_description": "Rustを使ってscreenに文字をdisplayしてみましょう。println! という特別なfunctionをuse。",
    "rust_lesson3_ex8_slide3_title": "Let's Try It!",
    "rust_lesson4_ex6_description": "一意なvalueのsetを管理しましょう。",
    "rust_lesson2_ex5_slide1_title": "impl ?",
    "rust_lesson1_ex8_title": "名前で引き出す「dictionary」",
    "rust_lesson2_ex7_description": "valueがあるかないかを表す「Option」を学びましょう。",
    "rust_lesson1_ex4_slide2_title": "Let's Try It!",
    "rust_lesson1_ex7_title": "たくさんのデータをまとめましょう「ベクタ」",
    "rust_lesson3_ex7_slide1_content": "# errorの早期リターン\n\n? は、Resultが Err の場合に早期リターンします。\n\n```rust\nfn read_file() -> Result<String, io::Error> {\n    let content = fs::read_to_string(\"file.txt\")?;\n    Ok(content)\n}\n```",
    "rust_lesson3_ex9_slide1_content": "# 末尾に追加\n\npush は、Vecの末尾にelementをadd。\n\n```rust\nlet mut v = vec![1, 2];\nv.push(3);\n// [1, 2, 3]\n```",
    "rust_lesson4_ex8_slide3_content": "トレイトを返す関数を簡潔に書きましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex1_title": "screenにメッセージを出しましょう",
    "rust_lesson2_ex8_slide2_title": "Result  Usage",
    "rust_lesson3_ex2_slide1_title": "closure?",
    "rust_lesson3_ex8_title": "unwrap_or でデフォルトvalue",
    "rust_lesson4_ex10_slide1_content": "# 番号とelementを一緒にもらう\n\nenumerate は、「何番目か」と「そのelement」をsetで取り出せるmethodです。\n\nFor example：\n- 0番目: りんご\n- 1番目: バナナ\n- 2番目: みかん\n\ncodeExample：\n```rust\nfor (i, x) in vec![\"a\", \"b\", \"c\"].iter().enumerate() {\n    println!(\"{}: {}\", i, x);\n}\n// 0: a\n// 1: b\n// 2: c\n```",
    "rust_lesson1_ex7_slide1_content": "# データを並べてまとめる「長い箱」\n\nベクタ（Vec） は、たくさんのデータを順番に並べて入れられる「長い箱」です。\n\nFor example：\n- 買い物listの商品を全部まとめる\n- testの点数を全部まとめる\n- 友だちの名前を全部まとめる\n\n100個でも1000個でも、1つのvariableでまとめて管理できます！\n\n作り方：\n```rust\nlet fruits = vec![\"りんご\", \"バナナ\", \"みかん\"];\n// vec! で ベクタを作る\n```",
    "rust_lesson4_ex8_slide3_title": "Let's Try It!",
    "rust_lesson4_ex7_description": "パターンマッチに条件を追加しましょう。",
    "rust_lesson1_ex4_comment2": "+= で 20 を足す",
    "rust_lesson1_ex2_comment2": "y に 5 を入れる",
    "rust_lesson2_ex3_slide3_title": "Let's Try It!",
    "rust_lesson3_ex4_slide1_title": "map（map）?",
    "rust_lesson1_ex2_slide3_content": "データに名前をつけて保存できる「変数（へんすう）」を使ってみましょう。letで変数を作ります。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex8_slide2_content": "# match で成功と失敗を分ける\n\n`match` で「成功したら」「失敗したら」の処理を書き分けます。\n\ncodeExample：\n```rust\nfn divide(a: i32, b: i32) -> Result<i32, String> {\n    if b == 0 {\n        return Err(\"0で割れません\".to_string());\n    }\n    Ok(a / b)  // 成功なら答えを返す\n}\n\nmatch divide(10, 2) {\n    Ok(v) => println!(\"答えは{}\", v),\n    Err(e) => println!(\"エラー: {}\", e),\n}\n```\n\nPoint：\n- `Ok(値)` で成功をreturn\n- `Err(エラー)` で失敗をreturn",
    "rust_lesson4_ex3_comment1": "Box::new でheapに格納",
    "rust_lesson4_ex8_description": "トレイトをreturnfunctionを簡潔に書きましょう。",
    "rust_lesson2_ex10_description": "typeを後から決められる「ジェネリクス」を学びましょう。",
    "rust_lesson2_ex3_slide1_title": "可変reference（かへんさんしょう）?",
    "rust_lesson2_ex2_description": "所有権を移さずにvalueを借りる「reference」を学びましょう。",
    "rust_lesson3_ex5_slide2_title": "** にNote！",
    "rust_lesson2_ex2_slide3_title": "Let's Try It!",
    "rust_lesson4_ex3_slide3_content": "ヒープにデータを格納するBoxを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex4_title": "累算assignmentoperator（+=、-=）",
    "rust_lesson3_ex3_slide2_content": "# 借りるか、もらうか\n\n3種類の iter があり、所有権の扱いが違います。\n\n3つの違い：\n```rust\nv.iter()       // 参照で借りる（&T）\nv.iter_mut()   // 変更可能で借りる（&mut T）\nv.into_iter()  // 所有権をもらう（T）\n```\n\n使い分け：\n- `iter()` → 見るだけ（元のベクタも使える）\n- `iter_mut()` → 中身を変更したい\n- `into_iter()` → ベクタごともらう（元は使えない）\n\n普通は `iter()` をuseことが多いです。",
    "rust_lesson2_ex1_slide1_title": "所有権（しょゆうけん）?",
    "rust_lesson4_ex6_slide3_content": "一意な値の集合を管理しましょう。\n\n（When you're ready, select \"Start Lesson\".）"
  },
  "zh-Hans": {
    "rust_lesson1_course_title": "Introduction to Rust",
    "rust_lesson1_course_description": "Learn the basics of Rust programming.",
    "rust_lesson2_course_title": "Rust II - Intermediate",
    "rust_lesson2_course_description": "Learn intermediate Rust concepts.",
    "rust_lesson3_course_title": "Rust III - Advanced",
    "rust_lesson3_course_description": "Master advanced Rust techniques.",
    "rust_lesson4_course_title": "Rust IV - Expert Level",
    "rust_lesson4_course_description": "Expert-level Rust programming.",
    "rust_lesson1_ex5_slide2_content": "条件によって動きを変える if文を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex9_title": "collect で変換",
    "rust_lesson2_ex7_slide1_content": "# 「あるかもしれない、ないかもしれない」\n\nOption<T> は、valueが「あるかもしれないし、ないかもしれない」ことを表すtypeです。\n\nFor example：\n- dictionaryで単語を探す → 見つかるかもしれないし、ないかもしれない\n- ゲームでアイテムを拾う → 落ちてるかもしれないし、ないかもしれない\n\n2つの状態：\n- `Some(値)` → valueがある！\n- `None` → valueがない...\n\n他の言語では `null` をuseが、Rustでは `Option` で安全に扱います。",
    "rust_lesson1_ex2_slide1_title": "variable（へんすう）?",
    "rust_lesson1_ex7_description": "「ベクタ（Vec）」をuseと、たくさんのデータを一つの「長い はこ」にまとめて入れられます。",
    "rust_lesson2_ex9_slide2_content": "# 約束を作って、守る\n\n1. `trait` で「約束」をdefinition\n2. `impl トレイト for 型` で「約束を守る」implementationをdo\n\ncodeExample：\n```rust\n// 1. トレイト（約束）を定義\ntrait Speak {\n    fn speak(&self);  // 鳴くメソッドを持つ約束\n}\n\n// 2. Dog構造体がトレイトを実装\nstruct Dog;\nimpl Speak for Dog {\n    fn speak(&self) {\n        println!(\"woof\");\n    }\n}\n```\n\n「DogはSpeakができる」ということになります。",
    "rust_lesson4_ex4_description": "referenceカウントでデータを共有しましょう。",
    "rust_lesson4_ex5_slide1_content": "# 名前で引ける「dictionary」\n\nHashMap は、「key（名前）」と「value（データ）」をsetで保存dodictionaryです。\n\nFor example：\n- 「青チーム」→ 10点\n- 「赤チーム」→ 15点\n\ncodeExample：\n```rust\nuse std::collections::HashMap;\n\nlet mut scores = HashMap::new();\nscores.insert(\"Blue\", 10);   // 追加\nscores.insert(\"Red\", 15);    // 追加\n```\n\n`use` で機能を読み込んでからuse。",
    "rust_lesson3_ex4_title": "map でiterator変換",
    "rust_lesson4_ex1_slide3_content": "共通の振る舞いを定義するトレイトを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex4_description": "variableのvalueを手軽に増やしたり減らしたりdo「+=」「-=」を学びましょう。",
    "rust_lesson1_ex2_description": "データに名前をつけて保存できる「variable（へんすう）」を使ってみましょう。letでvariableをcreate。",
    "rust_lesson4_ex4_slide2_title": "referenceカウントの仕組み",
    "rust_lesson3_ex8_slide2_title": "unwrap_or_else",
    "rust_lesson4_ex10_comment1": "1番目の i にindex、2番目の item にelementが入る",
    "rust_lesson3_ex6_slide1_content": "# 累積処理\n\nfold は、初期valueとfunctionでelementを1つずつ畳み込みます。\n\n```rust\nlet v = vec![1, 2, 3];\nlet sum = v.iter().fold(0, |acc, x| acc + x);\n// 6\n```",
    "rust_lesson4_ex2_slide2_title": "よくuse derive トレイト",
    "rust_lesson3_ex10_slide3_content": "文字列型の違いを理解しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex4_slide2_content": "変数の値を手軽に増やしたり減らしたりする「+=」「-=」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex4_slide3_title": "Let's Try It!",
    "rust_lesson3_ex5_slide1_title": "filter（filterー）?",
    "rust_lesson4_ex5_description": "keyとvalueのpairを格納しましょう。",
    "rust_lesson3_ex5_description": "条件に合うelementだけを取り出しましょう。",
    "rust_lesson2_ex2_slide2_content": "# functionに借りてもらう\n\nfunctionにデータを渡すとき、`&` をつけると「借りる」形になります。元のvariableはそのまま使い続けられます。\n\ncodeExample：\n```rust\nfn calc_len(s: &String) -> usize {\n    s.len()  // 長さを返す\n}\n\nfn main() {\n    let text = String::from(\"hello\");\n    let len = calc_len(&text);  // textを貸す\n    // text はまだ使える！\n    println!(\"{}の長さは{}\", text, len);\n}\n```\n\n`&String` は「Stringを借りる」という意味です。",
    "rust_lesson4_ex7_slide3_content": "パターンマッチに条件を追加しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex8_slide2_content": "# 遅延評価\n\n```rust\n// クロージャで計算\nlet value = x.unwrap_or_else(|| expensive_computation());\n```",
    "rust_lesson4_ex7_title": "match ガード",
    "rust_lesson3_ex7_title": "? operatorでerror伝播",
    "rust_lesson4_ex1_description": "共通の振る舞いをdefineトレイトを学びましょう。",
    "rust_lesson2_ex1_slide2_content": "# 所有権は「移動」do\n\nvariableを別のvariableにassignmentdoと、所有権が 移動（ムーブ） します。元のvariableは使えなくなります。\n\ncodeExample：\n```rust\nlet s1 = String::from(\"hello\");  // s1 が持ち主\nlet s2 = s1;  // 所有権が s2 に移動！\n// ↓ s1 はもう使えない（エラーになる）\n// println!(\"{}\", s1);  // ダメ！\nprintln!(\"{}\", s2);  // OK！\n```\n\nイメージ：\nおもちゃを友だちにあげたら、自分はもう使えない。これがムーブです。",
    "rust_lesson1_ex8_slide1_title": "dictionary（HashMap）?",
    "rust_lesson4_ex3_slide2_content": "# サイズが決まらないとき\n\nBoxは、コンパイル時にサイズがわからないtypeにuse。\n\nFor examplerecursion的なtype：\n```rust\n// リストは「値 + 次のリスト」の繰り返し\nenum List {\n    Cons(i32, Box<List>),  // Boxで次を指す\n    Nil,                   // 終わり\n}\n```\n\nなぜBoxが必要？\n- `List` の中に `List` がある → 無限に大きくなる？\n- `Box` をuseと、サイズが固定（pointerのサイズ）になる\n\n「中身」ではなく「中身への矢印」を持つイメージです。",
    "rust_lesson2_ex10_title": "ジェネリクスを使おう",
    "rust_lesson2_ex8_slide3_title": "Let's Try It!",
    "rust_lesson3_ex9_slide2_content": "# 可変reference\n\n```rust\n// mut が必要\nlet mut v = Vec::new();\nv.push(1);\nv.push(2);\n```",
    "rust_lesson4_ex4_title": "Rc<T>",
    "rust_lesson2_ex3_comment1": "mut で可変variableにdo",
    "rust_lesson4_ex5_slide3_title": "Let's Try It!",
    "rust_lesson2_ex6_slide2_content": "# バリアントを列挙\n\n`enum 名前 { バリアント1, バリアント2, ... }` でdefine。\n\ncodeExample：\n```rust\nenum Color {\n    Red,\n    Green,\n    Blue,\n}\nlet c = Color::Red;\n```",
    "rust_lesson1_ex1_comment1": "Hello, Rust! とdisplay",
    "rust_lesson1_ex1_slide1_content": "# 安全で速い！最新のプログラミング言語\n\nRust（ラスト）は、「間違いを事前に防ぐ」ことがとても得意なプログラミング言語です。\n\nRustのすごいところ：\n- programのミスをexecute前に見つけてくれる\n- とても速く動く\n- 世界中のプログラマーが「一番好き！」と選ぶ人気の言語\n\nたとえるなら：\n厳しいけど優しい先生のような言語です。「ここ間違ってるよ」と教えてくれるので、安心してprogramが書けます！",
    "rust_lesson3_ex8_slide1_content": "# None/Err の場合のデフォルト\n\nunwrap_or は、None や Err の場合にデフォルトvalueをreturn。\n\n```rust\nlet x: Option<i32> = None;\nlet value = x.unwrap_or(0);  // 0\n```",
    "rust_lesson2_ex7_slide3_title": "Let's Try It!",
    "rust_lesson2_ex6_title": "enum で状態を表す",
    "rust_lesson2_ex8_slide1_content": "# 「成功」か「失敗」かを表す\n\nResult<T, E> は、処理が「成功したか失敗したか」を表すtypeです。\n\nFor example：\n- fileをopen → 成功（内容）か失敗（error）\n- 0で割り算 → 成功（答え）か失敗（0で割れない！）\n\n2つの状態：\n- `Ok(値)` → 成功！valueが入っている\n- `Err(エラー)` → 失敗...error情報が入っている\n\n`Option` は「あるか・ないか」、`Result` は「成功か・失敗か」という違いです。",
    "rust_lesson2_ex8_slide3_content": "成功と失敗を表す「Result」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex6_slide1_title": "HashSet ?",
    "rust_lesson3_ex9_comment1": "push でelementを追加",
    "rust_lesson2_ex7_slide2_title": "Option  Usage",
    "rust_lesson3_ex2_title": "closureのBasic",
    "rust_lesson3_ex7_slide1_title": "? operator?",
    "rust_lesson4_ex6_comment1": "HashSet をimport",
    "rust_lesson2_ex10_slide1_content": "# どんなtypeでも使える「万能」の仕組み\n\nジェネリクス は、typeを後から決められる仕組みです。\n\nなぜ便利？\n同じようなfunctionを何度も書かなくてすみます。\n\nFor example：\n- 数字のarrayの最初のelementを取るfunction\n- stringのarrayの最初のelementを取るfunction\n\n両方とも「最初のelementを取る」のは同じなのに、typeが違うだけで別のfunctionをwriteのは大変！\n\nジェネリクスなら、`<T>` で「typeは後で決める」とwriteだけで、どんなtypeでも使えるfunctionが作れます。",
    "rust_lesson1_ex3_slide1_content": "# 剰余operator（じょうよえんざんし）「%」\n\n`%`（パーセント）は、割り算の 「あまり」 をcalculate特別な記号です。\n\nわかりやすいExample：\n- 10このアメを3人で分けると？\n- 1人3こずつで、1こあまる\n- これを `10 % 3` とwriteと、答えは `1`\n\ncodeExample：\n```rust\nprintln!(\"{}\", 10 % 3);  // 1（あまり1）\nprintln!(\"{}\", 8 % 4);   // 0（あまりなし＝割り切れる）\n```\n\n使いどころ：\n- 偶数か奇数か調べる（`n % 2` が0なら偶数）\n- 時計の計算（24を超えたら0に戻る、など）",
    "rust_lesson3_ex7_description": "errorを簡潔に伝播させましょう。",
    "rust_lesson3_ex8_comment1": "unwrap_or でデフォルトvalueを設定",
    "rust_lesson2_ex8_title": "Result<T, E> でerror処理",
    "rust_lesson2_ex10_comment1": "T をtypeパラメータとしてuse",
    "rust_lesson2_ex6_comment1": "enum で列挙typeをdefinition",
    "rust_lesson3_ex3_slide3_content": "要素を順番に処理するイテレータを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex2_comment1": "derive でトレイトを自動implementation",
    "rust_lesson1_ex8_slide1_content": "# 名前でsearchできる「dictionary」\n\nHashMap（ハッシュmap）は、「名前」と「データ」をsetにして保存できる仕組みです。本物のdictionaryのように使えます。\n\nFor example果物の色dictionary：\n- 「りんご」→「あか」\n- 「バナナ」→「きいろ」\n- 「みかん」→「オレンジ」\n\nuse準備：\n```rust\nuse std::collections::HashMap;  // 機能を読み込む\nlet mut fruits = HashMap::new();  // 空の辞書を作る\nfruits.insert(\"りんご\", \"あか\");  // データを追加\n```\n\n`use` は「この機能をuseよ」というdeclarationです。",
    "rust_lesson3_ex9_slide1_title": "push ?",
    "rust_lesson4_ex1_title": "トレイトのdefinition",
    "rust_lesson4_ex3_description": "heapにデータを格納doBoxを学びましょう。",
    "rust_lesson1_ex2_title": "便利な「はこ」variable（へんすう）",
    "rust_lesson1_ex8_comment2": "中身を出す",
    "rust_lesson3_ex9_slide3_title": "Let's Try It!",
    "rust_lesson1_ex4_comment3": "-= で 50 を引く",
    "rust_lesson1_ex6_comment1": "&& で両方の条件をチェック",
    "rust_lesson4_ex1_slide2_title": "トレイトのimplementation",
    "rust_lesson4_ex7_slide3_title": "Let's Try It!",
    "rust_lesson4_title": "Rust IV - トレイトとスマートpointer",
    "rust_lesson4_ex1_comment1": "trait でトレイトをdefinition",
    "rust_lesson4_ex4_slide1_content": "# 複数の「持ち主」を許可do仕組み\n\nRc<T> は「Reference Counted（referenceカウント）」の略で、複数の所有者でデータを共有できます。\n\n普通の所有権：\n1人だけが持ち主。渡したら元の人は使えない。\n\nRc をuseと：\n複数人が同じデータの「持ち主」になれる！\n\ncodeExample：\n```rust\nuse std::rc::Rc;\n\nlet a = Rc::new(5);       // Rcでラップ\nlet b = Rc::clone(&a);    // bも持ち主になる\n// a も b も使える！\n```",
    "rust_lesson3_ex5_slide1_content": "# 条件に合うものだけ残す\n\nfilter は、条件を満たすelementだけを残し、他を捨てます。\n\nFor example：\n- 80点以上の人だけ残す\n- 偶数だけ残す\n- 「あ」から始まる名前だけ残す\n\ncodeExample：\n```rust\nlet v = vec![1, 2, 3, 4, 5];\nlet evens: Vec<_> = v.iter()\n    .filter(|x| **x % 2 == 0)  // 偶数だけ\n    .collect();\n// [2, 4]\n```\n\n条件が `true` のelementだけが残ります。",
    "rust_lesson3_ex7_slide3_title": "Let's Try It!",
    "rust_lesson1_ex7_comment2": "2番目のデータ（1番）を出す",
    "rust_lesson4_ex8_title": "impl Trait",
    "rust_lesson1_ex5_description": "条件によって動きを変える if文を学びましょう。",
    "rust_lesson3_ex4_slide2_title": "遅延評価（ちえんひょうか）",
    "rust_lesson3_ex1_slide1_content": "# referenceの「寿命」を示す印\n\nライフタイム は、referenceがいつまで使えるかを示す印です。`'a`（アポストロフィ・エー）のようにwrite。\n\nなぜ必要？\nreferenceは「借りている」状態。借りた元のデータが消えたら、referenceも使えなくなります。\n\nFor example：\n- 図書館で借りた本 → 図書館が閉まったら読めない\n- referenceで借りたデータ → 元のデータが消えたら使えない\n\nライフタイムは「このreferenceはこの範囲で有効だよ」とコンパイラに伝える仕組みです。",
    "rust_lesson1_ex1_slide1_title": "Rust（ラスト）?",
    "rust_lesson1_ex2_slide2_title": "計算の記号（operator）",
    "rust_lesson4_ex5_slide2_content": "# get で安全に取り出す\n\n`get()` methodでvalueを取り出せます。見つからない可能性があるので、`Option` が返ってきます。\n\ncodeExample：\n```rust\n// getはOption<&V>を返す\nif let Some(score) = scores.get(\"Blue\") {\n    println!(\"青チームは{}点\", score);\n}\n```\n\nPoint：\n- keyがあれば `Some(値)` が返る\n- keyがなければ `None` が返る\n- `if let` で安全に取り出せる\n\n存在しないkeyでアクセスしてもprogramが落ちない！",
    "rust_lesson4_ex7_slide1_title": "match ガード?",
    "rust_lesson3_title": "Rust III - ライフタイムとiterator",
    "rust_lesson4_ex3_title": "Box<T>",
    "rust_lesson1_ex4_slide1_title": "累算assignmentoperator（るいさんだいにゅう）?",
    "rust_lesson2_ex9_comment1": "trait でトレイトをdefinition",
    "rust_lesson2_ex1_description": "Rust独自の概念「所有権」を学びましょう。",
    "rust_lesson2_ex3_slide3_content": "参照先の値を変更できる「可変参照」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex1_slide3_title": "Let's Try It!",
    "rust_lesson3_ex6_slide2_title": "様々な畳み込み",
    "rust_lesson4_ex9_slide3_title": "Let's Try It!",
    "rust_lesson2_ex5_title": "impl でmethodを追加",
    "rust_lesson2_ex6_slide1_content": "# 複数の選択肢\n\nenum は、valueがいくつかの種類のうちの一つであることを表します。各バリアントにデータを持たせることもできます。",
    "rust_lesson2_ex4_comment1": "struct で構造体をdefinition",
    "rust_lesson1_ex3_title": "剰余operator（%）",
    "rust_lesson1_ex7_comment1": "colors というベクタをcreate（'あか', 'あお'の順）",
    "rust_lesson1_ex4_slide1_content": "# valueをかんたんに増やす・減らす\n\n`+=`（プラスイコール）と `-=`（マイナスイコール）は、variableの中身を増やしたり減らしたりdo便利な記号です。\n\nRustのImportantなルール：`mut`が必要！\nRustでは、variableをchangeには `let mut`（レット ミュート）とwrite必要があります。`mut` は「mutable（変更できる）」の略です。\n\ncodeExample：\n```rust\nlet mut score = 100;  // mut をつけて変更可能に\nscore += 10;          // 10を足す → 110に\nscore -= 50;          // 50を引く → 60に\n```\n\n`mut` がないと「このvariableは変えちゃダメ！」とRustが怒ります。",
    "rust_lesson2_ex1_slide2_title": "ムーブ（移動）",
    "rust_lesson3_ex4_comment1": "map で各elementを変換",
    "rust_lesson3_ex8_slide1_title": "unwrap_or ?",
    "rust_lesson2_ex5_slide1_content": "# implementationブロック\n\nimpl ブロックで、構造体にmethodを追加できます。`self` で自分自身をreferenceします。",
    "rust_lesson2_ex10_slide1_title": "ジェネリクス?",
    "rust_lesson1_ex8_slide2_content": "# 名前（key）で取り出す\n\ndictionaryに入れたデータは、名前（key）を指定して取り出せます。\n\ncodeExample：\n```rust\nuse std::collections::HashMap;\nfn main() {\n    let mut fruits = HashMap::new();\n    fruits.insert(\"りんご\", \"あか\");  // 追加\n    fruits.insert(\"バナナ\", \"きいろ\");  // 追加\n    \n    println!(\"{}\", fruits[\"りんご\"]);  // あか と表示\n}\n```\n\nPoint：\n- `insert(名前, データ)` で追加\n- `辞書[名前]` で取り出し\n- 番号ではなく「名前」で探せるのが便利！",
    "rust_lesson4_ex9_slide1_content": "# iteratorをコレクションに\n\ncollect は、iteratorをVecやHashMapなどに変換します。\n\n```rust\nlet v: Vec<_> = (0..5).collect();\nlet s: String = vec!['a', 'b'].into_iter().collect();\n```",
    "rust_lesson2_ex2_slide3_content": "所有権を移さずに値を借りる「参照」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex2_slide3_content": "周囲の変数を使える無名関数「クロージャ」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex4_slide2_content": "# struct keyワードでdefinition\n\n`struct 名前 { フィールド }` で構造体をdefine。フィールドには名前とtypeをwrite。\n\ncodeExample：\n```rust\n// Point 構造体を定義\nstruct Point {\n    x: i32,  // xフィールド（整数）\n    y: i32,  // yフィールド（整数）\n}\n\n// 使い方\nlet p = Point { x: 10, y: 20 };\nprintln!(\"x={}, y={}\", p.x, p.y);\n```\n\nPoint：\n- `struct 名前` で構造体をcreate\n- `{ フィールド名: 型 }` でどんなデータを持つか決める\n- `.フィールド名` でアクセス",
    "rust_lesson2_ex10_slide3_content": "型を後から決められる「ジェネリクス」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex6_slide3_title": "Let's Try It!",
    "rust_lesson4_ex6_slide1_content": "# 一意なvalueのset\n\nHashSet は、重複のないvalueのsetです。\n\n```rust\nuse std::collections::HashSet;\n\nlet mut set = HashSet::new();\nset.insert(1);\nset.insert(2);\nset.insert(1); // 重複は無視\n```",
    "rust_lesson4_ex2_title": "derive 属性",
    "rust_lesson4_ex2_slide1_content": "# トレイトを「自動で」implementation\n\n#[derive(...)] をuseと、よくuseトレイトを自分で書かなくても自動でimplementationしてくれます。\n\nFor example：\n構造体を `println!` でdisplayしたいとき、普通は Display トレイトをimplementationdo必要がありますが、`#[derive(Debug)]` をwriteだけでOK！\n\ncodeExample：\n```rust\n#[derive(Debug)]  // Debug トレイトを自動実装\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nlet p = Point { x: 1, y: 2 };\nprintln!(\"{:?}\", p);  // Point { x: 1, y: 2 }\n```",
    "rust_lesson1_ex6_slide2_title": "Let's Try It!",
    "rust_lesson3_ex3_slide2_title": "3つの iter method",
    "rust_lesson4_ex7_slide2_content": "# 複雑なconditional\n\n```rust\nmatch Some(5) {\n    Some(x) if x % 2 == 0 => println!(\"even\"),\n    Some(x) => println!(\"odd: {}\", x),\n    None => println!(\"none\"),\n}\n```",
    "rust_lesson3_ex3_slide1_content": "# elementを1つずつ取り出す仕組み\n\niterator は、ベクタなどのデータを「1つずつ順番に」取り出す仕組みです。\n\nFor example：\n- 行列に並んでいる人を1人ずつ呼ぶ\n- 引き出しの中身を1つずつ出す\n\ncodeExample：\n```rust\nlet v = vec![1, 2, 3];\nfor x in v.iter() {\n    println!(\"{}\", x);  // 1, 2, 3 と順番に表示\n}\n```\n\n`iter()` で「順番に取り出す準備」をして、`for` で1つずつ処理します。",
    "rust_lesson3_ex3_slide1_title": "iterator?",
    "rust_lesson4_ex2_description": "トレイトを自動implementationdoderiveを学びましょう。",
    "rust_lesson3_ex4_slide1_content": "# 全部を同じように変換do\n\n**map** は、iteratorの各elementを「同じ方法で」変換します。\n\nFor example：\n- 全員の身長を2倍にdo\n- 全員の名前を大文字にdo\n- 全部の数を2乗do\n\ncodeExample：\n```rust\nlet v = vec![1, 2, 3];\nlet doubled: Vec<_> = v.iter()\n    .map(|x| x * 2)  // 各要素を2倍に\n    .collect();      // ベクタに戻す\n// [2, 4, 6]\n```\n\n`|x| x * 2` は「xを受け取って、x*2をreturn」closureです。",
    "rust_lesson1_ex3_slide1_title": "あまりを求める",
    "rust_lesson3_ex10_slide1_content": "# 所有権の違い\n\nString は所有権を持つheap上のstring、&str はreferenceです。\n\n```rust\nlet s1: String = String::from(\"hello\");\nlet s2: &str = \"hello\";\n```",
    "rust_lesson4_ex2_slide1_title": "derive（デライブ）?",
    "rust_lesson2_ex2_comment1": "& でreferenceを渡す",
    "rust_lesson4_ex5_slide1_title": "HashMap（ハッシュmap）?",
    "rust_lesson2_ex3_slide2_title": "&mut  Usage",
    "rust_lesson3_ex5_title": "filter で絞り込み",
    "rust_lesson4_ex3_slide2_title": "いつuse？",
    "rust_lesson2_ex2_title": "referenceと借用",
    "rust_lesson2_ex7_title": "Option<T> で null を安全に",
    "rust_lesson4_ex10_slide3_title": "Let's Try It!",
    "rust_lesson3_ex5_slide3_title": "Let's Try It!",
    "rust_lesson4_ex10_title": "enumerate でindex付き",
    "rust_lesson2_ex2_slide1_content": "# 所有権を渡さずに「借りる」\n\nreference をuseと、所有権を移さずにデータを「見せてもらう」ことができます。\n\nたとえるなら：\n- ムーブ = おもちゃをあげる（自分は使えない）\n- reference = おもちゃを見せる（自分も使える）\n\n作り方：\n`&`（アンパサンド）をつけるとreferenceを作れます。\n\n```rust\nlet s = String::from(\"hello\");\nlet r = &s;  // sを借りる（見せてもらう）\n// s も r も使える！\n```",
    "rust_lesson2_ex5_slide2_content": "# &self をuse\n\nmethodの最初のargumentは `&self` です。\n\ncodeExample：\n```rust\nimpl Rect {\n    fn area(&self) -> i32 {\n        self.width * self.height\n    }\n}\n```",
    "rust_lesson1_ex5_slide2_title": "Let's Try It!",
    "rust_lesson2_ex4_slide3_title": "Let's Try It!",
    "rust_lesson4_ex3_slide3_title": "Let's Try It!",
    "rust_lesson2_ex9_slide3_content": "共通の振る舞いを定義する「トレイト」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex1_slide2_content": "# impl で約束を守る\n\n構造体にトレイトをimplementationdoと、その構造体は「約束を守る」ことになります。\n\ncodeExample：\n```rust\nstruct Person { name: String }\n\nimpl Greet for Person {\n    fn greet(&self) -> String {\n        format!(\"Hello, {}\", self.name)\n    }\n}\n```\n\n読み方：\n- `impl Greet for Person` → 「PersonはGreetをimplementationdo」\n- これでPersonは「あいさつできる」ようになった！",
    "rust_lesson4_ex4_comment1": "clone でreferenceカウントを増やす",
    "rust_lesson3_ex4_slide2_content": "# map だけではexecuteされない！\n\nRustのiteratorは 遅延評価 といって、「本当に必要になるまで処理しない」仕組みです。\n\nなぜ？\n無駄な計算を省けるから。100万件あっても、最初の10件だけ欲しいなら10件だけ処理すればいい。\n\ncollect() でexecute：\n```rust\n// これだけでは何も起きない\nv.iter().map(|x| x * 2);\n\n// collect() で実行してベクタに変換\nlet result: Vec<_> = v.iter().map(|x| x * 2).collect();\n```\n\n`collect()` は「今すぐ全部処理してResultをちょうだい」という意味です。",
    "rust_lesson2_ex4_slide2_title": "struct のdefinitionのしかた",
    "rust_lesson2_ex3_slide1_content": "# 「書き換えできる」借り方\n\n普通のreference `&` は「見るだけ」ですが、可変reference `&mut` は「変更もできる」借り方です。\n\nたとえるなら：\n- `&` = 本を見せてもらう（readだけ）\n- `&mut` = ノートを借りる（writeOK）\n\nImportantなルール：\n- 可変referenceは同時に1つだけ！\n- 「みんなで見る」か「1人でwrite」かのどちらか\n\nこのルールで、データが同時に書き換えられるバグを防いでいます。",
    "rust_lesson2_ex10_slide3_title": "Let's Try It!",
    "rust_lesson2_ex4_title": "構造体をdefinitionしよう",
    "rust_lesson3_ex10_slide2_content": "# 相互変換\n\n```rust\n// &str -> String\nlet s = \"hello\".to_string();\n\n// String -> &str\nlet slice: &str = &s;\n```",
    "rust_lesson4_ex10_slide3_content": "イテレータにインデックスを付けましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex4_slide2_content": "# 「何人が持っているか」を数える\n\nRcは「今何人がこのデータを持っているか」を数えています。\n\ncodeExample：\n```rust\nlet a = Rc::new(5);\nprintln!(\"{}\", Rc::strong_count(&a));  // 1\n\nlet b = Rc::clone(&a);\nprintln!(\"{}\", Rc::strong_count(&a));  // 2\n```\n\nいつデータが消える？\n- カウントが0になったとき（誰も持っていないとき）\n- 最後の持ち主がいなくなると自動で片付けられる\n\n`Rc::clone` は「持ち主を1人増やす」操作です。",
    "rust_lesson1_ex8_slide2_title": "dictionary Usage",
    "rust_lesson4_ex3_slide1_content": "# データを「heap」に置く箱\n\nBox<T> は、データを「heap」という特別な場所に置くための箱です。\n\nmemoryの2つの場所：\n- stack：小さくて速い。サイズが決まっているデータ向け\n- heap：大きくて柔軟。サイズが大きいor変わるデータ向け\n\ncodeExample：\n```rust\nlet b = Box::new(5);  // 5をヒープに置く\nprintln!(\"{}\", *b);   // *で中身を取り出す → 5\n```\n\n`*` は「箱を開けて中身を見る」操作です。",
    "rust_lesson3_ex2_slide2_title": "closure Syntax",
    "rust_lesson4_ex4_slide1_title": "Rc（アールシー）?",
    "rust_lesson4_ex7_slide1_content": "# 追加条件\n\n**if** でパターンに追加条件をつけられます。\n\n```rust\nmatch x {\n    n if n < 0 => println!(\"negative\"),\n    n if n > 0 => println!(\"positive\"),\n    _ => println!(\"zero\"),\n}\n```",
    "rust_lesson2_ex3_title": "可変reference",
    "rust_lesson3_ex10_comment1": "to_string で String に変換",
    "rust_lesson3_ex10_slide2_title": "変換",
    "rust_lesson3_ex1_description": "referenceの有効期間を表すライフタイムを学びましょう。",
    "rust_lesson3_ex2_slide1_content": "# 名前のない「即席」function\n\nclosure は、名前をつけずにその場でcreatefunctionです。そして特別な能力があります：周りのvariableを使えるのです！\n\nFor example：\n```rust\nlet x = 5;  // 外側の変数\nlet add_x = |n| n + x;  // xを使えるクロージャ\nprintln!(\"{}\", add_x(10));  // 15\n```\n\n普通のfunctionとの違い：\n- 普通のfunction：argumentしか使えない\n- closure：argument + 周りのvariableも使える\n\n「その場の空気を読める」functionというイメージです！",
    "rust_lesson1_ex2_comment1": "x に 10 を入れる",
    "rust_lesson1_ex7_slide3_title": "Let's Try It!",
    "rust_lesson1_ex5_title": "「もし〜なら」で分けましょう",
    "rust_lesson3_ex2_slide3_title": "Let's Try It!",
    "rust_lesson3_ex7_slide2_content": "# 簡潔なerror処理\n\n```rust\n// ? を使わない場合\nmatch result {\n    Ok(v) => v,\n    Err(e) => return Err(e),\n}\n\n// ? を使う\nresult?\n```",
    "rust_lesson3_ex6_slide3_title": "Let's Try It!",
    "rust_lesson4_ex9_slide3_content": "イテレータをコレクションに変換しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex6_description": "elementを1つのvalueにまとめるfoldを学びましょう。",
    "rust_lesson2_ex9_description": "共通の振る舞いをdefine「トレイト」を学びましょう。",
    "rust_lesson2_ex8_comment1": "Ok で成功をreturn",
    "rust_lesson3_ex5_slide2_content": "# filter はreferenceのreferenceを受け取る\n\n`filter` のclosureは、referenceのreference（`&&T`）を受け取ります。そのため、valueをuseには `**x` と2回referenceを外す必要があります。\n\nなぜ？\n- `iter()` はreference（`&T`）をreturn\n- `filter` はそれをFurthermorereferenceで渡す（`&&T`）\n\nSyntax：\n```rust\n// **x で値を取り出す\n.filter(|x| **x > 2)\n\n// または * を引数につける\n.filter(|&x| *x > 2)\n```\n\n最初は混乱しますが、慣れれば大丈夫！",
    "rust_lesson1_ex5_comment1": "> でcompare",
    "rust_lesson2_ex4_description": "関連doデータをまとめる「構造体」を学びましょう。",
    "rust_lesson3_ex5_slide3_content": "条件に合う要素だけを取り出しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex7_slide3_content": "「ベクタ（Vec）」を使うと、たくさんのデータを一つの「長い はこ」にまとめて入れられます。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex5_slide2_title": "valueの取得",
    "rust_lesson3_ex1_slide1_title": "ライフタイム?",
    "rust_lesson1_ex3_comment1": "10 を 3 で割ったあまりをoutput",
    "rust_lesson3_ex1_comment1": "'a でライフタイムをdefinition",
    "rust_lesson3_ex10_slide1_title": "String vs &str",
    "rust_lesson2_title": "Rust II - 所有権とトレイト",
    "rust_lesson2_ex5_slide2_title": "methodのdefinition",
    "rust_lesson4_ex5_comment1": "insert でkeyとvalueを追加",
    "rust_lesson2_ex9_slide1_content": "# 「できること」の約束\n\nトレイト は、「このtypeはこういうことができる」という約束をdefine。\n\nFor example「鳴ける」という約束：\n- 犬は「ワン」と鳴く\n- 猫は「ニャー」と鳴く\n- 両方とも「鳴ける」能力がある\n\nトレイトは「鳴ける動物は、鳴き声を出すmethodを持つ」という約束です。\n\n他の言語とのcomparison：\n- Java: interface\n- TypeScript: interface\n\nに似た概念です。",
    "rust_lesson1_ex2_slide3_title": "Let's Try It!",
    "rust_lesson4_ex8_slide1_content": "# return valueのtypeをabstract化\n\nimpl Trait で、トレイトをimplementationdotypeを返せます。\n\n```rust\nfn make_iter() -> impl Iterator<Item = i32> {\n    vec![1, 2, 3].into_iter()\n}\n```",
    "rust_lesson1_ex2_slide2_content": "# 四則演算（しそくえんざん）\n\nRustでも算数と同じ記号で計算ができます。\n\n4つのBasic記号：\n- +（プラス）: たし算\n- -（マイナス）: ひき算\n- \\*（アスタリスク）: かけ算（×の代わり）\n- /（スラッシュ）: わり算（÷の代わり）\n\ncodeExample：\n```rust\nlet a = 10;\nlet b = 5;\nprintln!(\"{}\", a + b);  // 15 と表示される\n```\n\n`println!` の `{}` は「ここにvalueを入れてね」という目印です。",
    "rust_lesson4_ex9_slide2_content": "# 変換先を指定\n\n```rust\n// ターボフィッシュ構文\nlet v = (0..5).collect::<Vec<_>>();\n\n// 変数の型注釈\nlet v: Vec<i32> = (0..5).collect();\n```",
    "rust_lesson1_ex8_description": "「dictionary（HashMap）」をuseと、名前をつけてデータを保存し、その名前で取り出せます。",
    "rust_lesson4_ex9_slide2_title": "typeHint",
    "rust_lesson3_ex1_title": "ライフタイムのBasic",
    "rust_lesson2_ex5_description": "構造体にmethodをadd「impl」を学びましょう。",
    "rust_lesson4_ex8_comment1": "impl でトレイトをimplementationdotypeをreturn",
    "rust_lesson4_ex8_slide2_title": "argumentにも使える",
    "rust_lesson4_ex7_comment1": "if でマッチガードを追加",
    "rust_lesson2_ex9_slide2_title": "trait のdefinitionとimplementation",
    "rust_lesson4_ex10_slide2_title": "いつuse？",
    "rust_lesson3_ex7_slide2_title": "match の省略形",
    "rust_lesson1_ex6_title": "logicaloperator（&&、||）",
    "rust_lesson3_ex6_comment1": "fold で畳み込み",
    "rust_lesson2_ex6_description": "複数の状態を表す「列挙type（enum）」を学びましょう。",
    "rust_lesson4_ex10_slide1_title": "enumerate（イニュメレート）?",
    "rust_lesson1_ex7_slide1_title": "ベクタ（Vec）?",
    "rust_lesson2_ex6_slide3_content": "複数の状態を表す「列挙型（enum）」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex3_slide3_title": "Let's Try It!",
    "rust_lesson3_ex4_description": "各elementを変換domapを学びましょう。",
    "rust_lesson4_ex1_slide3_title": "Let's Try It!",
    "rust_lesson3_ex9_slide2_title": "mut が必要",
    "rust_lesson1_ex6_slide1_content": "# logicaloperator（ろんりえんざんし）\n\n2つ以上の条件を組み合わせたいときにuse記号です。\n\n2つの記号：\n- `&&`（アンドアンド）：「かつ」＝ 両方とも 正しいとき\n- `||`（オアオア）：「Alsoは」＝ どちらか 正しいとき\n\n身近なExample：\n- 遊園地：「18歳以上 かつ チケットあり」なら乗れる\n- おやつ：「宿題終わった Alsoは お手伝いした」ならOK\n\ncodeExample：\n```rust\nif score >= 70 && bonus > 0 {\n    // 70点以上 かつ ボーナスあり → 合格！\n    println!(\"合格！\");\n}\n```",
    "rust_lesson4_ex4_slide3_content": "参照カウントでデータを共有しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex6_slide3_title": "Let's Try It!",
    "rust_lesson2_ex5_slide3_content": "構造体にメソッドを追加する「impl」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex1_slide3_title": "Let's Try It!",
    "rust_lesson1_ex5_slide1_content": "# programに「判断」させよう\n\nconditional は、「もし〜なら、〇〇do」という判断をprogramにさせる仕組みです。\n\n身近なExample：\n- もし80点以上なら → 「合格！」とdisplay\n- もし雨なら → 傘を持っていく\n- もしHPが0なら → ゲームオーバー\n\nRustで Syntax：\n```rust\nif score > 80 {\n    println!(\"合格！\");\n}\n```\n\n読み方：\n- `if` →「もし」\n- `score > 80` →「スコアが80より大きいなら」\n- `{ }` の中 →「これをやる」",
    "rust_lesson4_ex5_title": "HashMap",
    "rust_lesson1_ex2_slide1_content": "# データを保存do「はこ」\n\nvariable（へんすう） は、数字や文字を入れておける「はこ」のことです。名前をつけて、あとでuseことができます。\n\nFor example：\n- 「りんごの数」というラベルの箱に「5」を入れる\n- あとで「りんごの数」と呼べば「5」が出てくる\n\nRustで Syntax：\n```rust\nlet x = 10;  // xという箱に10を入れる\nprintln!(\"{}\", x);  // xの中身（10）を表示\n```\n\n`let` は「この名前で箱をcreateよ」という意味です。",
    "rust_lesson2_ex4_slide3_content": "関連するデータをまとめる「構造体」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex6_slide1_title": "enum ?",
    "rust_lesson2_ex9_title": "トレイトをdefinitionしよう",
    "rust_lesson2_ex4_slide1_title": "構造体（こうぞうたい）?",
    "rust_lesson4_ex2_slide2_content": "# 覚えておくと便利な5つ\n\nよくusederiveトレイト：\n```rust\nDebug     // {:?} でデバッグ表示できる\nClone     // .clone() でコピーを作れる\nCopy      // 代入時に自動でコピー（小さい型向け）\nPartialEq // == で比較できる\nDefault   // 初期値を自動で作れる\n```\n\n複数指定もOK：\n```rust\n#[derive(Debug, Clone, PartialEq)]\nstruct User {\n    name: String,\n    age: u32,\n}\n```\n\n`Debug` は特によくuse。debug時に構造体の中身を見れて便利！",
    "rust_lesson2_ex1_slide1_content": "# データの「持ち主」を決めるルール\n\n所有権 は、Rust最大のFeatureです。「このデータの持ち主は誰か」をはっきりさせる仕組みです。\n\nルール：\n- データには必ず1人だけ「持ち主」がいる\n- 持ち主がいなくなると、データは自dynamicに片付けられる\n\nたとえるなら：\n- おもちゃは1人しか持てない\n- 持ち主が部屋を出たら、おもちゃは片付けられる\n\nこのルールのおかげで、Rustは「memoryリーク」（データが片付けられないバグ）を防げます！",
    "rust_lesson1_ex3_slide2_title": "Let's Try It!",
    "rust_lesson3_ex1_slide2_title": "なぜ必要？",
    "rust_lesson3_ex1_slide2_content": "# 危険なバグを防ぐ\n\nダングリングreference という危険なバグがあります。これは「もう存在しないデータ」を指し続けているreferenceのことです。\n\nExample：\n```rust\nfn longest<'a>(x: &'a str, y: &'a str) -> &'a str {\n    if x.len() > y.len() { x } else { y }\n}\n```\n\n`'a` の意味：\n- argument `x` と `y` は同じライフタイム `'a` を持つ\n- return valueも同じライフタイム `'a` を持つ\n- In other words「xとyが両方有効な間、return valueも有効」という約束\n\nRustはこれを自動でチェックしてくれます！",
    "rust_lesson4_ex6_slide2_title": "set演算",
    "rust_lesson3_ex7_comment1": "? でerrorを伝播",
    "rust_lesson3_ex2_slide2_content": "# | | でargumentを囲む\n\nclosureは `|引数| 処理` という形でwrite。`||` は「パイプ」と呼ばれます。\n\nいろいろなSyntax：\n```rust\n// 引数なし\n|| println!(\"Hello\")\n\n// 引数あり\n|x, y| x + y\n\n// 複数行のブロック\n|x| {\n    let y = x * 2;\n    y + 1\n}\n```\n\nPoint：\n- argumentを `| |` で囲む（functionの `()` の代わり）\n- typeは省略できることが多い（Rustが推測してくれる）",
    "rust_lesson2_ex7_comment1": "Some でvalueがあることを示す",
    "rust_lesson3_ex4_slide3_content": "各要素を変換するmapを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_title": "Rust (ラスト) に挑戦！",
    "rust_lesson2_ex8_description": "成功と失敗を表す「Result」を学びましょう。",
    "rust_lesson3_ex8_description": "Option/Resultのデフォルトvalueを設定しましょう。",
    "rust_lesson4_ex2_slide3_title": "Let's Try It!",
    "rust_lesson2_ex5_slide3_title": "Let's Try It!",
    "rust_lesson4_ex9_description": "iteratorをコレクションに変換しましょう。",
    "rust_lesson1_ex1_slide2_content": "# println! でscreenにdisplay\n\nRustで文字をscreenにdisplayには、`println!`（プリントラインびっくり）をuse。\n\nPoint：\n- `!` がつくのがRustのFeature（マクロと呼ばれます）\n- programは `fn main() { }` の中にwrite\n- `fn` は「function（function）」の略\n\ncodeExample：\n```rust\nfn main() {\n    println!(\"ヤッホー！\");\n}\n// 「ヤッホー！」と画面に表示される\n```\n\n`println!` の `!` は「マクロ」という特別な機能の印です。今は「おまじない」と思っておけばOK！",
    "rust_lesson3_ex6_slide1_title": "fold ?",
    "rust_lesson4_ex8_slide1_title": "impl Trait ?",
    "rust_lesson1_ex1_slide2_title": "Rustの「おまじない」",
    "rust_lesson3_ex10_description": "stringtypeの違いを理解しましょう。",
    "rust_lesson3_ex7_slide3_content": "エラーを簡潔に伝播させましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex1_comment1": "s1 の所有権を移動",
    "rust_lesson2_ex9_slide1_title": "トレイト?",
    "rust_lesson4_ex6_slide2_content": "# 和set、積setなど\n\n```rust\nset1.union(&set2)\nset1.intersection(&set2)\nset1.difference(&set2)\n```",
    "rust_lesson4_ex5_slide3_content": "キーと値のペアを格納しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex8_slide1_title": "Result（リザルト）?",
    "rust_lesson4_ex1_slide1_content": "# 「できること」の約束\n\nトレイト は、typeが持つべきmethodをdefine仕組みです。\n\nFor example：\n- 「あいさつできる」トレイト → greet() methodを持つ\n- 「displayできる」トレイト → display() methodを持つ\n\ncodeExample：\n```rust\ntrait Greet {\n    fn greet(&self) -> String;  // メソッドの「約束」\n}\n```\n\nこれは「Greetできるtypeは、greet()methodを持つ」という約束です。",
    "rust_lesson4_ex2_slide3_content": "トレイトを自動実装するderiveを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex6_title": "fold で畳み込み",
    "rust_lesson3_ex9_slide3_content": "Vecに要素を追加しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex4_slide1_content": "# 関係あるデータをまとめる「設計図」\n\n構造体（struct） は、いくつかのデータをひとまとめにdo仕組みです。\n\nFor example「点（座標）」のデータ：\n- x座標\n- y座標\n\nこの2つは関係があるので、「Point（点）」としてまとめると便利です。\n\nFor example「人」のデータ：\n- 名前\n- 年齢\n\nこれも「Person（人）」としてまとめられます。\n\n構造体は「こういうデータを持つ」という設計図です。",
    "rust_lesson4_ex1_slide1_title": "トレイト?（復習）",
    "rust_lesson2_ex3_description": "reference先のvalueを変更できる「可変reference」を学びましょう。",
    "rust_lesson2_ex7_slide2_content": "# match で安全に取り出す\n\n`match` を使って「ある場合」と「ない場合」で処理を分けます。\n\ncodeExample：\n```rust\nlet x: Option<i32> = Some(5);  // 値あり\n\nmatch x {\n    Some(n) => println!(\"値は{}です\", n),  // 5\n    None => println!(\"値がありません\"),\n}\n```\n\nなぜ安全？\n- `null` のように「あるつもりでアクセスしたら無かった」errorが起きない\n- 「ない場合」の処理を書かないとコンパイルerrorになる\n- 強制的に両方のケースを考えることになる！",
    "rust_lesson4_ex9_comment1": "collect で Vec に変換",
    "rust_lesson3_ex10_title": "String と &str",
    "rust_lesson2_ex7_slide1_title": "Option（オプション）?",
    "rust_lesson3_ex9_description": "Vecにelementを追加しましょう。",
    "rust_lesson2_ex5_comment1": "impl でmethodをimplementation",
    "rust_lesson3_ex1_slide3_content": "参照の有効期間を表すライフタイムを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex6_slide2_content": "複数の条件を組み合わせる「&&（かつ）」と「||（または）」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex5_comment1": "filter で条件に合うelementを絞り込む",
    "rust_lesson2_ex7_slide3_content": "値があるかないかを表す「Option」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex10_slide3_title": "Let's Try It!",
    "rust_lesson4_ex4_slide3_title": "Let's Try It!",
    "rust_lesson3_ex3_comment1": "iter でiteratorを取得",
    "rust_lesson3_ex6_slide3_content": "要素を1つの値にまとめるfoldを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex7_slide2_title": "ベクタの番号は「0」から！",
    "rust_lesson1_ex5_slide1_title": "conditional（じょうけんぶんき）?",
    "rust_lesson1_ex3_description": "割り算の「あまり」を求める「%」（パーセント）operatorを学びましょう。",
    "rust_lesson1_ex1_slide3_content": "Rustを使って画面に文字を表示してみましょう。println! という特別な関数を使います。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex10_slide2_content": "# <T> でtypeを「あとで決める」\n\nfunction名の後に `<T>` をつけて、`T` を「type」としてuse。\n\ncodeExample：\n```rust\n// Tはどんな型でもOK\nfn first<T>(arr: &[T]) -> &T {\n    &arr[0]  // 最初の要素を返す\n}\n\n// 使い方\nfirst(&[1, 2, 3]);         // Tはi32\nfirst(&[\"a\", \"b\", \"c\"]);   // Tは&str\n```\n\n読み方：\n- `<T>` → 「Tという名前のtypeをuseよ」\n- `T` は慣習で「Type（type）」の頭文字\n- 複数のtypeが必要なら `<T, U>` のようにwrite",
    "rust_lesson3_ex2_comment1": "|x| でclosureのargumentをdefinition",
    "rust_lesson3_ex3_description": "elementを順番に処理doiteratorを学びましょう。",
    "rust_lesson1_ex1_slide3_title": "Let's Try It!",
    "rust_lesson2_ex6_slide2_title": "enum のdefinition",
    "rust_lesson2_ex1_title": "所有権のBasic",
    "rust_lesson4_ex3_slide1_title": "Box（ボックス）?",
    "rust_lesson2_ex1_slide3_content": "Rust独自の概念「所有権」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex8_slide3_content": "Option/Resultのデフォルト値を設定しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex7_slide2_title": "使用Example",
    "rust_lesson4_ex10_description": "iteratorにindexを付けましょう。",
    "rust_lesson4_ex9_slide1_title": "collect ?",
    "rust_lesson4_ex10_slide2_content": "# 「何番目か」が必要なとき\n\n番号（index）とelementの両方が必要なときに便利です。\n\ncodeExample：\n```rust\nlet v = vec![10, 20, 30];\nfor (idx, val) in v.iter().enumerate() {\n    println!(\"{}番目の値は{}\", idx, val);\n}\n// 0番目の値は10\n// 1番目の値は20\n// 2番目の値は30\n```\n\nPoint：\n- `(i, x)` でtuple（2つのset）を受け取る\n- `i` にindex、`x` にelementが入る\n- indexは0から始まる",
    "rust_lesson3_ex2_description": "周囲のvariableを使えるanonymous function「closure」を学びましょう。",
    "rust_lesson1_ex4_comment1": "mut で変更可能にdo",
    "rust_lesson1_ex8_slide3_title": "Let's Try It!",
    "rust_lesson1_ex3_slide2_content": "割り算の「あまり」を求める「%」（パーセント）演算子を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex9_slide3_title": "Let's Try It!",
    "rust_lesson3_ex3_title": "iteratorのBasic",
    "rust_lesson3_ex9_title": "Vec のmethod push",
    "rust_lesson1_ex8_comment1": "dictionaryをcreate（keyは'みかん'、valueは'オレンジ'）",
    "rust_lesson1_ex2_comment3": "+ でたし算do",
    "rust_lesson4_ex8_slide2_content": "# ジェネリクスの代わり\n\n```rust\nfn print_all(iter: impl Iterator<Item = i32>) {\n    for x in iter {\n        println!(\"{}\", x);\n    }\n}\n```",
    "rust_lesson2_ex2_slide2_title": "reference Usage",
    "rust_lesson1_ex8_slide3_content": "「辞書（HashMap）」を使うと、名前をつけてデータを保存し、その名前で取り出せます。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex7_slide2_content": "# [ ]で番号を指定して取り出す\n\n`[番号]` で何番目のデータか指定して取り出せます。\n\nImportantなルール：番号は「0」から！\n- 1番目 → `[0]`\n- 2番目 → `[1]`\n- 3番目 → `[2]`\n\ncodeExample：\n```rust\nlet fruits = vec![\"りんご\", \"バナナ\", \"みかん\"];\n//                  ↑0番    ↑1番     ↑2番\nprintln!(\"{}\", fruits[0]);  // りんご\nprintln!(\"{}\", fruits[1]);  // バナナ\n```\n\nプログラミングでは「0から数える」のが世界共通のルールです！",
    "rust_lesson1_ex6_slide1_title": "条件を組み合わせる",
    "rust_lesson2_ex10_slide2_title": "ジェネリックfunction Syntax",
    "rust_lesson1_ex6_description": "複数の条件を組み合わせる「&&（かつ）」と「||（Alsoは）」を学びましょう。",
    "rust_lesson4_ex6_title": "HashSet",
    "rust_lesson2_ex3_slide2_content": "# mut が2か所に必要\n\n変更できるようにdoには、variableとreferenceの両方に `mut` が必要です。\n\ncodeExample：\n```rust\n// 1. 変数を mut で作る\nlet mut s = String::from(\"hello\");\n\n// 2. &mut で可変参照を渡す\nchange(&mut s);\n\nfn change(s: &mut String) {\n    s.push_str(\" world\");  // 変更できる！\n}\n```\n\nPoint：\n- `let mut 変数` でvariableを変更可能に\n- `&mut 変数` で可変referenceをcreate\n- 両方ないと変更できない！",
    "rust_lesson2_ex2_slide1_title": "reference（さんしょう）?",
    "rust_lesson3_ex6_slide2_content": "# 合計、積、結合など\n\n```rust\n// 積\nv.iter().fold(1, |acc, x| acc * x)\n\n// 文字列結合\nwords.iter().fold(String::new(), |acc, s| acc + s)\n```",
    "rust_lesson1_ex1_description": "Rustを使ってscreenに文字をdisplayしてみましょう。println! という特別なfunctionをuse。",
    "rust_lesson3_ex8_slide3_title": "Let's Try It!",
    "rust_lesson4_ex6_description": "一意なvalueのsetを管理しましょう。",
    "rust_lesson2_ex5_slide1_title": "impl ?",
    "rust_lesson1_ex8_title": "名前で引き出す「dictionary」",
    "rust_lesson2_ex7_description": "valueがあるかないかを表す「Option」を学びましょう。",
    "rust_lesson1_ex4_slide2_title": "Let's Try It!",
    "rust_lesson1_ex7_title": "たくさんのデータをまとめましょう「ベクタ」",
    "rust_lesson3_ex7_slide1_content": "# errorの早期リターン\n\n? は、Resultが Err の場合に早期リターンします。\n\n```rust\nfn read_file() -> Result<String, io::Error> {\n    let content = fs::read_to_string(\"file.txt\")?;\n    Ok(content)\n}\n```",
    "rust_lesson3_ex9_slide1_content": "# 末尾に追加\n\npush は、Vecの末尾にelementをadd。\n\n```rust\nlet mut v = vec![1, 2];\nv.push(3);\n// [1, 2, 3]\n```",
    "rust_lesson4_ex8_slide3_content": "トレイトを返す関数を簡潔に書きましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex1_title": "screenにメッセージを出しましょう",
    "rust_lesson2_ex8_slide2_title": "Result  Usage",
    "rust_lesson3_ex2_slide1_title": "closure?",
    "rust_lesson3_ex8_title": "unwrap_or でデフォルトvalue",
    "rust_lesson4_ex10_slide1_content": "# 番号とelementを一緒にもらう\n\nenumerate は、「何番目か」と「そのelement」をsetで取り出せるmethodです。\n\nFor example：\n- 0番目: りんご\n- 1番目: バナナ\n- 2番目: みかん\n\ncodeExample：\n```rust\nfor (i, x) in vec![\"a\", \"b\", \"c\"].iter().enumerate() {\n    println!(\"{}: {}\", i, x);\n}\n// 0: a\n// 1: b\n// 2: c\n```",
    "rust_lesson1_ex7_slide1_content": "# データを並べてまとめる「長い箱」\n\nベクタ（Vec） は、たくさんのデータを順番に並べて入れられる「長い箱」です。\n\nFor example：\n- 買い物listの商品を全部まとめる\n- testの点数を全部まとめる\n- 友だちの名前を全部まとめる\n\n100個でも1000個でも、1つのvariableでまとめて管理できます！\n\n作り方：\n```rust\nlet fruits = vec![\"りんご\", \"バナナ\", \"みかん\"];\n// vec! で ベクタを作る\n```",
    "rust_lesson4_ex8_slide3_title": "Let's Try It!",
    "rust_lesson4_ex7_description": "パターンマッチに条件を追加しましょう。",
    "rust_lesson1_ex4_comment2": "+= で 20 を足す",
    "rust_lesson1_ex2_comment2": "y に 5 を入れる",
    "rust_lesson2_ex3_slide3_title": "Let's Try It!",
    "rust_lesson3_ex4_slide1_title": "map（map）?",
    "rust_lesson1_ex2_slide3_content": "データに名前をつけて保存できる「変数（へんすう）」を使ってみましょう。letで変数を作ります。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex8_slide2_content": "# match で成功と失敗を分ける\n\n`match` で「成功したら」「失敗したら」の処理を書き分けます。\n\ncodeExample：\n```rust\nfn divide(a: i32, b: i32) -> Result<i32, String> {\n    if b == 0 {\n        return Err(\"0で割れません\".to_string());\n    }\n    Ok(a / b)  // 成功なら答えを返す\n}\n\nmatch divide(10, 2) {\n    Ok(v) => println!(\"答えは{}\", v),\n    Err(e) => println!(\"エラー: {}\", e),\n}\n```\n\nPoint：\n- `Ok(値)` で成功をreturn\n- `Err(エラー)` で失敗をreturn",
    "rust_lesson4_ex3_comment1": "Box::new でheapに格納",
    "rust_lesson4_ex8_description": "トレイトをreturnfunctionを簡潔に書きましょう。",
    "rust_lesson2_ex10_description": "typeを後から決められる「ジェネリクス」を学びましょう。",
    "rust_lesson2_ex3_slide1_title": "可変reference（かへんさんしょう）?",
    "rust_lesson2_ex2_description": "所有権を移さずにvalueを借りる「reference」を学びましょう。",
    "rust_lesson3_ex5_slide2_title": "** にNote！",
    "rust_lesson2_ex2_slide3_title": "Let's Try It!",
    "rust_lesson4_ex3_slide3_content": "ヒープにデータを格納するBoxを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex4_title": "累算assignmentoperator（+=、-=）",
    "rust_lesson3_ex3_slide2_content": "# 借りるか、もらうか\n\n3種類の iter があり、所有権の扱いが違います。\n\n3つの違い：\n```rust\nv.iter()       // 参照で借りる（&T）\nv.iter_mut()   // 変更可能で借りる（&mut T）\nv.into_iter()  // 所有権をもらう（T）\n```\n\n使い分け：\n- `iter()` → 見るだけ（元のベクタも使える）\n- `iter_mut()` → 中身を変更したい\n- `into_iter()` → ベクタごともらう（元は使えない）\n\n普通は `iter()` をuseことが多いです。",
    "rust_lesson2_ex1_slide1_title": "所有権（しょゆうけん）?",
    "rust_lesson4_ex6_slide3_content": "一意な値の集合を管理しましょう。\n\n（When you're ready, select \"Start Lesson\".）"
  },
  "zh-Hant": {
    "rust_lesson1_course_title": "Introduction to Rust",
    "rust_lesson1_course_description": "Learn the basics of Rust programming.",
    "rust_lesson2_course_title": "Rust II - Intermediate",
    "rust_lesson2_course_description": "Learn intermediate Rust concepts.",
    "rust_lesson3_course_title": "Rust III - Advanced",
    "rust_lesson3_course_description": "Master advanced Rust techniques.",
    "rust_lesson4_course_title": "Rust IV - Expert Level",
    "rust_lesson4_course_description": "Expert-level Rust programming.",
    "rust_lesson1_ex5_slide2_content": "条件によって動きを変える if文を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex9_title": "collect で変換",
    "rust_lesson2_ex7_slide1_content": "# 「あるかもしれない、ないかもしれない」\n\nOption<T> は、valueが「あるかもしれないし、ないかもしれない」ことを表すtypeです。\n\nFor example：\n- dictionaryで単語を探す → 見つかるかもしれないし、ないかもしれない\n- ゲームでアイテムを拾う → 落ちてるかもしれないし、ないかもしれない\n\n2つの状態：\n- `Some(値)` → valueがある！\n- `None` → valueがない...\n\n他の言語では `null` をuseが、Rustでは `Option` で安全に扱います。",
    "rust_lesson1_ex2_slide1_title": "variable（へんすう）?",
    "rust_lesson1_ex7_description": "「ベクタ（Vec）」をuseと、たくさんのデータを一つの「長い はこ」にまとめて入れられます。",
    "rust_lesson2_ex9_slide2_content": "# 約束を作って、守る\n\n1. `trait` で「約束」をdefinition\n2. `impl トレイト for 型` で「約束を守る」implementationをdo\n\ncodeExample：\n```rust\n// 1. トレイト（約束）を定義\ntrait Speak {\n    fn speak(&self);  // 鳴くメソッドを持つ約束\n}\n\n// 2. Dog構造体がトレイトを実装\nstruct Dog;\nimpl Speak for Dog {\n    fn speak(&self) {\n        println!(\"woof\");\n    }\n}\n```\n\n「DogはSpeakができる」ということになります。",
    "rust_lesson4_ex4_description": "referenceカウントでデータを共有しましょう。",
    "rust_lesson4_ex5_slide1_content": "# 名前で引ける「dictionary」\n\nHashMap は、「key（名前）」と「value（データ）」をsetで保存dodictionaryです。\n\nFor example：\n- 「青チーム」→ 10点\n- 「赤チーム」→ 15点\n\ncodeExample：\n```rust\nuse std::collections::HashMap;\n\nlet mut scores = HashMap::new();\nscores.insert(\"Blue\", 10);   // 追加\nscores.insert(\"Red\", 15);    // 追加\n```\n\n`use` で機能を読み込んでからuse。",
    "rust_lesson3_ex4_title": "map でiterator変換",
    "rust_lesson4_ex1_slide3_content": "共通の振る舞いを定義するトレイトを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex4_description": "variableのvalueを手軽に増やしたり減らしたりdo「+=」「-=」を学びましょう。",
    "rust_lesson1_ex2_description": "データに名前をつけて保存できる「variable（へんすう）」を使ってみましょう。letでvariableをcreate。",
    "rust_lesson4_ex4_slide2_title": "referenceカウントの仕組み",
    "rust_lesson3_ex8_slide2_title": "unwrap_or_else",
    "rust_lesson4_ex10_comment1": "1番目の i にindex、2番目の item にelementが入る",
    "rust_lesson3_ex6_slide1_content": "# 累積処理\n\nfold は、初期valueとfunctionでelementを1つずつ畳み込みます。\n\n```rust\nlet v = vec![1, 2, 3];\nlet sum = v.iter().fold(0, |acc, x| acc + x);\n// 6\n```",
    "rust_lesson4_ex2_slide2_title": "よくuse derive トレイト",
    "rust_lesson3_ex10_slide3_content": "文字列型の違いを理解しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex4_slide2_content": "変数の値を手軽に増やしたり減らしたりする「+=」「-=」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex4_slide3_title": "Let's Try It!",
    "rust_lesson3_ex5_slide1_title": "filter（filterー）?",
    "rust_lesson4_ex5_description": "keyとvalueのpairを格納しましょう。",
    "rust_lesson3_ex5_description": "条件に合うelementだけを取り出しましょう。",
    "rust_lesson2_ex2_slide2_content": "# functionに借りてもらう\n\nfunctionにデータを渡すとき、`&` をつけると「借りる」形になります。元のvariableはそのまま使い続けられます。\n\ncodeExample：\n```rust\nfn calc_len(s: &String) -> usize {\n    s.len()  // 長さを返す\n}\n\nfn main() {\n    let text = String::from(\"hello\");\n    let len = calc_len(&text);  // textを貸す\n    // text はまだ使える！\n    println!(\"{}の長さは{}\", text, len);\n}\n```\n\n`&String` は「Stringを借りる」という意味です。",
    "rust_lesson4_ex7_slide3_content": "パターンマッチに条件を追加しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex8_slide2_content": "# 遅延評価\n\n```rust\n// クロージャで計算\nlet value = x.unwrap_or_else(|| expensive_computation());\n```",
    "rust_lesson4_ex7_title": "match ガード",
    "rust_lesson3_ex7_title": "? operatorでerror伝播",
    "rust_lesson4_ex1_description": "共通の振る舞いをdefineトレイトを学びましょう。",
    "rust_lesson2_ex1_slide2_content": "# 所有権は「移動」do\n\nvariableを別のvariableにassignmentdoと、所有権が 移動（ムーブ） します。元のvariableは使えなくなります。\n\ncodeExample：\n```rust\nlet s1 = String::from(\"hello\");  // s1 が持ち主\nlet s2 = s1;  // 所有権が s2 に移動！\n// ↓ s1 はもう使えない（エラーになる）\n// println!(\"{}\", s1);  // ダメ！\nprintln!(\"{}\", s2);  // OK！\n```\n\nイメージ：\nおもちゃを友だちにあげたら、自分はもう使えない。これがムーブです。",
    "rust_lesson1_ex8_slide1_title": "dictionary（HashMap）?",
    "rust_lesson4_ex3_slide2_content": "# サイズが決まらないとき\n\nBoxは、コンパイル時にサイズがわからないtypeにuse。\n\nFor examplerecursion的なtype：\n```rust\n// リストは「値 + 次のリスト」の繰り返し\nenum List {\n    Cons(i32, Box<List>),  // Boxで次を指す\n    Nil,                   // 終わり\n}\n```\n\nなぜBoxが必要？\n- `List` の中に `List` がある → 無限に大きくなる？\n- `Box` をuseと、サイズが固定（pointerのサイズ）になる\n\n「中身」ではなく「中身への矢印」を持つイメージです。",
    "rust_lesson2_ex10_title": "ジェネリクスを使おう",
    "rust_lesson2_ex8_slide3_title": "Let's Try It!",
    "rust_lesson3_ex9_slide2_content": "# 可変reference\n\n```rust\n// mut が必要\nlet mut v = Vec::new();\nv.push(1);\nv.push(2);\n```",
    "rust_lesson4_ex4_title": "Rc<T>",
    "rust_lesson2_ex3_comment1": "mut で可変variableにdo",
    "rust_lesson4_ex5_slide3_title": "Let's Try It!",
    "rust_lesson2_ex6_slide2_content": "# バリアントを列挙\n\n`enum 名前 { バリアント1, バリアント2, ... }` でdefine。\n\ncodeExample：\n```rust\nenum Color {\n    Red,\n    Green,\n    Blue,\n}\nlet c = Color::Red;\n```",
    "rust_lesson1_ex1_comment1": "Hello, Rust! とdisplay",
    "rust_lesson1_ex1_slide1_content": "# 安全で速い！最新のプログラミング言語\n\nRust（ラスト）は、「間違いを事前に防ぐ」ことがとても得意なプログラミング言語です。\n\nRustのすごいところ：\n- programのミスをexecute前に見つけてくれる\n- とても速く動く\n- 世界中のプログラマーが「一番好き！」と選ぶ人気の言語\n\nたとえるなら：\n厳しいけど優しい先生のような言語です。「ここ間違ってるよ」と教えてくれるので、安心してprogramが書けます！",
    "rust_lesson3_ex8_slide1_content": "# None/Err の場合のデフォルト\n\nunwrap_or は、None や Err の場合にデフォルトvalueをreturn。\n\n```rust\nlet x: Option<i32> = None;\nlet value = x.unwrap_or(0);  // 0\n```",
    "rust_lesson2_ex7_slide3_title": "Let's Try It!",
    "rust_lesson2_ex6_title": "enum で状態を表す",
    "rust_lesson2_ex8_slide1_content": "# 「成功」か「失敗」かを表す\n\nResult<T, E> は、処理が「成功したか失敗したか」を表すtypeです。\n\nFor example：\n- fileをopen → 成功（内容）か失敗（error）\n- 0で割り算 → 成功（答え）か失敗（0で割れない！）\n\n2つの状態：\n- `Ok(値)` → 成功！valueが入っている\n- `Err(エラー)` → 失敗...error情報が入っている\n\n`Option` は「あるか・ないか」、`Result` は「成功か・失敗か」という違いです。",
    "rust_lesson2_ex8_slide3_content": "成功と失敗を表す「Result」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex6_slide1_title": "HashSet ?",
    "rust_lesson3_ex9_comment1": "push でelementを追加",
    "rust_lesson2_ex7_slide2_title": "Option  Usage",
    "rust_lesson3_ex2_title": "closureのBasic",
    "rust_lesson3_ex7_slide1_title": "? operator?",
    "rust_lesson4_ex6_comment1": "HashSet をimport",
    "rust_lesson2_ex10_slide1_content": "# どんなtypeでも使える「万能」の仕組み\n\nジェネリクス は、typeを後から決められる仕組みです。\n\nなぜ便利？\n同じようなfunctionを何度も書かなくてすみます。\n\nFor example：\n- 数字のarrayの最初のelementを取るfunction\n- stringのarrayの最初のelementを取るfunction\n\n両方とも「最初のelementを取る」のは同じなのに、typeが違うだけで別のfunctionをwriteのは大変！\n\nジェネリクスなら、`<T>` で「typeは後で決める」とwriteだけで、どんなtypeでも使えるfunctionが作れます。",
    "rust_lesson1_ex3_slide1_content": "# 剰余operator（じょうよえんざんし）「%」\n\n`%`（パーセント）は、割り算の 「あまり」 をcalculate特別な記号です。\n\nわかりやすいExample：\n- 10このアメを3人で分けると？\n- 1人3こずつで、1こあまる\n- これを `10 % 3` とwriteと、答えは `1`\n\ncodeExample：\n```rust\nprintln!(\"{}\", 10 % 3);  // 1（あまり1）\nprintln!(\"{}\", 8 % 4);   // 0（あまりなし＝割り切れる）\n```\n\n使いどころ：\n- 偶数か奇数か調べる（`n % 2` が0なら偶数）\n- 時計の計算（24を超えたら0に戻る、など）",
    "rust_lesson3_ex7_description": "errorを簡潔に伝播させましょう。",
    "rust_lesson3_ex8_comment1": "unwrap_or でデフォルトvalueを設定",
    "rust_lesson2_ex8_title": "Result<T, E> でerror処理",
    "rust_lesson2_ex10_comment1": "T をtypeパラメータとしてuse",
    "rust_lesson2_ex6_comment1": "enum で列挙typeをdefinition",
    "rust_lesson3_ex3_slide3_content": "要素を順番に処理するイテレータを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex2_comment1": "derive でトレイトを自動implementation",
    "rust_lesson1_ex8_slide1_content": "# 名前でsearchできる「dictionary」\n\nHashMap（ハッシュmap）は、「名前」と「データ」をsetにして保存できる仕組みです。本物のdictionaryのように使えます。\n\nFor example果物の色dictionary：\n- 「りんご」→「あか」\n- 「バナナ」→「きいろ」\n- 「みかん」→「オレンジ」\n\nuse準備：\n```rust\nuse std::collections::HashMap;  // 機能を読み込む\nlet mut fruits = HashMap::new();  // 空の辞書を作る\nfruits.insert(\"りんご\", \"あか\");  // データを追加\n```\n\n`use` は「この機能をuseよ」というdeclarationです。",
    "rust_lesson3_ex9_slide1_title": "push ?",
    "rust_lesson4_ex1_title": "トレイトのdefinition",
    "rust_lesson4_ex3_description": "heapにデータを格納doBoxを学びましょう。",
    "rust_lesson1_ex2_title": "便利な「はこ」variable（へんすう）",
    "rust_lesson1_ex8_comment2": "中身を出す",
    "rust_lesson3_ex9_slide3_title": "Let's Try It!",
    "rust_lesson1_ex4_comment3": "-= で 50 を引く",
    "rust_lesson1_ex6_comment1": "&& で両方の条件をチェック",
    "rust_lesson4_ex1_slide2_title": "トレイトのimplementation",
    "rust_lesson4_ex7_slide3_title": "Let's Try It!",
    "rust_lesson4_title": "Rust IV - トレイトとスマートpointer",
    "rust_lesson4_ex1_comment1": "trait でトレイトをdefinition",
    "rust_lesson4_ex4_slide1_content": "# 複数の「持ち主」を許可do仕組み\n\nRc<T> は「Reference Counted（referenceカウント）」の略で、複数の所有者でデータを共有できます。\n\n普通の所有権：\n1人だけが持ち主。渡したら元の人は使えない。\n\nRc をuseと：\n複数人が同じデータの「持ち主」になれる！\n\ncodeExample：\n```rust\nuse std::rc::Rc;\n\nlet a = Rc::new(5);       // Rcでラップ\nlet b = Rc::clone(&a);    // bも持ち主になる\n// a も b も使える！\n```",
    "rust_lesson3_ex5_slide1_content": "# 条件に合うものだけ残す\n\nfilter は、条件を満たすelementだけを残し、他を捨てます。\n\nFor example：\n- 80点以上の人だけ残す\n- 偶数だけ残す\n- 「あ」から始まる名前だけ残す\n\ncodeExample：\n```rust\nlet v = vec![1, 2, 3, 4, 5];\nlet evens: Vec<_> = v.iter()\n    .filter(|x| **x % 2 == 0)  // 偶数だけ\n    .collect();\n// [2, 4]\n```\n\n条件が `true` のelementだけが残ります。",
    "rust_lesson3_ex7_slide3_title": "Let's Try It!",
    "rust_lesson1_ex7_comment2": "2番目のデータ（1番）を出す",
    "rust_lesson4_ex8_title": "impl Trait",
    "rust_lesson1_ex5_description": "条件によって動きを変える if文を学びましょう。",
    "rust_lesson3_ex4_slide2_title": "遅延評価（ちえんひょうか）",
    "rust_lesson3_ex1_slide1_content": "# referenceの「寿命」を示す印\n\nライフタイム は、referenceがいつまで使えるかを示す印です。`'a`（アポストロフィ・エー）のようにwrite。\n\nなぜ必要？\nreferenceは「借りている」状態。借りた元のデータが消えたら、referenceも使えなくなります。\n\nFor example：\n- 図書館で借りた本 → 図書館が閉まったら読めない\n- referenceで借りたデータ → 元のデータが消えたら使えない\n\nライフタイムは「このreferenceはこの範囲で有効だよ」とコンパイラに伝える仕組みです。",
    "rust_lesson1_ex1_slide1_title": "Rust（ラスト）?",
    "rust_lesson1_ex2_slide2_title": "計算の記号（operator）",
    "rust_lesson4_ex5_slide2_content": "# get で安全に取り出す\n\n`get()` methodでvalueを取り出せます。見つからない可能性があるので、`Option` が返ってきます。\n\ncodeExample：\n```rust\n// getはOption<&V>を返す\nif let Some(score) = scores.get(\"Blue\") {\n    println!(\"青チームは{}点\", score);\n}\n```\n\nPoint：\n- keyがあれば `Some(値)` が返る\n- keyがなければ `None` が返る\n- `if let` で安全に取り出せる\n\n存在しないkeyでアクセスしてもprogramが落ちない！",
    "rust_lesson4_ex7_slide1_title": "match ガード?",
    "rust_lesson3_title": "Rust III - ライフタイムとiterator",
    "rust_lesson4_ex3_title": "Box<T>",
    "rust_lesson1_ex4_slide1_title": "累算assignmentoperator（るいさんだいにゅう）?",
    "rust_lesson2_ex9_comment1": "trait でトレイトをdefinition",
    "rust_lesson2_ex1_description": "Rust独自の概念「所有権」を学びましょう。",
    "rust_lesson2_ex3_slide3_content": "参照先の値を変更できる「可変参照」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex1_slide3_title": "Let's Try It!",
    "rust_lesson3_ex6_slide2_title": "様々な畳み込み",
    "rust_lesson4_ex9_slide3_title": "Let's Try It!",
    "rust_lesson2_ex5_title": "impl でmethodを追加",
    "rust_lesson2_ex6_slide1_content": "# 複数の選択肢\n\nenum は、valueがいくつかの種類のうちの一つであることを表します。各バリアントにデータを持たせることもできます。",
    "rust_lesson2_ex4_comment1": "struct で構造体をdefinition",
    "rust_lesson1_ex3_title": "剰余operator（%）",
    "rust_lesson1_ex7_comment1": "colors というベクタをcreate（'あか', 'あお'の順）",
    "rust_lesson1_ex4_slide1_content": "# valueをかんたんに増やす・減らす\n\n`+=`（プラスイコール）と `-=`（マイナスイコール）は、variableの中身を増やしたり減らしたりdo便利な記号です。\n\nRustのImportantなルール：`mut`が必要！\nRustでは、variableをchangeには `let mut`（レット ミュート）とwrite必要があります。`mut` は「mutable（変更できる）」の略です。\n\ncodeExample：\n```rust\nlet mut score = 100;  // mut をつけて変更可能に\nscore += 10;          // 10を足す → 110に\nscore -= 50;          // 50を引く → 60に\n```\n\n`mut` がないと「このvariableは変えちゃダメ！」とRustが怒ります。",
    "rust_lesson2_ex1_slide2_title": "ムーブ（移動）",
    "rust_lesson3_ex4_comment1": "map で各elementを変換",
    "rust_lesson3_ex8_slide1_title": "unwrap_or ?",
    "rust_lesson2_ex5_slide1_content": "# implementationブロック\n\nimpl ブロックで、構造体にmethodを追加できます。`self` で自分自身をreferenceします。",
    "rust_lesson2_ex10_slide1_title": "ジェネリクス?",
    "rust_lesson1_ex8_slide2_content": "# 名前（key）で取り出す\n\ndictionaryに入れたデータは、名前（key）を指定して取り出せます。\n\ncodeExample：\n```rust\nuse std::collections::HashMap;\nfn main() {\n    let mut fruits = HashMap::new();\n    fruits.insert(\"りんご\", \"あか\");  // 追加\n    fruits.insert(\"バナナ\", \"きいろ\");  // 追加\n    \n    println!(\"{}\", fruits[\"りんご\"]);  // あか と表示\n}\n```\n\nPoint：\n- `insert(名前, データ)` で追加\n- `辞書[名前]` で取り出し\n- 番号ではなく「名前」で探せるのが便利！",
    "rust_lesson4_ex9_slide1_content": "# iteratorをコレクションに\n\ncollect は、iteratorをVecやHashMapなどに変換します。\n\n```rust\nlet v: Vec<_> = (0..5).collect();\nlet s: String = vec!['a', 'b'].into_iter().collect();\n```",
    "rust_lesson2_ex2_slide3_content": "所有権を移さずに値を借りる「参照」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex2_slide3_content": "周囲の変数を使える無名関数「クロージャ」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex4_slide2_content": "# struct keyワードでdefinition\n\n`struct 名前 { フィールド }` で構造体をdefine。フィールドには名前とtypeをwrite。\n\ncodeExample：\n```rust\n// Point 構造体を定義\nstruct Point {\n    x: i32,  // xフィールド（整数）\n    y: i32,  // yフィールド（整数）\n}\n\n// 使い方\nlet p = Point { x: 10, y: 20 };\nprintln!(\"x={}, y={}\", p.x, p.y);\n```\n\nPoint：\n- `struct 名前` で構造体をcreate\n- `{ フィールド名: 型 }` でどんなデータを持つか決める\n- `.フィールド名` でアクセス",
    "rust_lesson2_ex10_slide3_content": "型を後から決められる「ジェネリクス」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex6_slide3_title": "Let's Try It!",
    "rust_lesson4_ex6_slide1_content": "# 一意なvalueのset\n\nHashSet は、重複のないvalueのsetです。\n\n```rust\nuse std::collections::HashSet;\n\nlet mut set = HashSet::new();\nset.insert(1);\nset.insert(2);\nset.insert(1); // 重複は無視\n```",
    "rust_lesson4_ex2_title": "derive 属性",
    "rust_lesson4_ex2_slide1_content": "# トレイトを「自動で」implementation\n\n#[derive(...)] をuseと、よくuseトレイトを自分で書かなくても自動でimplementationしてくれます。\n\nFor example：\n構造体を `println!` でdisplayしたいとき、普通は Display トレイトをimplementationdo必要がありますが、`#[derive(Debug)]` をwriteだけでOK！\n\ncodeExample：\n```rust\n#[derive(Debug)]  // Debug トレイトを自動実装\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nlet p = Point { x: 1, y: 2 };\nprintln!(\"{:?}\", p);  // Point { x: 1, y: 2 }\n```",
    "rust_lesson1_ex6_slide2_title": "Let's Try It!",
    "rust_lesson3_ex3_slide2_title": "3つの iter method",
    "rust_lesson4_ex7_slide2_content": "# 複雑なconditional\n\n```rust\nmatch Some(5) {\n    Some(x) if x % 2 == 0 => println!(\"even\"),\n    Some(x) => println!(\"odd: {}\", x),\n    None => println!(\"none\"),\n}\n```",
    "rust_lesson3_ex3_slide1_content": "# elementを1つずつ取り出す仕組み\n\niterator は、ベクタなどのデータを「1つずつ順番に」取り出す仕組みです。\n\nFor example：\n- 行列に並んでいる人を1人ずつ呼ぶ\n- 引き出しの中身を1つずつ出す\n\ncodeExample：\n```rust\nlet v = vec![1, 2, 3];\nfor x in v.iter() {\n    println!(\"{}\", x);  // 1, 2, 3 と順番に表示\n}\n```\n\n`iter()` で「順番に取り出す準備」をして、`for` で1つずつ処理します。",
    "rust_lesson3_ex3_slide1_title": "iterator?",
    "rust_lesson4_ex2_description": "トレイトを自動implementationdoderiveを学びましょう。",
    "rust_lesson3_ex4_slide1_content": "# 全部を同じように変換do\n\n**map** は、iteratorの各elementを「同じ方法で」変換します。\n\nFor example：\n- 全員の身長を2倍にdo\n- 全員の名前を大文字にdo\n- 全部の数を2乗do\n\ncodeExample：\n```rust\nlet v = vec![1, 2, 3];\nlet doubled: Vec<_> = v.iter()\n    .map(|x| x * 2)  // 各要素を2倍に\n    .collect();      // ベクタに戻す\n// [2, 4, 6]\n```\n\n`|x| x * 2` は「xを受け取って、x*2をreturn」closureです。",
    "rust_lesson1_ex3_slide1_title": "あまりを求める",
    "rust_lesson3_ex10_slide1_content": "# 所有権の違い\n\nString は所有権を持つheap上のstring、&str はreferenceです。\n\n```rust\nlet s1: String = String::from(\"hello\");\nlet s2: &str = \"hello\";\n```",
    "rust_lesson4_ex2_slide1_title": "derive（デライブ）?",
    "rust_lesson2_ex2_comment1": "& でreferenceを渡す",
    "rust_lesson4_ex5_slide1_title": "HashMap（ハッシュmap）?",
    "rust_lesson2_ex3_slide2_title": "&mut  Usage",
    "rust_lesson3_ex5_title": "filter で絞り込み",
    "rust_lesson4_ex3_slide2_title": "いつuse？",
    "rust_lesson2_ex2_title": "referenceと借用",
    "rust_lesson2_ex7_title": "Option<T> で null を安全に",
    "rust_lesson4_ex10_slide3_title": "Let's Try It!",
    "rust_lesson3_ex5_slide3_title": "Let's Try It!",
    "rust_lesson4_ex10_title": "enumerate でindex付き",
    "rust_lesson2_ex2_slide1_content": "# 所有権を渡さずに「借りる」\n\nreference をuseと、所有権を移さずにデータを「見せてもらう」ことができます。\n\nたとえるなら：\n- ムーブ = おもちゃをあげる（自分は使えない）\n- reference = おもちゃを見せる（自分も使える）\n\n作り方：\n`&`（アンパサンド）をつけるとreferenceを作れます。\n\n```rust\nlet s = String::from(\"hello\");\nlet r = &s;  // sを借りる（見せてもらう）\n// s も r も使える！\n```",
    "rust_lesson2_ex5_slide2_content": "# &self をuse\n\nmethodの最初のargumentは `&self` です。\n\ncodeExample：\n```rust\nimpl Rect {\n    fn area(&self) -> i32 {\n        self.width * self.height\n    }\n}\n```",
    "rust_lesson1_ex5_slide2_title": "Let's Try It!",
    "rust_lesson2_ex4_slide3_title": "Let's Try It!",
    "rust_lesson4_ex3_slide3_title": "Let's Try It!",
    "rust_lesson2_ex9_slide3_content": "共通の振る舞いを定義する「トレイト」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex1_slide2_content": "# impl で約束を守る\n\n構造体にトレイトをimplementationdoと、その構造体は「約束を守る」ことになります。\n\ncodeExample：\n```rust\nstruct Person { name: String }\n\nimpl Greet for Person {\n    fn greet(&self) -> String {\n        format!(\"Hello, {}\", self.name)\n    }\n}\n```\n\n読み方：\n- `impl Greet for Person` → 「PersonはGreetをimplementationdo」\n- これでPersonは「あいさつできる」ようになった！",
    "rust_lesson4_ex4_comment1": "clone でreferenceカウントを増やす",
    "rust_lesson3_ex4_slide2_content": "# map だけではexecuteされない！\n\nRustのiteratorは 遅延評価 といって、「本当に必要になるまで処理しない」仕組みです。\n\nなぜ？\n無駄な計算を省けるから。100万件あっても、最初の10件だけ欲しいなら10件だけ処理すればいい。\n\ncollect() でexecute：\n```rust\n// これだけでは何も起きない\nv.iter().map(|x| x * 2);\n\n// collect() で実行してベクタに変換\nlet result: Vec<_> = v.iter().map(|x| x * 2).collect();\n```\n\n`collect()` は「今すぐ全部処理してResultをちょうだい」という意味です。",
    "rust_lesson2_ex4_slide2_title": "struct のdefinitionのしかた",
    "rust_lesson2_ex3_slide1_content": "# 「書き換えできる」借り方\n\n普通のreference `&` は「見るだけ」ですが、可変reference `&mut` は「変更もできる」借り方です。\n\nたとえるなら：\n- `&` = 本を見せてもらう（readだけ）\n- `&mut` = ノートを借りる（writeOK）\n\nImportantなルール：\n- 可変referenceは同時に1つだけ！\n- 「みんなで見る」か「1人でwrite」かのどちらか\n\nこのルールで、データが同時に書き換えられるバグを防いでいます。",
    "rust_lesson2_ex10_slide3_title": "Let's Try It!",
    "rust_lesson2_ex4_title": "構造体をdefinitionしよう",
    "rust_lesson3_ex10_slide2_content": "# 相互変換\n\n```rust\n// &str -> String\nlet s = \"hello\".to_string();\n\n// String -> &str\nlet slice: &str = &s;\n```",
    "rust_lesson4_ex10_slide3_content": "イテレータにインデックスを付けましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex4_slide2_content": "# 「何人が持っているか」を数える\n\nRcは「今何人がこのデータを持っているか」を数えています。\n\ncodeExample：\n```rust\nlet a = Rc::new(5);\nprintln!(\"{}\", Rc::strong_count(&a));  // 1\n\nlet b = Rc::clone(&a);\nprintln!(\"{}\", Rc::strong_count(&a));  // 2\n```\n\nいつデータが消える？\n- カウントが0になったとき（誰も持っていないとき）\n- 最後の持ち主がいなくなると自動で片付けられる\n\n`Rc::clone` は「持ち主を1人増やす」操作です。",
    "rust_lesson1_ex8_slide2_title": "dictionary Usage",
    "rust_lesson4_ex3_slide1_content": "# データを「heap」に置く箱\n\nBox<T> は、データを「heap」という特別な場所に置くための箱です。\n\nmemoryの2つの場所：\n- stack：小さくて速い。サイズが決まっているデータ向け\n- heap：大きくて柔軟。サイズが大きいor変わるデータ向け\n\ncodeExample：\n```rust\nlet b = Box::new(5);  // 5をヒープに置く\nprintln!(\"{}\", *b);   // *で中身を取り出す → 5\n```\n\n`*` は「箱を開けて中身を見る」操作です。",
    "rust_lesson3_ex2_slide2_title": "closure Syntax",
    "rust_lesson4_ex4_slide1_title": "Rc（アールシー）?",
    "rust_lesson4_ex7_slide1_content": "# 追加条件\n\n**if** でパターンに追加条件をつけられます。\n\n```rust\nmatch x {\n    n if n < 0 => println!(\"negative\"),\n    n if n > 0 => println!(\"positive\"),\n    _ => println!(\"zero\"),\n}\n```",
    "rust_lesson2_ex3_title": "可変reference",
    "rust_lesson3_ex10_comment1": "to_string で String に変換",
    "rust_lesson3_ex10_slide2_title": "変換",
    "rust_lesson3_ex1_description": "referenceの有効期間を表すライフタイムを学びましょう。",
    "rust_lesson3_ex2_slide1_content": "# 名前のない「即席」function\n\nclosure は、名前をつけずにその場でcreatefunctionです。そして特別な能力があります：周りのvariableを使えるのです！\n\nFor example：\n```rust\nlet x = 5;  // 外側の変数\nlet add_x = |n| n + x;  // xを使えるクロージャ\nprintln!(\"{}\", add_x(10));  // 15\n```\n\n普通のfunctionとの違い：\n- 普通のfunction：argumentしか使えない\n- closure：argument + 周りのvariableも使える\n\n「その場の空気を読める」functionというイメージです！",
    "rust_lesson1_ex2_comment1": "x に 10 を入れる",
    "rust_lesson1_ex7_slide3_title": "Let's Try It!",
    "rust_lesson1_ex5_title": "「もし〜なら」で分けましょう",
    "rust_lesson3_ex2_slide3_title": "Let's Try It!",
    "rust_lesson3_ex7_slide2_content": "# 簡潔なerror処理\n\n```rust\n// ? を使わない場合\nmatch result {\n    Ok(v) => v,\n    Err(e) => return Err(e),\n}\n\n// ? を使う\nresult?\n```",
    "rust_lesson3_ex6_slide3_title": "Let's Try It!",
    "rust_lesson4_ex9_slide3_content": "イテレータをコレクションに変換しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex6_description": "elementを1つのvalueにまとめるfoldを学びましょう。",
    "rust_lesson2_ex9_description": "共通の振る舞いをdefine「トレイト」を学びましょう。",
    "rust_lesson2_ex8_comment1": "Ok で成功をreturn",
    "rust_lesson3_ex5_slide2_content": "# filter はreferenceのreferenceを受け取る\n\n`filter` のclosureは、referenceのreference（`&&T`）を受け取ります。そのため、valueをuseには `**x` と2回referenceを外す必要があります。\n\nなぜ？\n- `iter()` はreference（`&T`）をreturn\n- `filter` はそれをFurthermorereferenceで渡す（`&&T`）\n\nSyntax：\n```rust\n// **x で値を取り出す\n.filter(|x| **x > 2)\n\n// または * を引数につける\n.filter(|&x| *x > 2)\n```\n\n最初は混乱しますが、慣れれば大丈夫！",
    "rust_lesson1_ex5_comment1": "> でcompare",
    "rust_lesson2_ex4_description": "関連doデータをまとめる「構造体」を学びましょう。",
    "rust_lesson3_ex5_slide3_content": "条件に合う要素だけを取り出しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex7_slide3_content": "「ベクタ（Vec）」を使うと、たくさんのデータを一つの「長い はこ」にまとめて入れられます。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex5_slide2_title": "valueの取得",
    "rust_lesson3_ex1_slide1_title": "ライフタイム?",
    "rust_lesson1_ex3_comment1": "10 を 3 で割ったあまりをoutput",
    "rust_lesson3_ex1_comment1": "'a でライフタイムをdefinition",
    "rust_lesson3_ex10_slide1_title": "String vs &str",
    "rust_lesson2_title": "Rust II - 所有権とトレイト",
    "rust_lesson2_ex5_slide2_title": "methodのdefinition",
    "rust_lesson4_ex5_comment1": "insert でkeyとvalueを追加",
    "rust_lesson2_ex9_slide1_content": "# 「できること」の約束\n\nトレイト は、「このtypeはこういうことができる」という約束をdefine。\n\nFor example「鳴ける」という約束：\n- 犬は「ワン」と鳴く\n- 猫は「ニャー」と鳴く\n- 両方とも「鳴ける」能力がある\n\nトレイトは「鳴ける動物は、鳴き声を出すmethodを持つ」という約束です。\n\n他の言語とのcomparison：\n- Java: interface\n- TypeScript: interface\n\nに似た概念です。",
    "rust_lesson1_ex2_slide3_title": "Let's Try It!",
    "rust_lesson4_ex8_slide1_content": "# return valueのtypeをabstract化\n\nimpl Trait で、トレイトをimplementationdotypeを返せます。\n\n```rust\nfn make_iter() -> impl Iterator<Item = i32> {\n    vec![1, 2, 3].into_iter()\n}\n```",
    "rust_lesson1_ex2_slide2_content": "# 四則演算（しそくえんざん）\n\nRustでも算数と同じ記号で計算ができます。\n\n4つのBasic記号：\n- +（プラス）: たし算\n- -（マイナス）: ひき算\n- \\*（アスタリスク）: かけ算（×の代わり）\n- /（スラッシュ）: わり算（÷の代わり）\n\ncodeExample：\n```rust\nlet a = 10;\nlet b = 5;\nprintln!(\"{}\", a + b);  // 15 と表示される\n```\n\n`println!` の `{}` は「ここにvalueを入れてね」という目印です。",
    "rust_lesson4_ex9_slide2_content": "# 変換先を指定\n\n```rust\n// ターボフィッシュ構文\nlet v = (0..5).collect::<Vec<_>>();\n\n// 変数の型注釈\nlet v: Vec<i32> = (0..5).collect();\n```",
    "rust_lesson1_ex8_description": "「dictionary（HashMap）」をuseと、名前をつけてデータを保存し、その名前で取り出せます。",
    "rust_lesson4_ex9_slide2_title": "typeHint",
    "rust_lesson3_ex1_title": "ライフタイムのBasic",
    "rust_lesson2_ex5_description": "構造体にmethodをadd「impl」を学びましょう。",
    "rust_lesson4_ex8_comment1": "impl でトレイトをimplementationdotypeをreturn",
    "rust_lesson4_ex8_slide2_title": "argumentにも使える",
    "rust_lesson4_ex7_comment1": "if でマッチガードを追加",
    "rust_lesson2_ex9_slide2_title": "trait のdefinitionとimplementation",
    "rust_lesson4_ex10_slide2_title": "いつuse？",
    "rust_lesson3_ex7_slide2_title": "match の省略形",
    "rust_lesson1_ex6_title": "logicaloperator（&&、||）",
    "rust_lesson3_ex6_comment1": "fold で畳み込み",
    "rust_lesson2_ex6_description": "複数の状態を表す「列挙type（enum）」を学びましょう。",
    "rust_lesson4_ex10_slide1_title": "enumerate（イニュメレート）?",
    "rust_lesson1_ex7_slide1_title": "ベクタ（Vec）?",
    "rust_lesson2_ex6_slide3_content": "複数の状態を表す「列挙型（enum）」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex3_slide3_title": "Let's Try It!",
    "rust_lesson3_ex4_description": "各elementを変換domapを学びましょう。",
    "rust_lesson4_ex1_slide3_title": "Let's Try It!",
    "rust_lesson3_ex9_slide2_title": "mut が必要",
    "rust_lesson1_ex6_slide1_content": "# logicaloperator（ろんりえんざんし）\n\n2つ以上の条件を組み合わせたいときにuse記号です。\n\n2つの記号：\n- `&&`（アンドアンド）：「かつ」＝ 両方とも 正しいとき\n- `||`（オアオア）：「Alsoは」＝ どちらか 正しいとき\n\n身近なExample：\n- 遊園地：「18歳以上 かつ チケットあり」なら乗れる\n- おやつ：「宿題終わった Alsoは お手伝いした」ならOK\n\ncodeExample：\n```rust\nif score >= 70 && bonus > 0 {\n    // 70点以上 かつ ボーナスあり → 合格！\n    println!(\"合格！\");\n}\n```",
    "rust_lesson4_ex4_slide3_content": "参照カウントでデータを共有しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex6_slide3_title": "Let's Try It!",
    "rust_lesson2_ex5_slide3_content": "構造体にメソッドを追加する「impl」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex1_slide3_title": "Let's Try It!",
    "rust_lesson1_ex5_slide1_content": "# programに「判断」させよう\n\nconditional は、「もし〜なら、〇〇do」という判断をprogramにさせる仕組みです。\n\n身近なExample：\n- もし80点以上なら → 「合格！」とdisplay\n- もし雨なら → 傘を持っていく\n- もしHPが0なら → ゲームオーバー\n\nRustで Syntax：\n```rust\nif score > 80 {\n    println!(\"合格！\");\n}\n```\n\n読み方：\n- `if` →「もし」\n- `score > 80` →「スコアが80より大きいなら」\n- `{ }` の中 →「これをやる」",
    "rust_lesson4_ex5_title": "HashMap",
    "rust_lesson1_ex2_slide1_content": "# データを保存do「はこ」\n\nvariable（へんすう） は、数字や文字を入れておける「はこ」のことです。名前をつけて、あとでuseことができます。\n\nFor example：\n- 「りんごの数」というラベルの箱に「5」を入れる\n- あとで「りんごの数」と呼べば「5」が出てくる\n\nRustで Syntax：\n```rust\nlet x = 10;  // xという箱に10を入れる\nprintln!(\"{}\", x);  // xの中身（10）を表示\n```\n\n`let` は「この名前で箱をcreateよ」という意味です。",
    "rust_lesson2_ex4_slide3_content": "関連するデータをまとめる「構造体」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex6_slide1_title": "enum ?",
    "rust_lesson2_ex9_title": "トレイトをdefinitionしよう",
    "rust_lesson2_ex4_slide1_title": "構造体（こうぞうたい）?",
    "rust_lesson4_ex2_slide2_content": "# 覚えておくと便利な5つ\n\nよくusederiveトレイト：\n```rust\nDebug     // {:?} でデバッグ表示できる\nClone     // .clone() でコピーを作れる\nCopy      // 代入時に自動でコピー（小さい型向け）\nPartialEq // == で比較できる\nDefault   // 初期値を自動で作れる\n```\n\n複数指定もOK：\n```rust\n#[derive(Debug, Clone, PartialEq)]\nstruct User {\n    name: String,\n    age: u32,\n}\n```\n\n`Debug` は特によくuse。debug時に構造体の中身を見れて便利！",
    "rust_lesson2_ex1_slide1_content": "# データの「持ち主」を決めるルール\n\n所有権 は、Rust最大のFeatureです。「このデータの持ち主は誰か」をはっきりさせる仕組みです。\n\nルール：\n- データには必ず1人だけ「持ち主」がいる\n- 持ち主がいなくなると、データは自dynamicに片付けられる\n\nたとえるなら：\n- おもちゃは1人しか持てない\n- 持ち主が部屋を出たら、おもちゃは片付けられる\n\nこのルールのおかげで、Rustは「memoryリーク」（データが片付けられないバグ）を防げます！",
    "rust_lesson1_ex3_slide2_title": "Let's Try It!",
    "rust_lesson3_ex1_slide2_title": "なぜ必要？",
    "rust_lesson3_ex1_slide2_content": "# 危険なバグを防ぐ\n\nダングリングreference という危険なバグがあります。これは「もう存在しないデータ」を指し続けているreferenceのことです。\n\nExample：\n```rust\nfn longest<'a>(x: &'a str, y: &'a str) -> &'a str {\n    if x.len() > y.len() { x } else { y }\n}\n```\n\n`'a` の意味：\n- argument `x` と `y` は同じライフタイム `'a` を持つ\n- return valueも同じライフタイム `'a` を持つ\n- In other words「xとyが両方有効な間、return valueも有効」という約束\n\nRustはこれを自動でチェックしてくれます！",
    "rust_lesson4_ex6_slide2_title": "set演算",
    "rust_lesson3_ex7_comment1": "? でerrorを伝播",
    "rust_lesson3_ex2_slide2_content": "# | | でargumentを囲む\n\nclosureは `|引数| 処理` という形でwrite。`||` は「パイプ」と呼ばれます。\n\nいろいろなSyntax：\n```rust\n// 引数なし\n|| println!(\"Hello\")\n\n// 引数あり\n|x, y| x + y\n\n// 複数行のブロック\n|x| {\n    let y = x * 2;\n    y + 1\n}\n```\n\nPoint：\n- argumentを `| |` で囲む（functionの `()` の代わり）\n- typeは省略できることが多い（Rustが推測してくれる）",
    "rust_lesson2_ex7_comment1": "Some でvalueがあることを示す",
    "rust_lesson3_ex4_slide3_content": "各要素を変換するmapを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_title": "Rust (ラスト) に挑戦！",
    "rust_lesson2_ex8_description": "成功と失敗を表す「Result」を学びましょう。",
    "rust_lesson3_ex8_description": "Option/Resultのデフォルトvalueを設定しましょう。",
    "rust_lesson4_ex2_slide3_title": "Let's Try It!",
    "rust_lesson2_ex5_slide3_title": "Let's Try It!",
    "rust_lesson4_ex9_description": "iteratorをコレクションに変換しましょう。",
    "rust_lesson1_ex1_slide2_content": "# println! でscreenにdisplay\n\nRustで文字をscreenにdisplayには、`println!`（プリントラインびっくり）をuse。\n\nPoint：\n- `!` がつくのがRustのFeature（マクロと呼ばれます）\n- programは `fn main() { }` の中にwrite\n- `fn` は「function（function）」の略\n\ncodeExample：\n```rust\nfn main() {\n    println!(\"ヤッホー！\");\n}\n// 「ヤッホー！」と画面に表示される\n```\n\n`println!` の `!` は「マクロ」という特別な機能の印です。今は「おまじない」と思っておけばOK！",
    "rust_lesson3_ex6_slide1_title": "fold ?",
    "rust_lesson4_ex8_slide1_title": "impl Trait ?",
    "rust_lesson1_ex1_slide2_title": "Rustの「おまじない」",
    "rust_lesson3_ex10_description": "stringtypeの違いを理解しましょう。",
    "rust_lesson3_ex7_slide3_content": "エラーを簡潔に伝播させましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex1_comment1": "s1 の所有権を移動",
    "rust_lesson2_ex9_slide1_title": "トレイト?",
    "rust_lesson4_ex6_slide2_content": "# 和set、積setなど\n\n```rust\nset1.union(&set2)\nset1.intersection(&set2)\nset1.difference(&set2)\n```",
    "rust_lesson4_ex5_slide3_content": "キーと値のペアを格納しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex8_slide1_title": "Result（リザルト）?",
    "rust_lesson4_ex1_slide1_content": "# 「できること」の約束\n\nトレイト は、typeが持つべきmethodをdefine仕組みです。\n\nFor example：\n- 「あいさつできる」トレイト → greet() methodを持つ\n- 「displayできる」トレイト → display() methodを持つ\n\ncodeExample：\n```rust\ntrait Greet {\n    fn greet(&self) -> String;  // メソッドの「約束」\n}\n```\n\nこれは「Greetできるtypeは、greet()methodを持つ」という約束です。",
    "rust_lesson4_ex2_slide3_content": "トレイトを自動実装するderiveを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex6_title": "fold で畳み込み",
    "rust_lesson3_ex9_slide3_content": "Vecに要素を追加しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex4_slide1_content": "# 関係あるデータをまとめる「設計図」\n\n構造体（struct） は、いくつかのデータをひとまとめにdo仕組みです。\n\nFor example「点（座標）」のデータ：\n- x座標\n- y座標\n\nこの2つは関係があるので、「Point（点）」としてまとめると便利です。\n\nFor example「人」のデータ：\n- 名前\n- 年齢\n\nこれも「Person（人）」としてまとめられます。\n\n構造体は「こういうデータを持つ」という設計図です。",
    "rust_lesson4_ex1_slide1_title": "トレイト?（復習）",
    "rust_lesson2_ex3_description": "reference先のvalueを変更できる「可変reference」を学びましょう。",
    "rust_lesson2_ex7_slide2_content": "# match で安全に取り出す\n\n`match` を使って「ある場合」と「ない場合」で処理を分けます。\n\ncodeExample：\n```rust\nlet x: Option<i32> = Some(5);  // 値あり\n\nmatch x {\n    Some(n) => println!(\"値は{}です\", n),  // 5\n    None => println!(\"値がありません\"),\n}\n```\n\nなぜ安全？\n- `null` のように「あるつもりでアクセスしたら無かった」errorが起きない\n- 「ない場合」の処理を書かないとコンパイルerrorになる\n- 強制的に両方のケースを考えることになる！",
    "rust_lesson4_ex9_comment1": "collect で Vec に変換",
    "rust_lesson3_ex10_title": "String と &str",
    "rust_lesson2_ex7_slide1_title": "Option（オプション）?",
    "rust_lesson3_ex9_description": "Vecにelementを追加しましょう。",
    "rust_lesson2_ex5_comment1": "impl でmethodをimplementation",
    "rust_lesson3_ex1_slide3_content": "参照の有効期間を表すライフタイムを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex6_slide2_content": "複数の条件を組み合わせる「&&（かつ）」と「||（または）」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex5_comment1": "filter で条件に合うelementを絞り込む",
    "rust_lesson2_ex7_slide3_content": "値があるかないかを表す「Option」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex10_slide3_title": "Let's Try It!",
    "rust_lesson4_ex4_slide3_title": "Let's Try It!",
    "rust_lesson3_ex3_comment1": "iter でiteratorを取得",
    "rust_lesson3_ex6_slide3_content": "要素を1つの値にまとめるfoldを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex7_slide2_title": "ベクタの番号は「0」から！",
    "rust_lesson1_ex5_slide1_title": "conditional（じょうけんぶんき）?",
    "rust_lesson1_ex3_description": "割り算の「あまり」を求める「%」（パーセント）operatorを学びましょう。",
    "rust_lesson1_ex1_slide3_content": "Rustを使って画面に文字を表示してみましょう。println! という特別な関数を使います。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex10_slide2_content": "# <T> でtypeを「あとで決める」\n\nfunction名の後に `<T>` をつけて、`T` を「type」としてuse。\n\ncodeExample：\n```rust\n// Tはどんな型でもOK\nfn first<T>(arr: &[T]) -> &T {\n    &arr[0]  // 最初の要素を返す\n}\n\n// 使い方\nfirst(&[1, 2, 3]);         // Tはi32\nfirst(&[\"a\", \"b\", \"c\"]);   // Tは&str\n```\n\n読み方：\n- `<T>` → 「Tという名前のtypeをuseよ」\n- `T` は慣習で「Type（type）」の頭文字\n- 複数のtypeが必要なら `<T, U>` のようにwrite",
    "rust_lesson3_ex2_comment1": "|x| でclosureのargumentをdefinition",
    "rust_lesson3_ex3_description": "elementを順番に処理doiteratorを学びましょう。",
    "rust_lesson1_ex1_slide3_title": "Let's Try It!",
    "rust_lesson2_ex6_slide2_title": "enum のdefinition",
    "rust_lesson2_ex1_title": "所有権のBasic",
    "rust_lesson4_ex3_slide1_title": "Box（ボックス）?",
    "rust_lesson2_ex1_slide3_content": "Rust独自の概念「所有権」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson3_ex8_slide3_content": "Option/Resultのデフォルト値を設定しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson4_ex7_slide2_title": "使用Example",
    "rust_lesson4_ex10_description": "iteratorにindexを付けましょう。",
    "rust_lesson4_ex9_slide1_title": "collect ?",
    "rust_lesson4_ex10_slide2_content": "# 「何番目か」が必要なとき\n\n番号（index）とelementの両方が必要なときに便利です。\n\ncodeExample：\n```rust\nlet v = vec![10, 20, 30];\nfor (idx, val) in v.iter().enumerate() {\n    println!(\"{}番目の値は{}\", idx, val);\n}\n// 0番目の値は10\n// 1番目の値は20\n// 2番目の値は30\n```\n\nPoint：\n- `(i, x)` でtuple（2つのset）を受け取る\n- `i` にindex、`x` にelementが入る\n- indexは0から始まる",
    "rust_lesson3_ex2_description": "周囲のvariableを使えるanonymous function「closure」を学びましょう。",
    "rust_lesson1_ex4_comment1": "mut で変更可能にdo",
    "rust_lesson1_ex8_slide3_title": "Let's Try It!",
    "rust_lesson1_ex3_slide2_content": "割り算の「あまり」を求める「%」（パーセント）演算子を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex9_slide3_title": "Let's Try It!",
    "rust_lesson3_ex3_title": "iteratorのBasic",
    "rust_lesson3_ex9_title": "Vec のmethod push",
    "rust_lesson1_ex8_comment1": "dictionaryをcreate（keyは'みかん'、valueは'オレンジ'）",
    "rust_lesson1_ex2_comment3": "+ でたし算do",
    "rust_lesson4_ex8_slide2_content": "# ジェネリクスの代わり\n\n```rust\nfn print_all(iter: impl Iterator<Item = i32>) {\n    for x in iter {\n        println!(\"{}\", x);\n    }\n}\n```",
    "rust_lesson2_ex2_slide2_title": "reference Usage",
    "rust_lesson1_ex8_slide3_content": "「辞書（HashMap）」を使うと、名前をつけてデータを保存し、その名前で取り出せます。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex7_slide2_content": "# [ ]で番号を指定して取り出す\n\n`[番号]` で何番目のデータか指定して取り出せます。\n\nImportantなルール：番号は「0」から！\n- 1番目 → `[0]`\n- 2番目 → `[1]`\n- 3番目 → `[2]`\n\ncodeExample：\n```rust\nlet fruits = vec![\"りんご\", \"バナナ\", \"みかん\"];\n//                  ↑0番    ↑1番     ↑2番\nprintln!(\"{}\", fruits[0]);  // りんご\nprintln!(\"{}\", fruits[1]);  // バナナ\n```\n\nプログラミングでは「0から数える」のが世界共通のルールです！",
    "rust_lesson1_ex6_slide1_title": "条件を組み合わせる",
    "rust_lesson2_ex10_slide2_title": "ジェネリックfunction Syntax",
    "rust_lesson1_ex6_description": "複数の条件を組み合わせる「&&（かつ）」と「||（Alsoは）」を学びましょう。",
    "rust_lesson4_ex6_title": "HashSet",
    "rust_lesson2_ex3_slide2_content": "# mut が2か所に必要\n\n変更できるようにdoには、variableとreferenceの両方に `mut` が必要です。\n\ncodeExample：\n```rust\n// 1. 変数を mut で作る\nlet mut s = String::from(\"hello\");\n\n// 2. &mut で可変参照を渡す\nchange(&mut s);\n\nfn change(s: &mut String) {\n    s.push_str(\" world\");  // 変更できる！\n}\n```\n\nPoint：\n- `let mut 変数` でvariableを変更可能に\n- `&mut 変数` で可変referenceをcreate\n- 両方ないと変更できない！",
    "rust_lesson2_ex2_slide1_title": "reference（さんしょう）?",
    "rust_lesson3_ex6_slide2_content": "# 合計、積、結合など\n\n```rust\n// 積\nv.iter().fold(1, |acc, x| acc * x)\n\n// 文字列結合\nwords.iter().fold(String::new(), |acc, s| acc + s)\n```",
    "rust_lesson1_ex1_description": "Rustを使ってscreenに文字をdisplayしてみましょう。println! という特別なfunctionをuse。",
    "rust_lesson3_ex8_slide3_title": "Let's Try It!",
    "rust_lesson4_ex6_description": "一意なvalueのsetを管理しましょう。",
    "rust_lesson2_ex5_slide1_title": "impl ?",
    "rust_lesson1_ex8_title": "名前で引き出す「dictionary」",
    "rust_lesson2_ex7_description": "valueがあるかないかを表す「Option」を学びましょう。",
    "rust_lesson1_ex4_slide2_title": "Let's Try It!",
    "rust_lesson1_ex7_title": "たくさんのデータをまとめましょう「ベクタ」",
    "rust_lesson3_ex7_slide1_content": "# errorの早期リターン\n\n? は、Resultが Err の場合に早期リターンします。\n\n```rust\nfn read_file() -> Result<String, io::Error> {\n    let content = fs::read_to_string(\"file.txt\")?;\n    Ok(content)\n}\n```",
    "rust_lesson3_ex9_slide1_content": "# 末尾に追加\n\npush は、Vecの末尾にelementをadd。\n\n```rust\nlet mut v = vec![1, 2];\nv.push(3);\n// [1, 2, 3]\n```",
    "rust_lesson4_ex8_slide3_content": "トレイトを返す関数を簡潔に書きましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex1_title": "screenにメッセージを出しましょう",
    "rust_lesson2_ex8_slide2_title": "Result  Usage",
    "rust_lesson3_ex2_slide1_title": "closure?",
    "rust_lesson3_ex8_title": "unwrap_or でデフォルトvalue",
    "rust_lesson4_ex10_slide1_content": "# 番号とelementを一緒にもらう\n\nenumerate は、「何番目か」と「そのelement」をsetで取り出せるmethodです。\n\nFor example：\n- 0番目: りんご\n- 1番目: バナナ\n- 2番目: みかん\n\ncodeExample：\n```rust\nfor (i, x) in vec![\"a\", \"b\", \"c\"].iter().enumerate() {\n    println!(\"{}: {}\", i, x);\n}\n// 0: a\n// 1: b\n// 2: c\n```",
    "rust_lesson1_ex7_slide1_content": "# データを並べてまとめる「長い箱」\n\nベクタ（Vec） は、たくさんのデータを順番に並べて入れられる「長い箱」です。\n\nFor example：\n- 買い物listの商品を全部まとめる\n- testの点数を全部まとめる\n- 友だちの名前を全部まとめる\n\n100個でも1000個でも、1つのvariableでまとめて管理できます！\n\n作り方：\n```rust\nlet fruits = vec![\"りんご\", \"バナナ\", \"みかん\"];\n// vec! で ベクタを作る\n```",
    "rust_lesson4_ex8_slide3_title": "Let's Try It!",
    "rust_lesson4_ex7_description": "パターンマッチに条件を追加しましょう。",
    "rust_lesson1_ex4_comment2": "+= で 20 を足す",
    "rust_lesson1_ex2_comment2": "y に 5 を入れる",
    "rust_lesson2_ex3_slide3_title": "Let's Try It!",
    "rust_lesson3_ex4_slide1_title": "map（map）?",
    "rust_lesson1_ex2_slide3_content": "データに名前をつけて保存できる「変数（へんすう）」を使ってみましょう。letで変数を作ります。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson2_ex8_slide2_content": "# match で成功と失敗を分ける\n\n`match` で「成功したら」「失敗したら」の処理を書き分けます。\n\ncodeExample：\n```rust\nfn divide(a: i32, b: i32) -> Result<i32, String> {\n    if b == 0 {\n        return Err(\"0で割れません\".to_string());\n    }\n    Ok(a / b)  // 成功なら答えを返す\n}\n\nmatch divide(10, 2) {\n    Ok(v) => println!(\"答えは{}\", v),\n    Err(e) => println!(\"エラー: {}\", e),\n}\n```\n\nPoint：\n- `Ok(値)` で成功をreturn\n- `Err(エラー)` で失敗をreturn",
    "rust_lesson4_ex3_comment1": "Box::new でheapに格納",
    "rust_lesson4_ex8_description": "トレイトをreturnfunctionを簡潔に書きましょう。",
    "rust_lesson2_ex10_description": "typeを後から決められる「ジェネリクス」を学びましょう。",
    "rust_lesson2_ex3_slide1_title": "可変reference（かへんさんしょう）?",
    "rust_lesson2_ex2_description": "所有権を移さずにvalueを借りる「reference」を学びましょう。",
    "rust_lesson3_ex5_slide2_title": "** にNote！",
    "rust_lesson2_ex2_slide3_title": "Let's Try It!",
    "rust_lesson4_ex3_slide3_content": "ヒープにデータを格納するBoxを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
    "rust_lesson1_ex4_title": "累算assignmentoperator（+=、-=）",
    "rust_lesson3_ex3_slide2_content": "# 借りるか、もらうか\n\n3種類の iter があり、所有権の扱いが違います。\n\n3つの違い：\n```rust\nv.iter()       // 参照で借りる（&T）\nv.iter_mut()   // 変更可能で借りる（&mut T）\nv.into_iter()  // 所有権をもらう（T）\n```\n\n使い分け：\n- `iter()` → 見るだけ（元のベクタも使える）\n- `iter_mut()` → 中身を変更したい\n- `into_iter()` → ベクタごともらう（元は使えない）\n\n普通は `iter()` をuseことが多いです。",
    "rust_lesson2_ex1_slide1_title": "所有権（しょゆうけん）?",
    "rust_lesson4_ex6_slide3_content": "一意な値の集合を管理しましょう。\n\n（When you're ready, select \"Start Lesson\".）"
  },
  "common": {
    "rust_lesson1_ex1_slide1_image": "/illustrations/languages/rust.png",
    "rust_lesson1_ex1_slide2_image": "/illustrations/common/monitor.png",
    "rust_lesson1_ex2_slide1_image": "/illustrations/common/box.png",
    "rust_lesson1_ex2_slide2_image": "/illustrations/common/robot_math.png",
    "rust_lesson1_ex3_slide1_image": "/illustrations/common/robot_math.png",
    "rust_lesson1_ex4_slide1_image": "/illustrations/common/robot_math.png",
    "rust_lesson1_ex5_slide1_image": "/illustrations/common/if.png",
    "rust_lesson1_ex6_slide1_image": "/illustrations/common/if.png",
    "rust_lesson1_ex7_slide1_image": "/illustrations/common/list.png",
    "rust_lesson1_ex8_slide1_image": "/illustrations/common/dict.png",
    "rust_lesson1_ex8_slide2_image": "/illustrations/common/dict.png",
    "rust_lesson2_ex1_slide1_image": "/illustrations/3d/gear.png",
    "rust_lesson2_ex1_slide2_image": "/illustrations/3d/gear.png",
    "rust_lesson2_ex2_slide1_image": "/illustrations/3d_advanced/pointer_arrow.png",
    "rust_lesson2_ex2_slide2_image": "/illustrations/3d_advanced/pointer_arrow.png",
    "rust_lesson2_ex3_slide1_image": "/illustrations/3d_advanced/pointer_arrow.png",
    "rust_lesson2_ex3_slide2_image": "/illustrations/3d/gear.png",
    "rust_lesson2_ex4_slide1_image": "/illustrations/3d_advanced/class_template.png",
    "rust_lesson2_ex4_slide2_image": "/illustrations/3d_advanced/class_template.png",
    "rust_lesson2_ex5_slide1_image": "/illustrations/3d/gear.png",
    "rust_lesson2_ex5_slide2_image": "/illustrations/3d_advanced/class_to_instance.png",
    "rust_lesson2_ex6_slide1_image": "/illustrations/3d_advanced/union_funnel.png",
    "rust_lesson2_ex6_slide2_image": "/illustrations/3d_advanced/union_funnel.png",
    "rust_lesson2_ex7_slide1_image": "/illustrations/3d/gear.png",
    "rust_lesson2_ex7_slide2_image": "/illustrations/3d/gear.png",
    "rust_lesson2_ex8_slide1_image": "/illustrations/3d/gear.png",
    "rust_lesson2_ex8_slide2_image": "/illustrations/3d/gear.png",
    "rust_lesson2_ex9_slide1_image": "/illustrations/3d/gear.png",
    "rust_lesson2_ex9_slide2_image": "/illustrations/3d/gear.png",
    "rust_lesson2_ex10_slide1_image": "/illustrations/3d_advanced/generics_glass.png",
    "rust_lesson2_ex10_slide2_image": "/illustrations/3d/gear.png",
    "rust_lesson3_ex1_slide1_image": "/illustrations/3d/gear.png",
    "rust_lesson3_ex1_slide2_image": "/illustrations/3d/gear.png",
    "rust_lesson3_ex2_slide1_image": "/illustrations/3d_advanced/lambda_spark.png",
    "rust_lesson3_ex2_slide2_image": "/illustrations/3d_advanced/lambda_spark.png",
    "rust_lesson3_ex3_slide1_image": "/illustrations/3d/gear.png",
    "rust_lesson3_ex4_slide1_image": "/illustrations/3d_advanced/comprehension.png",
    "rust_lesson3_ex5_slide1_image": "/illustrations/3d_advanced/comprehension.png",
    "rust_lesson3_ex6_slide1_image": "/illustrations/3d/gear.png",
    "rust_lesson3_ex7_slide1_image": "/illustrations/3d/gear.png",
    "rust_lesson3_ex7_slide2_image": "/illustrations/3d/gear.png",
    "rust_lesson3_ex8_slide1_image": "/illustrations/3d/gear.png",
    "rust_lesson3_ex8_slide2_image": "/illustrations/3d/gear.png",
    "rust_lesson3_ex9_slide1_image": "/illustrations/3d/gear.png",
    "rust_lesson3_ex10_slide1_image": "/illustrations/3d/gear.png",
    "rust_lesson3_ex10_slide2_image": "/illustrations/3d_advanced/comprehension.png",
    "rust_lesson4_ex1_slide1_image": "/illustrations/3d/gear.png",
    "rust_lesson4_ex1_slide2_image": "/illustrations/3d/gear.png",
    "rust_lesson4_ex2_slide1_image": "/illustrations/3d/gear.png",
    "rust_lesson4_ex3_slide1_image": "/illustrations/3d/gear.png",
    "rust_lesson4_ex3_slide2_image": "/illustrations/3d/gear.png",
    "rust_lesson4_ex4_slide1_image": "/illustrations/3d/gear.png",
    "rust_lesson4_ex4_slide2_image": "/illustrations/3d_advanced/pointer_arrow.png",
    "rust_lesson4_ex5_slide1_image": "/illustrations/3d_advanced/comprehension.png",
    "rust_lesson4_ex5_slide2_image": "/illustrations/3d/gear.png",
    "rust_lesson4_ex6_slide1_image": "/illustrations/3d/gear.png",
    "rust_lesson4_ex6_slide2_image": "/illustrations/3d/gear.png",
    "rust_lesson4_ex7_slide1_image": "/illustrations/3d/gear.png",
    "rust_lesson4_ex7_slide2_image": "/illustrations/3d/gear.png",
    "rust_lesson4_ex8_slide1_image": "/illustrations/3d/gear.png",
    "rust_lesson4_ex9_slide1_image": "/illustrations/3d/gear.png",
    "rust_lesson4_ex10_slide1_image": "/illustrations/3d_advanced/union_funnel.png",
    "rust_lesson3_ex4_slide2_image": "/illustrations/3d/gear.png",
    "rust_lesson4_ex10_slide2_image": "/illustrations/3d/gear.png",
    "rust_lesson3_ex6_slide2_image": "/illustrations/3d/gear.png",
    "rust_lesson4_ex9_slide2_image": "/illustrations/3d/gear.png",
    "rust_lesson4_ex8_slide2_image": "/illustrations/3d/arguments.png",
    "rust_lesson3_ex3_slide2_image": "/illustrations/3d/gear.png",
    "rust_lesson3_ex5_slide2_image": "/illustrations/3d_advanced/pointer_arrow.png",
    "rust_lesson1_ex7_slide2_image": "/illustrations/common/list.png",
    "rust_lesson4_ex2_slide2_image": "/illustrations/3d/gear.png",
    "rust_lesson3_ex9_slide2_image": "/illustrations/3d/gear.png"
  }
}
{
  "cpp_lesson1_course_description": "C言語をもっとパワーアップさせた「C++（シープラスプラス）」のきほんを学びましょう。いろいろな機能を使って、自由にプログラムを作れるようになります。",
  "cpp_lesson1_course_title": "C++ (シープラスプラス) に挑戦！",
  "cpp_lesson1_ex10_comment1": "整数型の変数を宣言し、初期値を代入します。",
  "cpp_lesson1_ex10_comment2": "変数の値を計算して、その結果を同じ変数に再代入します。",
  "cpp_lesson1_ex10_comment3": "80以上 かつ 100以下 ならメッセージを出す",
  "cpp_lesson1_ex10_description": "2つ以上の条件を組み合わせる「&&」と「||」を学びましょう。両方の条件を満たすか、どちらかを満たすかを判定できます。",
  "cpp_lesson1_ex10_slide1_content": "# 引き算バージョン\n\n`-=` を使えば、「今の数字から引いて保存」ができます。\n\n```cpp\nint x = 10;\nx -= 3;  // x から 3 を引いて保存\nstd::cout << x << std::endl;  // => 7\n```",
  "cpp_lesson1_ex10_slide1_title": "-= も使える",
  "cpp_lesson1_ex10_slide2_content": "# 条件の合体技\n\n```cpp\nint age = 15;\nif (age >= 10 && age < 20) {\n    std::cout << \"10代です\" << std::endl;\n}\n```\n\n`&&` は「かつ」、`||` は「または」の意味です。",
  "cpp_lesson1_ex10_slide2_title": "&& と || の使い方",
  "cpp_lesson1_ex10_slide3_content": "2つ以上の条件を組み合わせる「&&」と「||」を学びましょう。両方の条件を満たすか、どちらかを満たすかを判定できます。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "cpp_lesson1_ex10_slide3_title": "やってみよう！",
  "cpp_lesson1_ex10_title": "-= も使える",
  "cpp_lesson1_ex11_comment1": "配列を作る",
  "cpp_lesson1_ex11_comment2": "全部取り出すループ",
  "cpp_lesson1_ex11_comment3": "配列を作る",
  "cpp_lesson1_ex11_comment4": "全部取り出すループ",
  "cpp_lesson1_ex11_description": "複数の項目を組み合わせて、一つの文章として表示してみましょう。",
  "cpp_lesson1_ex11_slide1_content": "# 自動で順番に処理する\n\n同じ作業を何度も繰り返すための仕組みが ループ（繰り返し） です。\n\n身近な例え：\n学校で出席をとるとき、「田中さん」「鈴木さん」「佐藤さん」...と一人ずつ名前を呼びますよね。ループはこの「順番に全員をチェック」する作業を自動でやってくれます。\n\n配列の中身を一つずつ順番に全部チェックしたいときなどに非常に役立ちます。",
  "cpp_lesson1_ex11_slide1_title": "繰り返し（ループ）とは？",
  "cpp_lesson1_ex11_slide2_content": "# for (変数 : コンテナ)\n\nC++には 範囲for文（はんいフォーぶん） という便利なループがあります。\n「はこ（配列）」の中に入っているものを、最初から最後まで順番に取り出せます。\n\n実際のコードを見てみましょう：\n```cpp\nstd::vector<std::string> fruits = {\"Apple\", \"Banana\"};\n// fruits の中身を一つずつ f に入れて繰り返す\nfor (std::string f : fruits) {\n    std::cout << f << std::endl;\n}\n```\n=> Apple と Banana が順番に表示されます\n\n読み方：\n「fruits の中身を、一つずつ f に入れながら繰り返す」\n\nポイント：\nC言語の `for (int i = 0; i < 2; i++)` より、とても簡単に書けます！",
  "cpp_lesson1_ex11_slide2_title": "範囲for文",
  "cpp_lesson1_ex11_slide3_content": "範囲for文という機能を使って、配列の中身を一つずつ順番に表示します。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "cpp_lesson1_ex11_slide3_title": "やってみよう！",
  "cpp_lesson1_ex11_title": "文字と「はこ」を並べましょう",
  "cpp_lesson1_ex12_comment1": "整数型の変数を宣言し、初期値を代入します。",
  "cpp_lesson1_ex12_comment2": "標準出力ストリームに文字列を流し込み、表示します。",
  "cpp_lesson1_ex12_comment3": "include <string>",
  "cpp_lesson1_ex12_comment4": "辞書のはこを作る",
  "cpp_lesson1_ex12_comment5": "キーを指定して表示する",
  "cpp_lesson1_ex12_description": "std::map（辞書）を使って、名前を指定してデータを取り出してみましょう。",
  "cpp_lesson1_ex12_slide1_content": "# ガチャンと連結！\n\n`<<` を何回も使うことで、文字やはこの中身をどんどん繋げることができます。\n\n**コード例：**\n```cpp\nint hour = 15;\nstd::cout << \\\"今は \\\" << hour << \\\" 時です\\\" << std::endl;\n```\n=> 今は 15 時です",
  "cpp_lesson1_ex12_slide1_title": "<< でつなげましょう",
  "cpp_lesson1_ex12_slide2_content": "# キーと値（あたい）のペア\n\n`map` では「キー（名前）」と「値（データ）」をセットで保存します。\n\n実際のコードを見てみましょう：\n```cpp\n#include <map>\n#include <string>\n\n// 「文字列」をキーに、「文字列」を値にする辞書\nstd::map<std::string, std::string> colors;\ncolors[\"りんご\"] = \"あか\";  // りんご→あか と登録\nstd::cout << colors[\"りんご\"] << std::endl;\n```\n=> あか と表示されます\n\n書き方のルール：\n`std::map<キーの型, 値の型>` のように、`< >` の中に2つの型を書きます。\n\nポイント：\n配列は「番号」でアクセスしますが、`map` は「名前（キー）」でアクセスします。",
  "cpp_lesson1_ex12_slide2_title": "std::map",
  "cpp_lesson1_ex12_slide3_content": "std::map（辞書）を使って、名前を指定してデータを取り出してみましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "cpp_lesson1_ex12_slide3_title": "やってみよう！",
  "cpp_lesson1_ex12_title": "<< でつなげましょう",
  "cpp_lesson1_ex13_comment1": "関数を実行する",
  "cpp_lesson1_ex13_comment2": "関数を実行する",
  "cpp_lesson1_ex13_description": "vector（ベクター）という機能を使うと、データの数を自由に変えられる「便利な配列」が作れます。",
  "cpp_lesson1_ex13_slide1_content": "# オリジナルの技を作ろう\n\n何度も使う手順をまとめて名前をつけたものを 関数（かんすう） と呼びます。\n\n身近な例え：\n「朝の準備」という言葉を聞くと、「起きる→顔を洗う→着替える→ご飯を食べる」という一連の動作を思い浮かべますよね。\n\n関数も同じです！「sayHello」と呼ぶだけで、中に書いた処理を全部やってくれます。\n\n一度作れば、「アレやって！」と名前を呼ぶだけで何度でも実行できる、便利なショートカットのようなものです。",
  "cpp_lesson1_ex13_slide1_title": "関数（かんすう）とは？",
  "cpp_lesson1_ex13_slide2_content": "# 関数の定義（ていぎ）\n\nやりたいことをひとまとめにして、名前をつけることができます。\n一度作っておけば、呼び出すだけでいつでも動かせます。\n\n実際のコードを見てみましょう：\n```cpp\n// 「sayHello」という関数を作る（定義する）\nvoid sayHello() {\n    std::cout << \"ハロー！\" << std::endl;\n}\n\n// mainの中で呼び出し（使う）\nsayHello();  // これで「ハロー！」と表示される\n```\n\n用語解説：\n- `void`（ボイド）: 「何も返さない」という意味\n- `()`: 関数名のあとに必ずつける丸かっこ\n- `{}`: この中に実行したい処理を書く",
  "cpp_lesson1_ex13_slide2_title": "手順をまとめる",
  "cpp_lesson1_ex13_slide3_content": "一連の手順をまとめて、名前をつけた「関数（かんすう）」を作ってみましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "cpp_lesson1_ex13_slide3_title": "やってみよう！",
  "cpp_lesson1_ex13_title": "自由に伸びる「はこ」vector",
  "cpp_lesson1_ex14_comment1": "可変長配列（ベクター）ライブラリを読み込み、使用可能にします。",
  "cpp_lesson1_ex14_comment2": "文字列クラスライブラリを読み込み、使用可能にします。",
  "cpp_lesson1_ex14_comment3": "{\\\"りんご\\\", \\\"バナナ\\\"} と入力して初期化します。",
  "cpp_lesson1_ex14_comment4": "2番目の番号は 1 です。",
  "cpp_lesson1_ex14_slide1_content": "# 書き方のルール\n\n`< >` の中に「何を入れるか」を指定します。\n- `<int>`: 整数を入れる\n- `<std::string>`: 文字列を入れる\n\n**実際のコードを見てみましょう：**\n```cpp\n#include <vector>  // vectorを使う準備\n\n// 文字列を入れる vector を作る\nstd::vector<std::string> items = {\\\"Apple\\\", \\\"Orange\\\"};\nstd::cout << items[0] << std::endl;  // 0番目を表示\n```\n=> Apple と表示されます\n\n**ポイント：**\n- 普通の配列と同じく、番号は0から始まります\n- `items[0]` は1番目の要素「Apple」です",
  "cpp_lesson1_ex14_slide1_title": "std::vector",
  "cpp_lesson1_ex14_title": "std::vector",
  "cpp_lesson1_ex15_description": "点数によって表示するメッセージを変えてみましょう。",
  "cpp_lesson1_ex15_title": "「もし〜なら」で分けましょう",
  "cpp_lesson1_ex16_comment1": "整数型の変数を宣言し、初期値を代入します。",
  "cpp_lesson1_ex16_comment2": "条件式（変数と数値の比較など）を評価し、真の場合にブロックを実行します。",
  "cpp_lesson1_ex16_comment3": "標準出力ストリームに文字列を流し込み、表示します。",
  "cpp_lesson1_ex16_slide1_content": "# ( ) と { } を使いましょう\n\nC++でも、`if (条件)` のあとに `{ }` を入力して、その中にやりたいことを入力します。\n\n**コード例：**\n```cpp\nint temp = 30;\nif (temp > 25) {\n    std::cout << \\\"暑いですね\\\" << std::endl;\n}",
  "cpp_lesson1_ex16_slide1_title": "if文",
  "cpp_lesson1_ex16_title": "if文",
  "cpp_lesson1_ex17_description": "else（エルス）を使って、「そうでなければ」の動きを作りましょう。",
  "cpp_lesson1_ex17_title": "ちがう場合はどうしましょう？",
  "cpp_lesson1_ex18_comment1": "整数型の変数を宣言し、初期値を代入します。",
  "cpp_lesson1_ex18_comment2": "条件式（変数と数値の比較など）を評価し、真の場合にブロックを実行します。",
  "cpp_lesson1_ex18_comment3": "標準出力ストリームに文字列を流し込み、表示します。",
  "cpp_lesson1_ex18_comment4": "もし条件が満たされなかった場合に実行する処理を記述します。",
  "cpp_lesson1_ex18_comment5": "標準出力ストリームに文字列を流し込み、表示します。",
  "cpp_lesson1_ex18_slide1_content": "# どちらかを選びます\n\n条件に当てはまらないときの動きは `else` を使って入力します。\n\n**コード例 ：**\n```cpp\nint age = 15;\nif (age >= 20) {\n    std::cout << \\\"大人\\\" << std::endl;\n} else {\n    std::cout << \\\"子供\\\" << std::endl;\n}",
  "cpp_lesson1_ex18_slide1_title": "elseブロック",
  "cpp_lesson1_ex18_title": "elseブロック",
  "cpp_lesson1_ex19_description": "2つ以上の条件を組み合わせる「&&」と「||」を学びましょう。両方の条件を満たすか、どちらかを満たすかを判定できます。",
  "cpp_lesson1_ex19_title": "論理演算子（&&、||）",
  "cpp_lesson1_ex1_comment1": "画面にメッセージを出す関数",
  "cpp_lesson1_ex1_comment2": "画面にメッセージを出す関数",
  "cpp_lesson1_ex1_description": "C++を使って画面にメッセージを出してみましょう。std::cout（シーアウト）という関数を使います。",
  "cpp_lesson1_ex1_slide1_content": "# パワフルで高速な言語（げんご）\n\nC++（シープラスプラス）は、C言語を元にしてさらに便利な機能を追加した言語です。\n\n身近な例え：\nC言語が「普通の車」だとしたら、C++は「スーパーカー」のような存在です！速さはそのままに、もっと便利な機能がついています。\n\nどんなところで使われているの？\n- ゲーム（速さが命！）\n- ブラウザ（ChromeやFirefoxなど）\n- 3DCGソフト\n\nなど、スピードが求められる場所で大活躍しています。",
  "cpp_lesson1_ex1_slide1_title": "C++（シープラスプラス）とは？",
  "cpp_lesson1_ex1_slide2_content": "# std::cout（シーアウト）を使おう\n\nC++で画面に文字を出すには、`std::cout`（スタンダード・シーアウト）を使います。\n`cout` は「Character OUTput」（文字を出力）の略です。\n\n`<<` という矢印のような記号を使って、文字を画面の方へ送ります。\n\nイメージ：\n画面 `<<` \"こんにちは\"\n（文字が矢印の方向に流れていくイメージ！）\n\n実際のコードを見てみましょう：\n```cpp\n#include <iostream>  // 入出力を使う準備\nint main() {\n    std::cout << \"C++最高！\" << std::endl;\n    return 0;\n}\n```\n\n用語解説：\n- `std::endl`（エンドエル）: 改行して次の行に進む\n- `#include <iostream>`: 入出力機能を使えるようにする",
  "cpp_lesson1_ex1_slide2_title": "C++への入り口",
  "cpp_lesson1_ex1_slide3_content": "C++を使って画面にメッセージを出してみましょう。std::cout（シーアウト）という関数を使います。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "cpp_lesson1_ex1_slide3_title": "やってみよう！",
  "cpp_lesson1_ex1_title": "画面にメッセージを出しましょう",
  "cpp_lesson1_ex20_comment1": "整数型の変数を宣言し、初期値を代入します。",
  "cpp_lesson1_ex20_comment2": "条件式（変数と数値の比較など）を評価し、真の場合にブロックを実行します。",
  "cpp_lesson1_ex20_comment3": "標準出力ストリームに文字列を流し込み、表示します。",
  "cpp_lesson1_ex20_slide1_content": "# 条件の合体技\n\n```cpp\nint age = 15;\nif (age >= 10 && age < 20) {\n    std::cout << \\\"10代です\\\" << std::endl;\n}\n```\n\n`&&` は「かつ」、`||` は「または」の意味です。",
  "cpp_lesson1_ex20_slide1_title": "&& と || の使い方",
  "cpp_lesson1_ex20_title": "&& と || の使い方",
  "cpp_lesson1_ex21_description": "範囲for文という機能を使って、配列の中身を一つずつ順番に表示します。",
  "cpp_lesson1_ex21_title": "中身を全部出してみましょう",
  "cpp_lesson1_ex22_comment1": "指定された回数や範囲で、繰り返し処理（ループ）を行います。",
  "cpp_lesson1_ex22_slide1_content": "# for (変数 : コンテナ)\n\nC++には **範囲for文（はんいフォーぶん）** という便利なループがあります。\n「はこ（配列）」の中に入っているものを、最初から最後まで順番に取り出せます。\n\n**実際のコードを見てみましょう：**\n```cpp\nstd::vector<std::string> fruits = {\\\"Apple\\\", \\\"Banana\\\"};\n// fruits の中身を一つずつ f に入れて繰り返す\nfor (std::string f : fruits) {\n    std::cout << f << std::endl;\n}\n```\n=> Apple と Banana が順番に表示されます\n\n**読み方：**\n「fruits の中身を、一つずつ f に入れながら繰り返す」\n\n**ポイント：**\nC言語の `for (int i = 0; i < 2; i++)` より、とても簡単に書けます！",
  "cpp_lesson1_ex22_slide1_title": "範囲for文",
  "cpp_lesson1_ex22_title": "範囲for文",
  "cpp_lesson1_ex23_description": "std::map（辞書）を使って、名前を指定してデータを取り出してみましょう。",
  "cpp_lesson1_ex23_title": "名前で探しましょう「じしょ」",
  "cpp_lesson1_ex24_comment1": "名前（キー）として \\\"Math\\\" と入力します。",
  "cpp_lesson1_ex24_comment2": "同じく \\\"Math\\\" と入力してデータを取り出します。",
  "cpp_lesson1_ex24_slide1_content": "# キーと値（あたい）のペア\n\n`map` では「キー（名前）」と「値（データ）」をセットで保存します。\n\n**実際のコードを見てみましょう：**\n```cpp\n#include <map>\n#include <string>\n\n// 「文字列」をキーに、「文字列」を値にする辞書\nstd::map<std::string, std::string> colors;\ncolors[\\\"りんご\\\"] = \\\"あか\\\";  // りんご→あか と登録\nstd::cout << colors[\\\"りんご\\\"] << std::endl;\n```\n=> あか と表示されます\n\n**書き方のルール：**\n`std::map<キーの型, 値の型>` のように、`< >` の中に2つの型を書きます。\n\n**ポイント：**\n配列は「番号」でアクセスしますが、`map` は「名前（キー）」でアクセスします。",
  "cpp_lesson1_ex24_slide1_title": "std::map",
  "cpp_lesson1_ex24_title": "std::map",
  "cpp_lesson1_ex25_description": "一連の手順をまとめて、名前をつけた「関数（かんすう）」を作ってみましょう。",
  "cpp_lesson1_ex25_title": "自分だけの関数を作りましょう",
  "cpp_lesson1_ex26_comment1": "void型の値を返す関数（greet）を定義します。",
  "cpp_lesson1_ex26_comment2": "関数の終わりです。",
  "cpp_lesson1_ex26_comment3": "関数（greet）を呼び出して実行します。",
  "cpp_lesson1_ex26_slide1_content": "# 関数の定義（ていぎ）\n\nやりたいことをひとまとめにして、名前をつけることができます。\n一度作っておけば、呼び出すだけでいつでも動かせます。\n\n**実際のコードを見てみましょう：**\n```cpp\n// 「sayHello」という関数を作る（定義する）\nvoid sayHello() {\n    std::cout << \\\"ハロー！\\\" << std::endl;\n}\n\n// mainの中で呼び出し（使う）\nsayHello();  // これで「ハロー！」と表示される\n```\n\n**用語解説：**\n- `void`（ボイド）: 「何も返さない」という意味\n- `()`: 関数名のあとに必ずつける丸かっこ\n- `{}`: この中に実行したい処理を書く",
  "cpp_lesson1_ex26_slide1_title": "手順をまとめる",
  "cpp_lesson1_ex26_title": "手順をまとめる",
  "cpp_lesson1_ex2_comment1": "標準入出力ストリームを読み込み、使用可能にします。",
  "cpp_lesson1_ex2_comment2": "プログラムの実行開始地点（エントリーポイント）となる関数を定義します。",
  "cpp_lesson1_ex2_comment3": "標準出力ストリームに文字列を流し込み、表示します。",
  "cpp_lesson1_ex2_comment4": "プログラムが正常に終了したことを示す値（通常は0）を返します。",
  "cpp_lesson1_ex2_comment5": "メイン部分の終わりです。",
  "cpp_lesson1_ex2_description": "数字をしまっておく「はこ」を作って、中身を表示してみましょう。",
  "cpp_lesson1_ex2_slide1_content": "# std::cout（シーアウト）を使おう\n\nC++で画面に文字を出すには、`std::cout`（スタンダード・シーアウト）を使います。\n`cout` は「Character OUTput」（文字を出力）の略です。\n\n`<<` という矢印のような記号を使って、文字を画面の方へ送ります。\n\n**イメージ：**\n画面 `<<` \\\"こんにちは\\\"\n（文字が矢印の方向に流れていくイメージ！）\n\n**実際のコードを見てみましょう：**\n```cpp\n#include <iostream>  // 入出力を使う準備\nint main() {\n    std::cout << \\\"C++最高！\\\" << std::endl;\n    return 0;\n}\n```\n\n**用語解説：**\n- `std::endl`（エンドエル）: 改行して次の行に進む\n- `#include <iostream>`: 入出力機能を使えるようにする",
  "cpp_lesson1_ex2_slide1_title": "C++への入り口",
  "cpp_lesson1_ex2_slide2_content": "# 整数（せいすう）のラベル\n\n数字（1, 2, 3 のような整数）を入れたいときは、`int`（イント）というラベルを貼ります。\n`int` は「Integer」（整数）の略です。\n\n実際のコードを見てみましょう：\n```cpp\nint age = 20;  // 「age」という名前のはこに20を入れる\nstd::cout << age << std::endl;  // ageの中身を表示\n```\n=> 20 と表示されます\n\nC言語との違い：\nC言語では `printf(\"%d\", age)` と書いていましたが、C++では `std::cout << age` とシンプルに書けます！",
  "cpp_lesson1_ex2_slide2_title": "数字のラベル int",
  "cpp_lesson1_ex2_slide3_content": "数字をしまっておく「はこ」を作って、中身を表示してみましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "cpp_lesson1_ex2_slide3_title": "やってみよう！",
  "cpp_lesson1_ex2_title": "C++への入り口",
  "cpp_lesson1_ex3_comment1": "はこに数字を入れる",
  "cpp_lesson1_ex3_comment2": "たし算した結果を表示する",
  "cpp_lesson1_ex3_comment3": "たし算した結果を表示する",
  "cpp_lesson1_ex3_description": "数字をしまっておく「はこ」を作って、中身を表示してみましょう。",
  "cpp_lesson1_ex3_slide1_content": "# 高速な計算処理\n\nコンピュータは人間よりもずっと速く計算できます。\nどんなに大きな数字でも、プログラミングで指示を出せば一瞬で解いてくれます。",
  "cpp_lesson1_ex3_slide1_title": "計算はコンピュータにお任せ",
  "cpp_lesson1_ex3_slide2_content": "# 矢印で送ろう\n\n`<<` で繋ぐことで、計算した結果をそのまま画面に出すことができます。\n\nコード例：\n```cpp\nint cookies = 10;\nint friends = 2;\n// クッキー ÷ 友達 の結果を画面へ！\nstd::cout << cookies / friends << std::endl;\n```\n=> 5",
  "cpp_lesson1_ex3_slide2_title": "計算の記号",
  "cpp_lesson1_ex3_slide3_content": "C++を使って、たし算をしてみましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "cpp_lesson1_ex3_slide3_title": "やってみよう！",
  "cpp_lesson1_ex3_title": "数字を入れる「はこ」",
  "cpp_lesson1_ex4_comment1": "整数型の変数を宣言し、初期値を代入します。",
  "cpp_lesson1_ex4_comment2": "はこの名前 x を指定して、表示させます。",
  "cpp_lesson1_ex4_description": "割り算の「あまり」を求める「%」（パーセント）演算子を学びましょう。10を3で割ったあまりは1になります。",
  "cpp_lesson1_ex4_slide1_content": "# 整数（せいすう）のラベル\n\n数字（1, 2, 3 のような整数）を入れたいときは、`int`（イント）というラベルを貼ります。\n`int` は「Integer」（整数）の略です。\n\n**実際のコードを見てみましょう：**\n```cpp\nint age = 20;  // 「age」という名前のはこに20を入れる\nstd::cout << age << std::endl;  // ageの中身を表示\n```\n=> 20 と表示されます\n\n**C言語との違い：**\nC言語では `printf(\\\"%d\\\", age)` と書いていましたが、C++では `std::cout << age` とシンプルに書けます！",
  "cpp_lesson1_ex4_slide1_title": "数字のラベル int",
  "cpp_lesson1_ex4_slide2_content": "# あまりを計算\n\n```cpp\nstd::cout << 10 % 3 << std::endl;  // => 1\n```\n10 ÷ 3 は 3 あまり 1 なので、「1」が表示されます。\n\n```cpp\nstd::cout << 8 % 2 << std::endl;   // => 0\n```\n8 ÷ 2 は 4 あまり 0 なので、「0」になります（割り切れるということです！）",
  "cpp_lesson1_ex4_slide2_title": "% の使い方",
  "cpp_lesson1_ex4_slide3_content": "割り算の「あまり」を求める「%」（パーセント）演算子を学びましょう。10を3で割ったあまりは1になります。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "cpp_lesson1_ex4_slide3_title": "やってみよう！",
  "cpp_lesson1_ex4_title": "数字のラベル int",
  "cpp_lesson1_ex5_comment1": "scoreに50を入れる",
  "cpp_lesson1_ex5_comment2": "10点プラスする",
  "cpp_lesson1_ex5_comment3": "結果を表示",
  "cpp_lesson1_ex5_comment4": "結果を表示",
  "cpp_lesson1_ex5_description": "C++を使って、たし算をしてみましょう。",
  "cpp_lesson1_ex5_slide1_content": "# はこの中身をパワーアップ\n\n「今の点数に10点プラスしたい！」というとき、`+=` を使うと便利です。\nこれは「今の数字に足して、そのまま保存する」という合体技です。\n\n```cpp\nint x = 10;\nx += 5;  // x に 5 を足して保存\nstd::cout << x << std::endl;  // => 15\n```",
  "cpp_lesson1_ex5_slide1_title": "中身を増やしたいとき",
  "cpp_lesson1_ex5_slide2_content": "# 引き算バージョン\n\n`-=` を使えば、「今の数字から引いて保存」ができます。\n\n```cpp\nint x = 10;\nx -= 3;  // x から 3 を引いて保存\nstd::cout << x << std::endl;  // => 7\n```",
  "cpp_lesson1_ex5_slide2_title": "-= も使える",
  "cpp_lesson1_ex5_slide3_content": "変数に値を足したり引いたりして、同じ変数に戻す便利な書き方を学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "cpp_lesson1_ex5_slide3_title": "やってみよう！",
  "cpp_lesson1_ex5_title": "コンピュータで計算しましょう",
  "cpp_lesson1_ex6_comment1": "たし算なので `+` を使います。",
  "cpp_lesson1_ex6_comment2": "文字とはこを並べて表示する",
  "cpp_lesson1_ex6_comment3": "文字とはこを並べて表示する",
  "cpp_lesson1_ex6_description": "複数の項目を組み合わせて、一つの文章として表示してみましょう。",
  "cpp_lesson1_ex6_slide1_content": "# 矢印で送ろう\n\n`<<` で繋ぐことで、計算した結果をそのまま画面に出すことができます。\n\n**コード例：**\n```cpp\nint cookies = 10;\nint friends = 2;\n// クッキー ÷ 友達 の結果を画面へ！\nstd::cout << cookies / friends << std::endl;\n```\n=> 5",
  "cpp_lesson1_ex6_slide1_title": "計算の記号",
  "cpp_lesson1_ex6_slide2_content": "# ガチャンと連結！\n\n`<<` を何回も使うことで、文字やはこの中身をどんどん繋げることができます。\n\nコード例：\n```cpp\nint hour = 15;\nstd::cout << \"今は \" << hour << \" 時です\" << std::endl;\n```\n=> 今は 15 時です",
  "cpp_lesson1_ex6_slide2_title": "<< でつなげましょう",
  "cpp_lesson1_ex6_slide3_content": "複数の項目を組み合わせて、一つの文章として表示してみましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "cpp_lesson1_ex6_slide3_title": "やってみよう！",
  "cpp_lesson1_ex6_title": "計算の記号",
  "cpp_lesson1_ex7_comment1": "くだものの配列（vector）を作る",
  "cpp_lesson1_ex7_comment2": "2番目のデータを表示する",
  "cpp_lesson1_ex7_comment3": "include <string>",
  "cpp_lesson1_ex7_comment4": "くだものの配列（vector）を作る",
  "cpp_lesson1_ex7_comment5": "2番目のデータを表示する",
  "cpp_lesson1_ex7_description": "割り算の「あまり」を求める「%」（パーセント）演算子を学びましょう。10を3で割ったあまりは1になります。",
  "cpp_lesson1_ex7_slide1_content": "# 長さが変わる便利な列\n\nあとから中身を増やしたり減らしたりできる「はこ」の列を 動的配列（どうてきはいれつ） と呼びます。\n\n身近な例え：\n普通の配列は「決まった数のロッカー」ですが、`vector` は「必要に応じて増やせるロッカー」のようなものです。\n\n「伸び縮みする魔法（まほう）の配列」みたいなものです。\nC++では `vector`（ベクター）という機能を使ってこれを作ります。",
  "cpp_lesson1_ex7_slide1_title": "動的配列（どうてきはいれつ）とは？",
  "cpp_lesson1_ex7_slide2_content": "# 書き方のルール\n\n`< >` の中に「何を入れるか」を指定します。\n- `<int>`: 整数を入れる\n- `<std::string>`: 文字列を入れる\n\n実際のコードを見てみましょう：\n```cpp\n#include <vector>  // vectorを使う準備\n\n// 文字列を入れる vector を作る\nstd::vector<std::string> items = {\"Apple\", \"Orange\"};\nstd::cout << items[0] << std::endl;  // 0番目を表示\n```\n=> Apple と表示されます\n\nポイント：\n- 普通の配列と同じく、番号は0から始まります\n- `items[0]` は1番目の要素「Apple」です",
  "cpp_lesson1_ex7_slide2_title": "std::vector",
  "cpp_lesson1_ex7_slide3_content": "vector（ベクター）という機能を使うと、データの数を自由に変えられる「便利な配列」が作れます。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "cpp_lesson1_ex7_slide3_title": "やってみよう！",
  "cpp_lesson1_ex7_title": "剰余演算子（%）",
  "cpp_lesson1_ex8_comment1": "あまりを求める % 演算子を使います。",
  "cpp_lesson1_ex8_comment2": "もし80より大きければ表示する",
  "cpp_lesson1_ex8_comment3": "もし80より大きければ表示する",
  "cpp_lesson1_ex8_description": "点数によって表示するメッセージを変えてみましょう。",
  "cpp_lesson1_ex8_slide1_content": "# あまりを計算\n\n```cpp\nstd::cout << 10 % 3 << std::endl;  // => 1\n```\n10 ÷ 3 は 3 あまり 1 なので、「1」が表示されます。\n\n```cpp\nstd::cout << 8 % 2 << std::endl;   // => 0\n```\n8 ÷ 2 は 4 あまり 0 なので、「0」になります（割り切れるということです！）",
  "cpp_lesson1_ex8_slide1_title": "% の使い方",
  "cpp_lesson1_ex8_slide2_content": "# ( ) と { } を使いましょう\n\nC++でも、`if (条件)` のあとに `{ }` を入力して、その中にやりたいことを入力します。\n\nコード例：\n```cpp\nint temp = 30;\nif (temp > 25) {\n    std::cout << \"暑いですね\" << std::endl;\n}",
  "cpp_lesson1_ex8_slide2_title": "if文",
  "cpp_lesson1_ex8_slide3_content": "点数によって表示するメッセージを変えてみましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "cpp_lesson1_ex8_slide3_title": "やってみよう！",
  "cpp_lesson1_ex8_title": "% の使い方",
  "cpp_lesson1_ex9_comment1": "ageに10を入れる",
  "cpp_lesson1_ex9_comment2": "20さい以上かどうかで分ける",
  "cpp_lesson1_ex9_comment3": "それ以外の場合",
  "cpp_lesson1_ex9_comment4": "それ以外の場合",
  "cpp_lesson1_ex9_description": "変数に値を足したり引いたりして、同じ変数に戻す便利な書き方を学びましょう。",
  "cpp_lesson1_ex9_slide1_content": "# else（エルス）の役割\n\n条件に当てはまらなかったときの別のルートを作るのが else（エルス） です。「もし〜なら」とセットで使うことで、プログラムのルートを2つに分けることができます。",
  "cpp_lesson1_ex9_slide1_title": "それ以外の場合は？",
  "cpp_lesson1_ex9_slide2_content": "# どちらかを選びます\n\n条件に当てはまらないときの動きは `else` を使って入力します。\n\nコード例 ：\n```cpp\nint age = 15;\nif (age >= 20) {\n    std::cout << \"大人\" << std::endl;\n} else {\n    std::cout << \"子供\" << std::endl;\n}",
  "cpp_lesson1_ex9_slide2_title": "elseブロック",
  "cpp_lesson1_ex9_slide3_content": "else（エルス）を使って、「そうでなければ」の動きを作りましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "cpp_lesson1_ex9_slide3_title": "やってみよう！",
  "cpp_lesson1_ex9_title": "累算代入演算子（+=、-=）",
  "cpp_lesson1_title": "C++ (シープラスプラス) に挑戦！",
  "cpp_lesson2_course_description": "C++の真髄「クラス」を使ったオブジェクト指向プログラミングを学びます。継承、テンプレート、スマートポインタなど現代C++の機能を身につけましょう。",
  "cpp_lesson2_course_title": "C++ II - クラスとオブジェクト指向",
  "cpp_lesson2_ex10_comment1": "新しいクラス（Vehicle）を定義します。",
  "cpp_lesson2_ex10_comment2": "void型の値を返す関数（move）を定義します。",
  "cpp_lesson2_ex10_comment3": "新しいクラス（Car）を定義します。",
  "cpp_lesson2_ex10_comment4": "Car は move() を使えます。",
  "cpp_lesson2_ex10_description": "エラーが起きたときに対処する「例外処理」を学びましょう。",
  "cpp_lesson2_ex10_slide1_content": "# : public 親クラス\n\n子クラス名の後に `: public 親クラス名` と書きます。\n\n**実際のコードを見てみましょう：**\n```cpp\n// 親クラス（動物）\nclass Animal {\npublic:\n    void eat() { std::cout << \\\"eating\\\" << std::endl; }\n};\n\n// 子クラス（犬）- Animalを継承\nclass Dog : public Animal {\n    // 何も書かなくても eat() が使える！\n};\n\nDog d;\nd.eat();  // \\\"eating\\\" と表示される（親から継承した機能）\n```\n\n**ポイント：**\n子クラスは、親クラスの `public` な機能を自動的に使えるようになります。",
  "cpp_lesson2_ex10_slide1_title": "継承の書き方",
  "cpp_lesson2_ex10_slide2_content": "# throw で例外を投げる\n\n基本の形：\n- `try { }`: エラーが起きるかもしれない処理\n- `throw`: エラーを「投げる」\n- `catch { }`: 投げられたエラーを「捕まえる」\n\n実際のコードを見てみましょう：\n```cpp\ntry {\n    // エラーを投げる\n    throw \"error!\";\n} catch (const char* e) {\n    // 投げられたエラーを捕まえて処理\n    std::cout << e << std::endl;\n}\n```\n=> \"error!\" と表示されます\n\nポイント：\n- `throw` でエラーを投げると、すぐに `catch` に移動します\n- `catch` でエラーに対処した後、プログラムは続行できます",
  "cpp_lesson2_ex10_slide2_title": "try-catch の使い方",
  "cpp_lesson2_ex10_slide3_content": "エラーが起きたときに対処する「例外処理」を学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "cpp_lesson2_ex10_slide3_title": "やってみよう！",
  "cpp_lesson2_ex10_title": "継承の書き方",
  "cpp_lesson2_ex11_description": "親クラスの関数を子クラスで上書きする「オーバーライド」を学びましょう。",
  "cpp_lesson2_ex11_title": "仮想関数でオーバーライド",
  "cpp_lesson2_ex12_comment1": "virtual をつけて仮想関数にします。",
  "cpp_lesson2_ex12_comment2": "void型の値を返す関数（draw）を定義します。",
  "cpp_lesson2_ex12_comment3": "Circle の draw が呼ばれます。",
  "cpp_lesson2_ex12_slide1_content": "# 仮想関数の仕組み\n\n親クラスで `virtual` をつけた関数は、子クラスで `override` して上書きできます。\n\n**コード例：**\n```cpp\nclass Animal {\npublic:\n    virtual void speak() { std::cout << \\\"...\\\" << std::endl; }\n};\nclass Cat : public Animal {\npublic:\n    void speak() override { std::cout << \\\"meow\\\" << std::endl; }\n};\n```",
  "cpp_lesson2_ex12_slide1_title": "virtual と override",
  "cpp_lesson2_ex12_title": "virtual と override",
  "cpp_lesson2_ex13_description": "型を後から決められる「テンプレート」を学びましょう。",
  "cpp_lesson2_ex13_title": "テンプレートを使おう",
  "cpp_lesson2_ex14_comment1": "T を型パラメータとして定義します。",
  "cpp_lesson2_ex14_comment2": "T型の引数を受け取り、T型を返します。",
  "cpp_lesson2_ex14_comment3": "大きい方を返します。",
  "cpp_lesson2_ex14_comment4": "int型で呼び出されます。",
  "cpp_lesson2_ex14_slide1_content": "# template<typename T>\n\n`template<typename T>`（テンプレート・タイプネーム・ティー）と書くと、`T` が「後から決まる型」を表します。\n\n**実際のコードを見てみましょう：**\n```cpp\n// T はどんな型にもなれる\ntemplate<typename T>\nT add(T a, T b) {\n    return a + b;\n}\n\n// 使うとき、型が自動で決まる\nadd(1, 2);       // T = int として動く\nadd(1.5, 2.5);   // T = double として動く\n```\n\n**ポイント：**\n- `T` は「型のための変数」のようなもの\n- 使われるときに、自動で適切な型に置き換わります\n- 同じコードで、いろいろな型に対応できます！",
  "cpp_lesson2_ex14_slide1_title": "関数テンプレート",
  "cpp_lesson2_ex14_title": "関数テンプレート",
  "cpp_lesson2_ex15_description": "その場で小さな関数を作れる「ラムダ式」を学びましょう。",
  "cpp_lesson2_ex15_title": "ラムダ式を使おう",
  "cpp_lesson2_ex16_comment1": "{ でラムダ式の本体を始めます。",
  "cpp_lesson2_ex16_comment2": "x の2乗を返します。",
  "cpp_lesson2_ex16_comment3": "square(4) で 16 が出力されます。",
  "cpp_lesson2_ex16_slide1_content": "# [ ] ( ) { }\n\nラムダ式は3つの部分でできています：\n- `[]`（キャプチャ）: 外の変数を使うかどうか\n- `()`（引数）: 関数に渡すデータ\n- `{}`（本体）: 実際の処理\n\n**実際のコードを見てみましょう：**\n```cpp\n// ラムダ式を変数 add に入れる\nauto add = [](int a, int b) {\n    return a + b;\n};\n\n// 普通の関数のように使える\nstd::cout << add(2, 3) << std::endl; // 5\n```\n\n**ポイント：**\n- `auto` で受け取る（型は自動で決まる）\n- `[]` から始まるのがラムダ式の目印",
  "cpp_lesson2_ex16_slide1_title": "ラムダ式の書き方",
  "cpp_lesson2_ex16_title": "ラムダ式の書き方",
  "cpp_lesson2_ex17_description": "自動でメモリを解放してくれる「スマートポインタ」を学びましょう。",
  "cpp_lesson2_ex17_title": "スマートポインタ unique_ptr",
  "cpp_lesson2_ex18_comment1": "memoryライブラリを読み込み、使用可能にします。",
  "cpp_lesson2_ex18_comment2": "make_unique でスマートポインタを作ります。",
  "cpp_lesson2_ex18_comment3": "*ptr で中身にアクセスします。",
  "cpp_lesson2_ex18_slide1_content": "# std::make_unique\n\n`std::make_unique<型>()` でスマートポインタを作ります。\n\n**実際のコードを見てみましょう：**\n```cpp\n#include <memory>  // スマートポインタを使う準備\n\n// 整数を入れるスマートポインタを作る\nauto p = std::make_unique<int>(42);\n\n// 中身を見る（*をつける）\nstd::cout << *p << std::endl; // 42\n\n// ここでブロックを抜けると、自動でメモリが解放される！\n```\n\n**用語解説：**\n- `unique_ptr`: 1つのポインタだけが所有する（独占）\n- **スコープを抜ける**: `{ }` の外に出ること\n- 自動解放なので、`delete` を書く必要がない！",
  "cpp_lesson2_ex18_slide1_title": "unique_ptr の使い方",
  "cpp_lesson2_ex18_title": "unique_ptr の使い方",
  "cpp_lesson2_ex19_description": "エラーが起きたときに対処する「例外処理」を学びましょう。",
  "cpp_lesson2_ex19_title": "例外処理 try-catch",
  "cpp_lesson2_ex1_comment1": "include <iostream>",
  "cpp_lesson2_ex1_comment2": "include <string>",
  "cpp_lesson2_ex1_description": "データと機能をまとめた「クラス」を定義してみましょう。",
  "cpp_lesson2_ex1_slide1_content": "# データと機能の設計図（せっけいず）\n\nクラスは、データ（変数）と機能（関数）をひとまとめにした「設計図」です。\n\n身近な例え：\n「犬」の設計図を考えてみましょう。\n- データ: 名前、年齢、毛の色\n- 機能: 吠（ほ）える、走る、食べる\n\nこの設計図（クラス）から、「ポチ」「タロウ」「ハチ」という実際の犬（オブジェクト）を作れます。\n\n設計図は1つでも、そこから何匹でも犬を作れるのがポイントです！",
  "cpp_lesson2_ex1_slide1_title": "クラスとは？",
  "cpp_lesson2_ex1_slide2_content": "# class キーワード\n\n`class`（クラス）を使ってクラスを定義（ていぎ）します。\n`public:`（パブリック）の下に、外から使える部分を書きます。\n\n実際のコードを見てみましょう：\n```cpp\nclass Dog {       // Dogという設計図を作る\npublic:           // ここから下は外から使える\n    std::string name;  // 名前を入れる場所\n};\n\n// 設計図から実際の犬を作る\nDog d;            // dという犬を作成\nd.name = \"Pochi\"; // 名前をつける\n```\n\n用語解説：\n- `public`: 公開（こうかい）という意味。外からアクセスできる\n- `.`（ドット）: オブジェクトの中身にアクセスする記号",
  "cpp_lesson2_ex1_slide2_title": "クラスの定義",
  "cpp_lesson2_ex1_slide3_content": "データと機能をまとめた「クラス」を定義してみましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "cpp_lesson2_ex1_slide3_title": "やってみよう！",
  "cpp_lesson2_ex1_title": "クラスを作ろう",
  "cpp_lesson2_ex20_comment1": "エラーが発生する可能性のある処理をここから記述します。",
  "cpp_lesson2_ex20_comment2": "throw で例外を投げます。",
  "cpp_lesson2_ex20_comment3": "エラー（例外）が発生した場合の処理を記述します。",
  "cpp_lesson2_ex20_comment4": "捕まえた値を表示します。",
  "cpp_lesson2_ex20_slide1_content": "# throw で例外を投げる\n\n**基本の形：**\n- `try { }`: エラーが起きるかもしれない処理\n- `throw`: エラーを「投げる」\n- `catch { }`: 投げられたエラーを「捕まえる」\n\n**実際のコードを見てみましょう：**\n```cpp\ntry {\n    // エラーを投げる\n    throw \\\"error!\\\";\n} catch (const char* e) {\n    // 投げられたエラーを捕まえて処理\n    std::cout << e << std::endl;\n}\n```\n=> \\\"error!\\\" と表示されます\n\n**ポイント：**\n- `throw` でエラーを投げると、すぐに `catch` に移動します\n- `catch` でエラーに対処した後、プログラムは続行できます",
  "cpp_lesson2_ex20_slide1_title": "try-catch の使い方",
  "cpp_lesson2_ex20_title": "try-catch の使い方",
  "cpp_lesson2_ex2_comment1": "新しいクラス（Cat）を定義します。",
  "cpp_lesson2_ex2_comment2": "public: で公開部分を示します。",
  "cpp_lesson2_ex2_comment3": "メンバ変数を定義します。",
  "cpp_lesson2_ex2_comment4": "Cat型のオブジェクトを作ります。",
  "cpp_lesson2_ex2_comment5": "メンバにアクセスします。",
  "cpp_lesson2_ex2_description": "オブジェクトを作るときに自動的に呼ばれる「コンストラクタ」を学びましょう。",
  "cpp_lesson2_ex2_slide1_content": "# class キーワード\n\n`class`（クラス）を使ってクラスを定義（ていぎ）します。\n`public:`（パブリック）の下に、外から使える部分を書きます。\n\n**実際のコードを見てみましょう：**\n```cpp\nclass Dog {       // Dogという設計図を作る\npublic:           // ここから下は外から使える\n    std::string name;  // 名前を入れる場所\n};\n\n// 設計図から実際の犬を作る\nDog d;            // dという犬を作成\nd.name = \\\"Pochi\\\"; // 名前をつける\n```\n\n**用語解説：**\n- `public`: 公開（こうかい）という意味。外からアクセスできる\n- `.`（ドット）: オブジェクトの中身にアクセスする記号",
  "cpp_lesson2_ex2_slide1_title": "クラスの定義",
  "cpp_lesson2_ex2_slide2_content": "# クラス名と同じ名前\n\nコンストラクタには特別なルールがあります：\n1. クラス名と同じ名前にする\n2. 戻り値の型を書かない（voidも書かない）\n\n実際のコードを見てみましょう：\n```cpp\nclass Box {\npublic:\n    int size;        // サイズを入れる場所\n    Box(int s) {     // コンストラクタ（クラス名と同じ）\n        size = s;    // 受け取った値で初期化\n    }\n};\n\nBox b(10);  // Boxを作ると同時にsize=10で初期化！\n```\n\nポイント：\n`Box b(10)` と書くと、コンストラクタが自動で呼ばれ、size に 10 が入ります。",
  "cpp_lesson2_ex2_slide2_title": "コンストラクタの書き方",
  "cpp_lesson2_ex2_slide3_content": "オブジェクトを作るときに自動的に呼ばれる「コンストラクタ」を学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "cpp_lesson2_ex2_slide3_title": "やってみよう！",
  "cpp_lesson2_ex2_title": "クラスの定義",
  "cpp_lesson2_ex3_comment1": "include <iostream>",
  "cpp_lesson2_ex3_comment2": "r.area() でメンバ関数を呼びます",
  "cpp_lesson2_ex3_description": "オブジェクトを作るときに自動的に呼ばれる「コンストラクタ」を学びましょう。",
  "cpp_lesson2_ex3_slide1_content": "# クラスに属する関数\n\nメンバ関数 は、クラスの中で定義される関数です。そのクラスのデータを使った処理ができます。",
  "cpp_lesson2_ex3_slide1_title": "メンバ関数とは？",
  "cpp_lesson2_ex3_slide2_content": "# クラスの中に関数を書く\n\nクラス定義の中に関数を書くと、そのクラスのメンバ関数になります。\n\nコード例：\n```cpp\nclass Circle {\npublic:\n    int radius;\n    int area() {\n        return radius * radius * 3;\n    }\n};\n```",
  "cpp_lesson2_ex3_slide2_title": "メンバ関数の定義",
  "cpp_lesson2_ex3_slide3_content": "クラスの中に関数（メンバ関数）を作ってみましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "cpp_lesson2_ex3_slide3_title": "やってみよう！",
  "cpp_lesson2_ex3_title": "コンストラクタを使おう",
  "cpp_lesson2_ex4_comment1": "メンバ変数です。",
  "cpp_lesson2_ex4_comment2": "コンストラクタはクラス名と同じ Counter です。",
  "cpp_lesson2_ex4_comment3": "引数で受け取った値を設定します。",
  "cpp_lesson2_ex4_comment4": "Counter(5) でオブジェクトを作ります。",
  "cpp_lesson2_ex4_description": "変数の「別名」を作る参照（リファレンス）を学びましょう。",
  "cpp_lesson2_ex4_slide1_content": "# クラス名と同じ名前\n\nコンストラクタには特別なルールがあります：\n1. **クラス名と同じ名前**にする\n2. **戻り値の型を書かない**（voidも書かない）\n\n**実際のコードを見てみましょう：**\n```cpp\nclass Box {\npublic:\n    int size;        // サイズを入れる場所\n    Box(int s) {     // コンストラクタ（クラス名と同じ）\n        size = s;    // 受け取った値で初期化\n    }\n};\n\nBox b(10);  // Boxを作ると同時にsize=10で初期化！\n```\n\n**ポイント：**\n`Box b(10)` と書くと、コンストラクタが自動で呼ばれ、size に 10 が入ります。",
  "cpp_lesson2_ex4_slide1_title": "コンストラクタの書き方",
  "cpp_lesson2_ex4_slide2_content": "# & で参照を作る\n\n型名の後に `&` をつけると参照型になります。参照は宣言時に必ず初期化が必要です。\n\nコード例：\n```cpp\nint x = 10;\nint& ref = x;  // ref は x の別名\nref = 20;      // x も 20 になる\n```",
  "cpp_lesson2_ex4_slide2_title": "参照の使い方",
  "cpp_lesson2_ex4_slide3_content": "変数の「別名」を作る参照（リファレンス）を学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "cpp_lesson2_ex4_slide3_title": "やってみよう！",
  "cpp_lesson2_ex4_title": "コンストラクタの書き方",
  "cpp_lesson2_ex5_comment1": "include <iostream>",
  "cpp_lesson2_ex5_comment2": "Car は move() を使えます",
  "cpp_lesson2_ex5_description": "クラスの中に関数（メンバ関数）を作ってみましょう。",
  "cpp_lesson2_ex5_slide1_content": "# クラスを拡張（かくちょう）する\n\n継承（けいしょう） を使うと、既存（きそん）のクラス（親クラス）の機能を引き継いだ新しいクラス（子クラス）を作れます。\n\n身近な例え：\n「動物」という親クラスがあるとします。\n- 動物は「食べる」「寝る」ができる\n\n「犬」は動物の子クラスです。\n- 犬は動物なので「食べる」「寝る」ができる（親から継承）\n- さらに「吠える」という独自の機能を追加できる\n\n一から作り直さなくても、親の機能を受け継げるので、コードの再利用（さいりよう）に便利です！",
  "cpp_lesson2_ex5_slide1_title": "継承（けいしょう）とは？",
  "cpp_lesson2_ex5_slide2_content": "# : public 親クラス\n\n子クラス名の後に `: public 親クラス名` と書きます。\n\n実際のコードを見てみましょう：\n```cpp\n// 親クラス（動物）\nclass Animal {\npublic:\n    void eat() { std::cout << \"eating\" << std::endl; }\n};\n\n// 子クラス（犬）- Animalを継承\nclass Dog : public Animal {\n    // 何も書かなくても eat() が使える！\n};\n\nDog d;\nd.eat();  // \"eating\" と表示される（親から継承した機能）\n```\n\nポイント：\n子クラスは、親クラスの `public` な機能を自動的に使えるようになります。",
  "cpp_lesson2_ex5_slide2_title": "継承の書き方",
  "cpp_lesson2_ex5_slide3_content": "既存のクラスを元に新しいクラスを作る「継承」を学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "cpp_lesson2_ex5_slide3_title": "やってみよう！",
  "cpp_lesson2_ex5_title": "メンバ関数を作ろう",
  "cpp_lesson2_ex6_comment1": "幅のメンバ変数です。",
  "cpp_lesson2_ex6_comment2": "高さのメンバ変数です。",
  "cpp_lesson2_ex6_comment3": "int型の値を返す関数（area）を定義します。",
  "cpp_lesson2_ex6_comment4": "* を使って掛け算します。",
  "cpp_lesson2_ex6_comment5": "r.area() でメンバ関数を呼びます。",
  "cpp_lesson2_ex6_description": "親クラスの関数を子クラスで上書きする「オーバーライド」を学びましょう。",
  "cpp_lesson2_ex6_slide1_content": "# クラスの中に関数を書く\n\nクラス定義の中に関数を書くと、そのクラスのメンバ関数になります。\n\n**コード例：**\n```cpp\nclass Circle {\npublic:\n    int radius;\n    int area() {\n        return radius * radius * 3;\n    }\n};\n```",
  "cpp_lesson2_ex6_slide1_title": "メンバ関数の定義",
  "cpp_lesson2_ex6_slide2_content": "# 仮想関数の仕組み\n\n親クラスで `virtual` をつけた関数は、子クラスで `override` して上書きできます。\n\nコード例：\n```cpp\nclass Animal {\npublic:\n    virtual void speak() { std::cout << \"...\" << std::endl; }\n};\nclass Cat : public Animal {\npublic:\n    void speak() override { std::cout << \"meow\" << std::endl; }\n};\n```",
  "cpp_lesson2_ex6_slide2_title": "virtual と override",
  "cpp_lesson2_ex6_slide3_content": "親クラスの関数を子クラスで上書きする「オーバーライド」を学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "cpp_lesson2_ex6_slide3_title": "やってみよう！",
  "cpp_lesson2_ex6_title": "メンバ関数の定義",
  "cpp_lesson2_ex7_comment1": "include <iostream>",
  "cpp_lesson2_ex7_comment2": "int型で呼び出されます",
  "cpp_lesson2_ex7_description": "変数の「別名」を作る参照（リファレンス）を学びましょう。",
  "cpp_lesson2_ex7_slide1_content": "# 汎用的（はんようてき）なコード\n\nテンプレートを使うと、どんな型（かた）でも使える汎用的な関数やクラスが作れます。\n\n身近な例え：\n「2つの数を足す」関数を作りたいとき、整数用、小数用...と別々に作るのは大変ですよね。\n\nテンプレートを使えば、型を後から決められる「万能な設計図」が作れます。\n\n1つのコードで、int でも double でも使える！これがテンプレートの力です。",
  "cpp_lesson2_ex7_slide1_title": "テンプレートとは？",
  "cpp_lesson2_ex7_slide2_content": "# template<typename T>\n\n`template<typename T>`（テンプレート・タイプネーム・ティー）と書くと、`T` が「後から決まる型」を表します。\n\n実際のコードを見てみましょう：\n```cpp\n// T はどんな型にもなれる\ntemplate<typename T>\nT add(T a, T b) {\n    return a + b;\n}\n\n// 使うとき、型が自動で決まる\nadd(1, 2);       // T = int として動く\nadd(1.5, 2.5);   // T = double として動く\n```\n\nポイント：\n- `T` は「型のための変数」のようなもの\n- 使われるときに、自動で適切な型に置き換わります\n- 同じコードで、いろいろな型に対応できます！",
  "cpp_lesson2_ex7_slide2_title": "関数テンプレート",
  "cpp_lesson2_ex7_slide3_content": "型を後から決められる「テンプレート」を学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "cpp_lesson2_ex7_slide3_title": "やってみよう！",
  "cpp_lesson2_ex7_title": "参照を使おう",
  "cpp_lesson2_ex8_comment1": "整数型の変数を宣言し、初期値を代入します。",
  "cpp_lesson2_ex8_comment2": "& を使って参照を作ります。",
  "cpp_lesson2_ex8_comment3": "ref を変えると num も変わります。",
  "cpp_lesson2_ex8_comment4": "num が 100 になっています。",
  "cpp_lesson2_ex8_description": "その場で小さな関数を作れる「ラムダ式」を学びましょう。",
  "cpp_lesson2_ex8_slide1_content": "# & で参照を作る\n\n型名の後に `&` をつけると参照型になります。参照は宣言時に必ず初期化が必要です。\n\n**コード例：**\n```cpp\nint x = 10;\nint& ref = x;  // ref は x の別名\nref = 20;      // x も 20 になる\n```",
  "cpp_lesson2_ex8_slide1_title": "参照の使い方",
  "cpp_lesson2_ex8_slide2_content": "# [ ] ( ) { }\n\nラムダ式は3つの部分でできています：\n- `[]`（キャプチャ）: 外の変数を使うかどうか\n- `()`（引数）: 関数に渡すデータ\n- `{}`（本体）: 実際の処理\n\n実際のコードを見てみましょう：\n```cpp\n// ラムダ式を変数 add に入れる\nauto add = [](int a, int b) {\n    return a + b;\n};\n\n// 普通の関数のように使える\nstd::cout << add(2, 3) << std::endl; // 5\n```\n\nポイント：\n- `auto` で受け取る（型は自動で決まる）\n- `[]` から始まるのがラムダ式の目印",
  "cpp_lesson2_ex8_slide2_title": "ラムダ式の書き方",
  "cpp_lesson2_ex8_slide3_content": "その場で小さな関数を作れる「ラムダ式」を学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "cpp_lesson2_ex8_slide3_title": "やってみよう！",
  "cpp_lesson2_ex8_title": "参照の使い方",
  "cpp_lesson2_ex9_comment1": "include <iostream>",
  "cpp_lesson2_ex9_comment2": "include <memory>",
  "cpp_lesson2_ex9_description": "既存のクラスを元に新しいクラスを作る「継承」を学びましょう。",
  "cpp_lesson2_ex9_slide1_content": "# 安全なメモリ管理（かんり）\n\nスマートポインタは、使い終わったら自動的にメモリを解放（かいほう）してくれる便利なポインタです。\n\n身近な例え：\n普通のポインタは「借りた本を自分で返さないといけない」状態です。返し忘れると大変！\n\nスマートポインタは「自動返却システム」がついた本のようなもの。使い終わったら勝手に返してくれます。\n\nメモリリーク（メモリの解放忘れ）を防ぐことができます。",
  "cpp_lesson2_ex9_slide1_title": "スマートポインタとは？",
  "cpp_lesson2_ex9_slide2_content": "# std::make_unique\n\n`std::make_unique<型>()` でスマートポインタを作ります。\n\n実際のコードを見てみましょう：\n```cpp\n#include <memory>  // スマートポインタを使う準備\n\n// 整数を入れるスマートポインタを作る\nauto p = std::make_unique<int>(42);\n\n// 中身を見る（*をつける）\nstd::cout << *p << std::endl; // 42\n\n// ここでブロックを抜けると、自動でメモリが解放される！\n```\n\n用語解説：\n- `unique_ptr`: 1つのポインタだけが所有する（独占）\n- スコープを抜ける: `{ }` の外に出ること\n- 自動解放なので、`delete` を書く必要がない！",
  "cpp_lesson2_ex9_slide2_title": "unique_ptr の使い方",
  "cpp_lesson2_ex9_slide3_content": "自動でメモリを解放してくれる「スマートポインタ」を学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "cpp_lesson2_ex9_slide3_title": "やってみよう！",
  "cpp_lesson2_ex9_title": "継承を学ぼう",
  "cpp_lesson2_title": "C++ II - クラスとオブジェクト指向",
  "cpp_lesson3_course_description": "モダンC++の機能を学びます。スマートポインタ、ムーブセマンティクス、STLアルゴリズムなどを身につけましょう。",
  "cpp_lesson3_course_title": "C++ III - モダンC++",
  "cpp_lesson3_ex10_comment1": "複数の値をまとめて格納する配列（またはリスト）を作成します。",
  "cpp_lesson3_ex10_comment2": "指定された回数や範囲で、繰り返し処理（ループ）を行います。",
  "cpp_lesson3_ex10_description": "外部変数をキャプチャする方法を学びましょう。",
  "cpp_lesson3_ex10_slide1_content": "# {} は型を厳（きび）しくチェック\n\n`{}` を使うと、データが失われる変換（縮小変換）を防いでくれます。\n\n**身近な例え：**\n大きな荷物を小さな箱に無理やり詰めようとすると警告が出るようなものです。\n\n**実際のコードを見てみましょう：**\n```cpp\n// () や = を使った場合\nint x = 3.14;   // OK（でも 3 になる。小数点以下が消える）\nint y(3.14);    // OK（同じく 3 になる）\n\n// {} を使った場合\nint z{3.14};    // エラー！小数点以下が消えるので拒否される\n```\n\n**ポイント：**\n- `()` や `=`: 縮小変換を許可（警告は出るかも）\n- `{}`: 縮小変換を禁止（エラーになる）\n\n`{}` を使うと、意図しないデータ損失を防げて安全です！",
  "cpp_lesson3_ex10_slide1_title": "縮小変換を防ぐ",
  "cpp_lesson3_ex10_slide2_content": "# いろいろなキャプチャ方法\n\nキャプチャにはいくつかの書き方があります。\n\n身近な例え：\n- コピーキャプチャ: 写真を撮って持っていく（元は変わらない）\n- 参照キャプチャ: リモコンを持っていく（元を直接操作できる）\n\n実際のコードを見てみましょう：\n```cpp\nint x = 1, y = 2, z = 3;\n\n[x]      // x だけコピーで持ち込む\n[&x]     // x だけ参照で持ち込む\n[=]      // 全部コピーで持ち込む\n[&]      // 全部参照で持ち込む\n[=, &x]  // 基本コピー、x だけ参照\n[&, x]   // 基本参照、x だけコピー\n```\n\n使い分け：\n- 値を読むだけ → コピー `[x]`\n- 値を変更したい → 参照 `[&x]`\n- たくさんの変数を使う → `[=]` か `[&]`",
  "cpp_lesson3_ex10_slide2_title": "キャプチャの種類",
  "cpp_lesson3_ex10_slide3_content": "外部変数をキャプチャする方法を学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "cpp_lesson3_ex10_slide3_title": "やってみよう！",
  "cpp_lesson3_ex10_title": "縮小変換を防ぐ",
  "cpp_lesson3_ex11_description": "共有所有権のスマートポインタを学びましょう。",
  "cpp_lesson3_ex11_title": "shared_ptr",
  "cpp_lesson3_ex12_comment1": "共有所有権のスマートポインタを作成する関数です。",
  "cpp_lesson3_ex12_comment2": "ポインタの中身を参照するための間接参照演算子です。",
  "cpp_lesson3_ex12_slide1_content": "# make_shared で効率的（こうりつてき）に作成\n\n`shared_ptr` を作るときは、`make_shared` 関数を使うのがオススメです。\n\n**身近な例え：**\n「部品を買ってきて自分で組み立てる」より「完成品を買う」方が楽で効率的ですよね。\n\n**実際のコードを見てみましょう：**\n```cpp\n// オススメの書き方\nauto p = make_shared<int>(100);  // 100という値を持つ共有ポインタ\n\n// 非推奨の書き方（動くけど効率が悪い）\nshared_ptr<int> p(new int(100));\n```\n\n**なぜ make_shared が良いの？**\n- メモリの確保が1回で済む（効率的）\n- 例外安全（エラーが起きてもメモリリークしない）\n- コードがスッキリする\n\n`make_shared<型>(初期値)` の形で覚えましょう！",
  "cpp_lesson3_ex12_slide1_title": "make_shared",
  "cpp_lesson3_ex12_title": "make_shared",
  "cpp_lesson3_ex13_description": "所有権を移動させましょう。",
  "cpp_lesson3_ex13_title": "std::move",
  "cpp_lesson3_ex14_comment1": "文字列型の変数を宣言し、文字列データを代入します。",
  "cpp_lesson3_ex14_comment2": "所有権を別の変数に移動させる関数です。",
  "cpp_lesson3_ex14_slide1_content": "# なぜ move が速いの？\n\n大きなデータを扱うとき、`move` はコピーより圧倒的（あっとうてき）に速いです。\n\n**身近な例え：**\n100冊の本を別の部屋に移したいとき：\n- **コピー**: 1冊ずつコピー機でコピーして運ぶ（遅い！）\n- **ムーブ**: 本棚ごと運ぶ（速い！）\n\n**実際のコードを見てみましょう：**\n```cpp\nvector<int> v1(1000000);  // 100万個の要素を持つベクター\n\n// コピー（遅い）: 100万個の要素を全部コピー\nvector<int> v2 = v1;\n\n// ムーブ（速い）: 内部のポインタだけ移動\nvector<int> v3 = move(v1);\n// v1 は空になる\n```\n\n**使いどころ：**\n- 大きなデータを関数に渡すとき\n- 元のデータをもう使わないとき\n- 効率を重視するとき",
  "cpp_lesson3_ex14_slide1_title": "コピーより効率的",
  "cpp_lesson3_ex14_title": "コピーより効率的",
  "cpp_lesson3_ex15_description": "値があるかもしれない型を表現しましょう。",
  "cpp_lesson3_ex15_title": "std::optional",
  "cpp_lesson3_ex16_comment1": "値があるかもしれない状態を表現できる型です。",
  "cpp_lesson3_ex16_comment2": "値が存在するかどうかを確認するメソッドです。",
  "cpp_lesson3_ex16_slide1_content": "# 値を安全に取り出す方法\n\n`optional` の中身を取り出す前に、「値があるか」をチェックします。\n\n**身近な例え：**\nプレゼントの箱を開ける前に、「中身が入っているか」確認してから開けるようなものです。\n\n**実際のコードを見てみましょう：**\n```cpp\noptional<int> result = find(v, 5);\n\n// 方法1: has_value() でチェック\nif (result.has_value()) {\n    cout << result.value() << endl;  // 中身を取り出す\n}\n\n// 方法2: if文で直接チェック（省略形）\nif (result) {\n    cout << *result << endl;  // * で中身を取り出す\n}\n```\n\n**注意：**\n値がないのに `value()` を呼ぶとエラーになります。必ずチェックしてから使いましょう！",
  "cpp_lesson3_ex16_slide1_title": "値の取得",
  "cpp_lesson3_ex16_title": "値の取得",
  "cpp_lesson3_ex17_description": "固定長配列を安全に使いましょう。",
  "cpp_lesson3_ex17_title": "std::array",
  "cpp_lesson3_ex18_comment1": "複数の値をまとめて格納する配列（またはリスト）を作成します。",
  "cpp_lesson3_ex18_comment2": "指定された回数や範囲で、繰り返し処理（ループ）を行います。",
  "cpp_lesson3_ex18_slide1_content": "# std::array は安全（あんぜん）\n\n普通の配列（C配列）と比べて、`std::array` は安全な機能がついています。\n\n**身近な例え：**\n普通の配列は「存在しない場所」にアクセスしてもエラーを出してくれません（危険！）。`std::array` は「そこにはないよ！」と教えてくれます。\n\n**実際のコードを見てみましょう：**\n```cpp\narray<int, 3> arr = {10, 20, 30};\n\n// サイズを聞ける（C配列にはない機能！）\ncout << arr.size() << endl;  // 3\n\n// 安全なアクセス（at を使う）\narr.at(1);   // OK: 20\narr.at(10);  // エラー！「範囲外」と教えてくれる\n\n// 普通のアクセス（危険）\narr[10];     // 動くけど何が起こるかわからない...\n```\n\n**オススメ：**\n- 安全性を重視するなら `at()` を使う\n- 速度を重視するなら `[]` を使う",
  "cpp_lesson3_ex18_slide1_title": "C配列との違い",
  "cpp_lesson3_ex18_title": "C配列との違い",
  "cpp_lesson3_ex19_description": "外部変数をキャプチャする方法を学びましょう。",
  "cpp_lesson3_ex19_title": "ラムダのキャプチャ",
  "cpp_lesson3_ex1_comment1": "include <iostream>",
  "cpp_lesson3_ex1_description": "コンパイラに型を推論させましょう。",
  "cpp_lesson3_ex1_slide1_content": "# 型（かた）の自動推論（すいろん）\n\nauto（オート）を使うと、コンパイラ（プログラムを翻訳するソフト）が自動で型を判断してくれます。\n\n身近な例え：\n「これはリンゴです」と言わなくても、見ればリンゴだとわかりますよね。`auto` は「見ればわかるでしょ？」とコンパイラに任せる書き方です。\n\n実際のコードを見てみましょう：\n```cpp\nauto x = 42;        // 42は整数 → int型と自動判断\nauto pi = 3.14;     // 3.14は小数 → double型と自動判断\nauto name = \"Alice\"; // 文字列 → const char*型と自動判断\n```\n\nメリット：\n型を書く手間が省けて、コードがスッキリします！",
  "cpp_lesson3_ex1_slide1_title": "auto とは？",
  "cpp_lesson3_ex1_slide2_content": "# 長い型名を省略（しょうりゃく）\n\n`auto` は、型名が長くて書くのが大変なときに特に便利です。\n\nイテレータ（配列の中を順番に見ていくための道具）は型名がとても長いです。\n\n実際のコードを見てみましょう：\n```cpp\nstd::vector<int> v = {1, 2, 3};\n\n// auto がないと...\nstd::vector<int>::iterator it = v.begin();  // 長い！\n\n// auto を使うと...\nauto it = v.begin();  // スッキリ！\n\nfor (auto it = v.begin(); it != v.end(); ++it) {\n    std::cout << *it << std::endl;\n}\n```\n\nポイント：\n型が複雑になるほど、`auto` の便利さがわかります！",
  "cpp_lesson3_ex1_slide2_title": "イテレータで便利",
  "cpp_lesson3_ex1_slide3_content": "コンパイラに型を推論させましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "cpp_lesson3_ex1_slide3_title": "やってみよう！",
  "cpp_lesson3_ex1_title": "auto で型推論",
  "cpp_lesson3_ex20_comment1": "整数型の変数を宣言し、初期値を代入します。",
  "cpp_lesson3_ex20_comment2": "変数をコピーしてラムダ内で使えるようにします。",
  "cpp_lesson3_ex20_slide1_content": "# いろいろなキャプチャ方法\n\nキャプチャにはいくつかの書き方があります。\n\n**身近な例え：**\n- コピーキャプチャ: 写真を撮って持っていく（元は変わらない）\n- 参照キャプチャ: リモコンを持っていく（元を直接操作できる）\n\n**実際のコードを見てみましょう：**\n```cpp\nint x = 1, y = 2, z = 3;\n\n[x]      // x だけコピーで持ち込む\n[&x]     // x だけ参照で持ち込む\n[=]      // 全部コピーで持ち込む\n[&]      // 全部参照で持ち込む\n[=, &x]  // 基本コピー、x だけ参照\n[&, x]   // 基本参照、x だけコピー\n```\n\n**使い分け：**\n- 値を読むだけ → コピー `[x]`\n- 値を変更したい → 参照 `[&x]`\n- たくさんの変数を使う → `[=]` か `[&]`",
  "cpp_lesson3_ex20_slide1_title": "キャプチャの種類",
  "cpp_lesson3_ex20_title": "キャプチャの種類",
  "cpp_lesson3_ex2_comment1": "auto で型を推論させます。",
  "cpp_lesson3_ex2_comment2": "auto で型を推論させます。",
  "cpp_lesson3_ex2_description": "コンテナの要素を簡単に走査しましょう。",
  "cpp_lesson3_ex2_slide1_content": "# 長い型名を省略（しょうりゃく）\n\n`auto` は、型名が長くて書くのが大変なときに特に便利です。\n\n**イテレータ**（配列の中を順番に見ていくための道具）は型名がとても長いです。\n\n**実際のコードを見てみましょう：**\n```cpp\nstd::vector<int> v = {1, 2, 3};\n\n// auto がないと...\nstd::vector<int>::iterator it = v.begin();  // 長い！\n\n// auto を使うと...\nauto it = v.begin();  // スッキリ！\n\nfor (auto it = v.begin(); it != v.end(); ++it) {\n    std::cout << *it << std::endl;\n}\n```\n\n**ポイント：**\n型が複雑になるほど、`auto` の便利さがわかります！",
  "cpp_lesson3_ex2_slide1_title": "イテレータで便利",
  "cpp_lesson3_ex2_slide2_content": "# コピーを避（さ）ける書き方\n\n通常の範囲for文は、要素を「コピー」して取り出します。大きなデータだとコピーに時間がかかります。\n\n身近な例え：\n本を読むとき、毎回コピーを取って読むより、本棚にある本をそのまま読む方が早いですよね。\n\n参照で受け取る書き方：\n```cpp\nfor (const auto& x : v) {\n    // & をつけると「参照」で受け取る（コピーしない）\n    // const をつけると「変更しない」という約束\n    cout << x << endl;\n}\n```\n\n使い分け：\n- `int x` : 小さいデータ（int, charなど）はコピーでOK\n- `const auto& x` : 大きいデータ（string, vectorなど）は参照が効率的\n\n`auto` を使うと型を自動で判断してくれるので便利です！",
  "cpp_lesson3_ex2_slide2_title": "参照で受け取る",
  "cpp_lesson3_ex2_slide3_content": "コンテナの要素を簡単に走査しましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "cpp_lesson3_ex2_slide3_title": "やってみよう！",
  "cpp_lesson3_ex2_title": "イテレータで便利",
  "cpp_lesson3_ex3_comment1": "include <iostream>",
  "cpp_lesson3_ex3_comment2": "nullptr と比較",
  "cpp_lesson3_ex3_description": "コンテナの要素を簡単に走査しましょう。",
  "cpp_lesson3_ex3_slide1_content": "# 型安全（かたあんぜん）なヌル\n\nnullptr（ヌルポインタ）は、「どこも指していないポインタ」を表す特別な値です。\n\n身近な例え：\n住所録に「住所なし」と書きたいとき、空欄にするより「なし」と明記した方が明確ですよね。`nullptr` は「このポインタはどこも指していません」と明示するための値です。\n\n実際のコードを見てみましょう：\n```cpp\nint* p = nullptr;  // pはどこも指していない\nif (p == nullptr) {\n    cout << \"null\" << endl;  // nullと表示される\n}\n```\n\nC++11からは、古い `NULL` より `nullptr` を使うのが推奨されています。",
  "cpp_lesson3_ex3_slide1_title": "nullptr とは？",
  "cpp_lesson3_ex3_slide2_content": "# なぜ nullptr の方が良いの？\n\n古い `NULL` は実は「0」という数字として扱われるため、問題が起きることがあります。\n\n困る例：\n```cpp\nvoid f(int);    // 整数を受け取る関数\nvoid f(int*);   // ポインタを受け取る関数\n\nf(NULL);    // どっちの f() を呼ぶ？→ あいまい！\nf(nullptr); // f(int*) が呼ばれる → 明確！\n```\n\nポイント：\n- `NULL` は「0」という数字に見えることがある\n- `nullptr` は「ポインタ専用のヌル」なので間違いが起きない\n\nモダンC++では、必ず `nullptr` を使いましょう！",
  "cpp_lesson3_ex3_slide2_title": "NULL との違い",
  "cpp_lesson3_ex3_slide3_content": "型安全なヌルポインタを使いましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "cpp_lesson3_ex3_slide3_title": "やってみよう！",
  "cpp_lesson3_ex3_title": "範囲for文",
  "cpp_lesson3_ex4_comment1": "複数の値をまとめて格納する配列（またはリスト）を作成します。",
  "cpp_lesson3_ex4_comment2": "指定された回数や範囲で、繰り返し処理（ループ）を行います。",
  "cpp_lesson3_ex4_description": "コンパイル時定数を定義しましょう。",
  "cpp_lesson3_ex4_slide1_content": "# コピーを避（さ）ける書き方\n\n通常の範囲for文は、要素を「コピー」して取り出します。大きなデータだとコピーに時間がかかります。\n\n**身近な例え：**\n本を読むとき、毎回コピーを取って読むより、本棚にある本をそのまま読む方が早いですよね。\n\n**参照で受け取る書き方：**\n```cpp\nfor (const auto& x : v) {\n    // & をつけると「参照」で受け取る（コピーしない）\n    // const をつけると「変更しない」という約束\n    cout << x << endl;\n}\n```\n\n**使い分け：**\n- `int x` : 小さいデータ（int, charなど）はコピーでOK\n- `const auto& x` : 大きいデータ（string, vectorなど）は参照が効率的\n\n`auto` を使うと型を自動で判断してくれるので便利です！",
  "cpp_lesson3_ex4_slide1_title": "参照で受け取る",
  "cpp_lesson3_ex4_slide2_content": "# コンパイル時 vs 実行時（じっこうじ）\n\n`const` と `constexpr` は似ていますが、違いがあります。\n\n比較：\n```cpp\n// const: 実行時に決まってもOK\nconst int a = getValue();     // 関数を呼んで決まる\n\n// constexpr: コンパイル時に決まっていないとダメ\nconstexpr int b = 10 * 10;    // コンパイル時に100と計算済み\n```\n\nわかりやすく言うと：\n- `const`: 「一度決めたら変えない」（いつ決まるかは問わない）\n- `constexpr`: 「プログラムを動かす前に決まっている」\n\nメリット：\n`constexpr` を使うと、プログラムの実行が速くなり、配列のサイズ指定などにも使えます。",
  "cpp_lesson3_ex4_slide2_title": "const との違い",
  "cpp_lesson3_ex4_slide3_content": "コンパイル時定数を定義しましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "cpp_lesson3_ex4_slide3_title": "やってみよう！",
  "cpp_lesson3_ex4_title": "参照で受け取る",
  "cpp_lesson3_ex5_comment1": "include <iostream>",
  "cpp_lesson3_ex5_comment2": "include <vector>",
  "cpp_lesson3_ex5_description": "型安全なヌルポインタを使いましょう。",
  "cpp_lesson3_ex5_slide1_content": "# {} を使った統一的（とういつてき）な初期化\n\n初期化子（しょきかし）リストは、波括弧（なみかっこ）`{}` を使って値を設定する方法です。\n\n身近な例え：\n買い物リストを作るとき、`{りんご, バナナ, みかん}` のように書くイメージです。配列やベクターにまとめて値を入れられます。\n\n実際のコードを見てみましょう：\n```cpp\nvector<int> v = {1, 2, 3};   // 数字を3つ入れたベクター\nmap<string, int> m = {       // 名前と数字のペアを入れた辞書\n    {\"りんご\", 100},\n    {\"バナナ\", 80}\n};\n```\n\nメリット：\n配列もベクターも同じ書き方で初期化できます！",
  "cpp_lesson3_ex5_slide1_title": "初期化子リストとは？",
  "cpp_lesson3_ex5_slide2_content": "# {} は型を厳（きび）しくチェック\n\n`{}` を使うと、データが失われる変換（縮小変換）を防いでくれます。\n\n身近な例え：\n大きな荷物を小さな箱に無理やり詰めようとすると警告が出るようなものです。\n\n実際のコードを見てみましょう：\n```cpp\n// () や = を使った場合\nint x = 3.14;   // OK（でも 3 になる。小数点以下が消える）\nint y(3.14);    // OK（同じく 3 になる）\n\n// {} を使った場合\nint z{3.14};    // エラー！小数点以下が消えるので拒否される\n```\n\nポイント：\n- `()` や `=`: 縮小変換を許可（警告は出るかも）\n- `{}`: 縮小変換を禁止（エラーになる）\n\n`{}` を使うと、意図しないデータ損失を防げて安全です！",
  "cpp_lesson3_ex5_slide2_title": "縮小変換を防ぐ",
  "cpp_lesson3_ex5_slide3_content": "{}を使った統一的な初期化を学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "cpp_lesson3_ex5_slide3_title": "やってみよう！",
  "cpp_lesson3_ex5_title": "nullptr",
  "cpp_lesson3_ex6_comment1": "型安全なヌルポインタを表すキーワードです。",
  "cpp_lesson3_ex6_comment2": "型安全なヌルポインタを表すキーワードです。",
  "cpp_lesson3_ex6_description": "共有所有権のスマートポインタを学びましょう。",
  "cpp_lesson3_ex6_slide1_content": "# なぜ nullptr の方が良いの？\n\n古い `NULL` は実は「0」という数字として扱われるため、問題が起きることがあります。\n\n**困る例：**\n```cpp\nvoid f(int);    // 整数を受け取る関数\nvoid f(int*);   // ポインタを受け取る関数\n\nf(NULL);    // どっちの f() を呼ぶ？→ あいまい！\nf(nullptr); // f(int*) が呼ばれる → 明確！\n```\n\n**ポイント：**\n- `NULL` は「0」という数字に見えることがある\n- `nullptr` は「ポインタ専用のヌル」なので間違いが起きない\n\nモダンC++では、必ず `nullptr` を使いましょう！",
  "cpp_lesson3_ex6_slide1_title": "NULL との違い",
  "cpp_lesson3_ex6_slide2_content": "# make_shared で効率的（こうりつてき）に作成\n\n`shared_ptr` を作るときは、`make_shared` 関数を使うのがオススメです。\n\n身近な例え：\n「部品を買ってきて自分で組み立てる」より「完成品を買う」方が楽で効率的ですよね。\n\n実際のコードを見てみましょう：\n```cpp\n// オススメの書き方\nauto p = make_shared<int>(100);  // 100という値を持つ共有ポインタ\n\n// 非推奨の書き方（動くけど効率が悪い）\nshared_ptr<int> p(new int(100));\n```\n\nなぜ make_shared が良いの？\n- メモリの確保が1回で済む（効率的）\n- 例外安全（エラーが起きてもメモリリークしない）\n- コードがスッキリする\n\n`make_shared<型>(初期値)` の形で覚えましょう！",
  "cpp_lesson3_ex6_slide2_title": "make_shared",
  "cpp_lesson3_ex6_slide3_content": "共有所有権のスマートポインタを学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "cpp_lesson3_ex6_slide3_title": "やってみよう！",
  "cpp_lesson3_ex6_title": "NULL との違い",
  "cpp_lesson3_ex7_comment1": "include <iostream>",
  "cpp_lesson3_ex7_comment2": "include <string>",
  "cpp_lesson3_ex7_comment3": "include <utility>",
  "cpp_lesson3_ex7_description": "コンパイル時定数を定義しましょう。",
  "cpp_lesson3_ex7_slide1_content": "# 所有権（しょゆうけん）の移動（いどう）\n\nstd::move（ムーブ）は、データの「所有権」を別の変数に移す機能です。\n\n身近な例え：\n引っ越しのようなものです。家具を「コピー」して新しい家に置くのではなく、元の家から「そのまま運び出す」ので速くて効率的。でも元の家は空っぽになります。\n\n実際のコードを見てみましょう：\n```cpp\nstring s1 = \"Hello\";       // s1 に \"Hello\" が入っている\nstring s2 = move(s1);      // s1 の中身を s2 に移動！\n// s1 は空っぽになる\n// s2 に \"Hello\" が入っている\ncout << s2 << endl;        // \"Hello\" と表示される\n```\n\nポイント：\n`move` した後の変数（s1）は使わないようにしましょう。",
  "cpp_lesson3_ex7_slide1_title": "move とは？",
  "cpp_lesson3_ex7_slide2_content": "# なぜ move が速いの？\n\n大きなデータを扱うとき、`move` はコピーより圧倒的（あっとうてき）に速いです。\n\n身近な例え：\n100冊の本を別の部屋に移したいとき：\n- コピー: 1冊ずつコピー機でコピーして運ぶ（遅い！）\n- ムーブ: 本棚ごと運ぶ（速い！）\n\n実際のコードを見てみましょう：\n```cpp\nvector<int> v1(1000000);  // 100万個の要素を持つベクター\n\n// コピー（遅い）: 100万個の要素を全部コピー\nvector<int> v2 = v1;\n\n// ムーブ（速い）: 内部のポインタだけ移動\nvector<int> v3 = move(v1);\n// v1 は空になる\n```\n\n使いどころ：\n- 大きなデータを関数に渡すとき\n- 元のデータをもう使わないとき\n- 効率を重視するとき",
  "cpp_lesson3_ex7_slide2_title": "コピーより効率的",
  "cpp_lesson3_ex7_slide3_content": "所有権を移動させましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "cpp_lesson3_ex7_slide3_title": "やってみよう！",
  "cpp_lesson3_ex7_title": "constexpr",
  "cpp_lesson3_ex8_comment1": "コンパイル時に計算を行うためのキーワードです。",
  "cpp_lesson3_ex8_comment2": "コンパイル時に計算を行うためのキーワードです。",
  "cpp_lesson3_ex8_description": "値があるかもしれない型を表現しましょう。",
  "cpp_lesson3_ex8_slide1_content": "# コンパイル時 vs 実行時（じっこうじ）\n\n`const` と `constexpr` は似ていますが、違いがあります。\n\n**比較：**\n```cpp\n// const: 実行時に決まってもOK\nconst int a = getValue();     // 関数を呼んで決まる\n\n// constexpr: コンパイル時に決まっていないとダメ\nconstexpr int b = 10 * 10;    // コンパイル時に100と計算済み\n```\n\n**わかりやすく言うと：**\n- `const`: 「一度決めたら変えない」（いつ決まるかは問わない）\n- `constexpr`: 「プログラムを動かす前に決まっている」\n\n**メリット：**\n`constexpr` を使うと、プログラムの実行が速くなり、配列のサイズ指定などにも使えます。",
  "cpp_lesson3_ex8_slide1_title": "const との違い",
  "cpp_lesson3_ex8_slide2_content": "# 値を安全に取り出す方法\n\n`optional` の中身を取り出す前に、「値があるか」をチェックします。\n\n身近な例え：\nプレゼントの箱を開ける前に、「中身が入っているか」確認してから開けるようなものです。\n\n実際のコードを見てみましょう：\n```cpp\noptional<int> result = find(v, 5);\n\n// 方法1: has_value() でチェック\nif (result.has_value()) {\n    cout << result.value() << endl;  // 中身を取り出す\n}\n\n// 方法2: if文で直接チェック（省略形）\nif (result) {\n    cout << *result << endl;  // * で中身を取り出す\n}\n```\n\n注意：\n値がないのに `value()` を呼ぶとエラーになります。必ずチェックしてから使いましょう！",
  "cpp_lesson3_ex8_slide2_title": "値の取得",
  "cpp_lesson3_ex8_slide3_content": "値があるかもしれない型を表現しましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "cpp_lesson3_ex8_slide3_title": "やってみよう！",
  "cpp_lesson3_ex8_title": "const との違い",
  "cpp_lesson3_ex9_comment1": "include <iostream>",
  "cpp_lesson3_ex9_comment2": "include <array>",
  "cpp_lesson3_ex9_description": "{}を使った統一的な初期化を学びましょう。",
  "cpp_lesson3_ex9_slide1_content": "# 固定長（こていちょう）の安全な配列\n\nstd::array（アレイ）は、サイズが固定された配列です。普通のC言語の配列より安全で便利な機能がついています。\n\n身近な例え：\n「3つ入りの卵パック」のようなものです。最初から3個入りと決まっていて、後から変えられません。でも「何個入りか」を聞くことができます。\n\n実際のコードを見てみましょう：\n```cpp\narray<int, 5> arr = {1, 2, 3, 4, 5};\n//     ↑型  ↑サイズ（5個入り）\n\ncout << arr.size() << endl;  // 5（サイズを取得できる！）\ncout << arr[0] << endl;      // 1（最初の要素）\n```\n\nポイント：\n`<型, サイズ>` の形式で、サイズは最初に決めます。",
  "cpp_lesson3_ex9_slide1_title": "array とは？",
  "cpp_lesson3_ex9_slide2_content": "# std::array は安全（あんぜん）\n\n普通の配列（C配列）と比べて、`std::array` は安全な機能がついています。\n\n身近な例え：\n普通の配列は「存在しない場所」にアクセスしてもエラーを出してくれません（危険！）。`std::array` は「そこにはないよ！」と教えてくれます。\n\n実際のコードを見てみましょう：\n```cpp\narray<int, 3> arr = {10, 20, 30};\n\n// サイズを聞ける（C配列にはない機能！）\ncout << arr.size() << endl;  // 3\n\n// 安全なアクセス（at を使う）\narr.at(1);   // OK: 20\narr.at(10);  // エラー！「範囲外」と教えてくれる\n\n// 普通のアクセス（危険）\narr[10];     // 動くけど何が起こるかわからない...\n```\n\nオススメ：\n- 安全性を重視するなら `at()` を使う\n- 速度を重視するなら `[]` を使う",
  "cpp_lesson3_ex9_slide2_title": "C配列との違い",
  "cpp_lesson3_ex9_slide3_content": "固定長配列を安全に使いましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "cpp_lesson3_ex9_slide3_title": "やってみよう！",
  "cpp_lesson3_ex9_title": "初期化子リスト",
  "cpp_lesson3_title": "C++ III - モダンC++",
  "cpp_lesson4_course_description": "STLアルゴリズムとC++17以降の機能を学びます。効率的で表現力豊かなコードを書くスキルを身につけましょう。",
  "cpp_lesson4_course_title": "C++ IV - STLアルゴリズムと高度な機能",
  "cpp_lesson4_ex10_comment1": "複数の値をまとめて格納する配列（またはリスト）を作成します。",
  "cpp_lesson4_ex10_comment2": "各要素に関数を適用して変換するアルゴリズムです。",
  "cpp_lesson4_ex10_description": "例外を投げないことを宣言しましょう。",
  "cpp_lesson4_ex10_slide1_content": "# 文字列を大文字（おおもじ）に変換\n\n`transform` は文字列の変換にも使えます。\n\n**身近な例え：**\n「hello」という文字を1文字ずつ大文字スタンプで押し直すイメージです。\n\n**実際のコードを見てみましょう：**\n```cpp\nstring s = \\\"hello\\\";\n\n// 各文字を大文字に変換（結果を同じ場所に上書き）\ntransform(s.begin(), s.end(), s.begin(), ::toupper);\n//        ↑開始    ↑終了    ↑出力先   ↑変換関数\n\ncout << s << endl;  // \\\"HELLO\\\"\n```\n\n**ポイント：**\n- 出力先を元の配列にすれば「上書き」できる\n- `::toupper` は「大文字に変換」する関数",
  "cpp_lesson4_ex10_slide1_title": "使用例",
  "cpp_lesson4_ex10_slide2_content": "# noexcept をつけると何が良いの？\n\n`noexcept` には2つの大きなメリットがあります。\n\nメリット1: プログラムが速くなる\n```cpp\nint add(int a, int b) noexcept {\n    return a + b;\n}\n// コンパイラが「例外処理のコード」を省略できる → 速い！\n```\n\nメリット2: ムーブが安全に使える\n```cpp\nclass MyClass {\npublic:\n    // noexcept をつけると、vectorなどで効率的に使われる\n    MyClass(MyClass&&) noexcept = default;\n};\n```\n\n身近な例え：\nレストランで「この料理はアレルギー物質を含みません」と保証されていれば、安心して注文できますよね。`noexcept` も同じで、「エラーは起きません」と保証することで、周りのコードが安心して使えます。\n\n使いどころ：\n- 単純な計算（足し算、掛け算など）\n- ムーブコンストラクタ、ムーブ代入演算子",
  "cpp_lesson4_ex10_slide2_title": "メリット",
  "cpp_lesson4_ex10_slide3_content": "例外を投げないことを宣言しましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "cpp_lesson4_ex10_slide3_title": "やってみよう！",
  "cpp_lesson4_ex10_title": "使用例",
  "cpp_lesson4_ex11_description": "要素を集約するアルゴリズムを学びましょう。",
  "cpp_lesson4_ex11_title": "std::accumulate",
  "cpp_lesson4_ex12_comment1": "複数の値をまとめて格納する配列（またはリスト）を作成します。",
  "cpp_lesson4_ex12_comment2": "要素を累積して1つの値にまとめるアルゴリズムです。",
  "cpp_lesson4_ex12_slide1_content": "# 足し算以外の計算もできる\n\n4つ目の引数で「どうやってまとめるか」を指定できます。\n\n**身近な例え：**\n「全部足す」だけでなく「全部かける」「最大値を見つける」など、まとめ方を変えられます。\n\n**実際のコードを見てみましょう：**\n```cpp\nvector<int> v = {1, 2, 3, 4, 5};\n\n// 全部かけ算する（初期値は 1）\nint product = accumulate(v.begin(), v.end(), 1,\n    [](int a, int b) { return a * b; });\n// 1 * 1 * 2 * 3 * 4 * 5 = 120\ncout << product << endl;  // 120\n```\n\n**ポイント：**\n- 足し算の初期値は `0`（0 + 1 + 2 + ...）\n- かけ算の初期値は `1`（1 * 1 * 2 * ...）\n- ラムダ式で好きな計算ができる",
  "cpp_lesson4_ex12_slide1_title": "カスタム演算",
  "cpp_lesson4_ex12_title": "カスタム演算",
  "cpp_lesson4_ex13_description": "条件に合う要素を検索しましょう。",
  "cpp_lesson4_ex13_title": "std::find_if",
  "cpp_lesson4_ex14_comment1": "複数の値をまとめて格納する配列（またはリスト）を作成します。",
  "cpp_lesson4_ex14_comment2": "条件に合う最初の要素を検索するアルゴリズムです。",
  "cpp_lesson4_ex14_slide1_content": "# 見つからなかったらどうなる？\n\n条件に合う要素が1つもない場合、`end()` が返されます。\n\n**身近な例え：**\n本棚を全部見ても「赤い本」がなかったら、「本棚の外」を指して「なかったよ」と教えてくれます。\n\n**実際のコードを見てみましょう：**\n```cpp\nvector<int> v = {1, 3, 5, 7};  // 偶数がない！\n\nauto it = find_if(v.begin(), v.end(),\n    [](int x) { return x % 2 == 0; });\n\n// 見つかったかどうかをチェック\nif (it != v.end()) {\n    cout << \\\"Found: \\\" << *it << endl;\n} else {\n    cout << \\\"Not found\\\" << endl;  // これが表示される\n}\n```\n\n**重要：**\n必ず `end()` と比較してから使いましょう！",
  "cpp_lesson4_ex14_slide1_title": "見つからない場合",
  "cpp_lesson4_ex14_title": "見つからない場合",
  "cpp_lesson4_ex15_description": "カスタム比較でソートしましょう。",
  "cpp_lesson4_ex15_title": "std::sort with lambda",
  "cpp_lesson4_ex16_comment1": "複数の値をまとめて格納する配列（またはリスト）を作成します。",
  "cpp_lesson4_ex16_comment2": "要素を並べ替えるアルゴリズムです。",
  "cpp_lesson4_ex16_slide1_content": "# クラスのオブジェクトを並べ替え\n\n自分で作ったクラスのリストも、好きな基準でソートできます。\n\n**身近な例え：**\n名簿を「名前順」で並べるか「年齢順」で並べるか選べるようなものです。\n\n**実際のコードを見てみましょう：**\n```cpp\nstruct Person {\n    string name;\n    int age;\n};\n\nvector<Person> people = {\n    {\\\"太郎\\\", 25}, {\\\"花子\\\", 20}, {\\\"次郎\\\", 30}\n};\n\n// 年齢で並べ替え（若い順）\nsort(people.begin(), people.end(),\n    [](const Person& a, const Person& b) {\n        return a.age < b.age;  // 年齢が小さい方を前に\n    });\n// 結果: 花子(20), 太郎(25), 次郎(30)\n```\n\n`const Person&` で受け取ると、コピーせず効率的に比較できます。",
  "cpp_lesson4_ex16_slide1_title": "オブジェクトのソート",
  "cpp_lesson4_ex16_title": "オブジェクトのソート",
  "cpp_lesson4_ex17_description": "例外をキャッチして処理しましょう。",
  "cpp_lesson4_ex17_title": "try-catch 例外処理",
  "cpp_lesson4_ex18_comment1": "例外オブジェクトを投げるキーワードです。",
  "cpp_lesson4_ex18_comment2": "エラー（例外）が発生した場合の処理を記述します。",
  "cpp_lesson4_ex18_slide1_content": "# よく使う例外（れいがい）の種類\n\nC++には、よくあるエラーのための「例外クラス」が用意されています。\n\n**身近な例え：**\n病院の「症状別窓口」のようなものです。「風邪」「怪我」「健康診断」で窓口が違うように、エラーの種類で対応を変えられます。\n\n**よく使う例外一覧：**\n```cpp\nruntime_error     // 実行時エラー（一般的なエラー）\nlogic_error       // 論理エラー（プログラムのバグ）\nout_of_range      // 範囲外アクセス（配列の外を見ようとした）\ninvalid_argument  // 不正な引数（おかしな値が渡された）\n```\n\n**使い分けの例：**\n```cpp\nif (index >= array.size()) {\n    throw out_of_range(\\\"インデックスが範囲外です\\\");\n}\nif (age < 0) {\n    throw invalid_argument(\\\"年齢は0以上である必要があります\\\");\n}\n```",
  "cpp_lesson4_ex18_slide1_title": "標準例外",
  "cpp_lesson4_ex18_title": "標準例外",
  "cpp_lesson4_ex19_description": "例外を投げないことを宣言しましょう。",
  "cpp_lesson4_ex19_title": "noexcept 指定",
  "cpp_lesson4_ex1_comment1": "include <iostream>",
  "cpp_lesson4_ex1_comment2": "include <memory>",
  "cpp_lesson4_ex1_description": "排他的所有権のスマートポインタを学びましょう。",
  "cpp_lesson4_ex1_slide1_content": "# 排他的（はいたてき）所有権（しょゆうけん）のスマートポインタ\n\nunique_ptr（ユニークポインタ）は、「1人だけが持てる」スマートポインタです。\n\n身近な例え：\n映画のチケットのようなものです。1枚のチケットは1人しか持てません。他の人に渡したら、自分は映画を見られなくなります。\n\n実際のコードを見てみましょう：\n```cpp\nauto p = make_unique<int>(42);  // 42という値を持つ専用のポインタ\ncout << *p << endl;             // 42と表示される\n// ここでスコープを出ると、自動でメモリが解放される！\n```\n\nメリット：\n- `delete` を書き忘れてもメモリリークしない\n- 誰が所有者かが明確",
  "cpp_lesson4_ex1_slide1_title": "unique_ptr とは？",
  "cpp_lesson4_ex1_slide2_content": "# コピーはできない、移動（いどう）のみ\n\n`unique_ptr` は「1人だけ」が鉄則なので、コピーできません。\n\n身近な例え：\n映画のチケットをコピーしたら、同じ席に2人座ることになって困りますよね。だからコピーは禁止。でも「渡す」ことはできます。\n\n実際のコードを見てみましょう：\n```cpp\nauto p1 = make_unique<int>(10);  // p1 が所有者\n\n// auto p2 = p1;           // エラー！コピーは禁止\nauto p2 = move(p1);         // OK！p1 から p2 に渡す\n// p1 はもう使えない（空っぽ）\n// p2 が新しい所有者\n```\n\nポイント：\n- コピー（複製）は禁止\n- ムーブ（移動）はOK\n- 移動後の元の変数は使わないこと",
  "cpp_lesson4_ex1_slide2_title": "コピー不可",
  "cpp_lesson4_ex1_slide3_content": "排他的所有権のスマートポインタを学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "cpp_lesson4_ex1_slide3_title": "やってみよう！",
  "cpp_lesson4_ex1_title": "unique_ptr",
  "cpp_lesson4_ex20_comment1": "int型の値を返す関数（add）を定義します。",
  "cpp_lesson4_ex20_comment2": "2つの数値を加算する演算子です。",
  "cpp_lesson4_ex20_slide1_content": "# noexcept をつけると何が良いの？\n\n`noexcept` には2つの大きなメリットがあります。\n\n**メリット1: プログラムが速くなる**\n```cpp\nint add(int a, int b) noexcept {\n    return a + b;\n}\n// コンパイラが「例外処理のコード」を省略できる → 速い！\n```\n\n**メリット2: ムーブが安全に使える**\n```cpp\nclass MyClass {\npublic:\n    // noexcept をつけると、vectorなどで効率的に使われる\n    MyClass(MyClass&&) noexcept = default;\n};\n```\n\n**身近な例え：**\nレストランで「この料理はアレルギー物質を含みません」と保証されていれば、安心して注文できますよね。`noexcept` も同じで、「エラーは起きません」と保証することで、周りのコードが安心して使えます。\n\n**使いどころ：**\n- 単純な計算（足し算、掛け算など）\n- ムーブコンストラクタ、ムーブ代入演算子",
  "cpp_lesson4_ex20_slide1_title": "メリット",
  "cpp_lesson4_ex20_title": "メリット",
  "cpp_lesson4_ex2_comment1": "排他的所有権のスマートポインタを作成する関数です。",
  "cpp_lesson4_ex2_comment2": "ポインタの中身を参照するための間接参照演算子です。",
  "cpp_lesson4_ex2_description": "型安全な共用体を学びましょう。",
  "cpp_lesson4_ex2_slide1_content": "# コピーはできない、移動（いどう）のみ\n\n`unique_ptr` は「1人だけ」が鉄則なので、コピーできません。\n\n**身近な例え：**\n映画のチケットをコピーしたら、同じ席に2人座ることになって困りますよね。だからコピーは禁止。でも「渡す」ことはできます。\n\n**実際のコードを見てみましょう：**\n```cpp\nauto p1 = make_unique<int>(10);  // p1 が所有者\n\n// auto p2 = p1;           // エラー！コピーは禁止\nauto p2 = move(p1);         // OK！p1 から p2 に渡す\n// p1 はもう使えない（空っぽ）\n// p2 が新しい所有者\n```\n\n**ポイント：**\n- コピー（複製）は禁止\n- ムーブ（移動）はOK\n- 移動後の元の変数は使わないこと",
  "cpp_lesson4_ex2_slide1_title": "コピー不可",
  "cpp_lesson4_ex2_slide2_content": "# 中身を取り出す方法\n\nvariant から値を取り出すには、「今何が入っているか」をチェックします。\n\n身近な例え：\n宝箱を開ける前に「中身は金貨？宝石？」と確認してから取り出すイメージです。\n\n実際のコードを見てみましょう：\n```cpp\nvariant<int, string> v = 42;\n\n// holds_alternative で「今 int が入っている？」と確認\nif (holds_alternative<int>(v)) {\n    cout << get<int>(v) << endl;  // get<int> で int として取り出す\n}\n\n// 間違った型で取り出そうとするとエラー！\n// get<string>(v);  // 今は int が入っているのでダメ\n```\n\nポイント：\n- `holds_alternative<型>(v)`: その型が入っているか確認\n- `get<型>(v)`: その型として取り出す",
  "cpp_lesson4_ex2_slide2_title": "値の取得",
  "cpp_lesson4_ex2_slide3_content": "型安全な共用体を学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "cpp_lesson4_ex2_slide3_title": "やってみよう！",
  "cpp_lesson4_ex2_title": "コピー不可",
  "cpp_lesson4_ex3_comment1": "include <iostream>",
  "cpp_lesson4_ex3_comment2": "include <tuple>",
  "cpp_lesson4_ex3_description": "型安全な共用体を学びましょう。",
  "cpp_lesson4_ex3_slide1_content": "# 複数（ふくすう）の値を一度に受け取る\n\n構造化束縛（こうぞうかそくばく）は、まとまったデータを一度にバラバラの変数に分けて受け取る機能です。\n\n身近な例え：\nプレゼント袋から「お菓子」「おもちゃ」「カード」を一気に取り出して、それぞれ別の箱に入れるイメージです。\n\n実際のコードを見てみましょう：\n```cpp\npair<int, string> p = {1, \"hello\"};  // 数字と文字列のペア\n\n// 構造化束縛で一度に受け取る\nauto [num, str] = p;\n//    ↑    ↑\n//    1   \"hello\" がそれぞれ入る\n\ncout << num << \", \" << str << endl;  // 1, hello\n```\n\nポイント：\n`auto [変数1, 変数2, ...] = データ;` の形で書きます。",
  "cpp_lesson4_ex3_slide1_title": "構造化束縛とは？",
  "cpp_lesson4_ex3_slide2_content": "# map を便利（べんり）にループ\n\n構造化束縛は、map（辞書）をループするときにとても便利です。\n\n身近な例え：\n電話帳を見るとき、「名前」と「電話番号」を同時に読み取れるようなものです。\n\n実際のコードを見てみましょう：\n```cpp\nmap<string, int> m = {{\"りんご\", 100}, {\"バナナ\", 80}};\n\n// 昔の書き方（面倒...）\nfor (auto it = m.begin(); it != m.end(); ++it) {\n    cout << it->first << \": \" << it->second << endl;\n}\n\n// 構造化束縛を使った書き方（スッキリ！）\nfor (auto [key, value] : m) {\n    cout << key << \": \" << value << endl;\n}\n// りんご: 100\n// バナナ: 80\n```\n\nキー（key）と値（value）を別々の変数で受け取れます！",
  "cpp_lesson4_ex3_slide2_title": "mapのイテレーション",
  "cpp_lesson4_ex3_slide3_content": "複数の値を一度に受け取りましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "cpp_lesson4_ex3_slide3_title": "やってみよう！",
  "cpp_lesson4_ex3_title": "std::variant",
  "cpp_lesson4_ex4_comment1": "複数の型のうち1つを安全に保持できる型です。",
  "cpp_lesson4_ex4_comment2": "variantから指定した型の値を取り出す関数です。",
  "cpp_lesson4_ex4_description": "文字列の参照ビューを学びましょう。",
  "cpp_lesson4_ex4_slide1_content": "# 中身を取り出す方法\n\nvariant から値を取り出すには、「今何が入っているか」をチェックします。\n\n**身近な例え：**\n宝箱を開ける前に「中身は金貨？宝石？」と確認してから取り出すイメージです。\n\n**実際のコードを見てみましょう：**\n```cpp\nvariant<int, string> v = 42;\n\n// holds_alternative で「今 int が入っている？」と確認\nif (holds_alternative<int>(v)) {\n    cout << get<int>(v) << endl;  // get<int> で int として取り出す\n}\n\n// 間違った型で取り出そうとするとエラー！\n// get<string>(v);  // 今は int が入っているのでダメ\n```\n\n**ポイント：**\n- `holds_alternative<型>(v)`: その型が入っているか確認\n- `get<型>(v)`: その型として取り出す",
  "cpp_lesson4_ex4_slide1_title": "値の取得",
  "cpp_lesson4_ex4_slide2_content": "# なぜ string_view が便利なの？\n\nこれまでの書き方と比べてみましょう。\n\n身近な例え：\n写真を見せるとき、「実物の写真」でも「スマホの画面」でも、見る分には同じですよね。string_view は両方受け取れます。\n\n実際のコードを見てみましょう：\n```cpp\n// 方法1: string で受け取る（コピーが発生）\nvoid f1(string s);     // 毎回コピー = 遅い\n\n// 方法2: const string& で受け取る\nvoid f2(const string& s);  // \"hello\" を渡すと一時オブジェクトが作られる\n\n// 方法3: string_view で受け取る（オススメ！）\nvoid f3(string_view sv);   // コピーなし、どんな文字列もOK！\n\nstring s = \"world\";\nf3(s);        // string型 → OK\nf3(\"hello\");  // 文字列リテラル → OK\nf3(\"abc\");    // const char* → OK\n```\n\n関数の引数で「文字列を読むだけ」なら string_view が最適！",
  "cpp_lesson4_ex4_slide2_title": "メリット",
  "cpp_lesson4_ex4_slide3_content": "文字列の参照ビューを学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "cpp_lesson4_ex4_slide3_title": "やってみよう！",
  "cpp_lesson4_ex4_title": "値の取得",
  "cpp_lesson4_ex5_comment1": "include <iostream>",
  "cpp_lesson4_ex5_comment2": "include <vector>",
  "cpp_lesson4_ex5_comment3": "include <algorithm>",
  "cpp_lesson4_ex5_description": "複数の値を一度に受け取りましょう。",
  "cpp_lesson4_ex5_slide1_content": "# 全ての要素（ようそ）を変換（へんかん）する\n\ntransform（トランスフォーム）は、配列の各要素に同じ処理を適用して、結果を別の場所に保存するアルゴリズムです。\n\n身近な例え：\n写真アプリで「全ての写真にフィルターをかける」ようなものです。1枚1枚手動でやらなくても、一括で処理できます。\n\n実際のコードを見てみましょう：\n```cpp\nvector<int> in = {1, 2, 3};    // 元の配列\nvector<int> out(3);             // 結果を入れる配列\n\n// 各要素を2倍にして out に保存\ntransform(in.begin(), in.end(), out.begin(),\n          [](int x) { return x * 2; });\n// out = {2, 4, 6}\n```\n\n引数: (開始, 終了, 出力先, 変換関数)",
  "cpp_lesson4_ex5_slide1_title": "transform とは？",
  "cpp_lesson4_ex5_slide2_content": "# 文字列を大文字（おおもじ）に変換\n\n`transform` は文字列の変換にも使えます。\n\n身近な例え：\n「hello」という文字を1文字ずつ大文字スタンプで押し直すイメージです。\n\n実際のコードを見てみましょう：\n```cpp\nstring s = \"hello\";\n\n// 各文字を大文字に変換（結果を同じ場所に上書き）\ntransform(s.begin(), s.end(), s.begin(), ::toupper);\n//        ↑開始    ↑終了    ↑出力先   ↑変換関数\n\ncout << s << endl;  // \"HELLO\"\n```\n\nポイント：\n- 出力先を元の配列にすれば「上書き」できる\n- `::toupper` は「大文字に変換」する関数",
  "cpp_lesson4_ex5_slide2_title": "使用例",
  "cpp_lesson4_ex5_slide3_content": "要素を変換するアルゴリズムを学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "cpp_lesson4_ex5_slide3_title": "やってみよう！",
  "cpp_lesson4_ex5_title": "構造化束縛",
  "cpp_lesson4_ex6_comment1": "複数の値をまとめて格納する配列（またはリスト）を作成します。",
  "cpp_lesson4_ex6_comment2": "型を自動推論して複数の変数に分解するキーワードです。",
  "cpp_lesson4_ex6_comment3": "include <numeric>",
  "cpp_lesson4_ex6_description": "要素を集約するアルゴリズムを学びましょう。",
  "cpp_lesson4_ex6_slide1_content": "# map を便利（べんり）にループ\n\n構造化束縛は、map（辞書）をループするときにとても便利です。\n\n**身近な例え：**\n電話帳を見るとき、「名前」と「電話番号」を同時に読み取れるようなものです。\n\n**実際のコードを見てみましょう：**\n```cpp\nmap<string, int> m = {{\\\"りんご\\\", 100}, {\\\"バナナ\\\", 80}};\n\n// 昔の書き方（面倒...）\nfor (auto it = m.begin(); it != m.end(); ++it) {\n    cout << it->first << \\\": \\\" << it->second << endl;\n}\n\n// 構造化束縛を使った書き方（スッキリ！）\nfor (auto [key, value] : m) {\n    cout << key << \\\": \\\" << value << endl;\n}\n// りんご: 100\n// バナナ: 80\n```\n\nキー（key）と値（value）を別々の変数で受け取れます！",
  "cpp_lesson4_ex6_slide1_title": "mapのイテレーション",
  "cpp_lesson4_ex6_slide2_content": "# 足し算以外の計算もできる\n\n4つ目の引数で「どうやってまとめるか」を指定できます。\n\n身近な例え：\n「全部足す」だけでなく「全部かける」「最大値を見つける」など、まとめ方を変えられます。\n\n実際のコードを見てみましょう：\n```cpp\nvector<int> v = {1, 2, 3, 4, 5};\n\n// 全部かけ算する（初期値は 1）\nint product = accumulate(v.begin(), v.end(), 1,\n    [](int a, int b) { return a * b; });\n// 1 * 1 * 2 * 3 * 4 * 5 = 120\ncout << product << endl;  // 120\n```\n\nポイント：\n- 足し算の初期値は `0`（0 + 1 + 2 + ...）\n- かけ算の初期値は `1`（1 * 1 * 2 * ...）\n- ラムダ式で好きな計算ができる",
  "cpp_lesson4_ex6_slide2_title": "カスタム演算",
  "cpp_lesson4_ex6_slide3_content": "要素を集約するアルゴリズムを学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "cpp_lesson4_ex6_slide3_title": "やってみよう！",
  "cpp_lesson4_ex6_title": "mapのイテレーション",
  "cpp_lesson4_ex7_comment1": "include <iostream>",
  "cpp_lesson4_ex7_comment2": "include <vector>",
  "cpp_lesson4_ex7_comment3": "include <algorithm>",
  "cpp_lesson4_ex7_description": "文字列の参照ビューを学びましょう。",
  "cpp_lesson4_ex7_slide1_content": "# 条件（じょうけん）に合うものを探す\n\nfind_if（ファインドイフ）は、「条件に合う最初の要素」を見つけるアルゴリズムです。\n\n身近な例え：\n本棚から「赤い表紙の本」を探すとき、左から順番に見ていって最初に見つかったものを取り出すイメージです。\n\n実際のコードを見てみましょう：\n```cpp\nvector<int> v = {1, 3, 5, 6, 7};\n\n// 最初の偶数（2で割り切れる数）を探す\nauto it = find_if(v.begin(), v.end(),\n    [](int x) { return x % 2 == 0; });  // 条件：偶数か？\n\ncout << *it << endl;  // 6（最初に見つかった偶数）\n```\n\n返り値はイテレータ（位置を指すもの）なので、`*` をつけて中身を取り出します。",
  "cpp_lesson4_ex7_slide1_title": "find_if とは？",
  "cpp_lesson4_ex7_slide2_content": "# 見つからなかったらどうなる？\n\n条件に合う要素が1つもない場合、`end()` が返されます。\n\n身近な例え：\n本棚を全部見ても「赤い本」がなかったら、「本棚の外」を指して「なかったよ」と教えてくれます。\n\n実際のコードを見てみましょう：\n```cpp\nvector<int> v = {1, 3, 5, 7};  // 偶数がない！\n\nauto it = find_if(v.begin(), v.end(),\n    [](int x) { return x % 2 == 0; });\n\n// 見つかったかどうかをチェック\nif (it != v.end()) {\n    cout << \"Found: \" << *it << endl;\n} else {\n    cout << \"Not found\" << endl;  // これが表示される\n}\n```\n\n重要：\n必ず `end()` と比較してから使いましょう！",
  "cpp_lesson4_ex7_slide2_title": "見つからない場合",
  "cpp_lesson4_ex7_slide3_content": "条件に合う要素を検索しましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "cpp_lesson4_ex7_slide3_title": "やってみよう！",
  "cpp_lesson4_ex7_title": "std::string_view",
  "cpp_lesson4_ex8_comment1": "void型の値を返す関数（greet）を定義します。",
  "cpp_lesson4_ex8_comment2": "定義した関数を呼び出します。",
  "cpp_lesson4_ex8_comment3": "include <algorithm>",
  "cpp_lesson4_ex8_description": "カスタム比較でソートしましょう。",
  "cpp_lesson4_ex8_slide1_content": "# なぜ string_view が便利なの？\n\nこれまでの書き方と比べてみましょう。\n\n**身近な例え：**\n写真を見せるとき、「実物の写真」でも「スマホの画面」でも、見る分には同じですよね。string_view は両方受け取れます。\n\n**実際のコードを見てみましょう：**\n```cpp\n// 方法1: string で受け取る（コピーが発生）\nvoid f1(string s);     // 毎回コピー = 遅い\n\n// 方法2: const string& で受け取る\nvoid f2(const string& s);  // \\\"hello\\\" を渡すと一時オブジェクトが作られる\n\n// 方法3: string_view で受け取る（オススメ！）\nvoid f3(string_view sv);   // コピーなし、どんな文字列もOK！\n\nstring s = \\\"world\\\";\nf3(s);        // string型 → OK\nf3(\\\"hello\\\");  // 文字列リテラル → OK\nf3(\\\"abc\\\");    // const char* → OK\n```\n\n関数の引数で「文字列を読むだけ」なら string_view が最適！",
  "cpp_lesson4_ex8_slide1_title": "メリット",
  "cpp_lesson4_ex8_slide2_content": "# クラスのオブジェクトを並べ替え\n\n自分で作ったクラスのリストも、好きな基準でソートできます。\n\n身近な例え：\n名簿を「名前順」で並べるか「年齢順」で並べるか選べるようなものです。\n\n実際のコードを見てみましょう：\n```cpp\nstruct Person {\n    string name;\n    int age;\n};\n\nvector<Person> people = {\n    {\"太郎\", 25}, {\"花子\", 20}, {\"次郎\", 30}\n};\n\n// 年齢で並べ替え（若い順）\nsort(people.begin(), people.end(),\n    [](const Person& a, const Person& b) {\n        return a.age < b.age;  // 年齢が小さい方を前に\n    });\n// 結果: 花子(20), 太郎(25), 次郎(30)\n```\n\n`const Person&` で受け取ると、コピーせず効率的に比較できます。",
  "cpp_lesson4_ex8_slide2_title": "オブジェクトのソート",
  "cpp_lesson4_ex8_slide3_content": "カスタム比較でソートしましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "cpp_lesson4_ex8_slide3_title": "やってみよう！",
  "cpp_lesson4_ex8_title": "メリット",
  "cpp_lesson4_ex9_comment1": "include <iostream>",
  "cpp_lesson4_ex9_comment2": "include <stdexcept>",
  "cpp_lesson4_ex9_description": "要素を変換するアルゴリズムを学びましょう。",
  "cpp_lesson4_ex9_slide1_content": "# try-catch でエラーを安全に処理（しょり）\n\n例外処理（れいがいしょり）は、プログラムでエラーが起きたときに安全に対処する仕組みです。\n\n身近な例え：\nサーカスの綱渡りで、落ちたときに備えて「セーフティネット」を張っておくようなものです。エラーが起きても、プログラムがクラッシュせずに済みます。\n\n実際のコードを見てみましょう：\n```cpp\ntry {                                // ここで危険な処理をする\n    throw runtime_error(\"Error!\");   // エラーを「投げる」\n} catch (const exception& e) {       // エラーを「捕まえる」\n    cout << e.what() << endl;        // エラーメッセージを表示\n}\n// プログラムは続行できる！\n```\n\n用語解説：\n- `throw`: エラーを投げる\n- `catch`: エラーを捕まえる\n- `e.what()`: エラーメッセージを取得",
  "cpp_lesson4_ex9_slide1_title": "例外処理",
  "cpp_lesson4_ex9_slide2_content": "# よく使う例外（れいがい）の種類\n\nC++には、よくあるエラーのための「例外クラス」が用意されています。\n\n身近な例え：\n病院の「症状別窓口」のようなものです。「風邪」「怪我」「健康診断」で窓口が違うように、エラーの種類で対応を変えられます。\n\nよく使う例外一覧：\n```cpp\nruntime_error     // 実行時エラー（一般的なエラー）\nlogic_error       // 論理エラー（プログラムのバグ）\nout_of_range      // 範囲外アクセス（配列の外を見ようとした）\ninvalid_argument  // 不正な引数（おかしな値が渡された）\n```\n\n使い分けの例：\n```cpp\nif (index >= array.size()) {\n    throw out_of_range(\"インデックスが範囲外です\");\n}\nif (age < 0) {\n    throw invalid_argument(\"年齢は0以上である必要があります\");\n}\n```",
  "cpp_lesson4_ex9_slide2_title": "標準例外",
  "cpp_lesson4_ex9_slide3_content": "例外をキャッチして処理しましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "cpp_lesson4_ex9_slide3_title": "やってみよう！",
  "cpp_lesson4_ex9_title": "std::transform",
  "cpp_lesson4_title": "C++ IV - STLアルゴリズムと高度な機能"
}
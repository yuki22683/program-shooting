{
  "go_lesson1_course_description": "Google（グーグル）が作った言葉「Go（ゴー）言語」のきほんを学びましょう。シンプルですばやく動くプログラムを作れるようになります。",
  "go_lesson1_course_title": "Go (ゴー) 言語に挑戦！",
  "go_lesson1_ex10_comment1": "変数の値を計算して、その結果を同じ変数に再代入します。",
  "go_lesson1_ex10_comment2": "変数の値を計算して、その結果を同じ変数に再代入します。",
  "go_lesson1_ex10_description": "複数の条件を組み合わせる「&&（かつ）」と「||（または）」を学びましょう。",
  "go_lesson1_ex10_slide1_content": "# 便利な書き方\n\nこの記号を使うと、同じ変数を2回書かなくてすみます。プログラマーは怠け者（？）なので、短く書く方法が大好きです！\n\n**比べてみましょう：**\n```go\n// 長い書き方（変数名を2回書く）\ncount = count + 1\n\n// 短い書き方（変数名は1回だけ！）\ncount += 1\n```\n\n同じ結果なら、短い方がわかりやすいですね。他にも `*=`（かけ算）や `/=`（わり算）もあります。",
  "go_lesson1_ex10_slide1_title": "コードを短く書こう！",
  "go_lesson1_ex10_slide2_content": "# どっちを使う？\n\n&&（かつ）：両方とも正しいとき\n```go\nif score >= 70 && bonus > 0 {\n    // 70点以上「かつ」ボーナスあり\n    fmt.Println(\"合格！\")\n}\n```\n\n||（または）：どちらか1つでも正しいとき\n```go\nif isHoliday || isWeekend {\n    // 祝日「または」週末\n    fmt.Println(\"お休み！\")\n}\n```\n\n覚え方：\n- `&&` → 「A と B」両方必要\n- `||` → 「A か B」どっちかでOK",
  "go_lesson1_ex10_slide2_title": "&&（かつ）と ||（または）の使い分け",
  "go_lesson1_ex10_slide3_content": "複数の条件を組み合わせる「&&（かつ）」と「||（または）」を学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "go_lesson1_ex10_slide3_title": "やってみよう！",
  "go_lesson1_ex10_title": "コードを短く書こう！",
  "go_lesson1_ex11_comment1": "range で全要素をループ",
  "go_lesson1_ex11_comment2": "rangeで全要素をループ",
  "go_lesson1_ex11_description": "Printf（プリントエフ）を使って、文章の中に「はこ（変数）」の中身を表示します。",
  "go_lesson1_ex11_slide1_content": "# 同じことを何度もやりたい！\n\nループ（繰り返し） は、同じ作業を何度も自動でやってくれる便利な仕組みです。\n\nたとえば：\n- クラス全員の名前を順番に呼ぶ\n- 買い物リストの商品を1つずつ表示\n- ゲームで敵キャラ全員を動かす\n\n人間がやると大変ですが、コンピュータは「繰り返し」が大得意！1000回でも10000回でも、文句を言わずにやってくれます。",
  "go_lesson1_ex11_slide1_title": "繰り返し（ループ）とは？",
  "go_lesson1_ex11_slide2_content": "# スライスの中身を順番に処理\n\n`range`（レンジ）を使うと、スライスの中身を最初から最後まで 1つずつ順番に 取り出せます。\n\nコード例：\n```go\ncolors := []string{\"赤\", \"青\", \"黄\"}\nfor _, c := range colors {\n    fmt.Println(c)\n}\n// 赤、青、黄 の順に表示される\n```\n\nコードの読み方：\n- `for` → 繰り返しスタート\n- `_` → 番号は使わない（無視する）\n- `c` → 取り出したデータを入れる変数\n- `range colors` → colorsの中身を順番に\n\n`_`（アンダースコア）は「使わないよ」という意味の特別な記号です。",
  "go_lesson1_ex11_slide2_title": "range（レンジ）で全部取り出す",
  "go_lesson1_ex11_slide3_content": "range（レンジ）という機能を使って、スライスの中身を一つずつ順番に表示します。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "go_lesson1_ex11_slide3_title": "やってみよう！",
  "go_lesson1_ex11_title": "文章の中に「はこ」を入れましょう",
  "go_lesson1_ex12_comment1": "フォーマットパッケージを使って文字列を出力します。",
  "go_lesson1_ex12_comment2": "Math をキーに指定",
  "go_lesson1_ex12_description": "Map（辞書）を使って、名前を指定してデータを取り出してみましょう。",
  "go_lesson1_ex12_slide1_content": "# %d のところに数字が入る\n\n`Printf`（プリントエフ）を使うと、文章の中の `%d` の部分が、あとで指定した変数の中身に置き換わります。\n\n**コード例：**\n```go\nmonth := 12\nfmt.Printf(\\\"今は %d 月です\\\n\\\", month)\n// → 「今は 12 月です」と表示される\n```\n\n**記号の意味：**\n- `%d` → 整数（せいすう：小数点のない数）を入れる場所\n- `%s` → 文字列（もじれつ：文字のならび）を入れる場所\n- `\\\n` → 改行（かいぎょう：次の行に移る）\n\n`Println` は自動で改行しますが、`Printf` では自分で `\\\n` を入れます。",
  "go_lesson1_ex12_slide1_title": "Printf（プリントエフ）を使いましょう",
  "go_lesson1_ex12_slide2_content": "# 名前で取り出す\n\nMapでは「名前（キー）」と「データ（値）」をセットで保存します。取り出すときは名前を指定するだけ！\n\nコード例：\n```go\n// りんご→あか、バナナ→きいろ のペアを作る\ncolors := map[string]string{\n    \"りんご\": \"あか\",\n    \"バナナ\": \"きいろ\",\n}\nfmt.Println(colors[\"りんご\"])  // あか が表示される\n```\n\n書き方のポイント：\n- `map[キーの種類]値の種類` で型を決める\n- `{\"キー\": \"値\"}` でデータを入れる\n- `マップ名[\"キー\"]` で取り出す",
  "go_lesson1_ex12_slide2_title": "Mapの使いかた",
  "go_lesson1_ex12_slide3_content": "Map（辞書）を使って、名前を指定してデータを取り出してみましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "go_lesson1_ex12_slide3_title": "やってみよう！",
  "go_lesson1_ex12_title": "Printf（プリントエフ）を使いましょう",
  "go_lesson1_ex13_comment1": "greet 関数を呼び出す",
  "go_lesson1_ex13_comment2": "greet関数を呼び出す",
  "go_lesson1_ex13_description": "「スライス」という機能を使うと、たくさんのデータを一つの「長い はこ」にまとめて入れられます。",
  "go_lesson1_ex13_slide1_content": "# 手順をまとめて名前をつける\n\n関数（かんすう） は、いくつかの命令をひとまとめにして名前をつけたものです。\n\n身近な例：料理のレシピ\n- 「カレーを作る」と言えば、具体的な手順がわかる\n- いちいち「野菜を切って、炒めて、煮込んで...」と言わなくていい\n\nプログラミングでも同じ！\n- 関数に名前をつけておけば、あとは名前を呼ぶだけで実行できる\n- 同じ処理を何度も書かなくてすむ\n\n一度作った関数は、何回でも使い回せます！",
  "go_lesson1_ex13_slide1_title": "関数（かんすう）とは？",
  "go_lesson1_ex13_slide2_content": "# func（ファンク）で関数を作る\n\n`func`（ファンク）というキーワードの後に名前をつけて、関数を作ります。\n\nコード例：\n```go\n// sayHello という関数を作る\nfunc sayHello() {\n    fmt.Println(\"こんにちは\")\n}\n\nfunc main() {\n    sayHello()  // 関数を呼び出す\n    sayHello()  // 何回でも使える！\n}\n```\n\n書き方：\n1. `func 関数名()` で関数を定義\n2. `{ }` の中にやりたい処理を書く\n3. 使うときは `関数名()` で呼び出す\n\n`()` は「関数を呼び出すよ」という合図です。",
  "go_lesson1_ex13_slide2_title": "関数の作りかた",
  "go_lesson1_ex13_slide3_content": "一連の手順をまとめて、名前をつけた「関数（かんすう）」を作ってみましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "go_lesson1_ex13_slide3_title": "やってみよう！",
  "go_lesson1_ex13_title": "データをならべる「スライス」",
  "go_lesson1_ex14_slide1_content": "# [ ]（角かっこ）で取り出す\n\nスライスの中身を取り出すときは、`[番号]` で何番目かを指定します。\n\n**大事なルール：番号は「0」からスタート！**\n- 1番目のデータ → `[0]`\n- 2番目のデータ → `[1]`\n- 3番目のデータ → `[2]`\n\n**コード例：**\n```go\nitems := []int{100, 200, 300}\n//            ↑0番  ↑1番  ↑2番\nfmt.Println(items[0]) // 100 が表示されます\nfmt.Println(items[1]) // 200 が表示されます\n```\n\nプログラミングでは「0から数える」のが世界共通のルールです！",
  "go_lesson1_ex14_slide1_title": "データの番号は「0」から！",
  "go_lesson1_ex14_title": "データの番号は「0」から！",
  "go_lesson1_ex15_description": "点数によって表示するメッセージを変えてみましょう。",
  "go_lesson1_ex15_title": "「もし〜なら」で分けましょう",
  "go_lesson1_ex16_comment1": "変数を宣言し、同時に数値を代入します（型推論を使用）。",
  "go_lesson1_ex16_comment2": "条件式（変数と数値の比較など）を評価し、真の場合にブロックを実行します。",
  "go_lesson1_ex16_comment3": "フォーマットパッケージを使って文字列を出力します。",
  "go_lesson1_ex16_slide1_content": "# 「もし〜なら」を書く方法\n\n`if`（イフ）は英語で「もし」という意味です。Go言語では次のように書きます。\n\n**書き方：**\n```go\nif 条件 {\n    やりたいこと\n}\n```\n\n**コード例：**\n```go\nif score > 80 {\n    fmt.Println(\\\"すごい！\\\")\n}\n```\n\n**ポイント：**\n- `if` のあとに条件を書く\n- `{ }` の中に「条件が正しいときにやること」を書く\n- Go言語では条件を `( )` で囲まなくてOK！\n\n`>` は「より大きい」という意味の記号（比較演算子・ひかくえんざんし）です。",
  "go_lesson1_ex16_slide1_title": "if文（イフぶん）を使おう",
  "go_lesson1_ex16_title": "if文（イフぶん）を使おう",
  "go_lesson1_ex17_description": "else（エルス）を使って、「そうでなければ」の動きを作りましょう。",
  "go_lesson1_ex17_title": "ちがう場合はどうしましょう？",
  "go_lesson1_ex18_comment1": "変数を宣言し、同時に数値を代入します（型推論を使用）。",
  "go_lesson1_ex18_comment2": "条件式（変数と数値の比較など）を評価し、真の場合にブロックを実行します。",
  "go_lesson1_ex18_comment3": "フォーマットパッケージを使って文字列を出力します。",
  "go_lesson1_ex18_comment4": "もし条件が満たされなかった場合に実行する処理を記述します。",
  "go_lesson1_ex18_comment5": "フォーマットパッケージを使って文字列を出力します。",
  "go_lesson1_ex18_slide1_content": "# } と同じ行に書くのがルール\n\nGo言語では、`else` の書き方に特別なルールがあります。\n\n**正しい書き方：**\n```go\nif hour < 12 {\n    fmt.Println(\\\"午前\\\")\n} else {\n    fmt.Println(\\\"午後\\\")\n}\n```\n\n**ポイント：**\n- `}` と `else` と `{` は **同じ行** に書く\n- `} else {` とつなげて書くのがGo言語のルール\n\n**やってること：**\n1. hour（時間）が12より小さいかチェック\n2. 小さければ「午前」と表示\n3. そうでなければ「午後」と表示",
  "go_lesson1_ex18_slide1_title": "else の書きかた",
  "go_lesson1_ex18_title": "else の書きかた",
  "go_lesson1_ex19_description": "複数の条件を組み合わせる「&&（かつ）」と「||（または）」を学びましょう。",
  "go_lesson1_ex19_title": "論理演算子（&&、||）",
  "go_lesson1_ex1_comment1": "Hello, Go! と表示する",
  "go_lesson1_ex1_description": "Go言語を使って画面に「こんにちは」と表示させてみましょう。fmt（エフエムティー）という機能を使います。",
  "go_lesson1_ex1_slide1_content": "# シンプルで速い言葉\n\nGo言語（ゴーげんご）は、Google（グーグル）という大きな会社が作ったプログラミング言語です。\n\nGo言語のとくちょう：\n- 書き方がシンプルで覚えやすい\n- プログラムがとても速く動く\n- 大きなシステム（たくさんのコンピュータを動かすしくみ）を作るのが得意\n\nまるで「シンプルだけどパワフルな車」のような言語です。むずかしい部品（きのう）を減らして、だれでも運転（プログラミング）しやすくしています。",
  "go_lesson1_ex1_slide1_title": "Go言語（ゴー）とは？",
  "go_lesson1_ex1_slide2_content": "# おまじないを入力しましょう\n\nGo言語でプログラムを書くときは、最初に必ず入力する「きまり文句」があります。これは「おまじない」のようなものです。\n\n3つのきまり文句：\n- `package main`（パッケージ メイン）：「このプログラムを動かせますよ」という合図\n- `import \"fmt\"`（インポート エフエムティー）：画面に文字を出す機能を使う準備\n- `func main()`（ファンク メイン）：プログラムがここからスタート！\n\nコード例：\n```go\npackage main\nimport \"fmt\"\nfunc main() {\n    fmt.Println(\"ヤッホー\")\n}\n```\n\n`fmt.Println`（エフエムティー プリントライン）で、かっこの中の文字を画面に表示できます。",
  "go_lesson1_ex1_slide2_title": "Go言語の「きまり文句」",
  "go_lesson1_ex1_slide3_content": "Go言語を使って画面に「こんにちは」と表示させてみましょう。fmt（エフエムティー）という機能を使います。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "go_lesson1_ex1_slide3_title": "やってみよう！",
  "go_lesson1_ex1_title": "画面にメッセージを出しましょう",
  "go_lesson1_ex20_comment1": "条件式（変数と数値の比較など）を評価し、真の場合にブロックを実行します。",
  "go_lesson1_ex20_slide1_content": "# どっちを使う？\n\n**&&（かつ）：両方とも正しいとき**\n```go\nif score >= 70 && bonus > 0 {\n    // 70点以上「かつ」ボーナスあり\n    fmt.Println(\\\"合格！\\\")\n}\n```\n\n**||（または）：どちらか1つでも正しいとき**\n```go\nif isHoliday || isWeekend {\n    // 祝日「または」週末\n    fmt.Println(\\\"お休み！\\\")\n}\n```\n\n**覚え方：**\n- `&&` → 「A **と** B」両方必要\n- `||` → 「A **か** B」どっちかでOK",
  "go_lesson1_ex20_slide1_title": "&&（かつ）と ||（または）の使い分け",
  "go_lesson1_ex20_title": "&&（かつ）と ||（または）の使い分け",
  "go_lesson1_ex21_description": "range（レンジ）という機能を使って、スライスの中身を一つずつ順番に表示します。",
  "go_lesson1_ex21_title": "中身を全部出してみましょう",
  "go_lesson1_ex22_comment1": "範囲をあらわす `range` を入力しましょう。",
  "go_lesson1_ex22_slide1_content": "# スライスの中身を順番に処理\n\n`range`（レンジ）を使うと、スライスの中身を最初から最後まで **1つずつ順番に** 取り出せます。\n\n**コード例：**\n```go\ncolors := []string{\\\"赤\\\", \\\"青\\\", \\\"黄\\\"}\nfor _, c := range colors {\n    fmt.Println(c)\n}\n// 赤、青、黄 の順に表示される\n```\n\n**コードの読み方：**\n- `for` → 繰り返しスタート\n- `_` → 番号は使わない（無視する）\n- `c` → 取り出したデータを入れる変数\n- `range colors` → colorsの中身を順番に\n\n`_`（アンダースコア）は「使わないよ」という意味の特別な記号です。",
  "go_lesson1_ex22_slide1_title": "range（レンジ）で全部取り出す",
  "go_lesson1_ex22_title": "range（レンジ）で全部取り出す",
  "go_lesson1_ex23_description": "Map（辞書）を使って、名前を指定してデータを取り出してみましょう。",
  "go_lesson1_ex23_title": "名前で探しましょう「じしょ」",
  "go_lesson1_ex24_comment1": "名前（キー）の種類として `string` と入力しましょう。",
  "go_lesson1_ex24_comment2": "\\\"Math\\\" という名前を指定してデータを取り出します。",
  "go_lesson1_ex24_slide1_content": "# 名前で取り出す\n\nMapでは「名前（キー）」と「データ（値）」をセットで保存します。取り出すときは名前を指定するだけ！\n\n**コード例：**\n```go\n// りんご→あか、バナナ→きいろ のペアを作る\ncolors := map[string]string{\n    \\\"りんご\\\": \\\"あか\\\",\n    \\\"バナナ\\\": \\\"きいろ\\\",\n}\nfmt.Println(colors[\\\"りんご\\\"])  // あか が表示される\n```\n\n**書き方のポイント：**\n- `map[キーの種類]値の種類` で型を決める\n- `{\\\"キー\\\": \\\"値\\\"}` でデータを入れる\n- `マップ名[\\\"キー\\\"]` で取り出す",
  "go_lesson1_ex24_slide1_title": "Mapの使いかた",
  "go_lesson1_ex24_title": "Mapの使いかた",
  "go_lesson1_ex25_description": "一連の手順をまとめて、名前をつけた「関数（かんすう）」を作ってみましょう。",
  "go_lesson1_ex25_title": "自分だけの関数を作りましょう",
  "go_lesson1_ex26_comment1": "関数（greet）を呼び出して実行します。",
  "go_lesson1_ex26_slide1_content": "# func（ファンク）で関数を作る\n\n`func`（ファンク）というキーワードの後に名前をつけて、関数を作ります。\n\n**コード例：**\n```go\n// sayHello という関数を作る\nfunc sayHello() {\n    fmt.Println(\\\"こんにちは\\\")\n}\n\nfunc main() {\n    sayHello()  // 関数を呼び出す\n    sayHello()  // 何回でも使える！\n}\n```\n\n**書き方：**\n1. `func 関数名()` で関数を定義\n2. `{ }` の中にやりたい処理を書く\n3. 使うときは `関数名()` で呼び出す\n\n`()` は「関数を呼び出すよ」という合図です。",
  "go_lesson1_ex26_slide1_title": "関数の作りかた",
  "go_lesson1_ex26_title": "関数の作りかた",
  "go_lesson1_ex2_comment1": "フォーマットパッケージを使って文字列を出力します。",
  "go_lesson1_ex2_comment2": "x を表示する",
  "go_lesson1_ex2_description": "数字をしまっておく「はこ」を作って、中身を表示してみましょう。",
  "go_lesson1_ex2_slide1_content": "# おまじないを入力しましょう\n\nGo言語でプログラムを書くときは、最初に必ず入力する「きまり文句」があります。これは「おまじない」のようなものです。\n\n**3つのきまり文句：**\n- `package main`（パッケージ メイン）：「このプログラムを動かせますよ」という合図\n- `import \\\"fmt\\\"`（インポート エフエムティー）：画面に文字を出す機能を使う準備\n- `func main()`（ファンク メイン）：プログラムがここからスタート！\n\n**コード例：**\n```go\npackage main\nimport \\\"fmt\\\"\nfunc main() {\n    fmt.Println(\\\"ヤッホー\\\")\n}\n```\n\n`fmt.Println`（エフエムティー プリントライン）で、かっこの中の文字を画面に表示できます。",
  "go_lesson1_ex2_slide1_title": "Go言語の「きまり文句」",
  "go_lesson1_ex2_slide2_content": "# かんたんな「はこ」の作りかた\n\nGo言語では、`:=`（コロン・イコール）という特別な記号を使うと、かんたんに「はこ（変数）」を作れます。\n\n`:=` のすごいところ：\n- 中に入れるものを見て、自動で「はこ」の種類を決めてくれる\n- 数字を入れれば「数字用のはこ」に\n- 文字を入れれば「文字用のはこ」に\n\nコード例：\n```go\napple := 5          // appleという名前の箱に5を入れる\nfmt.Println(apple)  // 5 が表示される\n```\n\n左側が「はこの名前」、右側が「中に入れるもの」です。",
  "go_lesson1_ex2_slide2_title": "「:=」を使いましょう",
  "go_lesson1_ex2_slide3_content": "数字をしまっておく「はこ」を作って、中身を表示してみましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "go_lesson1_ex2_slide3_title": "やってみよう！",
  "go_lesson1_ex2_title": "Go言語の「きまり文句」",
  "go_lesson1_ex3_comment1": "はこに数字を入れる",
  "go_lesson1_ex3_comment2": "+ でたし算する",
  "go_lesson1_ex3_description": "数字をしまっておく「はこ」を作って、中身を表示してみましょう。",
  "go_lesson1_ex3_slide1_content": "# コンピュータは計算が得意！\n\nコンピュータは、人間よりもずーっと速く計算ができます。1秒間に何億回もの計算ができるんです！\n\nプログラミングでは、算数と同じ記号を使って「これを計算して」とお願いします。コンピュータは一瞬で答えを出してくれます。\n\nたとえば：\n- 大きな数のたし算\n- むずかしいかけ算\n- 何回も繰り返す計算\n\n全部おまかせできます！",
  "go_lesson1_ex3_slide1_title": "計算はコンピュータにお任せ",
  "go_lesson1_ex3_slide2_content": "# 算数と同じ記号を使います\n\nGo言語での計算記号は、算数で使うものとほぼ同じです。\n\n4つの基本記号（演算子・えんざんし）：\n- +（プラス）: たし算\n- -（マイナス）: ひき算\n- \\*（アスタリスク）: かけ算（×の代わり）\n- /（スラッシュ）: わり算（÷の代わり）\n\nコード例：\n```go\nx := 100\ny := 20\nfmt.Println(x + y) // 120 が表示されます\n```\n\nかけ算は「*」、わり算は「/」を使うのがポイントです！",
  "go_lesson1_ex3_slide2_title": "計算の記号",
  "go_lesson1_ex3_slide3_content": "Go言語を使って、たし算をしてみましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "go_lesson1_ex3_slide3_title": "やってみよう！",
  "go_lesson1_ex3_title": "便利な「はこ」",
  "go_lesson1_ex4_comment1": "変数を宣言し、同時に数値を代入します（型推論を使用）。",
  "go_lesson1_ex4_comment2": "はこの名前 x を指定して、表示させます。",
  "go_lesson1_ex4_description": "割り算の「あまり」を求める「%」（パーセント）演算子を学びましょう。",
  "go_lesson1_ex4_slide1_content": "# かんたんな「はこ」の作りかた\n\nGo言語では、`:=`（コロン・イコール）という特別な記号を使うと、かんたんに「はこ（変数）」を作れます。\n\n**`:=` のすごいところ：**\n- 中に入れるものを見て、自動で「はこ」の種類を決めてくれる\n- 数字を入れれば「数字用のはこ」に\n- 文字を入れれば「文字用のはこ」に\n\n**コード例：**\n```go\napple := 5          // appleという名前の箱に5を入れる\nfmt.Println(apple)  // 5 が表示される\n```\n\n左側が「はこの名前」、右側が「中に入れるもの」です。",
  "go_lesson1_ex4_slide1_title": "「:=」を使いましょう",
  "go_lesson1_ex4_slide2_content": "# 便利な使い方：偶数（ぐうすう）と奇数（きすう）\n\n`%` を使うと、数が偶数か奇数かを調べられます。\n\n考え方：\n- 2で割ってあまりが 0 → 偶数（2, 4, 6, 8...）\n- 2で割ってあまりが 1 → 奇数（1, 3, 5, 7...）\n\n```go\nn := 7\nif n % 2 == 1 {\n    fmt.Println(\"奇数\")  // 7÷2=3あまり1 なので奇数！\n}\n```\n\nゲームで「1つおきに色を変える」などに使えます！",
  "go_lesson1_ex4_slide2_title": "偶数・奇数の判定",
  "go_lesson1_ex4_slide3_content": "割り算の「あまり」を求める「%」（パーセント）演算子を学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "go_lesson1_ex4_slide3_title": "やってみよう！",
  "go_lesson1_ex4_title": "「:=」を使いましょう",
  "go_lesson1_ex5_comment1": "+= で 20 を足す",
  "go_lesson1_ex5_comment2": "-= で 50 を引く",
  "go_lesson1_ex5_comment3": "-=で50を引く",
  "go_lesson1_ex5_description": "Go言語を使って、たし算をしてみましょう。",
  "go_lesson1_ex5_slide1_content": "# 値をかんたんに増やす・減らす\n\n`+=`（プラスイコール）と `-=`（マイナスイコール）は、「はこ」の中身を増やしたり減らしたりする便利な記号です。\n\nイメージ：\n- `+=` は「今持っているものに足す」\n- `-=` は「今持っているものから引く」\n\nたとえばゲームのスコア：\n```go\nscore := 100      // 最初は100点\nscore += 10       // 10点ゲット！ → 110点に\n// score = score + 10 と同じ意味です\n```",
  "go_lesson1_ex5_slide1_title": "累算代入演算子（るいさんだいにゅう）とは？",
  "go_lesson1_ex5_slide2_content": "# 便利な書き方\n\nこの記号を使うと、同じ変数を2回書かなくてすみます。プログラマーは怠け者（？）なので、短く書く方法が大好きです！\n\n比べてみましょう：\n```go\n// 長い書き方（変数名を2回書く）\ncount = count + 1\n\n// 短い書き方（変数名は1回だけ！）\ncount += 1\n```\n\n同じ結果なら、短い方がわかりやすいですね。他にも `*=`（かけ算）や `/=`（わり算）もあります。",
  "go_lesson1_ex5_slide2_title": "コードを短く書こう！",
  "go_lesson1_ex5_slide3_content": "変数の値を手軽に増やしたり減らしたりする「+=」「-=」を学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "go_lesson1_ex5_slide3_title": "やってみよう！",
  "go_lesson1_ex5_title": "コンピュータで計算しましょう",
  "go_lesson1_ex6_comment1": "たし算なので `+` を使います。",
  "go_lesson1_ex6_comment2": "age を埋め込む",
  "go_lesson1_ex6_description": "Printf（プリントエフ）を使って、文章の中に「はこ（変数）」の中身を表示します。",
  "go_lesson1_ex6_slide1_content": "# 算数と同じ記号を使います\n\nGo言語での計算記号は、算数で使うものとほぼ同じです。\n\n**4つの基本記号（演算子・えんざんし）：**\n- **+**（プラス）: たし算\n- **-**（マイナス）: ひき算\n- **\\\\***（アスタリスク）: かけ算（×の代わり）\n- **/**（スラッシュ）: わり算（÷の代わり）\n\n**コード例：**\n```go\nx := 100\ny := 20\nfmt.Println(x + y) // 120 が表示されます\n```\n\nかけ算は「*」、わり算は「/」を使うのがポイントです！",
  "go_lesson1_ex6_slide1_title": "計算の記号",
  "go_lesson1_ex6_slide2_content": "# %d のところに数字が入る\n\n`Printf`（プリントエフ）を使うと、文章の中の `%d` の部分が、あとで指定した変数の中身に置き換わります。\n\nコード例：\n```go\nmonth := 12\nfmt.Printf(\"今は %d 月です\\n\", month)\n// → 「今は 12 月です」と表示される\n```\n\n記号の意味：\n- `%d` → 整数（せいすう：小数点のない数）を入れる場所\n- `%s` → 文字列（もじれつ：文字のならび）を入れる場所\n- `\\n` → 改行（かいぎょう：次の行に移る）\n\n`Println` は自動で改行しますが、`Printf` では自分で `\\n` を入れます。",
  "go_lesson1_ex6_slide2_title": "Printf（プリントエフ）を使いましょう",
  "go_lesson1_ex6_slide3_content": "Printf（プリントエフ）を使って、文章の中に「はこ（変数）」の中身を表示します。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "go_lesson1_ex6_slide3_title": "やってみよう！",
  "go_lesson1_ex6_title": "計算の記号",
  "go_lesson1_ex7_comment1": "インデックス 1 で2番目を取得",
  "go_lesson1_ex7_comment2": "インデックス1で2番目を取得",
  "go_lesson1_ex7_description": "割り算の「あまり」を求める「%」（パーセント）演算子を学びましょう。",
  "go_lesson1_ex7_slide1_content": "# データを並べてまとめる「長い箱」\n\nスライス は、たくさんのデータを順番に並べて入れられる「長い箱」のようなものです。\n\nたとえば：\n- テストの点数を全部まとめて保存\n- 友だちの名前をリストにする\n- ゲームのスコアランキング\n\nスライスを使うと、100個でも1000個でも、1つの変数でまとめて管理できます。\n\n並んでいる順番には番号がついていて、0, 1, 2... と数えます。ロッカーの番号のようなイメージです！",
  "go_lesson1_ex7_slide1_title": "スライスとは？",
  "go_lesson1_ex7_slide2_content": "# [ ]（角かっこ）で取り出す\n\nスライスの中身を取り出すときは、`[番号]` で何番目かを指定します。\n\n大事なルール：番号は「0」からスタート！\n- 1番目のデータ → `[0]`\n- 2番目のデータ → `[1]`\n- 3番目のデータ → `[2]`\n\nコード例：\n```go\nitems := []int{100, 200, 300}\n//            ↑0番  ↑1番  ↑2番\nfmt.Println(items[0]) // 100 が表示されます\nfmt.Println(items[1]) // 200 が表示されます\n```\n\nプログラミングでは「0から数える」のが世界共通のルールです！",
  "go_lesson1_ex7_slide2_title": "データの番号は「0」から！",
  "go_lesson1_ex7_slide3_content": "「スライス」という機能を使うと、たくさんのデータを一つの「長い はこ」にまとめて入れられます。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "go_lesson1_ex7_slide3_title": "やってみよう！",
  "go_lesson1_ex7_title": "剰余演算子（%）",
  "go_lesson1_ex8_comment1": "あまりを求める `%` 演算子を使います。",
  "go_lesson1_ex8_comment2": "Great と表示する",
  "go_lesson1_ex8_comment3": "Greatと表示する",
  "go_lesson1_ex8_description": "点数によって表示するメッセージを変えてみましょう。",
  "go_lesson1_ex8_slide1_content": "# 便利な使い方：偶数（ぐうすう）と奇数（きすう）\n\n`%` を使うと、数が偶数か奇数かを調べられます。\n\n**考え方：**\n- 2で割ってあまりが **0** → 偶数（2, 4, 6, 8...）\n- 2で割ってあまりが **1** → 奇数（1, 3, 5, 7...）\n\n```go\nn := 7\nif n % 2 == 1 {\n    fmt.Println(\\\"奇数\\\")  // 7÷2=3あまり1 なので奇数！\n}\n```\n\nゲームで「1つおきに色を変える」などに使えます！",
  "go_lesson1_ex8_slide1_title": "偶数・奇数の判定",
  "go_lesson1_ex8_slide2_content": "# 「もし〜なら」を書く方法\n\n`if`（イフ）は英語で「もし」という意味です。Go言語では次のように書きます。\n\n書き方：\n```go\nif 条件 {\n    やりたいこと\n}\n```\n\nコード例：\n```go\nif score > 80 {\n    fmt.Println(\"すごい！\")\n}\n```\n\nポイント：\n- `if` のあとに条件を書く\n- `{ }` の中に「条件が正しいときにやること」を書く\n- Go言語では条件を `( )` で囲まなくてOK！\n\n`>` は「より大きい」という意味の記号（比較演算子・ひかくえんざんし）です。",
  "go_lesson1_ex8_slide2_title": "if文（イフぶん）を使おう",
  "go_lesson1_ex8_slide3_content": "点数によって表示するメッセージを変えてみましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "go_lesson1_ex8_slide3_title": "やってみよう！",
  "go_lesson1_ex8_title": "偶数・奇数の判定",
  "go_lesson1_ex9_comment1": "else で「そうでなければ」",
  "go_lesson1_ex9_comment2": ">で比較する",
  "go_lesson1_ex9_comment3": "elseで「そうでなければ」",
  "go_lesson1_ex9_description": "変数の値を手軽に増やしたり減らしたりする「+=」「-=」を学びましょう。",
  "go_lesson1_ex9_slide1_content": "# else（エルス）で「そうでなければ」\n\n`else`（エルス）は英語で「そうでなければ」という意味です。`if` の条件に当てはまらなかったときの動きを決められます。\n\n身近な例：\n- もし晴れなら → 公園に行く\n- そうでなければ → 家で遊ぶ\n\nこのように `if` と `else` をセットで使うと、プログラムの道を「2つに分ける」ことができます。どちらかの道を必ず通ります！",
  "go_lesson1_ex9_slide1_title": "それ以外の場合は？",
  "go_lesson1_ex9_slide2_content": "# } と同じ行に書くのがルール\n\nGo言語では、`else` の書き方に特別なルールがあります。\n\n正しい書き方：\n```go\nif hour < 12 {\n    fmt.Println(\"午前\")\n} else {\n    fmt.Println(\"午後\")\n}\n```\n\nポイント：\n- `}` と `else` と `{` は 同じ行 に書く\n- `} else {` とつなげて書くのがGo言語のルール\n\nやってること：\n1. hour（時間）が12より小さいかチェック\n2. 小さければ「午前」と表示\n3. そうでなければ「午後」と表示",
  "go_lesson1_ex9_slide2_title": "else の書きかた",
  "go_lesson1_ex9_slide3_content": "else（エルス）を使って、「そうでなければ」の動きを作りましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "go_lesson1_ex9_slide3_title": "やってみよう！",
  "go_lesson1_ex9_title": "累算代入演算子（+=、-=）",
  "go_lesson1_title": "Go (ゴー) 言語に挑戦！",
  "go_lesson2_course_description": "Go言語の強力な機能「構造体」「インターフェース」「ゴルーチン」を学びます。並行処理ができるGo言語の真の力を体験しましょう。",
  "go_lesson2_course_title": "Go II - 構造体と並行処理",
  "go_lesson2_ex10_comment1": "* で掛け算します。",
  "go_lesson2_ex10_comment2": "H に 4 を指定して構造体を初期化します。",
  "go_lesson2_ex10_comment3": "メソッド名 Area を入力して呼び出します。",
  "go_lesson2_ex10_description": "名前のない関数「無名関数」と変数を捕捉する「クロージャ」を学びましょう。",
  "go_lesson2_ex10_slide1_content": "# レシーバ（受け取り手）を指定\n\n`func (r 型) メソッド名()` と書きます。`(r 型)` の部分を「レシーバ（受け取り手）」と呼びます。\n\n**コード例：**\n```go\n// Rect構造体に Area メソッドを追加\nfunc (r Rect) Area() int {\n    return r.W * r.H  // 幅 × 高さ\n}\n\n// 使い方\nrect := Rect{W: 3, H: 4}\nfmt.Println(rect.Area())  // 12 が表示される\n```\n\n**読み方：**\n- `(r Rect)` → 「Rect型のrが」\n- `Area()` → 「Area というメソッドを持つ」\n- `r.W * r.H` → 「自分のWとHを使って計算」",
  "go_lesson2_ex10_slide1_title": "メソッドの定義のしかた",
  "go_lesson2_ex10_slide2_content": "# 周りの変数を「覚えている」関数\n\n無名関数は、自分の外側にある変数を使うことができます。この仕組みを クロージャ と呼びます。\n\nコード例：\n```go\nx := 10\nfn := func() int {\n    return x * 2  // 外側の x を使っている！\n}\nfmt.Println(fn())  // 20\n```\n\nイメージ：\n無名関数が作られたとき、周りの変数を「写真に撮って覚えておく」ようなものです。\n\n使いどころ：\n- カウンターを作る\n- 設定を保持したまま何度も使う関数\n- ゴルーチンで外のデータを使う",
  "go_lesson2_ex10_slide2_title": "クロージャ：外の変数を使える",
  "go_lesson2_ex10_slide3_content": "名前のない関数「無名関数」と変数を捕捉する「クロージャ」を学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "go_lesson2_ex10_slide3_title": "やってみよう！",
  "go_lesson2_ex10_title": "メソッドの定義のしかた",
  "go_lesson2_ex11_description": "共通の振る舞いを定義する「インターフェース」を学びましょう。",
  "go_lesson2_ex11_title": "インターフェースを使おう",
  "go_lesson2_ex12_comment1": "interface でインターフェースを定義します。",
  "go_lesson2_ex12_comment2": "Dog{} でインスタンスを作成して代入します。",
  "go_lesson2_ex12_comment3": "メソッド名 Speak を入力して呼び出します。",
  "go_lesson2_ex12_slide1_content": "# メソッドの名前だけ書く\n\nインターフェースには「中身」は書きません。「こういうメソッドがあるはず」という約束だけです。\n\n**コード例：**\n```go\n// Speaker インターフェースを定義\ntype Speaker interface {\n    Speak()  // Speak メソッドを持っている約束\n}\n\n// Dog は Speak() を持つので Speaker として使える\ntype Dog struct{}\nfunc (d Dog) Speak() {\n    fmt.Println(\\\"woof\\\")\n}\n```\n\n**ポイント：**\n- `interface { }` の中にメソッド名だけ書く\n- そのメソッドを持つ型は自動的にインターフェースを満たす\n- 「implements」などの宣言は不要（Go言語の特徴！）",
  "go_lesson2_ex12_slide1_title": "interface の定義のしかた",
  "go_lesson2_ex12_title": "interface の定義のしかた",
  "go_lesson2_ex13_description": "関数の終了時に実行される「defer」を学びましょう。",
  "go_lesson2_ex13_title": "defer で後処理",
  "go_lesson2_ex14_comment1": "フォーマットパッケージを使って文字列を出力します。",
  "go_lesson2_ex14_comment2": "フォーマットパッケージを使って文字列を出力します。",
  "go_lesson2_ex14_slide1_content": "# 書いた瞬間ではなく、最後に実行\n\n`defer` をつけた文は、その行を通り過ぎても実行されず、関数が終わるときに実行されます。\n\n**コード例：**\n```go\nfunc main() {\n    defer fmt.Println(\\\"last\\\")   // あとで実行\n    fmt.Println(\\\"first\\\")        // 先に実行\n}\n// 出力: first → last\n```\n\n**実行の流れ：**\n1. `defer` の行を通る → 「lastを表示」を予約\n2. 「first」を表示\n3. 関数が終わる → 予約していた「last」を表示\n\n`defer` は「関数の出口で必ず実行」と覚えましょう！",
  "go_lesson2_ex14_slide1_title": "defer の使い方",
  "go_lesson2_ex14_title": "defer の使い方",
  "go_lesson2_ex15_description": "軽量スレッド「ゴルーチン」を使って並行処理を学びましょう。",
  "go_lesson2_ex15_title": "ゴルーチンで並行処理",
  "go_lesson2_ex16_comment1": "go でゴルーチンを起動します。",
  "go_lesson2_ex16_comment2": "Sleep でゴルーチンの完了を待ちます。",
  "go_lesson2_ex16_slide1_content": "# 「go」をつけるだけ！\n\n関数を呼び出すときに `go` をつけると、その関数が別のゴルーチン（別の流れ）で実行されます。\n\n**コード例：**\n```go\nfunc say(msg string) {\n    fmt.Println(msg)\n}\n\nfunc main() {\n    go say(\\\"hello\\\")  // 別のゴルーチンで実行\n    say(\\\"world\\\")     // こちらは普通に実行\n}\n```\n\n**ポイント：**\n- `go 関数名()` で別のゴルーチンで実行\n- 元の処理は待たずに次に進む\n- 終了を待ちたい場合は別の仕組みが必要",
  "go_lesson2_ex16_slide1_title": "go キーワードで並行実行",
  "go_lesson2_ex16_title": "go キーワードで並行実行",
  "go_lesson2_ex17_description": "ゴルーチン間でデータをやり取りする「チャネル」を学びましょう。",
  "go_lesson2_ex17_title": "チャネルで通信",
  "go_lesson2_ex18_comment1": "chan でチャネルを作成します。",
  "go_lesson2_ex18_comment2": "<- でチャネルに値を送信します。",
  "go_lesson2_ex18_comment3": "<- でチャネルから値を受信します。",
  "go_lesson2_ex18_slide1_content": "# <- で送信と受信\n\n矢印 `<-` の向きでデータの流れを表します。\n\n**送信と受信：**\n- `ch <- 値` → チャネルに値を送る（入れる）\n- `<-ch` → チャネルから値を受け取る（取り出す）\n\n**コード例：**\n```go\nch := make(chan int)  // チャネルを作成\n\n// 別のゴルーチンで送信\ngo func() { \n    ch <- 42  // チャネルに42を送る\n}()\n\nval := <-ch  // チャネルから受け取る\n// val は 42 になる\n```\n\n**ポイント：**\n受信側は、データが届くまで待ちます。これで同期（タイミングを合わせる）ができます！",
  "go_lesson2_ex18_slide1_title": "チャネルの使い方",
  "go_lesson2_ex18_title": "チャネルの使い方",
  "go_lesson2_ex19_description": "名前のない関数「無名関数」と変数を捕捉する「クロージャ」を学びましょう。",
  "go_lesson2_ex19_title": "無名関数とクロージャ",
  "go_lesson2_ex1_comment1": "return で複数の値を返す",
  "go_lesson2_ex1_description": "Go言語では、関数から複数の値を返すことができます。",
  "go_lesson2_ex1_slide1_content": "# 関数から2つ以上の結果を返す\n\n普通の関数は結果を1つだけ返しますが、Go言語では 2つ以上の値 を同時に返すことができます！\n\nたとえば：\n- わり算の「答え」と「あまり」を同時に返す\n- 「結果」と「うまくいったかどうか」を同時に返す\n\nこれは他の言語にはあまりない、Go言語の便利な機能です。",
  "go_lesson2_ex1_slide1_title": "複数の戻り値（もどりち）",
  "go_lesson2_ex1_slide2_content": "# カッコで複数の型を指定\n\n戻り値（もどりち）の型を `(型1, 型2)` のように、かっこで囲んで書きます。\n\nコード例：\n```go\n// わり算の答えとあまりを両方返す関数\nfunc divide(a, b int) (int, int) {\n    return a / b, a % b  // 2つの値を返す\n}\n\n// 2つの変数で受け取る\nq, r := divide(10, 3)\n// q=3（答え）, r=1（あまり）\n```\n\nポイント：\n- `return` のあとにカンマで区切って複数の値を書く\n- 受け取るときもカンマで区切った変数で受ける",
  "go_lesson2_ex1_slide2_title": "戻り値の書き方",
  "go_lesson2_ex1_slide3_content": "Go言語では、関数から複数の値を返すことができます。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "go_lesson2_ex1_slide3_title": "やってみよう！",
  "go_lesson2_ex1_title": "複数の値を返す関数",
  "go_lesson2_ex20_comment1": "func で無名関数を定義します。",
  "go_lesson2_ex20_comment2": "* で掛け算をして外側の n にアクセスします。",
  "go_lesson2_ex20_slide1_content": "# 周りの変数を「覚えている」関数\n\n無名関数は、自分の外側にある変数を使うことができます。この仕組みを **クロージャ** と呼びます。\n\n**コード例：**\n```go\nx := 10\nfn := func() int {\n    return x * 2  // 外側の x を使っている！\n}\nfmt.Println(fn())  // 20\n```\n\n**イメージ：**\n無名関数が作られたとき、周りの変数を「写真に撮って覚えておく」ようなものです。\n\n**使いどころ：**\n- カウンターを作る\n- 設定を保持したまま何度も使う関数\n- ゴルーチンで外のデータを使う",
  "go_lesson2_ex20_slide1_title": "クロージャ：外の変数を使える",
  "go_lesson2_ex20_title": "クロージャ：外の変数を使える",
  "go_lesson2_ex2_comment1": "return で複数の値を返します。",
  "go_lesson2_ex2_comment2": "return で複数の値を返します。",
  "go_lesson2_ex2_comment3": "関数名 minmax を入力して呼び出します。",
  "go_lesson2_ex2_description": "Go言語でのエラーの扱い方を学びましょう。",
  "go_lesson2_ex2_slide1_content": "# カッコで複数の型を指定\n\n戻り値（もどりち）の型を `(型1, 型2)` のように、かっこで囲んで書きます。\n\n**コード例：**\n```go\n// わり算の答えとあまりを両方返す関数\nfunc divide(a, b int) (int, int) {\n    return a / b, a % b  // 2つの値を返す\n}\n\n// 2つの変数で受け取る\nq, r := divide(10, 3)\n// q=3（答え）, r=1（あまり）\n```\n\n**ポイント：**\n- `return` のあとにカンマで区切って複数の値を書く\n- 受け取るときもカンマで区切った変数で受ける",
  "go_lesson2_ex2_slide1_title": "戻り値の書き方",
  "go_lesson2_ex2_slide2_content": "# エラーがあるかどうか確認しよう\n\n関数を呼んだあと、エラーが起きていないかチェックするのがGo言語の作法です。\n\nコード例：\n```go\n// 結果とエラーの両方を受け取る\nresult, err := someFunc()\n\n// err が nil じゃなければエラーが起きている\nif err != nil {\n    fmt.Println(\"エラーが起きました！\")\n}\n```\n\nチェックの流れ：\n1. 関数から「結果」と「エラー」を受け取る\n2. `err != nil` でエラーがあるか確認\n3. エラーがあれば対処、なければ続行",
  "go_lesson2_ex2_slide2_title": "エラーのチェック",
  "go_lesson2_ex2_slide3_content": "Go言語でのエラーの扱い方を学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "go_lesson2_ex2_slide3_title": "やってみよう！",
  "go_lesson2_ex2_title": "戻り値の書き方",
  "go_lesson2_ex3_comment1": "& でアドレスを取得",
  "go_lesson2_ex3_comment2": "*pでポインタの値を変更",
  "go_lesson2_ex3_description": "Go言語でのエラーの扱い方を学びましょう。",
  "go_lesson2_ex3_slide1_content": "# 変数の「住所」を覚えておく\n\nポインタ は、変数がコンピュータのどこに保存されているかを指し示す「住所」のようなものです。\n\nたとえるなら：\n- 変数 = 家\n- ポインタ = その家の住所\n\n住所を知っていれば、直接その家に行って中身を変えることができます。\n\n2つの記号：\n- `&`（アンパサンド）：変数の「住所」を取得\n- `*`（アスタリスク）：住所を使って「中身」にアクセス",
  "go_lesson2_ex3_slide1_title": "ポインタとは？",
  "go_lesson2_ex3_slide2_content": "# & と * の使い分け\n\n`&` は「住所を調べる」、`*` は「住所を使って中身を見る・変える」という意味です。\n\nコード例：\n```go\nx := 10      // x という変数に 10 を入れる\np := &x      // p に x の住所を入れる\n*p = 20      // 住所を使って中身を 20 に変更\nfmt.Println(x)  // 20 が表示される！\n```\n\nなぜ便利？\n- 関数に変数を渡すとき、コピーではなく本体を渡せる\n- 大きなデータをコピーせずに扱える\n- 「中身を変更できる」関数が作れる",
  "go_lesson2_ex3_slide2_title": "ポインタの使い方",
  "go_lesson2_ex3_slide3_content": "変数のアドレスを扱う「ポインタ」を学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "go_lesson2_ex3_slide3_title": "やってみよう！",
  "go_lesson2_ex3_title": "エラー処理の基本",
  "go_lesson2_ex4_comment1": "errors.New でエラーオブジェクトを作成します。",
  "go_lesson2_ex4_comment2": "エラーがないときは nil を返します。",
  "go_lesson2_ex4_comment3": "関数名 check を入力して呼び出します。",
  "go_lesson2_ex4_description": "関連するデータをまとめる「構造体」を学びましょう。",
  "go_lesson2_ex4_slide1_content": "# エラーがあるかどうか確認しよう\n\n関数を呼んだあと、エラーが起きていないかチェックするのがGo言語の作法です。\n\n**コード例：**\n```go\n// 結果とエラーの両方を受け取る\nresult, err := someFunc()\n\n// err が nil じゃなければエラーが起きている\nif err != nil {\n    fmt.Println(\\\"エラーが起きました！\\\")\n}\n```\n\n**チェックの流れ：**\n1. 関数から「結果」と「エラー」を受け取る\n2. `err != nil` でエラーがあるか確認\n3. エラーがあれば対処、なければ続行",
  "go_lesson2_ex4_slide1_title": "エラーのチェック",
  "go_lesson2_ex4_slide2_content": "# type で新しい型を作る\n\n`type 名前 struct { }` で構造体を定義します。中にはフィールド（項目）を書きます。\n\nコード例：\n```go\n// Person という構造体を定義\ntype Person struct {\n    Name string  // 名前フィールド（文字列）\n    Age  int     // 年齢フィールド（整数）\n}\n\n// 構造体を使ってデータを作る\np := Person{Name: \"Taro\", Age: 20}\nfmt.Println(p.Name)  // Taro が表示される\n```\n\nポイント：\n- `type 名前 struct` で設計図を作る\n- `{ }` の中にフィールド名と型を書く\n- `.フィールド名` でデータにアクセス",
  "go_lesson2_ex4_slide2_title": "struct の定義のしかた",
  "go_lesson2_ex4_slide3_content": "関連するデータをまとめる「構造体」を学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "go_lesson2_ex4_slide3_title": "やってみよう！",
  "go_lesson2_ex4_title": "エラーのチェック",
  "go_lesson2_ex5_comment1": "* でかけ算",
  "go_lesson2_ex5_description": "変数のアドレスを扱う「ポインタ」を学びましょう。",
  "go_lesson2_ex5_slide1_content": "# 構造体に「できること」を追加\n\nメソッド は、構造体に関連づけられた特別な関数です。「この構造体は何ができるか」を定義します。\n\nたとえば「四角形」構造体なら：\n- 面積を計算する\n- 周囲の長さを計算する\n- 大きさを2倍にする\n\nこれらの「できること」をメソッドとして追加できます。\n\n普通の関数との違い：\n- 普通の関数：単独で動く\n- メソッド：特定の構造体と一緒に動く",
  "go_lesson2_ex5_slide1_title": "メソッドとは？",
  "go_lesson2_ex5_slide2_content": "# レシーバ（受け取り手）を指定\n\n`func (r 型) メソッド名()` と書きます。`(r 型)` の部分を「レシーバ（受け取り手）」と呼びます。\n\nコード例：\n```go\n// Rect構造体に Area メソッドを追加\nfunc (r Rect) Area() int {\n    return r.W * r.H  // 幅 × 高さ\n}\n\n// 使い方\nrect := Rect{W: 3, H: 4}\nfmt.Println(rect.Area())  // 12 が表示される\n```\n\n読み方：\n- `(r Rect)` → 「Rect型のrが」\n- `Area()` → 「Area というメソッドを持つ」\n- `r.W * r.H` → 「自分のWとHを使って計算」",
  "go_lesson2_ex5_slide2_title": "メソッドの定義のしかた",
  "go_lesson2_ex5_slide3_content": "構造体に関連付けられた関数「メソッド」を学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "go_lesson2_ex5_slide3_title": "やってみよう！",
  "go_lesson2_ex5_title": "ポインタを使おう",
  "go_lesson2_ex6_comment1": "& でアドレスを取得します。",
  "go_lesson2_ex6_comment2": "*p で値を変更します。",
  "go_lesson2_ex6_description": "共通の振る舞いを定義する「インターフェース」を学びましょう。",
  "go_lesson2_ex6_slide1_content": "# & と * の使い分け\n\n`&` は「住所を調べる」、`*` は「住所を使って中身を見る・変える」という意味です。\n\n**コード例：**\n```go\nx := 10      // x という変数に 10 を入れる\np := &x      // p に x の住所を入れる\n*p = 20      // 住所を使って中身を 20 に変更\nfmt.Println(x)  // 20 が表示される！\n```\n\n**なぜ便利？**\n- 関数に変数を渡すとき、コピーではなく本体を渡せる\n- 大きなデータをコピーせずに扱える\n- 「中身を変更できる」関数が作れる",
  "go_lesson2_ex6_slide1_title": "ポインタの使い方",
  "go_lesson2_ex6_slide2_content": "# メソッドの名前だけ書く\n\nインターフェースには「中身」は書きません。「こういうメソッドがあるはず」という約束だけです。\n\nコード例：\n```go\n// Speaker インターフェースを定義\ntype Speaker interface {\n    Speak()  // Speak メソッドを持っている約束\n}\n\n// Dog は Speak() を持つので Speaker として使える\ntype Dog struct{}\nfunc (d Dog) Speak() {\n    fmt.Println(\"woof\")\n}\n```\n\nポイント：\n- `interface { }` の中にメソッド名だけ書く\n- そのメソッドを持つ型は自動的にインターフェースを満たす\n- 「implements」などの宣言は不要（Go言語の特徴！）",
  "go_lesson2_ex6_slide2_title": "interface の定義のしかた",
  "go_lesson2_ex6_slide3_content": "共通の振る舞いを定義する「インターフェース」を学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "go_lesson2_ex6_slide3_title": "やってみよう！",
  "go_lesson2_ex6_title": "ポインタの使い方",
  "go_lesson2_ex7_comment1": "defer で関数終了時に実行",
  "go_lesson2_ex7_description": "関連するデータをまとめる「構造体」を学びましょう。",
  "go_lesson2_ex7_slide1_content": "# 「あとでやること」を予約する\n\ndefer（ディファー）は、「関数が終わるときに必ずやること」を予約する仕組みです。\n\nたとえば：\n- 冷蔵庫を開けたら → 必ず閉める\n- ファイルを開いたら → 必ず閉じる\n- 部屋に入ったら → 出るとき電気を消す\n\n`defer` を使うと、「開いたらすぐ横に閉じる処理を書ける」ので、閉じ忘れを防げます！",
  "go_lesson2_ex7_slide1_title": "defer（ディファー）とは？",
  "go_lesson2_ex7_slide2_content": "# 書いた瞬間ではなく、最後に実行\n\n`defer` をつけた文は、その行を通り過ぎても実行されず、関数が終わるときに実行されます。\n\nコード例：\n```go\nfunc main() {\n    defer fmt.Println(\"last\")   // あとで実行\n    fmt.Println(\"first\")        // 先に実行\n}\n// 出力: first → last\n```\n\n実行の流れ：\n1. `defer` の行を通る → 「lastを表示」を予約\n2. 「first」を表示\n3. 関数が終わる → 予約していた「last」を表示\n\n`defer` は「関数の出口で必ず実行」と覚えましょう！",
  "go_lesson2_ex7_slide2_title": "defer の使い方",
  "go_lesson2_ex7_slide3_content": "関数の終了時に実行される「defer」を学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "go_lesson2_ex7_slide3_title": "やってみよう！",
  "go_lesson2_ex7_title": "構造体を定義しよう",
  "go_lesson2_ex8_comment1": "struct で構造体を定義します。",
  "go_lesson2_ex8_comment2": "int 型のフィールドを定義します。",
  "go_lesson2_ex8_comment3": "Y に 4 を指定して構造体を初期化します。",
  "go_lesson2_ex8_description": "軽量スレッド「ゴルーチン」を使って並行処理を学びましょう。",
  "go_lesson2_ex8_slide1_content": "# type で新しい型を作る\n\n`type 名前 struct { }` で構造体を定義します。中にはフィールド（項目）を書きます。\n\n**コード例：**\n```go\n// Person という構造体を定義\ntype Person struct {\n    Name string  // 名前フィールド（文字列）\n    Age  int     // 年齢フィールド（整数）\n}\n\n// 構造体を使ってデータを作る\np := Person{Name: \\\"Taro\\\", Age: 20}\nfmt.Println(p.Name)  // Taro が表示される\n```\n\n**ポイント：**\n- `type 名前 struct` で設計図を作る\n- `{ }` の中にフィールド名と型を書く\n- `.フィールド名` でデータにアクセス",
  "go_lesson2_ex8_slide1_title": "struct の定義のしかた",
  "go_lesson2_ex8_slide2_content": "# 「go」をつけるだけ！\n\n関数を呼び出すときに `go` をつけると、その関数が別のゴルーチン（別の流れ）で実行されます。\n\nコード例：\n```go\nfunc say(msg string) {\n    fmt.Println(msg)\n}\n\nfunc main() {\n    go say(\"hello\")  // 別のゴルーチンで実行\n    say(\"world\")     // こちらは普通に実行\n}\n```\n\nポイント：\n- `go 関数名()` で別のゴルーチンで実行\n- 元の処理は待たずに次に進む\n- 終了を待ちたい場合は別の仕組みが必要",
  "go_lesson2_ex8_slide2_title": "go キーワードで並行実行",
  "go_lesson2_ex8_slide3_content": "軽量スレッド「ゴルーチン」を使って並行処理を学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "go_lesson2_ex8_slide3_title": "やってみよう！",
  "go_lesson2_ex8_title": "struct の定義のしかた",
  "go_lesson2_ex9_comment1": "chan でチャネルを作成",
  "go_lesson2_ex9_comment2": "チャネルに値を送信",
  "go_lesson2_ex9_comment3": "チャネルから値を受信",
  "go_lesson2_ex9_description": "構造体に関連付けられた関数「メソッド」を学びましょう。",
  "go_lesson2_ex9_slide1_content": "# ゴルーチン同士の「通信パイプ」\n\nチャネル は、ゴルーチン同士がデータをやり取りするための「パイプ」のようなものです。\n\nたとえるなら：\n- 筒（パイプ）の片方から手紙を入れる\n- もう片方から手紙を受け取る\n\nなぜ必要？\nゴルーチンは別々に動いているので、直接データを渡せません。チャネルを使えば安全にやり取りできます。\n\nチャネルの作り方：\n```go\nch := make(chan int)  // int型を送れるチャネル\n```",
  "go_lesson2_ex9_slide1_title": "チャネルとは？",
  "go_lesson2_ex9_slide2_content": "# <- で送信と受信\n\n矢印 `<-` の向きでデータの流れを表します。\n\n送信と受信：\n- `ch <- 値` → チャネルに値を送る（入れる）\n- `<-ch` → チャネルから値を受け取る（取り出す）\n\nコード例：\n```go\nch := make(chan int)  // チャネルを作成\n\n// 別のゴルーチンで送信\ngo func() { \n    ch <- 42  // チャネルに42を送る\n}()\n\nval := <-ch  // チャネルから受け取る\n// val は 42 になる\n```\n\nポイント：\n受信側は、データが届くまで待ちます。これで同期（タイミングを合わせる）ができます！",
  "go_lesson2_ex9_slide2_title": "チャネルの使い方",
  "go_lesson2_ex9_slide3_content": "ゴルーチン間でデータをやり取りする「チャネル」を学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "go_lesson2_ex9_slide3_title": "やってみよう！",
  "go_lesson2_ex9_title": "メソッドを作ろう",
  "go_lesson2_title": "Go II - 構造体と並行処理",
  "go_lesson3_course_description": "Go言語の高度な機能を学びます。ジェネリクス、テスト、コンテキストなど、本格的なGoプログラミングを身につけましょう。",
  "go_lesson3_course_title": "Go III - ジェネリクスとテスト",
  "go_lesson3_ex10_comment1": "複数の値をまとめて格納する配列（またはリスト）を作成します。",
  "go_lesson3_ex10_comment2": "make でコピー先のスライスを作成します。",
  "go_lesson3_ex10_comment3": "copy でスライスをコピーします。",
  "go_lesson3_ex10_description": "パニックから回復する方法を学びましょう。",
  "go_lesson3_ex10_slide1_content": "# 短い方に合わせる\n\n```go\nsrc := []int{1, 2, 3, 4, 5}\ndst := make([]int, 3)\nn := copy(dst, src)  // n = 3\n// dst = [1, 2, 3]\n```",
  "go_lesson3_ex10_slide1_title": "部分コピー",
  "go_lesson3_ex10_slide2_content": "# パニックから立ち直る方法\n\nrecover を使うと、panic で止まりかけたプログラムを救出できます。ただし `defer` の中でしか使えません。\n\nコード例：\n```go\nfunc main() {\n    defer func() {\n        if r := recover(); r != nil {\n            // パニックを捕まえた！\n            fmt.Println(\"回復しました:\", r)\n        }\n    }()\n    \n    panic(\"エラー！\")  // パニック発生\n}\n// → 「回復しました: エラー！」と表示されて続行\n```\n\nポイント：\n- recover は defer の中で使う\n- panic の値を受け取れる",
  "go_lesson3_ex10_slide2_title": "recover（リカバー）で回復",
  "go_lesson3_ex10_slide3_content": "パニックから回復する方法を学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "go_lesson3_ex10_slide3_title": "やってみよう！",
  "go_lesson3_ex10_title": "部分コピー",
  "go_lesson3_ex11_description": "複数のチャネルを同時に待機しましょう。",
  "go_lesson3_ex11_title": "select で複数チャネル",
  "go_lesson3_ex12_comment1": "1 を入力してバッファ付きチャネルを作成します。",
  "go_lesson3_ex12_comment2": "<- でチャネルに値を送信します。",
  "go_lesson3_ex12_comment3": "select で複数チャネルを待機します。",
  "go_lesson3_ex12_slide1_content": "# すぐに次に進む方法\n\n`default` をつけると、どのチャネルもすぐに受信できない場合に待たずに進めます。\n\n**コード例：**\n```go\nselect {\ncase v := <-ch:\n    fmt.Println(\\\"受信:\\\", v)\ndefault:\n    fmt.Println(\\\"データがない！\\\")  // 待たずにここが実行される\n}\n```\n\n**使いどころ：**\n- データがあれば処理、なければ別のことをする\n- プログラムを止めたくないとき",
  "go_lesson3_ex12_slide1_title": "default で待たない",
  "go_lesson3_ex12_title": "default で待たない",
  "go_lesson3_ex13_description": "辞書のキーと値をイテレートしましょう。",
  "go_lesson3_ex13_title": "range で辞書をループ",
  "go_lesson3_ex14_comment1": "85 を入力してマップを完成させます。",
  "go_lesson3_ex14_comment2": "range で辞書をイテレートします。",
  "go_lesson3_ex14_slide1_content": "# 値を無視\n\n```go\nfor k := range m {\n    fmt.Println(k)\n}\n```",
  "go_lesson3_ex14_slide1_title": "キーだけ取得",
  "go_lesson3_ex14_title": "キーだけ取得",
  "go_lesson3_ex15_description": "既存の型から新しい型を定義しましょう。",
  "go_lesson3_ex15_title": "type で新しい型",
  "go_lesson3_ex16_comment1": "type で新しい型を定義します。",
  "go_lesson3_ex16_comment2": "25 を入力して変数を初期化します。",
  "go_lesson3_ex16_slide1_content": "# 誤った代入を防ぐ\n\n```go\ntype Celsius float64\ntype Fahrenheit float64\n\nvar c Celsius = 25\nvar f Fahrenheit = c  // コンパイルエラー！\n```",
  "go_lesson3_ex16_slide1_title": "型安全性",
  "go_lesson3_ex16_title": "型安全性",
  "go_lesson3_ex17_description": "構造体に別の構造体を埋め込みましょう。",
  "go_lesson3_ex17_title": "埋め込み（Embedding）",
  "go_lesson3_ex18_comment1": "Base を埋め込みます。",
  "go_lesson3_ex18_comment2": "100 を入力して構造体を初期化します。",
  "go_lesson3_ex18_slide1_content": "# 直接アクセス可能\n\n```go\ne := Employee{Person: Person{Name: \\\"Alice\\\"}, ID: 1}\nfmt.Println(e.Name)  // Alice（直接アクセス）\n```",
  "go_lesson3_ex18_slide1_title": "フィールドへのアクセス",
  "go_lesson3_ex18_title": "フィールドへのアクセス",
  "go_lesson3_ex19_description": "パニックから回復する方法を学びましょう。",
  "go_lesson3_ex19_title": "panic と recover",
  "go_lesson3_ex1_comment1": "any で任意の型を受け入れる",
  "go_lesson3_ex1_description": "型パラメータを使った汎用関数を学びましょう。",
  "go_lesson3_ex1_slide1_content": "# どんな型でも使える「万能関数」\n\nジェネリクス は、型（数字、文字など）を後から決められる仕組みです。同じ処理を色々な型で使い回せます。\n\nたとえば：\n- 数字のリストから最初の要素を取る\n- 文字列のリストから最初の要素を取る\n\n両方とも「最初を取る」という同じ処理なのに、型が違うだけで別の関数を書くのは大変ですよね？\n\nジェネリクスを使うと：\n```go\nfunc Print[T any](v T) {\n    fmt.Println(v)  // Tは何の型でもOK\n}\nPrint(42)       // 数字でもOK\nPrint(\"hello\")  // 文字でもOK\n```",
  "go_lesson3_ex1_slide1_title": "ジェネリクスとは？",
  "go_lesson3_ex1_slide2_content": "# 「この型だけ使える」と制限する\n\n何でも受け入れると困ることもあります。「比較できる型だけ」など、制限をつけられます。\n\nよく使う制約：\n- `any`：どんな型でもOK\n- `comparable`：`==` で比較できる型だけ\n\nコード例：\n```go\n// comparable で比較できる型に制限\nfunc Equal[T comparable](a, b T) bool {\n    return a == b  // == が使える！\n}\n```\n\n`[T comparable]` は「Tは比較できる型だけね」という意味です。",
  "go_lesson3_ex1_slide2_title": "型制約（かたせいやく）",
  "go_lesson3_ex1_slide3_content": "型パラメータを使った汎用関数を学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "go_lesson3_ex1_slide3_title": "やってみよう！",
  "go_lesson3_ex1_title": "ジェネリクスの基本",
  "go_lesson3_ex20_comment1": "recover でパニックを捕捉します。",
  "go_lesson3_ex20_comment2": "panic でパニックを発生させます。",
  "go_lesson3_ex20_slide1_content": "# パニックから立ち直る方法\n\n**recover** を使うと、panic で止まりかけたプログラムを救出できます。ただし `defer` の中でしか使えません。\n\n**コード例：**\n```go\nfunc main() {\n    defer func() {\n        if r := recover(); r != nil {\n            // パニックを捕まえた！\n            fmt.Println(\\\"回復しました:\\\", r)\n        }\n    }()\n    \n    panic(\\\"エラー！\\\")  // パニック発生\n}\n// → 「回復しました: エラー！」と表示されて続行\n```\n\n**ポイント：**\n- recover は defer の中で使う\n- panic の値を受け取れる",
  "go_lesson3_ex20_slide1_title": "recover（リカバー）で回復",
  "go_lesson3_ex20_title": "recover（リカバー）で回復",
  "go_lesson3_ex2_comment1": "any で任意の型を受け入れます。",
  "go_lesson3_ex2_comment2": "slice を入力して最初の要素を返します。",
  "go_lesson3_ex2_comment3": "複数の値をまとめて格納する配列（またはリスト）を作成します。",
  "go_lesson3_ex2_description": "比較可能な型に制限する方法を学びましょう。",
  "go_lesson3_ex2_slide1_content": "# 「この型だけ使える」と制限する\n\n何でも受け入れると困ることもあります。「比較できる型だけ」など、制限をつけられます。\n\n**よく使う制約：**\n- `any`：どんな型でもOK\n- `comparable`：`==` で比較できる型だけ\n\n**コード例：**\n```go\n// comparable で比較できる型に制限\nfunc Equal[T comparable](a, b T) bool {\n    return a == b  // == が使える！\n}\n```\n\n`[T comparable]` は「Tは比較できる型だけね」という意味です。",
  "go_lesson3_ex2_slide1_title": "型制約（かたせいやく）",
  "go_lesson3_ex2_slide2_content": "# 要素の検索\n\n```go\nnums := []int{1, 2, 3}\nfmt.Println(Contains(nums, 2))  // true\nfmt.Println(Contains(nums, 5))  // false\n```",
  "go_lesson3_ex2_slide2_title": "使用例",
  "go_lesson3_ex2_slide3_content": "比較可能な型に制限する方法を学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "go_lesson3_ex2_slide3_title": "やってみよう！",
  "go_lesson3_ex2_title": "型制約（かたせいやく）",
  "go_lesson3_ex3_comment1": "make でスライスを作成",
  "go_lesson3_ex3_description": "比較可能な型に制限する方法を学びましょう。",
  "go_lesson3_ex3_slide1_content": "# サイズを指定してスライスを作る\n\nmake を使うと、最初からサイズを指定してスライスを作れます。\n\nたとえるなら：\n- `[]int{1,2,3}` → 「中身入り」のお弁当箱を用意\n- `make([]int, 5)` → 「5つ分の空の」お弁当箱を用意\n\nコード例：\n```go\n// 長さ5のスライスを作る（中身は0で埋まる）\ns1 := make([]int, 5)\n// s1 = [0, 0, 0, 0, 0]\n\n// 長さ0、でも10個分の場所を確保\ns2 := make([]int, 0, 10)\n```",
  "go_lesson3_ex3_slide1_title": "make（メイク）でスライスを作る",
  "go_lesson3_ex3_slide2_content": "# 速くて効率的になる\n\nスライスに `append` で要素を追加していくと、容量が足りなくなるたびに新しい場所を確保し直します。これは時間がかかります。\n\nmake で先に場所を確保：\n```go\n// 最初から100個分の場所を確保\nresult := make([]int, 0, 100)\n\nfor i := 0; i < 100; i++ {\n    result = append(result, i)  // 場所の確保し直しが不要！\n}\n```\n\n「100個追加する」とわかっているなら、先に100個分の場所を用意しておく方が効率的です。",
  "go_lesson3_ex3_slide2_title": "なぜ make を使う？",
  "go_lesson3_ex3_slide3_content": "容量を指定してスライスを作成しましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "go_lesson3_ex3_slide3_title": "やってみよう！",
  "go_lesson3_ex3_title": "型制約 comparable",
  "go_lesson3_ex4_comment1": "comparable で比較可能な型に制限します。",
  "go_lesson3_ex4_comment2": "range でスライスをイテレートします。",
  "go_lesson3_ex4_comment3": "== で値が一致するか比較します。",
  "go_lesson3_ex4_comment4": "\\\"c\\\" を入力してスライスを完成させます。",
  "go_lesson3_ex4_description": "スライスに要素を追加しましょう。",
  "go_lesson3_ex4_slide1_content": "# 要素の検索\n\n```go\nnums := []int{1, 2, 3}\nfmt.Println(Contains(nums, 2))  // true\nfmt.Println(Contains(nums, 5))  // false\n```",
  "go_lesson3_ex4_slide1_title": "使用例",
  "go_lesson3_ex4_slide2_content": "# ... で展開\n\n```go\na := []int{1, 2}\nb := []int{3, 4}\nc := append(a, b...)  // [1, 2, 3, 4]\n```",
  "go_lesson3_ex4_slide2_title": "スライス同士の結合",
  "go_lesson3_ex4_slide3_content": "スライスに要素を追加しましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "go_lesson3_ex4_slide3_title": "やってみよう！",
  "go_lesson3_ex4_title": "使用例",
  "go_lesson3_ex5_comment1": "copy でスライスをコピー",
  "go_lesson3_ex5_description": "容量を指定してスライスを作成しましょう。",
  "go_lesson3_ex5_slide1_content": "# 要素をコピー\n\ncopy は、スライスの要素を別のスライスにコピーします。\n\n```go\nsrc := []int{1, 2, 3}\ndst := make([]int, len(src))\ncopy(dst, src)\n```",
  "go_lesson3_ex5_slide1_title": "copy とは？",
  "go_lesson3_ex5_slide2_content": "# 短い方に合わせる\n\n```go\nsrc := []int{1, 2, 3, 4, 5}\ndst := make([]int, 3)\nn := copy(dst, src)  // n = 3\n// dst = [1, 2, 3]\n```",
  "go_lesson3_ex5_slide2_title": "部分コピー",
  "go_lesson3_ex5_slide3_content": "スライスの内容をコピーしましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "go_lesson3_ex5_slide3_title": "やってみよう！",
  "go_lesson3_ex5_title": "make でスライス作成",
  "go_lesson3_ex6_comment1": "make でスライスを作成します。",
  "go_lesson3_ex6_comment2": "10 を代入します。",
  "go_lesson3_ex6_description": "複数のチャネルを同時に待機しましょう。",
  "go_lesson3_ex6_slide1_content": "# 速くて効率的になる\n\nスライスに `append` で要素を追加していくと、容量が足りなくなるたびに新しい場所を確保し直します。これは時間がかかります。\n\n**make で先に場所を確保：**\n```go\n// 最初から100個分の場所を確保\nresult := make([]int, 0, 100)\n\nfor i := 0; i < 100; i++ {\n    result = append(result, i)  // 場所の確保し直しが不要！\n}\n```\n\n「100個追加する」とわかっているなら、先に100個分の場所を用意しておく方が効率的です。",
  "go_lesson3_ex6_slide1_title": "なぜ make を使う？",
  "go_lesson3_ex6_slide2_content": "# すぐに次に進む方法\n\n`default` をつけると、どのチャネルもすぐに受信できない場合に待たずに進めます。\n\nコード例：\n```go\nselect {\ncase v := <-ch:\n    fmt.Println(\"受信:\", v)\ndefault:\n    fmt.Println(\"データがない！\")  // 待たずにここが実行される\n}\n```\n\n使いどころ：\n- データがあれば処理、なければ別のことをする\n- プログラムを止めたくないとき",
  "go_lesson3_ex6_slide2_title": "default で待たない",
  "go_lesson3_ex6_slide3_content": "複数のチャネルを同時に待機しましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "go_lesson3_ex6_slide3_title": "やってみよう！",
  "go_lesson3_ex6_title": "なぜ make を使う？",
  "go_lesson3_ex7_comment1": "range で辞書をイテレート",
  "go_lesson3_ex7_description": "スライスに要素を追加しましょう。",
  "go_lesson3_ex7_slide1_content": "# キーと値を取得\n\nrange で辞書のキーと値を取得できます。\n\n```go\nm := map[string]int{\"a\": 1, \"b\": 2}\nfor k, v := range m {\n    fmt.Println(k, v)\n}\n```",
  "go_lesson3_ex7_slide1_title": "辞書の range",
  "go_lesson3_ex7_slide2_content": "# 値を無視\n\n```go\nfor k := range m {\n    fmt.Println(k)\n}\n```",
  "go_lesson3_ex7_slide2_title": "キーだけ取得",
  "go_lesson3_ex7_slide3_content": "辞書のキーと値をイテレートしましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "go_lesson3_ex7_slide3_title": "やってみよう！",
  "go_lesson3_ex7_title": "append でスライス結合",
  "go_lesson3_ex8_comment1": "複数の値をまとめて格納する配列（またはリスト）を作成します。",
  "go_lesson3_ex8_comment2": "... でスライスを展開します。",
  "go_lesson3_ex8_description": "既存の型から新しい型を定義しましょう。",
  "go_lesson3_ex8_slide1_content": "# ... で展開\n\n```go\na := []int{1, 2}\nb := []int{3, 4}\nc := append(a, b...)  // [1, 2, 3, 4]\n```",
  "go_lesson3_ex8_slide1_title": "スライス同士の結合",
  "go_lesson3_ex8_slide2_content": "# 誤った代入を防ぐ\n\n```go\ntype Celsius float64\ntype Fahrenheit float64\n\nvar c Celsius = 25\nvar f Fahrenheit = c  // コンパイルエラー！\n```",
  "go_lesson3_ex8_slide2_title": "型安全性",
  "go_lesson3_ex8_slide3_content": "既存の型から新しい型を定義しましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "go_lesson3_ex8_slide3_title": "やってみよう！",
  "go_lesson3_ex8_title": "スライス同士の結合",
  "go_lesson3_ex9_comment1": "Base を埋め込む",
  "go_lesson3_ex9_description": "スライスの内容をコピーしましょう。",
  "go_lesson3_ex9_slide1_content": "# 構造体の継承的な機能\n\nGoでは 埋め込み で構造体を合成できます。\n\n```go\ntype Person struct {\n    Name string\n}\n\ntype Employee struct {\n    Person  // 埋め込み\n    ID int\n}\n```",
  "go_lesson3_ex9_slide1_title": "埋め込みとは？",
  "go_lesson3_ex9_slide2_content": "# 直接アクセス可能\n\n```go\ne := Employee{Person: Person{Name: \"Alice\"}, ID: 1}\nfmt.Println(e.Name)  // Alice（直接アクセス）\n```",
  "go_lesson3_ex9_slide2_title": "フィールドへのアクセス",
  "go_lesson3_ex9_slide3_content": "構造体に別の構造体を埋め込みましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "go_lesson3_ex9_slide3_title": "やってみよう！",
  "go_lesson3_ex9_title": "copy でスライスコピー",
  "go_lesson3_title": "Go III - ジェネリクスとテスト",
  "go_lesson4_course_description": "Go言語の並行処理とネットワークプログラミングを学びます。context、sync、httpなど、実用的なパターンを身につけましょう。",
  "go_lesson4_course_title": "Go IV - 並行処理とネットワーク",
  "go_lesson4_ex10_comment1": "変数を宣言し、同時に数値を代入します（型推論を使用）。",
  "go_lesson4_ex10_description": "コマンドライン引数を取得しましょう。",
  "go_lesson4_ex10_slide1_content": "# 処理を一時停止\n\n```go\ntime.Sleep(1 * time.Second)\n```",
  "go_lesson4_ex10_slide1_title": "Sleep で一時停止",
  "go_lesson4_ex10_slide2_content": "# 引数の数をチェック\n\n```go\nif len(os.Args) < 2 {\n    fmt.Println(\"Usage: program <arg>\")\n    return\n}\n```",
  "go_lesson4_ex10_slide2_title": "len で引数数を確認",
  "go_lesson4_ex10_slide3_content": "コマンドライン引数を取得しましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "go_lesson4_ex10_slide3_title": "やってみよう！",
  "go_lesson4_ex10_title": "Sleep で一時停止",
  "go_lesson4_ex11_description": "構造体をJSONに変換しましょう。",
  "go_lesson4_ex11_title": "json.Marshal",
  "go_lesson4_ex12_comment1": "\\\"Apple\\\" を入力して構造体を初期化します。",
  "go_lesson4_ex12_comment2": "Marshal で JSON に変換します。",
  "go_lesson4_ex12_slide1_content": "# バッククォートでタグをつける\n\n構造体のフィールドに「タグ」をつけると、JSONでの名前を指定できます。\n\n**コード例：**\n```go\ntype Person struct {\n    Name string `json:\\\"name\\\"`      // JSONでは\\\"name\\\"\n    Age  int    `json:\\\"age\\\"`       // JSONでは\\\"age\\\"\n}\n```\n\n**タグの書き方：**\n- フィールド名のあとに `` `json:\\\"名前\\\"` `` と書く\n- バッククォート（`）で囲む（シングルクォートではない）\n\n**なぜ使う？**\nGoでは「Name」だけど、JSONでは「name」（小文字）にしたい、など。",
  "go_lesson4_ex12_slide1_title": "タグでJSONの名前を指定",
  "go_lesson4_ex12_title": "タグでJSONの名前を指定",
  "go_lesson4_ex13_description": "JSONを構造体に変換しましょう。",
  "go_lesson4_ex13_title": "json.Unmarshal",
  "go_lesson4_ex14_comment1": "\\\"Banana\\\" を入力してJSONを完成させます。",
  "go_lesson4_ex14_comment2": "Unmarshal で JSON をパースします。",
  "go_lesson4_ex14_slide1_content": "# & を忘れずに\n\n```go\njson.Unmarshal(data, &result)  // OK\njson.Unmarshal(data, result)   // NG\n```",
  "go_lesson4_ex14_slide1_title": "ポインタを渡す",
  "go_lesson4_ex14_title": "ポインタを渡す",
  "go_lesson4_ex15_description": "文字列操作関数を使いましょう。",
  "go_lesson4_ex15_title": "strings パッケージ",
  "go_lesson4_ex16_comment1": "\\\"hello,world\\\" を入力して文字列を設定します。",
  "go_lesson4_ex16_comment2": "Split で文字列を分割します。",
  "go_lesson4_ex16_slide1_content": "# 変換と検索\n\n```go\nstrings.ToUpper(s)\nstrings.ToLower(s)\nstrings.TrimSpace(s)\nstrings.Replace(s, \\\"old\\\", \\\"new\\\", -1)\n```",
  "go_lesson4_ex16_slide1_title": "よく使う関数",
  "go_lesson4_ex16_title": "よく使う関数",
  "go_lesson4_ex17_description": "文字列を数値に変換しましょう。",
  "go_lesson4_ex17_title": "strconv.Atoi",
  "go_lesson4_ex18_comment1": "Atoi で文字列を整数に変換します。",
  "go_lesson4_ex18_slide1_content": "# 数値から文字列\n\n```go\ns := strconv.Itoa(123)  // \\\"123\\\"\n```",
  "go_lesson4_ex18_slide1_title": "逆変換",
  "go_lesson4_ex18_title": "逆変換",
  "go_lesson4_ex19_description": "コマンドライン引数を取得しましょう。",
  "go_lesson4_ex19_title": "os.Args",
  "go_lesson4_ex1_comment1": "Lock でロックを取得",
  "go_lesson4_ex1_comment2": "Unlockでロックを解放",
  "go_lesson4_ex1_description": "排他制御でデータを保護しましょう。",
  "go_lesson4_ex1_slide1_content": "# 「今は私だけ！」と宣言する仕組み\n\nMutex は、複数のゴルーチンが同じデータを同時に変更しないようにする「鍵」です。\n\nたとえるなら：\n- トイレの個室のカギ\n- 入る前に「Lock（ロック）」→ 使用中\n- 出るときに「Unlock（アンロック）」→ 次の人どうぞ\n\nコード例：\n```go\nvar mu sync.Mutex  // カギを用意\nvar count int\n\nmu.Lock()    // カギを閉める（他の人は待つ）\ncount++      // 安全にデータを変更\nmu.Unlock()  // カギを開ける（次の人OK）\n```",
  "go_lesson4_ex1_slide1_title": "Mutex（ミューテックス）とは？",
  "go_lesson4_ex1_slide2_content": "# ロック忘れを防ぐ\n\n`defer` と組み合わせると、関数を抜けるときに必ず Unlock されます。\n\nコード例：\n```go\nmu.Lock()\ndefer mu.Unlock()  // 関数を抜けるとき必ずUnlock\n\n// ここで何か処理...\n// エラーが起きても、returnしても、Unlockされる！\n```\n\nなぜ大事？\n- Unlock を忘れると他のゴルーチンが永遠に待ち続ける\n- defer を使えば忘れる心配なし！",
  "go_lesson4_ex1_slide2_title": "defer と組み合わせると安全",
  "go_lesson4_ex1_slide3_content": "排他制御でデータを保護しましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "go_lesson4_ex1_slide3_title": "やってみよう！",
  "go_lesson4_ex1_title": "sync.Mutex",
  "go_lesson4_ex20_comment1": "Args でコマンドライン引数を取得します。",
  "go_lesson4_ex20_slide1_content": "# 引数の数をチェック\n\n```go\nif len(os.Args) < 2 {\n    fmt.Println(\\\"Usage: program <arg>\\\")\n    return\n}\n```",
  "go_lesson4_ex20_slide1_title": "len で引数数を確認",
  "go_lesson4_ex20_title": "len で引数数を確認",
  "go_lesson4_ex2_comment1": "Lock でロックを取得します。",
  "go_lesson4_ex2_comment2": "Unlock でロックを解放します。",
  "go_lesson4_ex2_comment3": "Waitでカウンタが0になるまで待つ",
  "go_lesson4_ex2_description": "複数のゴルーチンの完了を待機しましょう。",
  "go_lesson4_ex2_slide1_content": "# ロック忘れを防ぐ\n\n`defer` と組み合わせると、関数を抜けるときに必ず Unlock されます。\n\n**コード例：**\n```go\nmu.Lock()\ndefer mu.Unlock()  // 関数を抜けるとき必ずUnlock\n\n// ここで何か処理...\n// エラーが起きても、returnしても、Unlockされる！\n```\n\n**なぜ大事？**\n- Unlock を忘れると他のゴルーチンが永遠に待ち続ける\n- defer を使えば忘れる心配なし！",
  "go_lesson4_ex2_slide1_title": "defer と組み合わせると安全",
  "go_lesson4_ex2_slide2_content": "# Add, Done, Wait を覚えよう\n\n3つのメソッドの役割：\n\n- `Add(n)` → 「n人出発するよ」カウントを増やす\n- `Done()` → 「1人終わったよ」カウントを1減らす\n- `Wait()` → カウントが0になるまで待つ\n\n使い方の流れ：\n```go\nwg.Add(3)  // 3つのゴルーチンを待つ\n\ngo func() { defer wg.Done(); /* 処理1 */ }()\ngo func() { defer wg.Done(); /* 処理2 */ }()\ngo func() { defer wg.Done(); /* 処理3 */ }()\n\nwg.Wait()  // 3つ全部終わるまでここで止まる\nfmt.Println(\"全員完了！\")\n```",
  "go_lesson4_ex2_slide2_title": "3つのメソッド",
  "go_lesson4_ex2_slide3_content": "複数のゴルーチンの完了を待機しましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "go_lesson4_ex2_slide3_title": "やってみよう！",
  "go_lesson4_ex2_title": "defer と組み合わせると安全",
  "go_lesson4_ex3_comment1": "Background でルートコンテキストを作成",
  "go_lesson4_ex3_description": "複数のゴルーチンの完了を待機しましょう。",
  "go_lesson4_ex3_slide1_content": "# 処理を「キャンセル」したり「制限時間」をつける仕組み\n\ncontext は、処理を途中で止めたり、時間制限をつけたりするための仕組みです。\n\nたとえるなら：\n- レストランで注文したけど「やっぱりキャンセル」\n- 「5分待っても料理が来なかったら帰る」\n\nなぜ必要？\n- ユーザーがページを閉じたら、データ取得も止めたい\n- 時間がかかりすぎたら諦めたい\n\n基本のコンテキスト：\n```go\nctx := context.Background()  // 一番基本のコンテキスト\n```",
  "go_lesson4_ex3_slide1_title": "context（コンテキスト）とは？",
  "go_lesson4_ex3_slide2_content": "# キャンセルや時間制限をつける\n\n基本のコンテキストから、機能を追加したコンテキストを作れます。\n\nWithCancel：キャンセルできる\n```go\nctx, cancel := context.WithCancel(context.Background())\ndefer cancel()  // 関数を抜けるときキャンセル\n```\n\nWithTimeout：時間制限をつける\n```go\n// 5秒で自動的にキャンセル\nctx, cancel := context.WithTimeout(ctx, 5*time.Second)\ndefer cancel()\n```\n\nポイント：\n`cancel()` を呼ぶと、そのコンテキストを使っている処理に「もう止めて」と伝えられます。",
  "go_lesson4_ex3_slide2_title": "色々なコンテキスト",
  "go_lesson4_ex3_slide3_content": "コンテキストの基本を学びましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "go_lesson4_ex3_slide3_title": "やってみよう！",
  "go_lesson4_ex3_title": "sync.WaitGroup",
  "go_lesson4_ex4_comment1": "Add でカウンタを増やします。",
  "go_lesson4_ex4_comment2": "Done でカウンタを減らします。",
  "go_lesson4_ex4_comment3": "Wait でカウンタが0になるまで待ちます。",
  "go_lesson4_ex4_description": "キャンセル可能なコンテキストを作成しましょう。",
  "go_lesson4_ex4_slide1_content": "# Add, Done, Wait を覚えよう\n\n**3つのメソッドの役割：**\n\n- `Add(n)` → 「n人出発するよ」カウントを増やす\n- `Done()` → 「1人終わったよ」カウントを1減らす\n- `Wait()` → カウントが0になるまで待つ\n\n**使い方の流れ：**\n```go\nwg.Add(3)  // 3つのゴルーチンを待つ\n\ngo func() { defer wg.Done(); /* 処理1 */ }()\ngo func() { defer wg.Done(); /* 処理2 */ }()\ngo func() { defer wg.Done(); /* 処理3 */ }()\n\nwg.Wait()  // 3つ全部終わるまでここで止まる\nfmt.Println(\\\"全員完了！\\\")\n```",
  "go_lesson4_ex4_slide1_title": "3つのメソッド",
  "go_lesson4_ex4_slide2_content": "# Done チャネル\n\n```go\nselect {\ncase <-ctx.Done():\n    return ctx.Err()\ndefault:\n    // 処理続行\n}\n```",
  "go_lesson4_ex4_slide2_title": "キャンセルの確認",
  "go_lesson4_ex4_slide3_content": "キャンセル可能なコンテキストを作成しましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "go_lesson4_ex4_slide3_title": "やってみよう！",
  "go_lesson4_ex4_title": "3つのメソッド",
  "go_lesson4_ex5_comment1": "Millisecond でミリ秒を表す",
  "go_lesson4_ex5_description": "コンテキストの基本を学びましょう。",
  "go_lesson4_ex5_slide1_content": "# 時間の長さ\n\ntime.Duration は、ナノ秒単位の時間を表します。\n\n```go\nd := 5 * time.Second\nd := 100 * time.Millisecond\nd := 2 * time.Hour\n```",
  "go_lesson4_ex5_slide1_title": "Duration とは？",
  "go_lesson4_ex5_slide2_content": "# 処理を一時停止\n\n```go\ntime.Sleep(1 * time.Second)\n```",
  "go_lesson4_ex5_slide2_title": "Sleep で一時停止",
  "go_lesson4_ex5_slide3_content": "時間の長さを扱いましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "go_lesson4_ex5_slide3_title": "やってみよう！",
  "go_lesson4_ex5_title": "context.Background",
  "go_lesson4_ex6_comment1": "Background でルートコンテキストを作成します。",
  "go_lesson4_ex6_comment2": "Err でエラーを取得します。",
  "go_lesson4_ex6_description": "構造体をJSONに変換しましょう。",
  "go_lesson4_ex6_slide1_content": "# キャンセルや時間制限をつける\n\n基本のコンテキストから、機能を追加したコンテキストを作れます。\n\n**WithCancel：キャンセルできる**\n```go\nctx, cancel := context.WithCancel(context.Background())\ndefer cancel()  // 関数を抜けるときキャンセル\n```\n\n**WithTimeout：時間制限をつける**\n```go\n// 5秒で自動的にキャンセル\nctx, cancel := context.WithTimeout(ctx, 5*time.Second)\ndefer cancel()\n```\n\n**ポイント：**\n`cancel()` を呼ぶと、そのコンテキストを使っている処理に「もう止めて」と伝えられます。",
  "go_lesson4_ex6_slide1_title": "色々なコンテキスト",
  "go_lesson4_ex6_slide2_content": "# バッククォートでタグをつける\n\n構造体のフィールドに「タグ」をつけると、JSONでの名前を指定できます。\n\nコード例：\n```go\ntype Person struct {\n    Name string `json:\"name\"`      // JSONでは\"name\"\n    Age  int    `json:\"age\"`       // JSONでは\"age\"\n}\n```\n\nタグの書き方：\n- フィールド名のあとに `` `json:\"名前\"` `` と書く\n- バッククォート（`）で囲む（シングルクォートではない）\n\nなぜ使う？\nGoでは「Name」だけど、JSONでは「name」（小文字）にしたい、など。",
  "go_lesson4_ex6_slide2_title": "タグでJSONの名前を指定",
  "go_lesson4_ex6_slide3_content": "構造体をJSONに変換しましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "go_lesson4_ex6_slide3_title": "やってみよう！",
  "go_lesson4_ex6_title": "色々なコンテキスト",
  "go_lesson4_ex7_comment1": "Unmarshal で JSON をパース",
  "go_lesson4_ex7_description": "キャンセル可能なコンテキストを作成しましょう。",
  "go_lesson4_ex7_slide1_content": "# JSON → Go\n\njson.Unmarshal で JSON を Go の値に変換します。\n\n```go\nvar user User\nerr := json.Unmarshal(data, &user)\n```",
  "go_lesson4_ex7_slide1_title": "Unmarshal とは？",
  "go_lesson4_ex7_slide2_content": "# & を忘れずに\n\n```go\njson.Unmarshal(data, &result)  // OK\njson.Unmarshal(data, result)   // NG\n```",
  "go_lesson4_ex7_slide2_title": "ポインタを渡す",
  "go_lesson4_ex7_slide3_content": "JSONを構造体に変換しましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "go_lesson4_ex7_slide3_title": "やってみよう！",
  "go_lesson4_ex7_title": "context.WithCancel",
  "go_lesson4_ex8_comment1": "WithCancel でキャンセル可能にします。",
  "go_lesson4_ex8_comment2": "関数（cancel）を呼び出して実行します。",
  "go_lesson4_ex8_description": "文字列操作関数を使いましょう。",
  "go_lesson4_ex8_slide1_content": "# Done チャネル\n\n```go\nselect {\ncase <-ctx.Done():\n    return ctx.Err()\ndefault:\n    // 処理続行\n}\n```",
  "go_lesson4_ex8_slide1_title": "キャンセルの確認",
  "go_lesson4_ex8_slide2_content": "# 変換と検索\n\n```go\nstrings.ToUpper(s)\nstrings.ToLower(s)\nstrings.TrimSpace(s)\nstrings.Replace(s, \"old\", \"new\", -1)\n```",
  "go_lesson4_ex8_slide2_title": "よく使う関数",
  "go_lesson4_ex8_slide3_content": "文字列操作関数を使いましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "go_lesson4_ex8_slide3_title": "やってみよう！",
  "go_lesson4_ex8_title": "キャンセルの確認",
  "go_lesson4_ex9_comment1": "Atoi で文字列を整数に変換",
  "go_lesson4_ex9_description": "時間の長さを扱いましょう。",
  "go_lesson4_ex9_slide1_content": "# 文字列と数値の変換\n\nstrconv.Atoi で文字列を整数に変換します。\n\n```go\nnum, err := strconv.Atoi(\"123\")\nif err != nil {\n    // エラー処理\n}\n```",
  "go_lesson4_ex9_slide1_title": "strconv パッケージ",
  "go_lesson4_ex9_slide2_content": "# 数値から文字列\n\n```go\ns := strconv.Itoa(123)  // \"123\"\n```",
  "go_lesson4_ex9_slide2_title": "逆変換",
  "go_lesson4_ex9_slide3_content": "文字列を数値に変換しましょう。\n\n（準備ができたら「レッスン開始」を選択してください。）",
  "go_lesson4_ex9_slide3_title": "やってみよう！",
  "go_lesson4_ex9_title": "time.Duration",
  "go_lesson4_title": "Go IV - 並行処理とネットワーク"
}
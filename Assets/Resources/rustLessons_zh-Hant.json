{
  "rust_lesson1_course_title": "Introduction to Rust",
  "rust_lesson1_course_description": "Learn the basics of Rust programming.",
  "rust_lesson2_course_title": "Rust II - Intermediate",
  "rust_lesson2_course_description": "Learn intermediate Rust concepts.",
  "rust_lesson3_course_title": "Rust III - Advanced",
  "rust_lesson3_course_description": "Master advanced Rust techniques.",
  "rust_lesson4_course_title": "Rust IV - Expert Level",
  "rust_lesson4_course_description": "Expert-level Rust programming.",
  "rust_lesson1_ex5_slide2_content": "条件によって動きを変える if文を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
  "rust_lesson4_ex9_title": "collect で変換",
  "rust_lesson2_ex7_slide1_content": "# 「あるかもしれない、ないかもしれない」\n\nOption<T> は、valueが「あるかもしれないし、ないかもしれない」ことを表すtypeです。\n\nFor example：\n- dictionaryで単語を探す → 見つかるかもしれないし、ないかもしれない\n- ゲームでアイテムを拾う → 落ちてるかもしれないし、ないかもしれない\n\n2つの状態：\n- `Some(値)` → valueがある！\n- `None` → valueがない...\n\n他の言語では `null` をuseが、Rustでは `Option` で安全に扱います。",
  "rust_lesson1_ex2_slide1_title": "variable（へんすう）?",
  "rust_lesson1_ex7_description": "「ベクタ（Vec）」をuseと、たくさんのデータを一つの「長い はこ」にまとめて入れられます。",
  "rust_lesson2_ex9_slide2_content": "# 約束を作って、守る\n\n1. `trait` で「約束」をdefinition\n2. `impl トレイト for 型` で「約束を守る」implementationをdo\n\ncodeExample：\n```rust\n// 1. トレイト（約束）を定義\ntrait Speak {\n    fn speak(&self);  // 鳴くメソッドを持つ約束\n}\n\n// 2. Dog構造体がトレイトを実装\nstruct Dog;\nimpl Speak for Dog {\n    fn speak(&self) {\n        println!(\"woof\");\n    }\n}\n```\n\n「DogはSpeakができる」ということになります。",
  "rust_lesson4_ex4_description": "referenceカウントでデータを共有しましょう。",
  "rust_lesson4_ex5_slide1_content": "# 名前で引ける「dictionary」\n\nHashMap は、「key（名前）」と「value（データ）」をsetで保存dodictionaryです。\n\nFor example：\n- 「青チーム」→ 10点\n- 「赤チーム」→ 15点\n\ncodeExample：\n```rust\nuse std::collections::HashMap;\n\nlet mut scores = HashMap::new();\nscores.insert(\"Blue\", 10);   // 追加\nscores.insert(\"Red\", 15);    // 追加\n```\n\n`use` で機能を読み込んでからuse。",
  "rust_lesson3_ex4_title": "map でiterator変換",
  "rust_lesson4_ex1_slide3_content": "共通の振る舞いを定義するトレイトを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
  "rust_lesson1_ex4_description": "variableのvalueを手軽に増やしたり減らしたりdo「+=」「-=」を学びましょう。",
  "rust_lesson1_ex2_description": "データに名前をつけて保存できる「variable（へんすう）」を使ってみましょう。letでvariableをcreate。",
  "rust_lesson4_ex4_slide2_title": "referenceカウントの仕組み",
  "rust_lesson3_ex8_slide2_title": "unwrap_or_else",
  "rust_lesson4_ex10_comment1": "1番目の i にindex、2番目の item にelementが入る",
  "rust_lesson3_ex6_slide1_content": "# 累積処理\n\nfold は、初期valueとfunctionでelementを1つずつ畳み込みます。\n\n```rust\nlet v = vec![1, 2, 3];\nlet sum = v.iter().fold(0, |acc, x| acc + x);\n// 6\n```",
  "rust_lesson4_ex2_slide2_title": "よくuse derive トレイト",
  "rust_lesson3_ex10_slide3_content": "文字列型の違いを理解しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
  "rust_lesson1_ex4_slide2_content": "変数の値を手軽に増やしたり減らしたりする「+=」「-=」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
  "rust_lesson3_ex4_slide3_title": "Let's Try It!",
  "rust_lesson3_ex5_slide1_title": "filter（filterー）?",
  "rust_lesson4_ex5_description": "keyとvalueのpairを格納しましょう。",
  "rust_lesson3_ex5_description": "条件に合うelementだけを取り出しましょう。",
  "rust_lesson2_ex2_slide2_content": "# functionに借りてもらう\n\nfunctionにデータを渡すとき、`&` をつけると「借りる」形になります。元のvariableはそのまま使い続けられます。\n\ncodeExample：\n```rust\nfn calc_len(s: &String) -> usize {\n    s.len()  // 長さを返す\n}\n\nfn main() {\n    let text = String::from(\"hello\");\n    let len = calc_len(&text);  // textを貸す\n    // text はまだ使える！\n    println!(\"{}の長さは{}\", text, len);\n}\n```\n\n`&String` は「Stringを借りる」という意味です。",
  "rust_lesson4_ex7_slide3_content": "パターンマッチに条件を追加しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
  "rust_lesson3_ex8_slide2_content": "# 遅延評価\n\n```rust\n// クロージャで計算\nlet value = x.unwrap_or_else(|| expensive_computation());\n```",
  "rust_lesson4_ex7_title": "match ガード",
  "rust_lesson3_ex7_title": "? operatorでerror伝播",
  "rust_lesson4_ex1_description": "共通の振る舞いをdefineトレイトを学びましょう。",
  "rust_lesson2_ex1_slide2_content": "# 所有権は「移動」do\n\nvariableを別のvariableにassignmentdoと、所有権が 移動（ムーブ） します。元のvariableは使えなくなります。\n\ncodeExample：\n```rust\nlet s1 = String::from(\"hello\");  // s1 が持ち主\nlet s2 = s1;  // 所有権が s2 に移動！\n// ↓ s1 はもう使えない（エラーになる）\n// println!(\"{}\", s1);  // ダメ！\nprintln!(\"{}\", s2);  // OK！\n```\n\nイメージ：\nおもちゃを友だちにあげたら、自分はもう使えない。これがムーブです。",
  "rust_lesson1_ex8_slide1_title": "dictionary（HashMap）?",
  "rust_lesson4_ex3_slide2_content": "# サイズが決まらないとき\n\nBoxは、コンパイル時にサイズがわからないtypeにuse。\n\nFor examplerecursion的なtype：\n```rust\n// リストは「値 + 次のリスト」の繰り返し\nenum List {\n    Cons(i32, Box<List>),  // Boxで次を指す\n    Nil,                   // 終わり\n}\n```\n\nなぜBoxが必要？\n- `List` の中に `List` がある → 無限に大きくなる？\n- `Box` をuseと、サイズが固定（pointerのサイズ）になる\n\n「中身」ではなく「中身への矢印」を持つイメージです。",
  "rust_lesson2_ex10_title": "ジェネリクスを使おう",
  "rust_lesson2_ex8_slide3_title": "Let's Try It!",
  "rust_lesson3_ex9_slide2_content": "# 可変reference\n\n```rust\n// mut が必要\nlet mut v = Vec::new();\nv.push(1);\nv.push(2);\n```",
  "rust_lesson4_ex4_title": "Rc<T>",
  "rust_lesson2_ex3_comment1": "mut で可変variableにdo",
  "rust_lesson4_ex5_slide3_title": "Let's Try It!",
  "rust_lesson2_ex6_slide2_content": "# バリアントを列挙\n\n`enum 名前 { バリアント1, バリアント2, ... }` でdefine。\n\ncodeExample：\n```rust\nenum Color {\n    Red,\n    Green,\n    Blue,\n}\nlet c = Color::Red;\n```",
  "rust_lesson1_ex1_comment1": "Hello, Rust! とdisplay",
  "rust_lesson1_ex1_slide1_content": "# 安全で速い！最新のプログラミング言語\n\nRust（ラスト）は、「間違いを事前に防ぐ」ことがとても得意なプログラミング言語です。\n\nRustのすごいところ：\n- programのミスをexecute前に見つけてくれる\n- とても速く動く\n- 世界中のプログラマーが「一番好き！」と選ぶ人気の言語\n\nたとえるなら：\n厳しいけど優しい先生のような言語です。「ここ間違ってるよ」と教えてくれるので、安心してprogramが書けます！",
  "rust_lesson3_ex8_slide1_content": "# None/Err の場合のデフォルト\n\nunwrap_or は、None や Err の場合にデフォルトvalueをreturn。\n\n```rust\nlet x: Option<i32> = None;\nlet value = x.unwrap_or(0);  // 0\n```",
  "rust_lesson2_ex7_slide3_title": "Let's Try It!",
  "rust_lesson2_ex6_title": "enum で状態を表す",
  "rust_lesson2_ex8_slide1_content": "# 「成功」か「失敗」かを表す\n\nResult<T, E> は、処理が「成功したか失敗したか」を表すtypeです。\n\nFor example：\n- fileをopen → 成功（内容）か失敗（error）\n- 0で割り算 → 成功（答え）か失敗（0で割れない！）\n\n2つの状態：\n- `Ok(値)` → 成功！valueが入っている\n- `Err(エラー)` → 失敗...error情報が入っている\n\n`Option` は「あるか・ないか」、`Result` は「成功か・失敗か」という違いです。",
  "rust_lesson2_ex8_slide3_content": "成功と失敗を表す「Result」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
  "rust_lesson4_ex6_slide1_title": "HashSet ?",
  "rust_lesson3_ex9_comment1": "push でelementを追加",
  "rust_lesson2_ex7_slide2_title": "Option  Usage",
  "rust_lesson3_ex2_title": "closureのBasic",
  "rust_lesson3_ex7_slide1_title": "? operator?",
  "rust_lesson4_ex6_comment1": "HashSet をimport",
  "rust_lesson2_ex10_slide1_content": "# どんなtypeでも使える「万能」の仕組み\n\nジェネリクス は、typeを後から決められる仕組みです。\n\nなぜ便利？\n同じようなfunctionを何度も書かなくてすみます。\n\nFor example：\n- 数字のarrayの最初のelementを取るfunction\n- stringのarrayの最初のelementを取るfunction\n\n両方とも「最初のelementを取る」のは同じなのに、typeが違うだけで別のfunctionをwriteのは大変！\n\nジェネリクスなら、`<T>` で「typeは後で決める」とwriteだけで、どんなtypeでも使えるfunctionが作れます。",
  "rust_lesson1_ex3_slide1_content": "# 剰余operator（じょうよえんざんし）「%」\n\n`%`（パーセント）は、割り算の 「あまり」 をcalculate特別な記号です。\n\nわかりやすいExample：\n- 10このアメを3人で分けると？\n- 1人3こずつで、1こあまる\n- これを `10 % 3` とwriteと、答えは `1`\n\ncodeExample：\n```rust\nprintln!(\"{}\", 10 % 3);  // 1（あまり1）\nprintln!(\"{}\", 8 % 4);   // 0（あまりなし＝割り切れる）\n```\n\n使いどころ：\n- 偶数か奇数か調べる（`n % 2` が0なら偶数）\n- 時計の計算（24を超えたら0に戻る、など）",
  "rust_lesson3_ex7_description": "errorを簡潔に伝播させましょう。",
  "rust_lesson3_ex8_comment1": "unwrap_or でデフォルトvalueを設定",
  "rust_lesson2_ex8_title": "Result<T, E> でerror処理",
  "rust_lesson2_ex10_comment1": "T をtypeパラメータとしてuse",
  "rust_lesson2_ex6_comment1": "enum で列挙typeをdefinition",
  "rust_lesson3_ex3_slide3_content": "要素を順番に処理するイテレータを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
  "rust_lesson4_ex2_comment1": "derive でトレイトを自動implementation",
  "rust_lesson1_ex8_slide1_content": "# 名前でsearchできる「dictionary」\n\nHashMap（ハッシュmap）は、「名前」と「データ」をsetにして保存できる仕組みです。本物のdictionaryのように使えます。\n\nFor example果物の色dictionary：\n- 「りんご」→「あか」\n- 「バナナ」→「きいろ」\n- 「みかん」→「オレンジ」\n\nuse準備：\n```rust\nuse std::collections::HashMap;  // 機能を読み込む\nlet mut fruits = HashMap::new();  // 空の辞書を作る\nfruits.insert(\"りんご\", \"あか\");  // データを追加\n```\n\n`use` は「この機能をuseよ」というdeclarationです。",
  "rust_lesson3_ex9_slide1_title": "push ?",
  "rust_lesson4_ex1_title": "トレイトのdefinition",
  "rust_lesson4_ex3_description": "heapにデータを格納doBoxを学びましょう。",
  "rust_lesson1_ex2_title": "便利な「はこ」variable（へんすう）",
  "rust_lesson1_ex8_comment2": "中身を出す",
  "rust_lesson3_ex9_slide3_title": "Let's Try It!",
  "rust_lesson1_ex4_comment3": "-= で 50 を引く",
  "rust_lesson1_ex6_comment1": "&& で両方の条件をチェック",
  "rust_lesson4_ex1_slide2_title": "トレイトのimplementation",
  "rust_lesson4_ex7_slide3_title": "Let's Try It!",
  "rust_lesson4_title": "Rust IV - トレイトとスマートpointer",
  "rust_lesson4_ex1_comment1": "trait でトレイトをdefinition",
  "rust_lesson4_ex4_slide1_content": "# 複数の「持ち主」を許可do仕組み\n\nRc<T> は「Reference Counted（referenceカウント）」の略で、複数の所有者でデータを共有できます。\n\n普通の所有権：\n1人だけが持ち主。渡したら元の人は使えない。\n\nRc をuseと：\n複数人が同じデータの「持ち主」になれる！\n\ncodeExample：\n```rust\nuse std::rc::Rc;\n\nlet a = Rc::new(5);       // Rcでラップ\nlet b = Rc::clone(&a);    // bも持ち主になる\n// a も b も使える！\n```",
  "rust_lesson3_ex5_slide1_content": "# 条件に合うものだけ残す\n\nfilter は、条件を満たすelementだけを残し、他を捨てます。\n\nFor example：\n- 80点以上の人だけ残す\n- 偶数だけ残す\n- 「あ」から始まる名前だけ残す\n\ncodeExample：\n```rust\nlet v = vec![1, 2, 3, 4, 5];\nlet evens: Vec<_> = v.iter()\n    .filter(|x| **x % 2 == 0)  // 偶数だけ\n    .collect();\n// [2, 4]\n```\n\n条件が `true` のelementだけが残ります。",
  "rust_lesson3_ex7_slide3_title": "Let's Try It!",
  "rust_lesson1_ex7_comment2": "2番目のデータ（1番）を出す",
  "rust_lesson4_ex8_title": "impl Trait",
  "rust_lesson1_ex5_description": "条件によって動きを変える if文を学びましょう。",
  "rust_lesson3_ex4_slide2_title": "遅延評価（ちえんひょうか）",
  "rust_lesson3_ex1_slide1_content": "# referenceの「寿命」を示す印\n\nライフタイム は、referenceがいつまで使えるかを示す印です。`'a`（アポストロフィ・エー）のようにwrite。\n\nなぜ必要？\nreferenceは「借りている」状態。借りた元のデータが消えたら、referenceも使えなくなります。\n\nFor example：\n- 図書館で借りた本 → 図書館が閉まったら読めない\n- referenceで借りたデータ → 元のデータが消えたら使えない\n\nライフタイムは「このreferenceはこの範囲で有効だよ」とコンパイラに伝える仕組みです。",
  "rust_lesson1_ex1_slide1_title": "Rust（ラスト）?",
  "rust_lesson1_ex2_slide2_title": "計算の記号（operator）",
  "rust_lesson4_ex5_slide2_content": "# get で安全に取り出す\n\n`get()` methodでvalueを取り出せます。見つからない可能性があるので、`Option` が返ってきます。\n\ncodeExample：\n```rust\n// getはOption<&V>を返す\nif let Some(score) = scores.get(\"Blue\") {\n    println!(\"青チームは{}点\", score);\n}\n```\n\nPoint：\n- keyがあれば `Some(値)` が返る\n- keyがなければ `None` が返る\n- `if let` で安全に取り出せる\n\n存在しないkeyでアクセスしてもprogramが落ちない！",
  "rust_lesson4_ex7_slide1_title": "match ガード?",
  "rust_lesson3_title": "Rust III - ライフタイムとiterator",
  "rust_lesson4_ex3_title": "Box<T>",
  "rust_lesson1_ex4_slide1_title": "累算assignmentoperator（るいさんだいにゅう）?",
  "rust_lesson2_ex9_comment1": "trait でトレイトをdefinition",
  "rust_lesson2_ex1_description": "Rust独自の概念「所有権」を学びましょう。",
  "rust_lesson2_ex3_slide3_content": "参照先の値を変更できる「可変参照」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
  "rust_lesson2_ex1_slide3_title": "Let's Try It!",
  "rust_lesson3_ex6_slide2_title": "様々な畳み込み",
  "rust_lesson4_ex9_slide3_title": "Let's Try It!",
  "rust_lesson2_ex5_title": "impl でmethodを追加",
  "rust_lesson2_ex6_slide1_content": "# 複数の選択肢\n\nenum は、valueがいくつかの種類のうちの一つであることを表します。各バリアントにデータを持たせることもできます。",
  "rust_lesson2_ex4_comment1": "struct で構造体をdefinition",
  "rust_lesson1_ex3_title": "剰余operator（%）",
  "rust_lesson1_ex7_comment1": "colors というベクタをcreate（'あか', 'あお'の順）",
  "rust_lesson1_ex4_slide1_content": "# valueをかんたんに増やす・減らす\n\n`+=`（プラスイコール）と `-=`（マイナスイコール）は、variableの中身を増やしたり減らしたりdo便利な記号です。\n\nRustのImportantなルール：`mut`が必要！\nRustでは、variableをchangeには `let mut`（レット ミュート）とwrite必要があります。`mut` は「mutable（変更できる）」の略です。\n\ncodeExample：\n```rust\nlet mut score = 100;  // mut をつけて変更可能に\nscore += 10;          // 10を足す → 110に\nscore -= 50;          // 50を引く → 60に\n```\n\n`mut` がないと「このvariableは変えちゃダメ！」とRustが怒ります。",
  "rust_lesson2_ex1_slide2_title": "ムーブ（移動）",
  "rust_lesson3_ex4_comment1": "map で各elementを変換",
  "rust_lesson3_ex8_slide1_title": "unwrap_or ?",
  "rust_lesson2_ex5_slide1_content": "# implementationブロック\n\nimpl ブロックで、構造体にmethodを追加できます。`self` で自分自身をreferenceします。",
  "rust_lesson2_ex10_slide1_title": "ジェネリクス?",
  "rust_lesson1_ex8_slide2_content": "# 名前（key）で取り出す\n\ndictionaryに入れたデータは、名前（key）を指定して取り出せます。\n\ncodeExample：\n```rust\nuse std::collections::HashMap;\nfn main() {\n    let mut fruits = HashMap::new();\n    fruits.insert(\"りんご\", \"あか\");  // 追加\n    fruits.insert(\"バナナ\", \"きいろ\");  // 追加\n    \n    println!(\"{}\", fruits[\"りんご\"]);  // あか と表示\n}\n```\n\nPoint：\n- `insert(名前, データ)` で追加\n- `辞書[名前]` で取り出し\n- 番号ではなく「名前」で探せるのが便利！",
  "rust_lesson4_ex9_slide1_content": "# iteratorをコレクションに\n\ncollect は、iteratorをVecやHashMapなどに変換します。\n\n```rust\nlet v: Vec<_> = (0..5).collect();\nlet s: String = vec!['a', 'b'].into_iter().collect();\n```",
  "rust_lesson2_ex2_slide3_content": "所有権を移さずに値を借りる「参照」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
  "rust_lesson3_ex2_slide3_content": "周囲の変数を使える無名関数「クロージャ」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
  "rust_lesson2_ex4_slide2_content": "# struct keyワードでdefinition\n\n`struct 名前 { フィールド }` で構造体をdefine。フィールドには名前とtypeをwrite。\n\ncodeExample：\n```rust\n// Point 構造体を定義\nstruct Point {\n    x: i32,  // xフィールド（整数）\n    y: i32,  // yフィールド（整数）\n}\n\n// 使い方\nlet p = Point { x: 10, y: 20 };\nprintln!(\"x={}, y={}\", p.x, p.y);\n```\n\nPoint：\n- `struct 名前` で構造体をcreate\n- `{ フィールド名: 型 }` でどんなデータを持つか決める\n- `.フィールド名` でアクセス",
  "rust_lesson2_ex10_slide3_content": "型を後から決められる「ジェネリクス」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
  "rust_lesson4_ex6_slide3_title": "Let's Try It!",
  "rust_lesson4_ex6_slide1_content": "# 一意なvalueのset\n\nHashSet は、重複のないvalueのsetです。\n\n```rust\nuse std::collections::HashSet;\n\nlet mut set = HashSet::new();\nset.insert(1);\nset.insert(2);\nset.insert(1); // 重複は無視\n```",
  "rust_lesson4_ex2_title": "derive 属性",
  "rust_lesson4_ex2_slide1_content": "# トレイトを「自動で」implementation\n\n#[derive(...)] をuseと、よくuseトレイトを自分で書かなくても自動でimplementationしてくれます。\n\nFor example：\n構造体を `println!` でdisplayしたいとき、普通は Display トレイトをimplementationdo必要がありますが、`#[derive(Debug)]` をwriteだけでOK！\n\ncodeExample：\n```rust\n#[derive(Debug)]  // Debug トレイトを自動実装\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nlet p = Point { x: 1, y: 2 };\nprintln!(\"{:?}\", p);  // Point { x: 1, y: 2 }\n```",
  "rust_lesson1_ex6_slide2_title": "Let's Try It!",
  "rust_lesson3_ex3_slide2_title": "3つの iter method",
  "rust_lesson4_ex7_slide2_content": "# 複雑なconditional\n\n```rust\nmatch Some(5) {\n    Some(x) if x % 2 == 0 => println!(\"even\"),\n    Some(x) => println!(\"odd: {}\", x),\n    None => println!(\"none\"),\n}\n```",
  "rust_lesson3_ex3_slide1_content": "# elementを1つずつ取り出す仕組み\n\niterator は、ベクタなどのデータを「1つずつ順番に」取り出す仕組みです。\n\nFor example：\n- 行列に並んでいる人を1人ずつ呼ぶ\n- 引き出しの中身を1つずつ出す\n\ncodeExample：\n```rust\nlet v = vec![1, 2, 3];\nfor x in v.iter() {\n    println!(\"{}\", x);  // 1, 2, 3 と順番に表示\n}\n```\n\n`iter()` で「順番に取り出す準備」をして、`for` で1つずつ処理します。",
  "rust_lesson3_ex3_slide1_title": "iterator?",
  "rust_lesson4_ex2_description": "トレイトを自動implementationdoderiveを学びましょう。",
  "rust_lesson3_ex4_slide1_content": "# 全部を同じように変換do\n\n**map** は、iteratorの各elementを「同じ方法で」変換します。\n\nFor example：\n- 全員の身長を2倍にdo\n- 全員の名前を大文字にdo\n- 全部の数を2乗do\n\ncodeExample：\n```rust\nlet v = vec![1, 2, 3];\nlet doubled: Vec<_> = v.iter()\n    .map(|x| x * 2)  // 各要素を2倍に\n    .collect();      // ベクタに戻す\n// [2, 4, 6]\n```\n\n`|x| x * 2` は「xを受け取って、x*2をreturn」closureです。",
  "rust_lesson1_ex3_slide1_title": "あまりを求める",
  "rust_lesson3_ex10_slide1_content": "# 所有権の違い\n\nString は所有権を持つheap上のstring、&str はreferenceです。\n\n```rust\nlet s1: String = String::from(\"hello\");\nlet s2: &str = \"hello\";\n```",
  "rust_lesson4_ex2_slide1_title": "derive（デライブ）?",
  "rust_lesson2_ex2_comment1": "& でreferenceを渡す",
  "rust_lesson4_ex5_slide1_title": "HashMap（ハッシュmap）?",
  "rust_lesson2_ex3_slide2_title": "&mut  Usage",
  "rust_lesson3_ex5_title": "filter で絞り込み",
  "rust_lesson4_ex3_slide2_title": "いつuse？",
  "rust_lesson2_ex2_title": "referenceと借用",
  "rust_lesson2_ex7_title": "Option<T> で null を安全に",
  "rust_lesson4_ex10_slide3_title": "Let's Try It!",
  "rust_lesson3_ex5_slide3_title": "Let's Try It!",
  "rust_lesson4_ex10_title": "enumerate でindex付き",
  "rust_lesson2_ex2_slide1_content": "# 所有権を渡さずに「借りる」\n\nreference をuseと、所有権を移さずにデータを「見せてもらう」ことができます。\n\nたとえるなら：\n- ムーブ = おもちゃをあげる（自分は使えない）\n- reference = おもちゃを見せる（自分も使える）\n\n作り方：\n`&`（アンパサンド）をつけるとreferenceを作れます。\n\n```rust\nlet s = String::from(\"hello\");\nlet r = &s;  // sを借りる（見せてもらう）\n// s も r も使える！\n```",
  "rust_lesson2_ex5_slide2_content": "# &self をuse\n\nmethodの最初のargumentは `&self` です。\n\ncodeExample：\n```rust\nimpl Rect {\n    fn area(&self) -> i32 {\n        self.width * self.height\n    }\n}\n```",
  "rust_lesson1_ex5_slide2_title": "Let's Try It!",
  "rust_lesson2_ex4_slide3_title": "Let's Try It!",
  "rust_lesson4_ex3_slide3_title": "Let's Try It!",
  "rust_lesson2_ex9_slide3_content": "共通の振る舞いを定義する「トレイト」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
  "rust_lesson4_ex1_slide2_content": "# impl で約束を守る\n\n構造体にトレイトをimplementationdoと、その構造体は「約束を守る」ことになります。\n\ncodeExample：\n```rust\nstruct Person { name: String }\n\nimpl Greet for Person {\n    fn greet(&self) -> String {\n        format!(\"Hello, {}\", self.name)\n    }\n}\n```\n\n読み方：\n- `impl Greet for Person` → 「PersonはGreetをimplementationdo」\n- これでPersonは「あいさつできる」ようになった！",
  "rust_lesson4_ex4_comment1": "clone でreferenceカウントを増やす",
  "rust_lesson3_ex4_slide2_content": "# map だけではexecuteされない！\n\nRustのiteratorは 遅延評価 といって、「本当に必要になるまで処理しない」仕組みです。\n\nなぜ？\n無駄な計算を省けるから。100万件あっても、最初の10件だけ欲しいなら10件だけ処理すればいい。\n\ncollect() でexecute：\n```rust\n// これだけでは何も起きない\nv.iter().map(|x| x * 2);\n\n// collect() で実行してベクタに変換\nlet result: Vec<_> = v.iter().map(|x| x * 2).collect();\n```\n\n`collect()` は「今すぐ全部処理してResultをちょうだい」という意味です。",
  "rust_lesson2_ex4_slide2_title": "struct のdefinitionのしかた",
  "rust_lesson2_ex3_slide1_content": "# 「書き換えできる」借り方\n\n普通のreference `&` は「見るだけ」ですが、可変reference `&mut` は「変更もできる」借り方です。\n\nたとえるなら：\n- `&` = 本を見せてもらう（readだけ）\n- `&mut` = ノートを借りる（writeOK）\n\nImportantなルール：\n- 可変referenceは同時に1つだけ！\n- 「みんなで見る」か「1人でwrite」かのどちらか\n\nこのルールで、データが同時に書き換えられるバグを防いでいます。",
  "rust_lesson2_ex10_slide3_title": "Let's Try It!",
  "rust_lesson2_ex4_title": "構造体をdefinitionしよう",
  "rust_lesson3_ex10_slide2_content": "# 相互変換\n\n```rust\n// &str -> String\nlet s = \"hello\".to_string();\n\n// String -> &str\nlet slice: &str = &s;\n```",
  "rust_lesson4_ex10_slide3_content": "イテレータにインデックスを付けましょう。\n\n（When you're ready, select \"Start Lesson\".）",
  "rust_lesson4_ex4_slide2_content": "# 「何人が持っているか」を数える\n\nRcは「今何人がこのデータを持っているか」を数えています。\n\ncodeExample：\n```rust\nlet a = Rc::new(5);\nprintln!(\"{}\", Rc::strong_count(&a));  // 1\n\nlet b = Rc::clone(&a);\nprintln!(\"{}\", Rc::strong_count(&a));  // 2\n```\n\nいつデータが消える？\n- カウントが0になったとき（誰も持っていないとき）\n- 最後の持ち主がいなくなると自動で片付けられる\n\n`Rc::clone` は「持ち主を1人増やす」操作です。",
  "rust_lesson1_ex8_slide2_title": "dictionary Usage",
  "rust_lesson4_ex3_slide1_content": "# データを「heap」に置く箱\n\nBox<T> は、データを「heap」という特別な場所に置くための箱です。\n\nmemoryの2つの場所：\n- stack：小さくて速い。サイズが決まっているデータ向け\n- heap：大きくて柔軟。サイズが大きいor変わるデータ向け\n\ncodeExample：\n```rust\nlet b = Box::new(5);  // 5をヒープに置く\nprintln!(\"{}\", *b);   // *で中身を取り出す → 5\n```\n\n`*` は「箱を開けて中身を見る」操作です。",
  "rust_lesson3_ex2_slide2_title": "closure Syntax",
  "rust_lesson4_ex4_slide1_title": "Rc（アールシー）?",
  "rust_lesson4_ex7_slide1_content": "# 追加条件\n\n**if** でパターンに追加条件をつけられます。\n\n```rust\nmatch x {\n    n if n < 0 => println!(\"negative\"),\n    n if n > 0 => println!(\"positive\"),\n    _ => println!(\"zero\"),\n}\n```",
  "rust_lesson2_ex3_title": "可変reference",
  "rust_lesson3_ex10_comment1": "to_string で String に変換",
  "rust_lesson3_ex10_slide2_title": "変換",
  "rust_lesson3_ex1_description": "referenceの有効期間を表すライフタイムを学びましょう。",
  "rust_lesson3_ex2_slide1_content": "# 名前のない「即席」function\n\nclosure は、名前をつけずにその場でcreatefunctionです。そして特別な能力があります：周りのvariableを使えるのです！\n\nFor example：\n```rust\nlet x = 5;  // 外側の変数\nlet add_x = |n| n + x;  // xを使えるクロージャ\nprintln!(\"{}\", add_x(10));  // 15\n```\n\n普通のfunctionとの違い：\n- 普通のfunction：argumentしか使えない\n- closure：argument + 周りのvariableも使える\n\n「その場の空気を読める」functionというイメージです！",
  "rust_lesson1_ex2_comment1": "x に 10 を入れる",
  "rust_lesson1_ex7_slide3_title": "Let's Try It!",
  "rust_lesson1_ex5_title": "「もし〜なら」で分けましょう",
  "rust_lesson3_ex2_slide3_title": "Let's Try It!",
  "rust_lesson3_ex7_slide2_content": "# 簡潔なerror処理\n\n```rust\n// ? を使わない場合\nmatch result {\n    Ok(v) => v,\n    Err(e) => return Err(e),\n}\n\n// ? を使う\nresult?\n```",
  "rust_lesson3_ex6_slide3_title": "Let's Try It!",
  "rust_lesson4_ex9_slide3_content": "イテレータをコレクションに変換しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
  "rust_lesson3_ex6_description": "elementを1つのvalueにまとめるfoldを学びましょう。",
  "rust_lesson2_ex9_description": "共通の振る舞いをdefine「トレイト」を学びましょう。",
  "rust_lesson2_ex8_comment1": "Ok で成功をreturn",
  "rust_lesson3_ex5_slide2_content": "# filter はreferenceのreferenceを受け取る\n\n`filter` のclosureは、referenceのreference（`&&T`）を受け取ります。そのため、valueをuseには `**x` と2回referenceを外す必要があります。\n\nなぜ？\n- `iter()` はreference（`&T`）をreturn\n- `filter` はそれをFurthermorereferenceで渡す（`&&T`）\n\nSyntax：\n```rust\n// **x で値を取り出す\n.filter(|x| **x > 2)\n\n// または * を引数につける\n.filter(|&x| *x > 2)\n```\n\n最初は混乱しますが、慣れれば大丈夫！",
  "rust_lesson1_ex5_comment1": "> でcompare",
  "rust_lesson2_ex4_description": "関連doデータをまとめる「構造体」を学びましょう。",
  "rust_lesson3_ex5_slide3_content": "条件に合う要素だけを取り出しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
  "rust_lesson1_ex7_slide3_content": "「ベクタ（Vec）」を使うと、たくさんのデータを一つの「長い はこ」にまとめて入れられます。\n\n（When you're ready, select \"Start Lesson\".）",
  "rust_lesson4_ex5_slide2_title": "valueの取得",
  "rust_lesson3_ex1_slide1_title": "ライフタイム?",
  "rust_lesson1_ex3_comment1": "10 を 3 で割ったあまりをoutput",
  "rust_lesson3_ex1_comment1": "'a でライフタイムをdefinition",
  "rust_lesson3_ex10_slide1_title": "String vs &str",
  "rust_lesson2_title": "Rust II - 所有権とトレイト",
  "rust_lesson2_ex5_slide2_title": "methodのdefinition",
  "rust_lesson4_ex5_comment1": "insert でkeyとvalueを追加",
  "rust_lesson2_ex9_slide1_content": "# 「できること」の約束\n\nトレイト は、「このtypeはこういうことができる」という約束をdefine。\n\nFor example「鳴ける」という約束：\n- 犬は「ワン」と鳴く\n- 猫は「ニャー」と鳴く\n- 両方とも「鳴ける」能力がある\n\nトレイトは「鳴ける動物は、鳴き声を出すmethodを持つ」という約束です。\n\n他の言語とのcomparison：\n- Java: interface\n- TypeScript: interface\n\nに似た概念です。",
  "rust_lesson1_ex2_slide3_title": "Let's Try It!",
  "rust_lesson4_ex8_slide1_content": "# return valueのtypeをabstract化\n\nimpl Trait で、トレイトをimplementationdotypeを返せます。\n\n```rust\nfn make_iter() -> impl Iterator<Item = i32> {\n    vec![1, 2, 3].into_iter()\n}\n```",
  "rust_lesson1_ex2_slide2_content": "# 四則演算（しそくえんざん）\n\nRustでも算数と同じ記号で計算ができます。\n\n4つのBasic記号：\n- +（プラス）: たし算\n- -（マイナス）: ひき算\n- \\*（アスタリスク）: かけ算（×の代わり）\n- /（スラッシュ）: わり算（÷の代わり）\n\ncodeExample：\n```rust\nlet a = 10;\nlet b = 5;\nprintln!(\"{}\", a + b);  // 15 と表示される\n```\n\n`println!` の `{}` は「ここにvalueを入れてね」という目印です。",
  "rust_lesson4_ex9_slide2_content": "# 変換先を指定\n\n```rust\n// ターボフィッシュ構文\nlet v = (0..5).collect::<Vec<_>>();\n\n// 変数の型注釈\nlet v: Vec<i32> = (0..5).collect();\n```",
  "rust_lesson1_ex8_description": "「dictionary（HashMap）」をuseと、名前をつけてデータを保存し、その名前で取り出せます。",
  "rust_lesson4_ex9_slide2_title": "typeHint",
  "rust_lesson3_ex1_title": "ライフタイムのBasic",
  "rust_lesson2_ex5_description": "構造体にmethodをadd「impl」を学びましょう。",
  "rust_lesson4_ex8_comment1": "impl でトレイトをimplementationdotypeをreturn",
  "rust_lesson4_ex8_slide2_title": "argumentにも使える",
  "rust_lesson4_ex7_comment1": "if でマッチガードを追加",
  "rust_lesson2_ex9_slide2_title": "trait のdefinitionとimplementation",
  "rust_lesson4_ex10_slide2_title": "いつuse？",
  "rust_lesson3_ex7_slide2_title": "match の省略形",
  "rust_lesson1_ex6_title": "logicaloperator（&&、||）",
  "rust_lesson3_ex6_comment1": "fold で畳み込み",
  "rust_lesson2_ex6_description": "複数の状態を表す「列挙type（enum）」を学びましょう。",
  "rust_lesson4_ex10_slide1_title": "enumerate（イニュメレート）?",
  "rust_lesson1_ex7_slide1_title": "ベクタ（Vec）?",
  "rust_lesson2_ex6_slide3_content": "複数の状態を表す「列挙型（enum）」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
  "rust_lesson3_ex3_slide3_title": "Let's Try It!",
  "rust_lesson3_ex4_description": "各elementを変換domapを学びましょう。",
  "rust_lesson4_ex1_slide3_title": "Let's Try It!",
  "rust_lesson3_ex9_slide2_title": "mut が必要",
  "rust_lesson1_ex6_slide1_content": "# logicaloperator（ろんりえんざんし）\n\n2つ以上の条件を組み合わせたいときにuse記号です。\n\n2つの記号：\n- `&&`（アンドアンド）：「かつ」＝ 両方とも 正しいとき\n- `||`（オアオア）：「Alsoは」＝ どちらか 正しいとき\n\n身近なExample：\n- 遊園地：「18歳以上 かつ チケットあり」なら乗れる\n- おやつ：「宿題終わった Alsoは お手伝いした」ならOK\n\ncodeExample：\n```rust\nif score >= 70 && bonus > 0 {\n    // 70点以上 かつ ボーナスあり → 合格！\n    println!(\"合格！\");\n}\n```",
  "rust_lesson4_ex4_slide3_content": "参照カウントでデータを共有しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
  "rust_lesson2_ex6_slide3_title": "Let's Try It!",
  "rust_lesson2_ex5_slide3_content": "構造体にメソッドを追加する「impl」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
  "rust_lesson3_ex1_slide3_title": "Let's Try It!",
  "rust_lesson1_ex5_slide1_content": "# programに「判断」させよう\n\nconditional は、「もし〜なら、〇〇do」という判断をprogramにさせる仕組みです。\n\n身近なExample：\n- もし80点以上なら → 「合格！」とdisplay\n- もし雨なら → 傘を持っていく\n- もしHPが0なら → ゲームオーバー\n\nRustで Syntax：\n```rust\nif score > 80 {\n    println!(\"合格！\");\n}\n```\n\n読み方：\n- `if` →「もし」\n- `score > 80` →「スコアが80より大きいなら」\n- `{ }` の中 →「これをやる」",
  "rust_lesson4_ex5_title": "HashMap",
  "rust_lesson1_ex2_slide1_content": "# データを保存do「はこ」\n\nvariable（へんすう） は、数字や文字を入れておける「はこ」のことです。名前をつけて、あとでuseことができます。\n\nFor example：\n- 「りんごの数」というラベルの箱に「5」を入れる\n- あとで「りんごの数」と呼べば「5」が出てくる\n\nRustで Syntax：\n```rust\nlet x = 10;  // xという箱に10を入れる\nprintln!(\"{}\", x);  // xの中身（10）を表示\n```\n\n`let` は「この名前で箱をcreateよ」という意味です。",
  "rust_lesson2_ex4_slide3_content": "関連するデータをまとめる「構造体」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
  "rust_lesson2_ex6_slide1_title": "enum ?",
  "rust_lesson2_ex9_title": "トレイトをdefinitionしよう",
  "rust_lesson2_ex4_slide1_title": "構造体（こうぞうたい）?",
  "rust_lesson4_ex2_slide2_content": "# 覚えておくと便利な5つ\n\nよくusederiveトレイト：\n```rust\nDebug     // {:?} でデバッグ表示できる\nClone     // .clone() でコピーを作れる\nCopy      // 代入時に自動でコピー（小さい型向け）\nPartialEq // == で比較できる\nDefault   // 初期値を自動で作れる\n```\n\n複数指定もOK：\n```rust\n#[derive(Debug, Clone, PartialEq)]\nstruct User {\n    name: String,\n    age: u32,\n}\n```\n\n`Debug` は特によくuse。debug時に構造体の中身を見れて便利！",
  "rust_lesson2_ex1_slide1_content": "# データの「持ち主」を決めるルール\n\n所有権 は、Rust最大のFeatureです。「このデータの持ち主は誰か」をはっきりさせる仕組みです。\n\nルール：\n- データには必ず1人だけ「持ち主」がいる\n- 持ち主がいなくなると、データは自dynamicに片付けられる\n\nたとえるなら：\n- おもちゃは1人しか持てない\n- 持ち主が部屋を出たら、おもちゃは片付けられる\n\nこのルールのおかげで、Rustは「memoryリーク」（データが片付けられないバグ）を防げます！",
  "rust_lesson1_ex3_slide2_title": "Let's Try It!",
  "rust_lesson3_ex1_slide2_title": "なぜ必要？",
  "rust_lesson3_ex1_slide2_content": "# 危険なバグを防ぐ\n\nダングリングreference という危険なバグがあります。これは「もう存在しないデータ」を指し続けているreferenceのことです。\n\nExample：\n```rust\nfn longest<'a>(x: &'a str, y: &'a str) -> &'a str {\n    if x.len() > y.len() { x } else { y }\n}\n```\n\n`'a` の意味：\n- argument `x` と `y` は同じライフタイム `'a` を持つ\n- return valueも同じライフタイム `'a` を持つ\n- In other words「xとyが両方有効な間、return valueも有効」という約束\n\nRustはこれを自動でチェックしてくれます！",
  "rust_lesson4_ex6_slide2_title": "set演算",
  "rust_lesson3_ex7_comment1": "? でerrorを伝播",
  "rust_lesson3_ex2_slide2_content": "# | | でargumentを囲む\n\nclosureは `|引数| 処理` という形でwrite。`||` は「パイプ」と呼ばれます。\n\nいろいろなSyntax：\n```rust\n// 引数なし\n|| println!(\"Hello\")\n\n// 引数あり\n|x, y| x + y\n\n// 複数行のブロック\n|x| {\n    let y = x * 2;\n    y + 1\n}\n```\n\nPoint：\n- argumentを `| |` で囲む（functionの `()` の代わり）\n- typeは省略できることが多い（Rustが推測してくれる）",
  "rust_lesson2_ex7_comment1": "Some でvalueがあることを示す",
  "rust_lesson3_ex4_slide3_content": "各要素を変換するmapを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
  "rust_lesson1_title": "Rust (ラスト) に挑戦！",
  "rust_lesson2_ex8_description": "成功と失敗を表す「Result」を学びましょう。",
  "rust_lesson3_ex8_description": "Option/Resultのデフォルトvalueを設定しましょう。",
  "rust_lesson4_ex2_slide3_title": "Let's Try It!",
  "rust_lesson2_ex5_slide3_title": "Let's Try It!",
  "rust_lesson4_ex9_description": "iteratorをコレクションに変換しましょう。",
  "rust_lesson1_ex1_slide2_content": "# println! でscreenにdisplay\n\nRustで文字をscreenにdisplayには、`println!`（プリントラインびっくり）をuse。\n\nPoint：\n- `!` がつくのがRustのFeature（マクロと呼ばれます）\n- programは `fn main() { }` の中にwrite\n- `fn` は「function（function）」の略\n\ncodeExample：\n```rust\nfn main() {\n    println!(\"ヤッホー！\");\n}\n// 「ヤッホー！」と画面に表示される\n```\n\n`println!` の `!` は「マクロ」という特別な機能の印です。今は「おまじない」と思っておけばOK！",
  "rust_lesson3_ex6_slide1_title": "fold ?",
  "rust_lesson4_ex8_slide1_title": "impl Trait ?",
  "rust_lesson1_ex1_slide2_title": "Rustの「おまじない」",
  "rust_lesson3_ex10_description": "stringtypeの違いを理解しましょう。",
  "rust_lesson3_ex7_slide3_content": "エラーを簡潔に伝播させましょう。\n\n（When you're ready, select \"Start Lesson\".）",
  "rust_lesson2_ex1_comment1": "s1 の所有権を移動",
  "rust_lesson2_ex9_slide1_title": "トレイト?",
  "rust_lesson4_ex6_slide2_content": "# 和set、積setなど\n\n```rust\nset1.union(&set2)\nset1.intersection(&set2)\nset1.difference(&set2)\n```",
  "rust_lesson4_ex5_slide3_content": "キーと値のペアを格納しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
  "rust_lesson2_ex8_slide1_title": "Result（リザルト）?",
  "rust_lesson4_ex1_slide1_content": "# 「できること」の約束\n\nトレイト は、typeが持つべきmethodをdefine仕組みです。\n\nFor example：\n- 「あいさつできる」トレイト → greet() methodを持つ\n- 「displayできる」トレイト → display() methodを持つ\n\ncodeExample：\n```rust\ntrait Greet {\n    fn greet(&self) -> String;  // メソッドの「約束」\n}\n```\n\nこれは「Greetできるtypeは、greet()methodを持つ」という約束です。",
  "rust_lesson4_ex2_slide3_content": "トレイトを自動実装するderiveを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
  "rust_lesson3_ex6_title": "fold で畳み込み",
  "rust_lesson3_ex9_slide3_content": "Vecに要素を追加しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
  "rust_lesson2_ex4_slide1_content": "# 関係あるデータをまとめる「設計図」\n\n構造体（struct） は、いくつかのデータをひとまとめにdo仕組みです。\n\nFor example「点（座標）」のデータ：\n- x座標\n- y座標\n\nこの2つは関係があるので、「Point（点）」としてまとめると便利です。\n\nFor example「人」のデータ：\n- 名前\n- 年齢\n\nこれも「Person（人）」としてまとめられます。\n\n構造体は「こういうデータを持つ」という設計図です。",
  "rust_lesson4_ex1_slide1_title": "トレイト?（復習）",
  "rust_lesson2_ex3_description": "reference先のvalueを変更できる「可変reference」を学びましょう。",
  "rust_lesson2_ex7_slide2_content": "# match で安全に取り出す\n\n`match` を使って「ある場合」と「ない場合」で処理を分けます。\n\ncodeExample：\n```rust\nlet x: Option<i32> = Some(5);  // 値あり\n\nmatch x {\n    Some(n) => println!(\"値は{}です\", n),  // 5\n    None => println!(\"値がありません\"),\n}\n```\n\nなぜ安全？\n- `null` のように「あるつもりでアクセスしたら無かった」errorが起きない\n- 「ない場合」の処理を書かないとコンパイルerrorになる\n- 強制的に両方のケースを考えることになる！",
  "rust_lesson4_ex9_comment1": "collect で Vec に変換",
  "rust_lesson3_ex10_title": "String と &str",
  "rust_lesson2_ex7_slide1_title": "Option（オプション）?",
  "rust_lesson3_ex9_description": "Vecにelementを追加しましょう。",
  "rust_lesson2_ex5_comment1": "impl でmethodをimplementation",
  "rust_lesson3_ex1_slide3_content": "参照の有効期間を表すライフタイムを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
  "rust_lesson1_ex6_slide2_content": "複数の条件を組み合わせる「&&（かつ）」と「||（または）」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
  "rust_lesson3_ex5_comment1": "filter で条件に合うelementを絞り込む",
  "rust_lesson2_ex7_slide3_content": "値があるかないかを表す「Option」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
  "rust_lesson3_ex10_slide3_title": "Let's Try It!",
  "rust_lesson4_ex4_slide3_title": "Let's Try It!",
  "rust_lesson3_ex3_comment1": "iter でiteratorを取得",
  "rust_lesson3_ex6_slide3_content": "要素を1つの値にまとめるfoldを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
  "rust_lesson1_ex7_slide2_title": "ベクタの番号は「0」から！",
  "rust_lesson1_ex5_slide1_title": "conditional（じょうけんぶんき）?",
  "rust_lesson1_ex3_description": "割り算の「あまり」を求める「%」（パーセント）operatorを学びましょう。",
  "rust_lesson1_ex1_slide3_content": "Rustを使って画面に文字を表示してみましょう。println! という特別な関数を使います。\n\n（When you're ready, select \"Start Lesson\".）",
  "rust_lesson2_ex10_slide2_content": "# <T> でtypeを「あとで決める」\n\nfunction名の後に `<T>` をつけて、`T` を「type」としてuse。\n\ncodeExample：\n```rust\n// Tはどんな型でもOK\nfn first<T>(arr: &[T]) -> &T {\n    &arr[0]  // 最初の要素を返す\n}\n\n// 使い方\nfirst(&[1, 2, 3]);         // Tはi32\nfirst(&[\"a\", \"b\", \"c\"]);   // Tは&str\n```\n\n読み方：\n- `<T>` → 「Tという名前のtypeをuseよ」\n- `T` は慣習で「Type（type）」の頭文字\n- 複数のtypeが必要なら `<T, U>` のようにwrite",
  "rust_lesson3_ex2_comment1": "|x| でclosureのargumentをdefinition",
  "rust_lesson3_ex3_description": "elementを順番に処理doiteratorを学びましょう。",
  "rust_lesson1_ex1_slide3_title": "Let's Try It!",
  "rust_lesson2_ex6_slide2_title": "enum のdefinition",
  "rust_lesson2_ex1_title": "所有権のBasic",
  "rust_lesson4_ex3_slide1_title": "Box（ボックス）?",
  "rust_lesson2_ex1_slide3_content": "Rust独自の概念「所有権」を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
  "rust_lesson3_ex8_slide3_content": "Option/Resultのデフォルト値を設定しましょう。\n\n（When you're ready, select \"Start Lesson\".）",
  "rust_lesson4_ex7_slide2_title": "使用Example",
  "rust_lesson4_ex10_description": "iteratorにindexを付けましょう。",
  "rust_lesson4_ex9_slide1_title": "collect ?",
  "rust_lesson4_ex10_slide2_content": "# 「何番目か」が必要なとき\n\n番号（index）とelementの両方が必要なときに便利です。\n\ncodeExample：\n```rust\nlet v = vec![10, 20, 30];\nfor (idx, val) in v.iter().enumerate() {\n    println!(\"{}番目の値は{}\", idx, val);\n}\n// 0番目の値は10\n// 1番目の値は20\n// 2番目の値は30\n```\n\nPoint：\n- `(i, x)` でtuple（2つのset）を受け取る\n- `i` にindex、`x` にelementが入る\n- indexは0から始まる",
  "rust_lesson3_ex2_description": "周囲のvariableを使えるanonymous function「closure」を学びましょう。",
  "rust_lesson1_ex4_comment1": "mut で変更可能にdo",
  "rust_lesson1_ex8_slide3_title": "Let's Try It!",
  "rust_lesson1_ex3_slide2_content": "割り算の「あまり」を求める「%」（パーセント）演算子を学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
  "rust_lesson2_ex9_slide3_title": "Let's Try It!",
  "rust_lesson3_ex3_title": "iteratorのBasic",
  "rust_lesson3_ex9_title": "Vec のmethod push",
  "rust_lesson1_ex8_comment1": "dictionaryをcreate（keyは'みかん'、valueは'オレンジ'）",
  "rust_lesson1_ex2_comment3": "+ でたし算do",
  "rust_lesson4_ex8_slide2_content": "# ジェネリクスの代わり\n\n```rust\nfn print_all(iter: impl Iterator<Item = i32>) {\n    for x in iter {\n        println!(\"{}\", x);\n    }\n}\n```",
  "rust_lesson2_ex2_slide2_title": "reference Usage",
  "rust_lesson1_ex8_slide3_content": "「辞書（HashMap）」を使うと、名前をつけてデータを保存し、その名前で取り出せます。\n\n（When you're ready, select \"Start Lesson\".）",
  "rust_lesson1_ex7_slide2_content": "# [ ]で番号を指定して取り出す\n\n`[番号]` で何番目のデータか指定して取り出せます。\n\nImportantなルール：番号は「0」から！\n- 1番目 → `[0]`\n- 2番目 → `[1]`\n- 3番目 → `[2]`\n\ncodeExample：\n```rust\nlet fruits = vec![\"りんご\", \"バナナ\", \"みかん\"];\n//                  ↑0番    ↑1番     ↑2番\nprintln!(\"{}\", fruits[0]);  // りんご\nprintln!(\"{}\", fruits[1]);  // バナナ\n```\n\nプログラミングでは「0から数える」のが世界共通のルールです！",
  "rust_lesson1_ex6_slide1_title": "条件を組み合わせる",
  "rust_lesson2_ex10_slide2_title": "ジェネリックfunction Syntax",
  "rust_lesson1_ex6_description": "複数の条件を組み合わせる「&&（かつ）」と「||（Alsoは）」を学びましょう。",
  "rust_lesson4_ex6_title": "HashSet",
  "rust_lesson2_ex3_slide2_content": "# mut が2か所に必要\n\n変更できるようにdoには、variableとreferenceの両方に `mut` が必要です。\n\ncodeExample：\n```rust\n// 1. 変数を mut で作る\nlet mut s = String::from(\"hello\");\n\n// 2. &mut で可変参照を渡す\nchange(&mut s);\n\nfn change(s: &mut String) {\n    s.push_str(\" world\");  // 変更できる！\n}\n```\n\nPoint：\n- `let mut 変数` でvariableを変更可能に\n- `&mut 変数` で可変referenceをcreate\n- 両方ないと変更できない！",
  "rust_lesson2_ex2_slide1_title": "reference（さんしょう）?",
  "rust_lesson3_ex6_slide2_content": "# 合計、積、結合など\n\n```rust\n// 積\nv.iter().fold(1, |acc, x| acc * x)\n\n// 文字列結合\nwords.iter().fold(String::new(), |acc, s| acc + s)\n```",
  "rust_lesson1_ex1_description": "Rustを使ってscreenに文字をdisplayしてみましょう。println! という特別なfunctionをuse。",
  "rust_lesson3_ex8_slide3_title": "Let's Try It!",
  "rust_lesson4_ex6_description": "一意なvalueのsetを管理しましょう。",
  "rust_lesson2_ex5_slide1_title": "impl ?",
  "rust_lesson1_ex8_title": "名前で引き出す「dictionary」",
  "rust_lesson2_ex7_description": "valueがあるかないかを表す「Option」を学びましょう。",
  "rust_lesson1_ex4_slide2_title": "Let's Try It!",
  "rust_lesson1_ex7_title": "たくさんのデータをまとめましょう「ベクタ」",
  "rust_lesson3_ex7_slide1_content": "# errorの早期リターン\n\n? は、Resultが Err の場合に早期リターンします。\n\n```rust\nfn read_file() -> Result<String, io::Error> {\n    let content = fs::read_to_string(\"file.txt\")?;\n    Ok(content)\n}\n```",
  "rust_lesson3_ex9_slide1_content": "# 末尾に追加\n\npush は、Vecの末尾にelementをadd。\n\n```rust\nlet mut v = vec![1, 2];\nv.push(3);\n// [1, 2, 3]\n```",
  "rust_lesson4_ex8_slide3_content": "トレイトを返す関数を簡潔に書きましょう。\n\n（When you're ready, select \"Start Lesson\".）",
  "rust_lesson1_ex1_title": "screenにメッセージを出しましょう",
  "rust_lesson2_ex8_slide2_title": "Result  Usage",
  "rust_lesson3_ex2_slide1_title": "closure?",
  "rust_lesson3_ex8_title": "unwrap_or でデフォルトvalue",
  "rust_lesson4_ex10_slide1_content": "# 番号とelementを一緒にもらう\n\nenumerate は、「何番目か」と「そのelement」をsetで取り出せるmethodです。\n\nFor example：\n- 0番目: りんご\n- 1番目: バナナ\n- 2番目: みかん\n\ncodeExample：\n```rust\nfor (i, x) in vec![\"a\", \"b\", \"c\"].iter().enumerate() {\n    println!(\"{}: {}\", i, x);\n}\n// 0: a\n// 1: b\n// 2: c\n```",
  "rust_lesson1_ex7_slide1_content": "# データを並べてまとめる「長い箱」\n\nベクタ（Vec） は、たくさんのデータを順番に並べて入れられる「長い箱」です。\n\nFor example：\n- 買い物listの商品を全部まとめる\n- testの点数を全部まとめる\n- 友だちの名前を全部まとめる\n\n100個でも1000個でも、1つのvariableでまとめて管理できます！\n\n作り方：\n```rust\nlet fruits = vec![\"りんご\", \"バナナ\", \"みかん\"];\n// vec! で ベクタを作る\n```",
  "rust_lesson4_ex8_slide3_title": "Let's Try It!",
  "rust_lesson4_ex7_description": "パターンマッチに条件を追加しましょう。",
  "rust_lesson1_ex4_comment2": "+= で 20 を足す",
  "rust_lesson1_ex2_comment2": "y に 5 を入れる",
  "rust_lesson2_ex3_slide3_title": "Let's Try It!",
  "rust_lesson3_ex4_slide1_title": "map（map）?",
  "rust_lesson1_ex2_slide3_content": "データに名前をつけて保存できる「変数（へんすう）」を使ってみましょう。letで変数を作ります。\n\n（When you're ready, select \"Start Lesson\".）",
  "rust_lesson2_ex8_slide2_content": "# match で成功と失敗を分ける\n\n`match` で「成功したら」「失敗したら」の処理を書き分けます。\n\ncodeExample：\n```rust\nfn divide(a: i32, b: i32) -> Result<i32, String> {\n    if b == 0 {\n        return Err(\"0で割れません\".to_string());\n    }\n    Ok(a / b)  // 成功なら答えを返す\n}\n\nmatch divide(10, 2) {\n    Ok(v) => println!(\"答えは{}\", v),\n    Err(e) => println!(\"エラー: {}\", e),\n}\n```\n\nPoint：\n- `Ok(値)` で成功をreturn\n- `Err(エラー)` で失敗をreturn",
  "rust_lesson4_ex3_comment1": "Box::new でheapに格納",
  "rust_lesson4_ex8_description": "トレイトをreturnfunctionを簡潔に書きましょう。",
  "rust_lesson2_ex10_description": "typeを後から決められる「ジェネリクス」を学びましょう。",
  "rust_lesson2_ex3_slide1_title": "可変reference（かへんさんしょう）?",
  "rust_lesson2_ex2_description": "所有権を移さずにvalueを借りる「reference」を学びましょう。",
  "rust_lesson3_ex5_slide2_title": "** にNote！",
  "rust_lesson2_ex2_slide3_title": "Let's Try It!",
  "rust_lesson4_ex3_slide3_content": "ヒープにデータを格納するBoxを学びましょう。\n\n（When you're ready, select \"Start Lesson\".）",
  "rust_lesson1_ex4_title": "累算assignmentoperator（+=、-=）",
  "rust_lesson3_ex3_slide2_content": "# 借りるか、もらうか\n\n3種類の iter があり、所有権の扱いが違います。\n\n3つの違い：\n```rust\nv.iter()       // 参照で借りる（&T）\nv.iter_mut()   // 変更可能で借りる（&mut T）\nv.into_iter()  // 所有権をもらう（T）\n```\n\n使い分け：\n- `iter()` → 見るだけ（元のベクタも使える）\n- `iter_mut()` → 中身を変更したい\n- `into_iter()` → ベクタごともらう（元は使えない）\n\n普通は `iter()` をuseことが多いです。",
  "rust_lesson2_ex1_slide1_title": "所有権（しょゆうけん）?",
  "rust_lesson4_ex6_slide3_content": "一意な値の集合を管理しましょう。\n\n（When you're ready, select \"Start Lesson\".）"
}